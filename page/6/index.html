<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.cyblogs.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="简栈文化">
<meta property="og:url" content="http://www.cyblogs.com/page/6/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.cyblogs.com/page/6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>简栈文化</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">简栈文化</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java技术人的成长之路~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vernon"
      src="/images/vernonchen.jpg">
  <p class="site-author-name" itemprop="name">Vernon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengcheng222e" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengcheng222e" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengcheng222e@gmail.com" title="E-Mail → mailto:chengcheng222e@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/04/02/2020/04/%E7%BE%A4%E9%87%8C%E4%B8%80%E4%B8%AA%E8%BD%AC%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/02/2020/04/%E7%BE%A4%E9%87%8C%E4%B8%80%E4%B8%AA%E8%BD%AC%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE/" class="post-title-link" itemprop="url">群里一个转码问题的灵魂拷问</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-02T00:00:00+08:00">2020-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>这几天确实太忙了，之前是日更，说上班后来个隔日更，还是坚持不了。完成Q1季度的考评后发现群里有人问了一个问题，非常的有意思。当时我也是非常的懵逼，然后想自己尝试的去解决一下。</p>
<p>问题是：<code>0xee 0xb9</code>  转<code>short</code>得到 <code>-4423</code> 为什么？对啊，为什么？我TM也想知道。</p>
<p><img src="http://static.cyblogs.com/QQ20200411-001905@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200411-001905@2x.jpg"></p>
<p>其实到这里，我先总结一下：</p>
<ul>
<li>计算机为什么能计算你这么快，原因是它只会处理0与1，二级制；</li>
<li>其实到硬件上面表现的就是电流信号、脉冲信号；</li>
<li>计算机虽然支持减法，乘法，除法，实际上底层只会一种算法，那就是加法；</li>
</ul>
<p>这也就是当时大学老师跟我们说的，别以为计算机很厉害，其实它很傻逼。每一步操作都需要设定好逻辑与程序。</p>
<h4 id="恶补基础知识点"><a href="#恶补基础知识点" class="headerlink" title="恶补基础知识点"></a>恶补基础知识点</h4><p>我们还是梳理一下基础知识吧~</p>
<ul>
<li><p>1、<code>byte</code>：有符号（意思是有正和负），在网络传输中都是会用到byte的，它占1个字节，共8位，比如说<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=1111&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">1111</a>1111就可以用1个byte表示，转化为10进制：- （2的6次+2的5次+2的4次+2的3次+2的2次+2的1次+2的0次） &#x3D; -127。其中前7位表示数字，最高位表示符号，0为正，1为负。范围是 （-2的7次 ~ 2的7次 - 1），那为什么前面最小是-127，范围最小又是-128呢？因为规定-0（10000000）为-128。</p>
</li>
<li><p>2、<code>short</code>：有符号，占2个字节，共16位。同byte一样，它的取值范围就是 （-2的15次 ~ 2的15次 - 1）。</p>
</li>
<li><p>3、<code>int</code> ：有符号，占4个字节，共32位。它的取值范围就是（-2的31次 ~ 2的31次）。</p>
</li>
<li><p>4、<code>long</code>：有符号，占8个字节，共64位，它的取值范围就是（-2的63次 ~ 2的63次）。</p>
</li>
<li><p>5、<code>^</code>：表示异或位运算，两者相同则为0，两者不同则为1。比如说15^2，15用二进制表示就是1111，2用2进制表示就是0010，两者进行异或运算，结果就是1101，转换为十进制就是13。</p>
</li>
<li><p>6、<code>|</code>：表示或运算，两者只有有一个为1就为1， 比如说13|2，13用二进制表示就是1101，2用二进制表示就是0010，两者进行或运算，那么结果就是1111，转换为十进制就是15。</p>
</li>
<li><p>7、<code>&amp;</code>：表示与运算，两者都为1就为1，其余都为0，比如说15&amp;2， 13用二进制表示就是1111，2用二进制表示就是0010， 两者进行与运算，那么结果就是0010，转换为十进制就是2。</p>
</li>
<li><p>8、<code>~</code>：取反，就是本来是0变成1，本来是1变成0。</p>
</li>
</ul>
<p><strong>计算机中存储是用补码！！，同时注意一下计算省略了高位不变部分</strong></p>
<p>我举个例子，比如说<code>-15|3</code>等于多少呢？有些人会觉得<code>-15</code>转化为二进制就是<code>10001111</code>，而3转化为二进制就是<code>00000011</code>，那么结果应该是<code>10001111</code>呀，转换为十进制就是-15呀？大家可以自己写个<code>demo</code>就会发现是不对的。要注意在计算机中所有的都是用补码的形式存储的，之所以上面介绍两个正数是对的，因为正数的反码和补码都是一样的。而负数求补码应该是出去符号位取反+1，我们再来看看这个题<code>-15|3</code>，其中<code>-15</code>的原码为<code>10001111</code>，反码为<code>11110000</code>，那么补码就是<code>11110001</code>，然后3的补码为<code>00000011</code>，两者进行或操作就是<code>11110011</code>，你以为结束了么？还没有，再又要求它的原码了，原码就是补码再求补码再+1（是不是已经晕掉了？），也就是<code>10001101</code>，结果就是-13。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">求 -<span class="number">15</span>|<span class="number">3</span></span><br><span class="line"></span><br><span class="line">[-<span class="number">15</span>]原码 = <span class="number">10001111</span></span><br><span class="line">[-<span class="number">15</span>]反码 = <span class="number">11110000</span> <span class="comment">//原码求反码符号位不变</span></span><br><span class="line">[-<span class="number">15</span>]补码 = <span class="number">11110001</span> <span class="comment">//反码+1等于补码</span></span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]原码 = <span class="number">00000011</span></span><br><span class="line">[<span class="number">3</span>]反码 = <span class="number">00000011</span> <span class="comment">//正数都一致</span></span><br><span class="line">[<span class="number">3</span>]补码 = <span class="number">00000011</span> <span class="comment">//正数都一致</span></span><br><span class="line"></span><br><span class="line">-<span class="number">15</span>|<span class="number">3</span> = <span class="number">11110011</span> <span class="comment">//两个补码进行或操作</span></span><br><span class="line"></span><br><span class="line">[结果]补码 = <span class="number">11110011</span> <span class="comment">//上面求得的值</span></span><br><span class="line">[结果]反码 = <span class="number">10001100</span> <span class="comment">//符号位不变</span></span><br><span class="line">[结果]原码 = <span class="number">10001101</span> <span class="comment">//反码+1</span></span><br><span class="line"></span><br><span class="line"><span class="number">100001101</span> 转化为十进制就是-<span class="number">13</span>。</span><br></pre></td></tr></table></figure>

<h4 id="开始解他那道题"><a href="#开始解他那道题" class="headerlink" title="开始解他那道题"></a>开始解他那道题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sophist</span> 其实这个是基础知识，我们在计算机的存储里面<span class="type">short</span>：<span class="number">16</span>位，最大数据存储量是<span class="number">65536</span>，数据范围是-<span class="number">32768</span>~<span class="number">32767</span>之间。</span><br><span class="line"></span><br><span class="line"><span class="number">0xee</span> <span class="number">0xb9</span> → -<span class="number">4423</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span>进制对应二进制：<span class="number">11101110</span> <span class="number">10111001</span></span><br><span class="line"></span><br><span class="line">high &lt;&lt; <span class="number">8</span> | low &amp; <span class="number">255</span> 低位保持不变</span><br><span class="line"></span><br><span class="line"><span class="number">11101110</span> <span class="number">00000000</span></span><br><span class="line">或</span><br><span class="line"><span class="number">00000000</span> <span class="number">10111001</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1110111010111001</span> 第一位代表符号位，这个数字肯定是负数</span><br><span class="line"></span><br><span class="line">取不骂 + <span class="number">1</span></span><br><span class="line"><span class="number">1001000101000110</span> + <span class="number">1</span> = <span class="number">1001000101000111</span> = -<span class="number">4423</span></span><br></pre></td></tr></table></figure>

<p>这样子结果就得到了：-4423。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/04/01/2020/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6@ConfigurationProperties%E8%AF%BB%E5%8F%96List%E3%80%81Map%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/01/2020/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6@ConfigurationProperties%E8%AF%BB%E5%8F%96List%E3%80%81Map%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">配置文件@ConfigurationProperties读取List、Map参数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-01T00:00:00+08:00">2020-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在SpringBoot环境中，我们有“使用不完的”注解。这也是SpringBoot替代了传统的Spring项目中的xml配置的原因。在使用这些annotation的时候，我们一定要了解这些注解背后的原理以及约定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.context.properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AliasFor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigurationProperties &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h4><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom.config.config1.folders[0]</span>=<span class="string">/root</span></span><br><span class="line"><span class="attr">custom.config.config1.folders[1]</span>=<span class="string">/home/user1</span></span><br><span class="line"><span class="attr">custom.config.config1.folders[2]</span>=<span class="string">/home/user2</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;custom.config.config1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config1Properties</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; folders;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom.config.config1.map.key1</span>=<span class="string">value1</span></span><br><span class="line"><span class="attr">custom.config.config1.map.key2</span>=<span class="string">value2</span></span><br><span class="line"><span class="attr">custom.config.config1.map.key3</span>=<span class="string">value3</span></span><br><span class="line"><span class="attr">custom.config.config1.map.key4</span>=<span class="string">value4</span></span><br><span class="line"><span class="attr">custom.config.config1.map.key5</span>=<span class="string">value5</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;custom.config.config1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config1Properties</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom.config.config1.server.host</span>=<span class="string">host1</span></span><br><span class="line"><span class="attr">custom.config.config1.server.port</span>=<span class="string">22</span></span><br><span class="line"><span class="attr">custom.config.config1.server.username</span>=<span class="string">username1</span></span><br><span class="line"><span class="attr">custom.config.config1.server.password</span>=<span class="string">password1</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;custom.config.config1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config1Properties</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ServerProperties server;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ServerProperties</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> String host;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">		<span class="keyword">private</span> String username;</span><br><span class="line">		<span class="keyword">private</span> String password;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Object-List"><a href="#Object-List" class="headerlink" title="Object List"></a>Object List</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom.config.config1.servers[0].host</span>=<span class="string">host1</span></span><br><span class="line"><span class="attr">custom.config.config1.servers[0].port</span>=<span class="string">22</span></span><br><span class="line"><span class="attr">custom.config.config1.servers[0].username</span>=<span class="string">username1</span></span><br><span class="line"><span class="attr">custom.config.config1.servers[0].password</span>=<span class="string">password1</span></span><br><span class="line"><span class="attr">custom.config.config1.servers[1].host</span>=<span class="string">host2</span></span><br><span class="line"><span class="attr">custom.config.config1.servers[1].port</span>=<span class="string">22</span></span><br><span class="line"><span class="attr">custom.config.config1.servers[1].username</span>=<span class="string">username2</span></span><br><span class="line"><span class="attr">custom.config.config1.servers[1].password</span>=<span class="string">password2</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;custom.config.config1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config1Properties</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;ServerProperties&gt; servers;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ServerProperties</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> String host;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">		<span class="keyword">private</span> String username;</span><br><span class="line">		<span class="keyword">private</span> String password;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map的使用案例"><a href="#Map的使用案例" class="headerlink" title="Map的使用案例"></a>Map的使用案例</h4><p>比如，我们同时需要连接多个OSS（阿里对象存储），那我们就可以利用ConfigurationProperties的方式来配置多个。而且可以通过Spring的加载动态的注入到容器中去。</p>
<p>配置中心的配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OSS1配置</span></span><br><span class="line"><span class="attr">oss.multi.clients.accout.accessKeyId</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">oss.multi.clients.accout.accessKeySecret</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">oss.multi.clients.accout.privateEndpoint</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">oss.multi.clients.accout.bucketName</span>=<span class="string">bucket-b-test</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># OSS2配置</span></span><br><span class="line"><span class="attr">oss.multi.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">oss.multi.clients.xdtrans.accessKeyId</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">oss.multi.clients.xdtrans.accessKeySecret</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">oss.multi.clients.xdtrans.privateEndpoint</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">oss.multi.clients.xdtrans.bucketName</span>=<span class="string">bucket-a-test</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = OssConstants.MULTI_CONFIG_PREFIX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiOssProperties</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, OssProperties&gt; clients;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OssProperties</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> String accessKeyId;</span><br><span class="line">		<span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">		<span class="keyword">private</span> String publicEndpoint;</span><br><span class="line">		<span class="keyword">private</span> String privateEndpoint;</span><br><span class="line">		<span class="keyword">private</span> String bucketName;</span><br><span class="line">		<span class="keyword">private</span> String object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>动态的定义我们需要的BeanDefinition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiOssScannerConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span>, InitializingBean, ApplicationContextAware, BeanNameAware &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Setter</span></span><br><span class="line">	<span class="keyword">private</span> MultiOssProperties multiOssProperties;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		log.info(<span class="string">&quot;init bean &#123;&#125;&quot;</span>, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		Objects.requireNonNull(<span class="built_in">this</span>.multiOssProperties, <span class="string">&quot;multiOssProperties不能为空&quot;</span>);</span><br><span class="line">		Objects.requireNonNull(<span class="built_in">this</span>.applicationContext, <span class="string">&quot;applicationContext不能为空&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 动态的定义Bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">beanSuffixName</span> <span class="operator">=</span> StringUtils.capitalize(OssConstants.BEAN_SUFFIX_NAME);</span><br><span class="line">    <span class="comment">// productCodes实际与oss.multi.clients.xdtrans的xdtrans保持一致</span></span><br><span class="line">		multiOssProperties.getClients().forEach((productCode, ossProperties) -&gt; &#123;</span><br><span class="line">			<span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(OssClient.class,</span><br><span class="line">					() -&gt; OssClientUtils.buildOssClient(ossProperties))</span><br><span class="line">					.getRawBeanDefinition();</span><br><span class="line">			beanDefinition.setInitMethodName(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">			beanDefinition.setDestroyMethodName(<span class="string">&quot;shutDown&quot;</span>);</span><br><span class="line">			beanDefinitionRegistry.registerBeanDefinition(productCode + beanSuffixName, beanDefinition);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过binder来让配置与对应的Java代码产生关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MultiOssProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = OssConstants.MULTI_CONFIG_PREFIX, value = &quot;enabled&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiOssAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化多个 ossClient 自动配置</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> environment 环境变量属性</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> OssClient 自动扫描注册器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> MultiOssScannerConfigurer <span class="title function_">multiOssScannerConfigurer</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">		<span class="type">Binder</span> <span class="variable">binder</span> <span class="operator">=</span> Binder.get(environment);</span><br><span class="line">		<span class="type">MultiOssProperties</span> <span class="variable">properties</span> <span class="operator">=</span> binder.bind(OssConstants.MULTI_CONFIG_PREFIX, MultiOssProperties.class).get();</span><br><span class="line">		<span class="type">MultiOssScannerConfigurer</span> <span class="variable">multiOssScannerConfigurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiOssScannerConfigurer</span>();</span><br><span class="line">		multiOssScannerConfigurer.setMultiOssProperties(properties);</span><br><span class="line">		<span class="keyword">return</span> multiOssScannerConfigurer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OssTypeEnum</span> &#123;</span><br><span class="line">		<span class="comment">// 注意一下这里的beanName,要跟上面的postProcessBeanDefinitionRegistry保持一致</span></span><br><span class="line">    XDtransOssClient(<span class="string">&quot;xdtransOssClient&quot;</span>, <span class="string">&quot;oss1&quot;</span>),</span><br><span class="line">    DianDianOssClient(<span class="string">&quot;ddacctOssClient&quot;</span>, <span class="string">&quot;oss2&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据BeanName来Spring容器中获取即可</span></span><br><span class="line">    <span class="keyword">public</span> OssClient <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SpringContextHolder.getBean(beanName, OssClient.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Binder是如何映射的？"><a href="#Binder是如何映射的？" class="headerlink" title="Binder是如何映射的？"></a>Binder是如何映射的？</h4><p>通过上面的代码<code>binder.bind(OssConstants.MULTI_CONFIG_PREFIX, MultiOssProperties.class).get();</code>来进行bind。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> &lt;T&gt; T <span class="title function_">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Context context, <span class="type">boolean</span> allowRecursiveBinding)</span> &#123;</span><br><span class="line">		context.clearConfigurationProperty();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			target = handler.onStart(name, target, context);</span><br><span class="line">			<span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">bound</span> <span class="operator">=</span> bindObject(name, target, handler, context,allowRecursiveBinding);</span><br><span class="line">			<span class="keyword">return</span> handleBindResult(name, target, handler, context, bound);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">return</span> handleBindError(name, target, handler, context, ex);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们的key是：oss.multi.clients.accout.xxx</p>
<p>实际上对应的是Map，那么它的引用名字就是clients。具体的key就是accout，那么对应的value就是OssProperties。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">bindBean</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;?&gt; target,</span></span><br><span class="line"><span class="params">		BindHandler handler, Context context, <span class="type">boolean</span> allowRecursiveBinding)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (containsNoDescendantOf(context.getSources(), name)</span><br><span class="line">			|| isUnbindableBean(name, target, context)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">BeanPropertyBinder</span> <span class="variable">propertyBinder</span> <span class="operator">=</span> (propertyName, propertyTarget) -&gt; bind(</span><br><span class="line">			name.append(propertyName), propertyTarget, handler, context, <span class="literal">false</span>);</span><br><span class="line">	Class&lt;?&gt; type = target.getType().resolve(Object.class);</span><br><span class="line">	<span class="keyword">if</span> (!allowRecursiveBinding &amp;&amp; context.hasBoundBean(type)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> context.withBean(type, () -&gt; &#123;</span><br><span class="line">		Stream&lt;?&gt; boundBeans = BEAN_BINDERS.stream()</span><br><span class="line">				.map((b) -&gt; b.bind(name, target, context, propertyBinder));</span><br><span class="line">		<span class="keyword">return</span> boundBeans.filter(Objects::nonNull).findFirst().orElse(<span class="literal">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/QQ20200422-222025@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200422-222025@2x.jpg"></p>
<p>具体的一个bind情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;BeanBinder&gt; BEAN_BINDERS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	List&lt;BeanBinder&gt; binders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	binders.add(<span class="keyword">new</span> <span class="title class_">JavaBeanBinder</span>());</span><br><span class="line">	BEAN_BINDERS = Collections.unmodifiableList(binders);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, Context context,</span></span><br><span class="line"><span class="params">		BeanPropertyBinder propertyBinder)</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">hasKnownBindableProperties</span> <span class="operator">=</span> hasKnownBindableProperties(name, context);</span><br><span class="line">	Bean&lt;T&gt; bean = Bean.get(target, hasKnownBindableProperties);</span><br><span class="line">	<span class="keyword">if</span> (bean == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BeanSupplier&lt;T&gt; beanSupplier = bean.getSupplier(target);</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">bound</span> <span class="operator">=</span> bind(propertyBinder, bean, beanSupplier);</span><br><span class="line">	<span class="keyword">return</span> (bound ? beanSupplier.get() : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回对应的对象</span></span><br><span class="line"><span class="keyword">public</span> BeanSupplier&lt;T&gt; <span class="title function_">getSupplier</span><span class="params">(Bindable&lt;T&gt; target)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanSupplier</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">		<span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (target.getValue() != <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = target.getValue().get();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">			instance = (T) BeanUtils.instantiateClass(<span class="built_in">this</span>.resolvedType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sayyy/article/details/83657119">https://blog.csdn.net/sayyy/article/details/83657119</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/27/2020/03/UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/27/2020/03/UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/" class="post-title-link" itemprop="url">UDP如何实现可靠传输</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-27 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-27T00:00:00+08:00">2020-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/UDP/" itemprop="url" rel="index"><span itemprop="name">UDP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。</p>
<p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li>1、添加seq&#x2F;ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
<p>详细说明：送端发送数据时，生成一个随机seq&#x3D;x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack&#x3D;x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为 <strong>RUDP、RTP、UDT</strong>。</p>
<h3 id="开源程序"><a href="#开源程序" class="headerlink" title="开源程序"></a>开源程序</h3><h5 id="1、RUDP（Reliable-User-Datagram-Protocol）"><a href="#1、RUDP（Reliable-User-Datagram-Protocol）" class="headerlink" title="1、RUDP（Reliable User Datagram Protocol）"></a>1、RUDP（Reliable User Datagram Protocol）</h5><p><strong>RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等</strong> ，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。</p>
<h5 id="2、RTP（Real-Time-Protocol）"><a href="#2、RTP（Real-Time-Protocol）" class="headerlink" title="2、RTP（Real Time Protocol）"></a>2、RTP（Real Time Protocol）</h5><p><strong>RTP为数据提供了具有实时特征的端对端传送服务</strong>，如在组播或单播网络服务下的交互式视频音频或模拟数据。</p>
<p>应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。</p>
<p>RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。</p>
<h5 id="3、UDT（UDP-based-Data-Transfer-Protocol）"><a href="#3、UDT（UDP-based-Data-Transfer-Protocol）" class="headerlink" title="3、UDT（UDP-based Data Transfer Protocol）"></a>3、UDT（UDP-based Data Transfer Protocol）</h5><p>基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。*<strong>UDT的主要目的是支持高速广域网上的海量数据传输*</strong>，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。</p>
<p>顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6c73a4585eba">https://www.jianshu.com/p/6c73a4585eba</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/26/2020/03/TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/26/2020/03/TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">TCP粘包拆包及解决方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-26 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-26T00:00:00+08:00">2020-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TCP/" itemprop="url" rel="index"><span itemprop="name">TCP</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p>
<h4 id="什么是粘包、拆包？"><a href="#什么是粘包、拆包？" class="headerlink" title="什么是粘包、拆包？"></a>什么是粘包、拆包？</h4><p>假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：</p>
<p>**第一种情况：**接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。</p>
<p> <img src="http://static.cyblogs.com/1422100-20180822164943488-1549063928.png" alt="img"></p>
<p>**第二种情况：**接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p>
<p> <img src="http://static.cyblogs.com/1422100-20180822164950622-1403347423.png" alt="img"></p>
<p>**第三种情况：**这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p>
<p> <img src="http://static.cyblogs.com/1422100-20180822164958646-1790874821.png" alt="img"></p>
<p> <img src="http://static.cyblogs.com/1422100-20180822165003871-693771235.png" alt="img"></p>
<h4 id="为什么会发生TCP粘包、拆包？"><a href="#为什么会发生TCP粘包、拆包？" class="headerlink" title="为什么会发生TCP粘包、拆包？"></a>为什么会发生TCP粘包、拆包？</h4><p>发生TCP粘包、拆包主要是由于下面一些原因：</p>
<ul>
<li><p>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</p>
</li>
<li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</p>
</li>
<li><p>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。</p>
</li>
<li><p>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</p>
</li>
</ul>
<h4 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h4><p>TCP本身是面向流的，作为网络服务器，如何从这源源不断涌来的数据流中拆分出或者合并出有意义的信息呢？通常会有以下一些常用的方法：</p>
<ul>
<li><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p>
</li>
<li><p>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p>
</li>
<li><p>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p>
</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/panchanggui/p/9518735.html">https://www.cnblogs.com/panchanggui/p/9518735.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/25/2020/03/StringBuilder%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/25/2020/03/StringBuilder%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">StringBuilder为什么线程不安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-25T00:00:00+08:00">2020-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在这之前我只记住了StringBuilder不是线程安全的，StringBuffer是线程安全的这个结论，至于StringBuilder为什么不安全从来没有去想过。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><blockquote>
<p>在分析设个问题之前我们要知道StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。</p>
</blockquote>
<p>首先通过一段代码去看一下多线程操作StringBuilder对象会出现什么问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>( &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                        stringBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(stringBuilder.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们能看到这段代码创建了10个线程，每个线程循环1000次往StringBuilder对象里面append字符。正常情况下代码应该输出10000，但是实际运行会输出什么呢？</p>
<p><img src="http://static.cyblogs.com/16cc76d348d29915.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;16cc76d348d29915.png"></p>
<p>我们看到输出了“9326”，小于预期的10000，并且还抛出了一个ArrayIndexOutOfBoundsException异常（异常不是必现）。</p>
<h5 id="1、为什么输出值跟预期值不一样"><a href="#1、为什么输出值跟预期值不一样" class="headerlink" title="1、为什么输出值跟预期值不一样"></a>1、为什么输出值跟预期值不一样</h5><p>我们先看一下StringBuilder的两个成员变量（这两个成员变量实际上是定义在AbstractStringBuilder里面的，StringBuilder和StringBuffer都继承了AbstractStringBuilder）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储字符串的具体内容</span></span><br><span class="line"><span class="type">char</span>[] value;</span><br><span class="line"><span class="comment">//已经使用的字符数组的数量</span></span><br><span class="line"><span class="type">int</span> count;</span><br></pre></td></tr></table></figure>

<p>再看StringBuilder的append()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先不管代码的第五行和第六行干了什么，直接看第七行，count +&#x3D; len不是一个原子操作。假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12。这就是为什么测试代码输出的值要比10000小的原因。</p>
<h5 id="2、为什么会抛出ArrayIndexOutOfBoundsException异常。"><a href="#2、为什么会抛出ArrayIndexOutOfBoundsException异常。" class="headerlink" title="2、为什么会抛出ArrayIndexOutOfBoundsException异常。"></a>2、为什么会抛出ArrayIndexOutOfBoundsException异常。</h5><p>我们看回AbstractStringBuilder的append()方法源码的第五行，ensureCapacityInternal()方法是检查StringBuilder对象的原char数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity()方法对char数组进行扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容的逻辑就是new一个新的char数组，新的char数组的容量是原来char数组的两倍再加2，再通过System.arryCopy()函数将原数组的内容复制到新数组，最后将指针指向新的char数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">expandCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//计算新的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//中间省略了一些检查逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Arrys.copyOf()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] copyOf(<span class="type">char</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="type">char</span>[] copy = <span class="keyword">new</span> <span class="title class_">char</span>[newLength];</span><br><span class="line">    <span class="comment">//拷贝数组</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractStringBuilder的append()方法源码的第六行，是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.getChars(<span class="number">0</span>, len, value, count);</span><br></pre></td></tr></table></figure>

<p>getChars()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span> dst[], <span class="type">int</span> dstBegin)</span> &#123;</span><br><span class="line">    <span class="comment">//中间省略了一些检查</span></span><br><span class="line">    ...   </span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>拷贝流程见下图</p>
<p><img src="http://static.cyblogs.com/16cc76dc56ffc2f2.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;16cc76dc56ffc2f2.png"></p>
<p>假设现在有两个线程同时执行了StringBuilder的append()方法，两个线程都执行完了第五行的ensureCapacityInternal()方法，此刻count&#x3D;5。</p>
<p><img src="http://static.cyblogs.com/16cc76df391e9f4f.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;16cc76df391e9f4f.png"></p>
<p>这个时候线程1的cpu时间片用完了，线程2继续执行。线程2执行完整个append()方法后count变成6了</p>
<p><img src="http://static.cyblogs.com/16cc76e4b1c9c16b.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;16cc76e4b1c9c16b.png"></p>
<p>线程1继续执行第六行的str.getChars()方法的时候拿到的count值就是6了，执行char数组拷贝的时候就会抛出ArrayIndexOutOfBoundsException异常。</p>
<p>至此，StringBuilder为什么不安全已经分析完了。如果我们将测试代码的StringBuilder对象换成StringBuffer对象会输出什么呢？</p>
<p><img src="http://static.cyblogs.com/16cc76e852c2a3cb.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;16cc76e852c2a3cb.png"></p>
<p>当然是输出10000啦！</p>
<p>那么StringBuffer用什么手段保证线程安全的？这个问题你点进StringBuffer的append()方法里面就知道了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5d6228046fb9a06add4e37fe">https://juejin.im/post/5d6228046fb9a06add4e37fe</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/24/2020/03/Spring%E5%90%AF%E5%8A%A8invokeBeanFactoryPostProcessors%E6%96%B9%E6%B3%95%E8%A7%A3%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/24/2020/03/Spring%E5%90%AF%E5%8A%A8invokeBeanFactoryPostProcessors%E6%96%B9%E6%B3%95%E8%A7%A3%E9%87%8A/" class="post-title-link" itemprop="url">Spring启动invokeBeanFactoryPostProcessors方法解释</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-24T00:00:00+08:00">2020-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>本方法<code>（invokeBeanFactoryPostProcessors）</code>会实例化和调用所有 <code>BeanFactoryPostProcessor</code>（包括其子类<code>BeanDefinitionRegistryPostProcessor</code>）。</p>
<p><code>BeanFactoryPostProcessor</code> 接口是 <code>Spring</code> 初始化 <code>BeanFactory</code> 时对外暴露的扩展点，<code>Spring</code> IoC 容器允许 <code>BeanFactoryPostProcessor</code> 在容器实例化任何 <code>bean</code> 之前读取 <code>bean</code> 的定义，并可以修改它。</p>
<p><code>BeanDefinitionRegistryPostProcessor</code> 继承自 <code>BeanFactoryPostProcessor</code>，比 <code>BeanFactoryPostProcessor</code> 具有更高的优先级，主要用来在常规的 <code>BeanFactoryPostProcessor</code> 检测开始之前注册其他 <code>bean</code> 定义。特别是，你可以通过 <code>BeanDefinitionRegistryPostProcessor</code> 来注册一些常规的 <code>BeanFactoryPostProcessor</code>，因为此时所有常规的 <code>BeanFactoryPostProcessor</code> 都还没开始被处理。 </p>
<h4 id="项目中的实战"><a href="#项目中的实战" class="headerlink" title="项目中的实战"></a>项目中的实战</h4><p><code>BeanDefinitionRegistryPostProcessor</code>初始化<code>Bean</code>的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想根据配置文件来动态的生成我们的Bean对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiOssScannerConfigurer</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span>, InitializingBean, ApplicationContextAware, BeanNameAware &#123;</span><br><span class="line">	<span class="meta">@Setter</span></span><br><span class="line">	<span class="keyword">private</span> MultiOssProperties multiOssProperties;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">beanSuffixName</span> <span class="operator">=</span> StringUtils.capitalize(OssConstants.BEAN_SUFFIX_NAME);</span><br><span class="line">		multiOssProperties.getClients().forEach((productCode, ossProperties) -&gt; &#123;</span><br><span class="line">			<span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(OssClient.class,</span><br><span class="line">					() -&gt; OssClientUtils.buildOssClient(ossProperties))</span><br><span class="line">					.getRawBeanDefinition();</span><br><span class="line">			beanDefinition.setInitMethodName(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">			beanDefinition.setDestroyMethodName(<span class="string">&quot;shutDown&quot;</span>);</span><br><span class="line">			beanDefinitionRegistry.registerBeanDefinition(productCode + beanSuffixName, beanDefinition);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor初始化的时候do something</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeplerBeanFactoryPostInitializer</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		Map&lt;String, AviatorFunction&gt; aviatorFunctionMap = beanFactory.getBeansOfType(AviatorFunction.class);</span><br><span class="line">		<span class="keyword">if</span> (aviatorFunctionMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			log.info(<span class="string">&quot;初始化自定义RuleLoader...&quot;</span>);</span><br><span class="line">			aviatorFunctionMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">				log.info(<span class="string">&quot;加载Rule:&#123;&#125;&quot;</span>, k);</span><br><span class="line">				AviatorEvaluator.addFunction(v);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		RuleLoader.initRule();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跟进源代码"><a href="#跟进源代码" class="headerlink" title="跟进源代码"></a>跟进源代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">	<span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getBeanFactoryPostProcessors"><a href="#getBeanFactoryPostProcessors" class="headerlink" title="getBeanFactoryPostProcessors"></a>getBeanFactoryPostProcessors</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the list of BeanFactoryPostProcessors that will get applied</span></span><br><span class="line"><span class="comment">	 * to the internal BeanFactory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;BeanFactoryPostProcessor&gt; <span class="title function_">getBeanFactoryPostProcessors</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.beanFactoryPostProcessors;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这边 <code>getBeanFactoryPostProcessors()</code> 会拿到当前应用上下文中已经注册的 <code>BeanFactoryPostProcessor</code>，在默认情况下，<code>this.beanFactoryPostProcessors</code> 是返回空的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextInitializer</span>&lt;C <span class="keyword">extends</span> <span class="title class_">ConfigurableApplicationContext</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the given application context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> applicationContext the application to configure</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(C applicationContext)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1.判断beanFactory是否为BeanDefinitionRegistry，beanFactory为DefaultListableBeanFactory,</span></span><br><span class="line">    <span class="comment">// 而DefaultListableBeanFactory实现了BeanDefinitionRegistry接口，因此这边为true</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        <span class="comment">// 用于存放普通的BeanFactoryPostProcessor</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">        <span class="comment">// 用于存放BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2.首先处理入参中的beanFactoryPostProcessors</span></span><br><span class="line">        <span class="comment">// 遍历所有的beanFactoryPostProcessors, 将BeanDefinitionRegistryPostProcessor和普通BeanFactoryPostProcessor区分开</span></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                <span class="comment">// 2.1 如果是BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">                <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                <span class="comment">// 2.1.1 直接执行BeanDefinitionRegistryPostProcessor接口的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                <span class="comment">// 2.1.2 添加到registryProcessors(用于最后执行postProcessBeanFactory方法)</span></span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 2.2 否则，只是普通的BeanFactoryPostProcessor</span></span><br><span class="line">                <span class="comment">// 2.2.1 添加到regularPostProcessors(用于最后执行postProcessBeanFactory方法)</span></span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">        <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">        <span class="comment">// 用于保存本次要执行的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">        <span class="comment">// 3.调用所有实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor实现类</span></span><br><span class="line">        <span class="comment">// 3.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的Bean的beanName</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 3.2 遍历postProcessorNames</span></span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// 3.3 校验是否实现了PriorityOrdered接口</span></span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                <span class="comment">// 3.4 获取ppName对应的bean实例, 添加到currentRegistryProcessors中,</span></span><br><span class="line">                <span class="comment">// beanFactory.getBean: 这边getBean方法会触发创建ppName对应的bean对象, 目前暂不深入解析</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                <span class="comment">// 3.5 将要被执行的加入processedBeans，避免后续重复执行</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.6 进行排序(根据是否实现PriorityOrdered、Ordered接口和order值来排序)</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// 3.7 添加到registryProcessors(用于最后执行postProcessBeanFactory方法)</span></span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 3.8 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">// 3.9 执行完毕后, 清空currentRegistryProcessors</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">        <span class="comment">// 4.调用所有实现了Ordered接口的BeanDefinitionRegistryPostProcessor实现类（过程跟上面的步骤3基本一样）</span></span><br><span class="line">        <span class="comment">// 4.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的类, 这边重复查找是因为执行完上面的BeanDefinitionRegistryPostProcessor,</span></span><br><span class="line">        <span class="comment">// 可能会新增了其他的BeanDefinitionRegistryPostProcessor, 因此需要重新查找</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// 校验是否实现了Ordered接口，并且还未执行过</span></span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 4.2 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">        <span class="comment">// 5.最后, 调用所有剩下的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 5.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的类</span></span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="comment">// 5.2 跳过已经执行过的</span></span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    <span class="comment">// 5.3 如果有BeanDefinitionRegistryPostProcessor被执行, 则有可能会产生新的BeanDefinitionRegistryPostProcessor,</span></span><br><span class="line">                    <span class="comment">// 因此这边将reiterate赋值为true, 代表需要再循环查找一次</span></span><br><span class="line">                    reiterate = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            <span class="comment">// 5.4 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">        <span class="comment">// 6.调用所有BeanDefinitionRegistryPostProcessor的postProcessBeanFactory方法(BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor)</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// 7.最后, 调用入参beanFactoryPostProcessors中的普通BeanFactoryPostProcessor的postProcessBeanFactory方法</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 到这里 , 入参beanFactoryPostProcessors和容器中的所有BeanDefinitionRegistryPostProcessor已经全部处理完毕,</span></span><br><span class="line">    <span class="comment">// 下面开始处理容器中的所有BeanFactoryPostProcessor</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">    <span class="comment">// 8.找出所有实现BeanFactoryPostProcessor接口的类</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    <span class="comment">// 用于存放实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    <span class="comment">// 用于存放实现了Ordered接口的BeanFactoryPostProcessor的beanName</span></span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 用于存放普通BeanFactoryPostProcessor的beanName</span></span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 8.1 遍历postProcessorNames, 将BeanFactoryPostProcessor按实现PriorityOrdered、实现Ordered接口、普通三种区分开</span></span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// 8.2 跳过已经执行过的</span></span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            <span class="comment">// 8.3 添加实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            <span class="comment">// 8.4 添加实现了Ordered接口的BeanFactoryPostProcessor的beanName</span></span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 8.5 添加剩下的普通BeanFactoryPostProcessor的beanName</span></span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    <span class="comment">// 9.调用所有实现PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line">    <span class="comment">// 9.1 对priorityOrderedPostProcessors排序</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 9.2 遍历priorityOrderedPostProcessors, 执行postProcessBeanFactory方法</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">    <span class="comment">// 10.调用所有实现Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// 10.1 获取postProcessorName对应的bean实例, 添加到orderedPostProcessors, 准备执行</span></span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 10.2 对orderedPostProcessors排序</span></span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 10.3 遍历orderedPostProcessors, 执行postProcessBeanFactory方法</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">    <span class="comment">// 11.调用所有剩下的BeanFactoryPostProcessor</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// 11.1 获取postProcessorName对应的bean实例, 添加到nonOrderedPostProcessors, 准备执行</span></span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 11.2 遍历nonOrderedPostProcessors, 执行postProcessBeanFactory方法</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    <span class="comment">// 12.清除元数据缓存（mergedBeanDefinitions、allBeanNamesByType、singletonBeanNamesByType），</span></span><br><span class="line">    <span class="comment">// 因为后处理器可能已经修改了原始元数据，例如， 替换值中的占位符...</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sortPostProcessors"><a href="#sortPostProcessors" class="headerlink" title="sortPostProcessors"></a>sortPostProcessors</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortPostProcessors</span><span class="params">(List&lt;?&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    Comparator&lt;Object&gt; comparatorToUse = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        <span class="comment">// 1.获取设置的比较器</span></span><br><span class="line">        comparatorToUse = ((DefaultListableBeanFactory) beanFactory).getDependencyComparator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (comparatorToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.如果没有设置比较器, 则使用默认的OrderComparator</span></span><br><span class="line">        comparatorToUse = OrderComparator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.使用比较器对postProcessors进行排序</span></span><br><span class="line">    Collections.sort(postProcessors, comparatorToUse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，比较器为 <code>OrderComparator</code>；如果配置了 <code>annotation-config</code>，并且值为<code>true</code>，使用的是 <code>AnnotationAwareOrderComparator</code>，<code>AnnotationAwareOrderComparator</code> 继承自 <code>OrderComparator</code>，只是重写了部分方法，比较器的部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> doCompare(o1, o2, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doCompare</span><span class="params">(Object o1, Object o2, OrderSourceProvider sourceProvider)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断o1是否实现了PriorityOrdered接口</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">p1</span> <span class="operator">=</span> (o1 <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">    <span class="comment">// 判断o2是否实现了PriorityOrdered接口</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">p2</span> <span class="operator">=</span> (o2 <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">    <span class="comment">// 1.如果o1实现了PriorityOrdered接口, 而o2没有, 则o1排前面</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &amp;&amp; !p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果o2实现了PriorityOrdered接口, 而o1没有, 则o2排前面</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p2 &amp;&amp; !p1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3.如果o1和o2都实现（都没实现）PriorityOrdered接口</span></span><br><span class="line">    <span class="comment">// Direct evaluation instead of Integer.compareTo to avoid unnecessary object creation.</span></span><br><span class="line">    <span class="comment">// 拿到o1的order值, 如果没实现Ordered接口, 值为Ordered.LOWEST_PRECEDENCE</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> getOrder(o1, sourceProvider);</span><br><span class="line">    <span class="comment">// 拿到o2的order值, 如果没实现Ordered接口, 值为Ordered.LOWEST_PRECEDENCE</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> getOrder(o2, sourceProvider);</span><br><span class="line">    <span class="comment">// 4.通过order值(order值越小, 优先级越高)排序</span></span><br><span class="line">    <span class="keyword">return</span> (i1 &lt; i2) ? -<span class="number">1</span> : (i1 &gt; i2) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一点：整个 <code>invokeBeanFactoryPostProcessors</code> 方法围绕两个接口，<code>BeanDefinitionRegistryPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code>，其中 <code>BeanDefinitionRegistryPostProcessor</code> 继承了 <code>BeanFactoryPostProcessor</code> 。<code>BeanDefinitionRegistryPostProcessor</code> 主要用来在常规 <code>BeanFactoryPostProcessor</code> 检测开始之前注册其他 Bean 定义，说的简单点，就是 <code>BeanDefinitionRegistryPostProcessor</code> 具有更高的优先级，执行顺序在 <code>BeanFactoryPostProcessor</code> 之前。</p>
<p>第二点：整个 <code>invokeBeanFactoryPostProcessors</code> 方法操作了 3 种 bean 对象：</p>
<ul>
<li>入参 <code>beanFactoryPostProcessors</code>：拿的是 <code>AbstractApplicationContext</code> 类的 <code>beanFactoryPostProcessors</code> 属性值，也就是在之前已经添加到 <code>beanFactoryPostProcessors</code> 中的 <code>BeanFactoryPostProcessor</code></li>
<li><code>BeanDefinitionRegistryPostProcessor</code> 接口实现类：实现了 <code>BeanDefinitionRegistryPostProcessor</code> 接口，并且注册到 <code>Spring IoC</code>容器中。</li>
<li>常规 <code>BeanFactoryPostProcessor</code> 接口实现类：实现了 <code>BeanFactoryPostProcessor</code> 接口，并且注册到 <code>Spring IoC</code>容器中。</li>
</ul>
<p>第三点：操作3种 bean 对象具体指的是调用它们重写的方法，调用实现方法时会遵循以下的优先级：<br>两个用于排序的重要接口：<code>PriorityOrdered</code> 和 <code>Ordered</code>，其中 <code>PriorityOrdered</code> 继承了 <code>Ordered</code>，并且 <code>PriorityOrdered</code> 的优先级要高于 <code>Ordered</code>，这跟 <code>BeanDefinitionRegistryPostProcessor</code> 继承 <code>BeanFactoryPostProcessor</code> 有点类似。实现 <code>Ordered</code> 接口需要重写 <code>getOrder</code> 方法，返回一个用于排序的 <code>order</code> 值，<code>order</code> 值的范围为 <code>Integer.MIN_VALUE ~ Integer.MAX_VALUE</code>，<code>order</code> 值越小优先级越高，<code>Integer.MIN_VALUE</code> 拥有最高优先级，而 <code>Integer.MAX_VALUE</code> 则对应的拥有最低优先级。</p>
<p>第四点：常见的 <code>Java EE</code> 相关的框架或者中间件，经常使用 <code>BeanFactoryPostProcessor</code> 来进行扩展，例如上面的 <code>Mybatis</code>，因此了解 <code>BeanFactoryPostProcessor</code> 的原理会对之后理解其他中间件的原理有帮助。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/v123411739/article/details/87741251">https://blog.csdn.net/v123411739/article/details/87741251</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/23/2020/03/Spring-bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/23/2020/03/Spring-bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">Spring-bean的循环依赖以及解决方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-23 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-23T00:00:00+08:00">2020-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<blockquote>
<p>本文主要是分析Spring bean的循环依赖，以及Spring的解决方式。 通过这种解决方式，我们可以应用在我们实际开发项目中。</p>
</blockquote>
<p>什么是循环依赖？<br>怎么检测循环依赖<br>Spring怎么解决循环依赖<br>Spring对于循环依赖无法解决的场景<br>Spring解决循环依赖的方式我们能够学到什么？</p>
</blockquote>
<h4 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h4><p>循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：</p>
<p><img src="http://static.cyblogs.com/20170912082357749.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20170912082357749.jpg"></p>
<p>注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。</p>
<h5 id="Spring中循环依赖场景有："><a href="#Spring中循环依赖场景有：" class="headerlink" title="Spring中循环依赖场景有："></a>Spring中循环依赖场景有：</h5><p>（1）构造器的循环依赖<br>（2）field属性的循环依赖。</p>
<h4 id="怎么检测是否存在循环依赖"><a href="#怎么检测是否存在循环依赖" class="headerlink" title="怎么检测是否存在循环依赖"></a>怎么检测是否存在循环依赖</h4><p>检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。</p>
<h4 id="Spring怎么解决循环依赖"><a href="#Spring怎么解决循环依赖" class="headerlink" title="Spring怎么解决循环依赖"></a>Spring怎么解决循环依赖</h4><p>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。</p>
<p>Spring的单例对象的初始化主要分为三步：</p>
<p>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象</p>
<p>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充</p>
<p>（3）initializeBean：调用spring xml中的init 方法。</p>
<p>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二部。也就是构造器循环依赖和field循环依赖。</p>
<p>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</p>
<p>首先我们看源码，三级缓存主要指：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这三级缓存分别指：<br>singletonFactories ： 单例对象工厂的cache<br>earlySingletonObjects ：提前暴光的单例对象的Cache<br>singletonObjects：单例对象的cache</p>
<p>我们在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。主要调用方法就就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码需要解释两个参数：</p>
<p>isSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中，也就是没有初始化完成(比如A的构造器依赖了B对象所以得先去创建B对象， 或则在A的populateBean过程中依赖了B对象，得先去创建B对象，这时的A就是处于创建中的状态。)<br>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象<br>分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</span><br></pre></td></tr></table></figure>

<p>从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</p>
<p>从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口在下面被引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p>
<p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。</p>
<ul>
<li>A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</li>
</ul>
<p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010853261/article/details/77940767">https://blog.csdn.net/u010853261/article/details/77940767</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/22/2020/03/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%B7%83%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/22/2020/03/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%B7%83%E8%A1%A8/" class="post-title-link" itemprop="url">Redis为什么要使用跳跃表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-22T00:00:00+08:00">2020-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p>
<p>以下是个典型的跳跃表例子</p>
<p><img src="http://static.cyblogs.com/skiplist.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;skiplist.png"></p>
<p>从图中可以看到， 跳跃表主要由以下部分构成：</p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针。</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末尾。</li>
</ul>
<p>因为跳跃表的定义可以在任何一本算法或数据结构的书中找到， 所以本章不介绍跳跃表的具体实现方式或者具体的算法， 而只介绍跳跃表在 Redis 的应用、核心数据结构和 API 。</p>
<h4 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h4><p>为了满足自身的功能需要， Redis 基于 William Pugh 论文中描述的跳跃表进行了以下修改：</p>
<ol>
<li>允许重复的 <code>score</code> 值：多个不同的 <code>member</code> 的 <code>score</code> 值可以相同。</li>
<li>进行对比操作时，不仅要检查 <code>score</code> 值，还要检查 <code>member</code> ：当 <code>score</code> 值可以重复时，单靠 <code>score</code> 值无法判断一个元素的身份，所以需要连 <code>member</code> 域都一并检查才行。</li>
<li>每个节点都带有一个高度为 1 层的后退指针，用于从表尾方向向表头方向迭代：当执行 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrange.html#zrevrange">ZREVRANGE</a> 或 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrangebyscore.html#zrevrangebyscore">ZREVRANGEBYSCORE</a> 这类以逆序处理有序集的命令时，就会用到这个属性。</li>
</ol>
<p>这个修改版的跳跃表由 <code>redis.h/zskiplist</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>跳跃表的节点由 <code>redis.h/zskiplistNode</code> 定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>以下是操作这两个数据结构的 API ，API 的用途与相应的算法复杂度：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
<th align="left">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zslCreateNode</code></td>
<td align="left">创建并返回一个新的跳跃表节点</td>
<td align="left">最坏 O(1)O(1)</td>
</tr>
<tr>
<td align="left"><code>zslFreeNode</code></td>
<td align="left">释放给定的跳跃表节点</td>
<td align="left">最坏 O(1)O(1)</td>
</tr>
<tr>
<td align="left"><code>zslCreate</code></td>
<td align="left">创建并初始化一个新的跳跃表</td>
<td align="left">最坏 O(1)O(1)</td>
</tr>
<tr>
<td align="left"><code>zslFree</code></td>
<td align="left">释放给定的跳跃表</td>
<td align="left">最坏 O(N)O(N)</td>
</tr>
<tr>
<td align="left"><code>zslInsert</code></td>
<td align="left">将一个包含给定 <code>score</code> 和 <code>member</code> 的新节点添加到跳跃表中</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslDeleteNode</code></td>
<td align="left">删除给定的跳跃表节点</td>
<td align="left">最坏 O(N)O(N)</td>
</tr>
<tr>
<td align="left"><code>zslDelete</code></td>
<td align="left">删除匹配给定 <code>member</code> 和 <code>score</code> 的元素</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslFirstInRange</code></td>
<td align="left">找到跳跃表中第一个符合给定范围的元素</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslLastInRange</code></td>
<td align="left">找到跳跃表中最后一个符合给定范围的元素</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslDeleteRangeByScore</code></td>
<td align="left">删除 <code>score</code> 值在给定范围内的所有节点</td>
<td align="left">最坏 O(N2)O(N2)</td>
</tr>
<tr>
<td align="left"><code>zslDeleteRangeByRank</code></td>
<td align="left">删除给定排序范围内的所有节点</td>
<td align="left">最坏 O(N2)O(N2)</td>
</tr>
<tr>
<td align="left"><code>zslGetRank</code></td>
<td align="left">返回目标元素在有序集中的排位</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslGetElementByRank</code></td>
<td align="left">根据给定排位，返回该排位上的元素节点</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
</tbody></table>
<h4 id="跳跃表的应用"><a href="#跳跃表的应用" class="headerlink" title="跳跃表的应用"></a>跳跃表的应用</h4><p>和字典、链表或者字符串这几种在 Redis 中大量使用的数据结构不同， 跳跃表在 Redis 的唯一作用， 就是实现有序集数据类型。</p>
<p>跳跃表将指向有序集的 <code>score</code> 值和 <code>member</code> 域的指针作为元素， 并以 <code>score</code> 值为索引， 对有序集元素进行排序。</p>
<p>举个例子， 以下代码创建了一个带有 3 个元素的有序集：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">ZADD s 6 x 10 y 15 z</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">ZRANGE s 0 -1 WITHSCORES</span></span><br><span class="line">1) &quot;x&quot;</span><br><span class="line">2) &quot;6&quot;</span><br><span class="line">3) &quot;y&quot;</span><br><span class="line">4) &quot;10&quot;</span><br><span class="line">5) &quot;z&quot;</span><br><span class="line">6) &quot;15&quot;</span><br></pre></td></tr></table></figure>

<p>在底层实现中， Redis 为 <code>x</code> 、 <code>y</code> 和 <code>z</code> 三个 <code>member</code> 分别创建了三个字符串， 值分别为 <code>double</code> 类型的 <code>6</code> 、 <code>10</code> 和 <code>15</code> ， 然后用跳跃表将这些指针有序地保存起来， 形成这样一个跳跃表：</p>
<p><img src="http://static.cyblogs.com/QQ20200329-225534@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200329-225534@2x.jpg"></p>
<p>为了方便展示， 在图片中我们直接将 <code>member</code> 和 <code>score</code> 值包含在表节点中， 但是在实际的定义中， 因为跳跃表要和另一个实现有序集的结构（字典）分享 <code>member</code> 和 <code>score</code> 值， 所以跳跃表只保存指向 <code>member</code> 和 <code>score</code> 的指针。 更详细的信息，请参考《<a target="_blank" rel="noopener" href="https://redisbook.readthedocs.io/en/latest/datatype/sorted_set.html#sorted-set-chapter">有序集</a>》章节。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>❑跳跃表是有序集合的底层实现之一。</p>
<p>❑Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</p>
<p>❑每个跳跃表节点的层高都是1至32之间的随机数。</p>
<p>❑在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</p>
<p>❑跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html">https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html</a></li>
<li>书籍：《Redis设计与实现》</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/21/2020/03/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/21/2020/03/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Redis事务的设计与实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-21T00:00:00+08:00">2020-03-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Redis 通过 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi">MULTI</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard">DISCARD</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 和 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch">WATCH</a> 四个命令来实现事务功能， 本章首先讨论使用 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi">MULTI</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard">DISCARD</a> 和 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 三个命令实现的一般事务， 然后再来讨论带有 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch">WATCH</a> 的事务的实现。</p>
<p>因为事务的安全性也非常重要， 所以本章最后通过常见的 ACID 性质对 Redis 事务的安全性进行了说明。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。</p>
<p>以下是一个事务的例子， 它先以 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi">MULTI</a> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 命令触发事务， 一并执行事务中的所有命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">MULTI</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET book-name <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GET book-name</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SADD tag <span class="string">&quot;C++&quot;</span> <span class="string">&quot;Programming&quot;</span> <span class="string">&quot;Mastering Series&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SMEMBERS tag</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EXEC</span></span><br><span class="line">1) OK</span><br><span class="line">2) &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) 1) &quot;Mastering Series&quot;</span><br><span class="line">   2) &quot;C++&quot;</span><br><span class="line">   3) &quot;Programming&quot;</span><br></pre></td></tr></table></figure>

<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ol>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ol>
<p>下文将分别介绍事务的这三个阶段。</p>
<h4 id="开始事务"><a href="#开始事务" class="headerlink" title="开始事务"></a>开始事务</h4><p><a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi">MULTI</a> 命令的执行标记着事务的开始：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">MULTI</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>这个命令唯一做的就是， 将客户端的 <code>REDIS_MULTI</code> 选项打开， 让客户端从非事务状态切换到事务状态。</p>
<p><img src="http://static.cyblogs.com/QQ20200308-222741@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200308-222741@2x.jpg"></p>
<h4 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET msg <span class="string">&quot;hello moto&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GET msg</span></span><br><span class="line">&quot;hello moto&quot;</span><br></pre></td></tr></table></figure>

<p>但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 <code>QUEUED</code> ， 表示命令已入队：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">MULTI</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET msg <span class="string">&quot;hello moto&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GET msg</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>

<p>以下流程图展示了这一行为：</p>
<p><img src="http://static.cyblogs.com/Redis%E4%BA%8B%E7%89%A9%E9%98%9F%E5%88%97.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Redis事物队列.jpg"></p>
<p>事务队列是一个数组， 每个数组项是都包含三个属性：</p>
<ol>
<li>要执行的命令（cmd）。</li>
<li>命令的参数（argv）。</li>
<li>参数的个数（argc）。</li>
</ol>
<p>举个例子， 如果客户端执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">MULTI</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET book-name <span class="string">&quot;Mastering C++ in 21 days&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GET book-name</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SADD tag <span class="string">&quot;C++&quot;</span> <span class="string">&quot;Programming&quot;</span> <span class="string">&quot;Mastering Series&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SMEMBERS tag</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>

<p>那么程序将为客户端创建以下事务队列：</p>
<table>
<thead>
<tr>
<th align="left">数组索引</th>
<th align="left">cmd</th>
<th align="left">argv</th>
<th align="left">argc</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code></td>
<td align="left"><code>SET</code></td>
<td align="left"><code>[&quot;book-name&quot;, &quot;Mastering C++ in 21 days&quot;]</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left"><code>GET</code></td>
<td align="left"><code>[&quot;book-name&quot;]</code></td>
<td align="left"><code>1</code></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>SADD</code></td>
<td align="left"><code>[&quot;tag&quot;, &quot;C++&quot;, &quot;Programming&quot;, &quot;Mastering Series&quot;]</code></td>
<td align="left"><code>4</code></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>SMEMBERS</code></td>
<td align="left"><code>[&quot;tag&quot;]</code></td>
<td align="left"><code>1</code></td>
</tr>
</tbody></table>
<h4 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h4><p>前面说到， 当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。</p>
<p>但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard">DISCARD</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi">MULTI</a> 和 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch">WATCH</a> 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-225830@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200308-225830@2x.jpg"></p>
<p>如果客户端正处于事务状态， 那么当 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p>
<p>比如说，对于以下事务队列：</p>
<table>
<thead>
<tr>
<th align="left">数组索引</th>
<th align="left">cmd</th>
<th align="left">argv</th>
<th align="left">argc</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code></td>
<td align="left"><code>SET</code></td>
<td align="left"><code>[&quot;book-name&quot;, &quot;Mastering C++ in 21 days&quot;]</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left"><code>GET</code></td>
<td align="left"><code>[&quot;book-name&quot;]</code></td>
<td align="left"><code>1</code></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>SADD</code></td>
<td align="left"><code>[&quot;tag&quot;, &quot;C++&quot;, &quot;Programming&quot;, &quot;Mastering Series&quot;]</code></td>
<td align="left"><code>4</code></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>SMEMBERS</code></td>
<td align="left"><code>[&quot;tag&quot;]</code></td>
<td align="left"><code>1</code></td>
</tr>
</tbody></table>
<p>程序会首先执行 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/string/set.html#set">SET</a> 命令， 然后执行 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/string/get.html#get">GET</a> 命令， 再然后执行 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/set/sadd.html#sadd">SADD</a> 命令， 最后执行 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/set/smembers.html#smembers">SMEMBERS</a> 命令。</p>
<p>执行事务中的命令所得的结果会以 FIFO 的顺序保存到一个回复队列中。</p>
<p>比如说，对于上面给出的事务队列，程序将为队列中的命令创建如下回复队列：</p>
<table>
<thead>
<tr>
<th align="left">数组索引</th>
<th align="left">回复类型</th>
<th align="left">回复内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code></td>
<td align="left">status code reply</td>
<td align="left"><code>OK</code></td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left">bulk reply</td>
<td align="left"><code>&quot;Mastering C++ in 21 days&quot;</code></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left">integer reply</td>
<td align="left"><code>3</code></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left">multi-bulk reply</td>
<td align="left"><code>[&quot;Mastering Series&quot;, &quot;C++&quot;, &quot;Programming&quot;]</code></td>
</tr>
</tbody></table>
<p>当事务队列里的所有命令被执行完之后， <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 命令会将回复队列作为自己的执行结果返回给客户端， 客户端从事务状态返回到非事务状态， 至此， 事务执行完毕。</p>
<p>事务的整个执行过程可以用以下伪代码表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">execute_transaction</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建空白的回复队列</span></span><br><span class="line">    reply_queue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出事务队列里的所有命令、参数和参数数量</span></span><br><span class="line">    <span class="keyword">for</span> cmd, argv, argc <span class="keyword">in</span> client.transaction_queue:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行命令，并取得命令的返回值</span></span><br><span class="line">        reply = execute_redis_command(cmd, argv, argc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将返回值追加到回复队列末尾</span></span><br><span class="line">        reply_queue.append(reply)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清除客户端的事务状态</span></span><br><span class="line">    clear_transaction_state(client)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清空事务队列</span></span><br><span class="line">    clear_transaction_queue(client)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将事务的执行结果返回给客户端</span></span><br><span class="line">    send_reply_to_client(client, reply_queue)</span><br></pre></td></tr></table></figure>

<h4 id="在事务和非事务状态下执行命令"><a href="#在事务和非事务状态下执行命令" class="headerlink" title="在事务和非事务状态下执行命令"></a>在事务和非事务状态下执行命令</h4><p>无论在事务状态下， 还是在非事务状态下， Redis 命令都由同一个函数执行， 所以它们共享很多服务器的一般设置， 比如 AOF 的配置、RDB 的配置，以及内存限制，等等。</p>
<p>不过事务中的命令和普通命令在执行上还是有一点区别的，其中最重要的两点是：</p>
<ol>
<li><p>非事务状态下的命令以单个命令为单位执行，前一个命令和后一个命令的客户端不一定是同一个；</p>
<p>而事务状态则是以一个事务为单位，执行事务队列中的所有命令：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。</p>
</li>
<li><p>在非事务状态下，执行命令所得的结果会立即被返回给客户端；</p>
<p>而事务则是将所有命令的结果集合到回复队列，再作为 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 命令的结果返回给客户端。</p>
</li>
</ol>
<h4 id="事务状态下的-DISCARD-、-MULTI-和-WATCH-命令"><a href="#事务状态下的-DISCARD-、-MULTI-和-WATCH-命令" class="headerlink" title="事务状态下的 DISCARD 、 MULTI 和 WATCH 命令"></a>事务状态下的 DISCARD 、 MULTI 和 WATCH 命令</h4><p>除了 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard">DISCARD</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi">MULTI</a> 和 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch">WATCH</a> 。</p>
<p><a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard">DISCARD</a> 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 <code>OK</code> 给客户端， 说明事务已被取消。</p>
<p>Redis 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi">MULTI</a> 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi">MULTI</a> 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</p>
<p><a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch">WATCH</a> 只能在客户端进入事务状态之前执行， 在事务状态下发送 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch">WATCH</a> 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi">MULTI</a> 的情况一样）。</p>
<h4 id="带-WATCH-的事务"><a href="#带-WATCH-的事务" class="headerlink" title="带 WATCH 的事务"></a>带 WATCH 的事务</h4><p><a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch">WATCH</a> 命令用于在事务开始之前监视任意数量的键： 当调用 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。</p>
<p>以下示例展示了一个执行失败的事务例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">WATCH name</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">MULTI</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET name peter</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EXEC</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>以下执行序列展示了上面的例子是如何失败的：</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">客户端 A</th>
<th align="left">客户端 B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left"><code>WATCH name</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"><code>MULTI</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"><code>SET name peter</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left"><code>SET name john</code></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"><code>EXEC</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在时间 T4 ，客户端 B 修改了 <code>name</code> 键的值， 当客户端 A 在 T5 执行 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 时，Redis 会发现 <code>name</code> 这个被监视的键已经被修改， 因此客户端 A 的事务不会被执行，而是直接返回失败。</p>
<p>下文就来介绍 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch">WATCH</a> 的实现机制，并且看看事务系统是如何检查某个被监视的键是否被修改，从而保证事务的安全性的。</p>
<h4 id="WATCH-命令的实现"><a href="#WATCH-命令的实现" class="headerlink" title="WATCH 命令的实现"></a>WATCH 命令的实现</h4><p>在每个代表数据库的 <code>redis.h/redisDb</code> 结构类型中， 都保存了一个 <code>watched_keys</code> 字典， 字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端。</p>
<p>比如说，以下字典就展示了一个 <code>watched_keys</code> 字典的例子：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-225905@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200308-225905@2x.jpg"></p>
<p>其中， 键 <code>key1</code> 正在被 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端监视， 其他一些键也分别被其他别的客户端监视着。</p>
<p><a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch">WATCH</a> 命令的作用， 就是将当前客户端和要监视的键在 <code>watched_keys</code> 中进行关联。</p>
<p>举个例子， 如果当前客户端为 <code>client10086</code> ， 那么当客户端执行 <code>WATCH key1 key2</code> 时， 前面展示的 <code>watched_keys</code> 将被修改成这个样子：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-225928@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200308-225928@2x.jpg"></p>
<p>通过 <code>watched_keys</code> 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p>
<h4 id="WATCH-的触发"><a href="#WATCH-的触发" class="headerlink" title="WATCH 的触发"></a>WATCH 的触发</h4><p>在任何对数据库键空间（key space）进行修改的命令成功执行之后 （比如 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/server/flushdb.html#flushdb">FLUSHDB</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/string/set.html#set">SET</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/key/del.html#del">DEL</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/list/lpush.html#lpush">LPUSH</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/set/sadd.html#sadd">SADD</a> 、 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/sorted_set/zrem.html#zrem">ZREM</a> ，诸如此类）， <code>multi.c/touchWatchedKey</code> 函数都会被调用 —— 它检查数据库的 <code>watched_keys</code> 字典， 看是否有客户端在监视已经被命令修改的键， 如果有的话， 程序将所有监视这个&#x2F;这些被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-225953@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200308-225953@2x.jpg"></p>
<p>当客户端发送 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 命令、触发事务执行时， 服务器会对客户端的状态进行检查：</p>
<ul>
<li>如果客户端的 <code>REDIS_DIRTY_CAS</code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li>
<li>如果 <code>REDIS_DIRTY_CAS</code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li>
</ul>
<p>可以用一段伪代码来表示这个检查：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_safety_before_execute_trasaction</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> client.state &amp; REDIS_DIRTY_CAS:</span><br><span class="line">        <span class="comment"># 安全性已破坏，清除事务状态</span></span><br><span class="line">        clear_transaction_state(client)</span><br><span class="line">        <span class="comment"># 清空事务队列</span></span><br><span class="line">        clear_transaction_queue(client)</span><br><span class="line">        <span class="comment"># 返回空回复给客户端</span></span><br><span class="line">        send_empty_reply(client)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 安全性完好，执行事务</span></span><br><span class="line">        execute_transaction()</span><br></pre></td></tr></table></figure>

<p>举个例子，假设数据库的 <code>watched_keys</code> 字典如下图所示：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-230029@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200308-230029@2x.jpg"></p>
<h4 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h4><p>在传统的关系式数据库中，常常用 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/ACID">ACID 性质</a>来检验事务功能的安全性。</p>
<p>Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p>
<p>以下四小节是关于这四个性质的详细讨论。</p>
<h5 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h5><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p>
<p>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。</p>
<p>当事务失败时，Redis 也不会进行任何的重试或者回滚动作。</p>
<h5 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h5><p>Redis 的一致性问题可以分为三部分来讨论：入队错误、执行错误、Redis 进程被终结。</p>
<h6 id="入队错误"><a href="#入队错误" class="headerlink" title="入队错误"></a>入队错误</h6><p>在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等， 那么服务器将向客户端返回一个出错信息， 并且将客户端的事务状态设为 <code>REDIS_DIRTY_EXEC</code> 。</p>
<p>当客户端执行 <a target="_blank" rel="noopener" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec">EXEC</a> 命令时， Redis 会拒绝执行状态为 <code>REDIS_DIRTY_EXEC</code> 的事务， 并返回失败信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; set key</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;set&#x27; command</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXISTS key</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>

<p>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</p>
<h6 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h6><p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作， 那么 Redis 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。</p>
<h6 id="Redis-进程被终结"><a href="#Redis-进程被终结" class="headerlink" title="Redis 进程被终结"></a>Redis 进程被终结</h6><p>如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：</p>
<ul>
<li><p>内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p>
</li>
<li><p>RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</p>
</li>
<li><p>AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：</p>
<p>1）如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</p>
<p>2）如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p>
</li>
</ul>
<h5 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h5><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h5 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h5><p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：</p>
<ul>
<li><p>在单纯的内存模式下，事务肯定是不持久的。</p>
</li>
<li><p>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。</p>
</li>
<li><p>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 <code>fsync</code> 或 <code>fdatasync</code> 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</p>
<p>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</p>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li>
<li>事务在执行过程中不会被中断，所有事务命令执行完之后，事务才能结束。</li>
<li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li>
<li>带 <code>WATCH</code> 命令的事务会将客户端和被监视的键在数据库的 <code>watched_keys</code> 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开。</li>
<li>只有在客户端的 <code>REDIS_DIRTY_CAS</code> 选项未被打开时，才能执行事务，否则事务直接返回失败。</li>
<li>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html">https://redisbook.readthedocs.io/en/latest/feature/transaction.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/20/2020/03/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E5%8C%BA%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/20/2020/03/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E5%8C%BA%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Redis哨兵模式与分区详细分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-20T00:00:00+08:00">2020-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一、Redis-Sentinel-哨兵"><a href="#一、Redis-Sentinel-哨兵" class="headerlink" title="一、Redis-Sentinel(哨兵)"></a>一、Redis-Sentinel(哨兵)</h3><h4 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>Redis-Sentinel是redis官方推荐的高可用性解决方案，<br>当用redis作master-slave的高可用时，如果master本身宕机，redis本身或者客户端都没有实现主从切换的功能。</p>
<p>而redis-sentinel就是一个独立运行的进程，用于监控多个master-slave集群，<br>自动发现master宕机，进行自动切换slave &gt; master。</p>
<p><strong>sentinel主要功能如下：</strong></p>
<p>　　1. 不时的监控redis是否良好运行，如果节点不可达就会对节点进行下线标识<br>　　2. 如果被标识的是主节点，sentinel就会和其他的sentinel节点“协商”，如果其他节点也认为主节点不可达，<br>　　  就会选举一个sentinel节点来完成自动故障转移<br>　　3. 在master-slave进行切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，<br>　　  即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换</p>
<h4 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h4><p>每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令</p>
<p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。</p>
<p>如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。</p>
<p>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线</p>
<p>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令</p>
<p>当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次</p>
<p>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。</p>
<p>若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p>
<p>主观下线和客观下线</p>
<p>主观下线：Subjectively Down，简称 SDOWN，指的是当前 Sentinel 实例对某个redis服务器做出的下线判断。<br>客观下线：Objectively Down， 简称 ODOWN，指的是多个 Sentinel 实例在对Master Server做出 SDOWN 判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master Server下线判断，然后开启failover.</p>
<p>SDOWN适合于Master和Slave，只要一个 Sentinel 发现Master进入了ODOWN， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对下线的主服务器执行自动故障迁移操作。</p>
<p>ODOWN只适用于Master，对于Slave的 Redis 实例，Sentinel 在将它们判断为下线前不需要进行协商， 所以Slave的 Sentinel 永远不会达到ODOWN。</p>
<h4 id="3、master宕机处理"><a href="#3、master宕机处理" class="headerlink" title="3、master宕机处理"></a>3、master宕机处理</h4><p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081403893-388342745.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081416634-1637699103.png" alt="img"></p>
<p>如果master宕机，我们应该先选一个slave出来，让他成为新的master，其他redis都修改成这个新的master的slave，但是redis本身或者客户端都没有实现主从切换的功能，当然，人为地修改配置文件，实现上图的功能也是可以的，但是如果是在深夜，所有人都睡觉了呢，谁来修改配置信息？这个时候就可以使用redis的Sentinel功能了，它就是实现了，当发现master宕机，自动帮我们去修改其他redis配置文件，选举出一个新master。</p>
<h4 id="4、Sentinel功能实现图"><a href="#4、Sentinel功能实现图" class="headerlink" title="4、Sentinel功能实现图"></a>4、Sentinel功能实现图</h4><p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081538985-1395233418.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081557550-451529206.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081612394-1096354711.png" alt="img"></p>
<h4 id="5、redis一些查看命令"><a href="#5、redis一些查看命令" class="headerlink" title="5、redis一些查看命令"></a>5、redis一些查看命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli info  # 查看redis数据库信息</span><br><span class="line"></span><br><span class="line">redis-cli info replication # 查看redis的复制授权信息(主从复制)</span><br><span class="line"></span><br><span class="line">redis-cli info sentinel   # 查看redis的哨兵信息</span><br></pre></td></tr></table></figure>

<h4 id="6、Redis主从配置"><a href="#6、Redis主从配置" class="headerlink" title="6、Redis主从配置"></a>6、Redis主从配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">1.准备三个redis实例，一主两从</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-6379.conf配置</span></span><br><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">dbfilename &quot;dump-6379.rdb&quot;</span><br><span class="line">dir &quot;/var/redis/data/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-6380.conf配置</span></span><br><span class="line">port 6380</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6380.log&quot;</span><br><span class="line">dbfilename &quot;dump-6380.rdb&quot;</span><br><span class="line">dir &quot;/var/redis/data/&quot;</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-6381.conf配置</span></span><br><span class="line">port 6381</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6381.log&quot;</span><br><span class="line">dbfilename &quot;dump-6381.rdb&quot;</span><br><span class="line">dir &quot;/var/redis/data/&quot;</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 准备好了三个数据库实例，启动三个数据库实例</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动前记得先去创建redis数据存放的文件夹</span></span><br><span class="line">mkdir -p /var/redis/data/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动实例</span></span><br><span class="line">redis-server  redis-6379.conf</span><br><span class="line">redis-server  redis-6380.conf</span><br><span class="line">redis-server  redis-6381.conf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看redis服务是否已经启动</span></span><br><span class="line">ps -ef | grep redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 确定主从关系</span><br><span class="line">redis-cli  -p 6379 info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=336,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=336,lag=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis-cli  -p 6380 info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br></pre></td></tr></table></figure>

<h4 id="7、Redis-Sentinel安装配置"><a href="#7、Redis-Sentinel安装配置" class="headerlink" title="7、Redis Sentinel安装配置"></a>7、Redis Sentinel安装配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">1. Sentinel配置解析</span><br><span class="line">port 26379  // Sentinel的端口</span><br><span class="line">dir /var/redis/data/  // Sentinel日志文件存放位置</span><br><span class="line">logfile &quot;26379.log&quot;  // Sentinel日志文件名字</span><br><span class="line"></span><br><span class="line">// 当前Sentinel节点监控 127.0.0.1:6379 这个主节点</span><br><span class="line">// 2代表判断主节点失败至少需要2个Sentinel节点节点同意</span><br><span class="line">// mymaster是主节点的别名</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line">// 每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达</span><br><span class="line">// 如果超过30000毫秒30s且没有回复，则判定不可达</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line">// 当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，</span><br><span class="line">// 原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">//故障转移超时时间为180000毫秒</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line">// 后台执行</span><br><span class="line">daemonize yes </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 准备三个哨兵，开始监控主从架构</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">哨兵配置文件redis-26379.conf</span></span><br><span class="line">port 26379  </span><br><span class="line">dir /var/redis/data/</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line">sentinel monitor zbjmaster  127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds zbjmaster 30000</span><br><span class="line">sentinel parallel-syncs zbjmaster 1</span><br><span class="line">sentinel failover-timeout zbjmaster 180000</span><br><span class="line">daemonize yes </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">哨兵配置文件redis-26380.conf</span></span><br><span class="line">port 26380  </span><br><span class="line">dir /var/redis/data/</span><br><span class="line">logfile &quot;26380.log&quot;</span><br><span class="line">sentinel monitor zbjmaster  127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds zbjmaster 30000</span><br><span class="line">sentinel parallel-syncs zbjmaster 1</span><br><span class="line">sentinel failover-timeout zbjmaster 180000</span><br><span class="line">daemonize yes </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">哨兵配置文件redis-26381.conf</span></span><br><span class="line">port 26381  </span><br><span class="line">dir /var/redis/data/</span><br><span class="line">logfile &quot;26381.log&quot;</span><br><span class="line">sentinel monitor zbjmaster  127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds zbjmaster 30000</span><br><span class="line">sentinel parallel-syncs zbjmaster 1</span><br><span class="line">sentinel failover-timeout zbjmaster 180000</span><br><span class="line">daemonize yes </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">3. 启动三个哨兵实例</span><br><span class="line">redis-sentinel redis-26379.conf</span><br><span class="line">redis-sentinel redis-26380.conf</span><br><span class="line">redis-sentinel redis-26381.conf</span><br><span class="line"></span><br><span class="line">注意！！如果发现实验不成功，需删掉所有的哨兵配置文件，从新来过</span><br><span class="line">注意！！如果发现实验不成功，需删掉所有的哨兵配置文件，从新来过</span><br><span class="line">注意！！如果发现实验不成功，需删掉所有的哨兵配置文件，从新来过</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查哨兵状态是否正常</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只有发现如下信息，即为正常</span></span><br><span class="line">redis-cli -p 26379 info sentinel</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sentinel</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最重要的一句</span></span><br><span class="line">master0:name=zbjmaster,status=ok,address=127.0.0.1:6380,slaves=2,sentinels=3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 测试哨兵的自动主从切换</span><br><span class="line">1,干掉6379的redis数据库</span><br><span class="line">    kill -9 6379的PID</span><br><span class="line"></span><br><span class="line">2,查看6380和6381的身份信息，是否自动的进行主从切换</span><br><span class="line">    我们设置的是30s后master没有响应，哨兵自动进行主从切换，因此30s后查看主从信息</span><br><span class="line">    redis-cli -p 6380 info replication</span><br><span class="line">    redis-cli -p 6381 info replication</span><br><span class="line">    </span><br><span class="line">3,手动启动6379挂掉的数据库，查看是否会被哨兵，添加进信息的主从集群</span><br><span class="line">    redis-server redis-6379.conf</span><br><span class="line">    redis-cli -p 6379 info replication</span><br></pre></td></tr></table></figure>

<h3 id="二、redis分区和集群"><a href="#二、redis分区和集群" class="headerlink" title="二、redis分区和集群"></a>二、redis分区和集群</h3><h4 id="1、什么是分区和集群"><a href="#1、什么是分区和集群" class="headerlink" title="1、什么是分区和集群"></a>1、什么是分区和集群</h4><ol>
<li><p>分区<br><strong>分区是分割数据到多个Redis实例的处理过程</strong>，因此每个实例只保存key的一个子集。<br>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。<br>分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
</li>
<li><p>集群<br><strong>redis集群就是分区的一种的实现</strong></p>
</li>
</ol>
<h4 id="2、为什么要用分区"><a href="#2、为什么要用分区" class="headerlink" title="2、为什么要用分区"></a>2、为什么要用分区</h4><ol>
<li><p>并发问题<br>官方声称 redis 每秒可以执行10万条命令<br>但是假如业务需要每秒100万的命令执行呢(例如新浪微博某某明星出轨、官宣之类的)</p>
</li>
<li><p>数据量<br>当数据量太大的时候，一台服务器内存正常是16~256G，假如你的业务需要500G内存，怎么办？</p>
</li>
<li><p>解决方案</p>
<ol>
<li>方案一：<br>配置一台超级牛逼的服务器，拥有超大内存和超强的cpu，<br>但是这么做的成本是非常高的，而且，万一这台机器宕掉了，那你的服务还不是全挂了。</li>
<li>方案二：<br>考虑分布式，加机器，把数据分到不同的位置，分摊集中式的压力，一堆机器做一件事。</li>
</ol>
</li>
</ol>
<h4 id="3、分区的数据分布理论"><a href="#3、分区的数据分布理论" class="headerlink" title="3、分区的数据分布理论"></a>3、分区的数据分布理论</h4><p>redis是一个非关系型数据库，它的存储是key-value形式的，<br>redis实例集群主要思想是将redis数据的key进行散列，通过hash函数特定的key会映射到指定的redis节点上</p>
<p>分布式数据库首要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整个数据的一个子集。</p>
<p><strong>常见的分区规则有哈希分区和顺序分区。</strong></p>
<h4 id="4、顺序分区"><a href="#4、顺序分区" class="headerlink" title="4、顺序分区"></a>4、顺序分区</h4><p>假设我有三个节点，100个redis的数据，按照平均值(几乎是平均的)，顺序分区的规则就是：<br>把1-33个数据 放在 node1<br>把34-66个数据 放在node2<br>把67-100个数据 放在node3</p>
<h4 id="5、哈希分区"><a href="#5、哈希分区" class="headerlink" title="5、哈希分区"></a>5、哈希分区</h4><ol>
<li>节点取余<br>例如按照节点取余的方式，分三个节点<br>1~100的数据对3取余，可以分为三类<br>余数为0<br>余数为1<br>余数为2<br>把余数为0的数据存到同一个节点<br>把余数为1的数据存到同一个节点<br>把余数为2的数据存到同一个节点</li>
</ol>
<p>那么同样的分4个节点就是hash(key)%4，余数相同的存到同一个节点<br>节点取余的优点是简单，客户端分片直接是哈希+取余</p>
<ol start="2">
<li>一致性哈希<br>客户端进行分片，哈希+顺时针取余</li>
<li>虚拟槽分区<br>本文研究哈希分区之虚拟槽分区，因此下面单独来聊一聊</li>
</ol>
<h3 id="三、哈希分区之虚拟槽分区"><a href="#三、哈希分区之虚拟槽分区" class="headerlink" title="三、哈希分区之虚拟槽分区"></a>三、哈希分区之虚拟槽分区</h3><h4 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>Redis Cluster采用的就是虚拟槽分区</p>
<p>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有的数据映射到一个固定范围内的整数集合，<br>这些整数就定义为槽（slot）。</p>
<p><strong>Redis Cluster槽的范围是0 ～ 16383，即一共16384个槽</strong>。</p>
<p>槽是集群内数据管理和迁移的基本单位。采用大范围的槽的主要目的是为了方便数据的拆分和集群的扩展，</p>
<p>每个节点(redis实例)负责一定数量的槽。</p>
<h4 id="2、虚拟槽图解"><a href="#2、虚拟槽图解" class="headerlink" title="2、虚拟槽图解"></a>2、虚拟槽图解</h4><p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117082348428-1446271590.png" alt="img"></p>
<h4 id="3、搭建redis-cluster"><a href="#3、搭建redis-cluster" class="headerlink" title="3、搭建redis cluster"></a>3、搭建redis cluster</h4><p>redis支持多实例的功能，我们在单机演示集群搭建，需要6个实例，三个是主节点，三个是从节点，数量为6个节点才能保证高可用的集群。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">1.准备6个节点，用于存储数据，分配槽位，每个节点的配置，如下，仅仅是端口的区别</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-7000.conf配置</span></span><br><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/opt/redis/data&quot;</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dbfilename &quot;dump-7000.rdb&quot;</span><br><span class="line">cluster-enabled yes  </span><br><span class="line">cluster-config-file nodes-7000.conf　</span><br><span class="line"></span><br><span class="line">其余5个配置跟上面一模一样，仅仅是端口的区别</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-7001.conf配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-7002.conf配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-7003.conf配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-7004.conf配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">redis-7005.conf配置</span></span><br><span class="line"></span><br><span class="line">注意：要创建存放日志的文件夹  mkdir -p /opt/redis/data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.启动6个数据库实例</span><br><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">redis-server redis-7002.conf</span><br><span class="line">redis-server redis-7003.conf</span><br><span class="line">redis-server redis-7004.conf</span><br><span class="line">redis-server redis-7005.conf</span><br><span class="line"></span><br><span class="line">3.开始分配redis集群状态，以及槽位分配</span><br><span class="line">Redis Cluster本身提供了自动将数据分散到Redis Cluster不同节点的能力，</span><br><span class="line">但是槽位的分配就比较麻烦了，当然了，如果你是大神，你完全可以自定义槽位的分配，</span><br><span class="line">一些大神已经写好了槽位分配的工具或脚本了，例如豆瓣公司开源的codis工具，还有ruby语言的作者，写的redsi.rb，</span><br><span class="line">因此我们可以使用一些工具帮我们进行redis cluster的搭建</span><br><span class="line"></span><br><span class="line">4.通过ruby脚本，一键创建redis-cluster,进行槽位分配</span><br><span class="line"></span><br><span class="line">5.准备ruby的编程环境</span><br><span class="line">1,下载ruby的源码包</span><br><span class="line">wget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz</span><br><span class="line"></span><br><span class="line">2,解压缩ruby远吗</span><br><span class="line">tar -zxvf ruby-2.3.1.tar.gz</span><br><span class="line"></span><br><span class="line">3,开始编译安装ruby</span><br><span class="line">进入ruby源码包</span><br><span class="line">./configure --prefix=/opt/ruby/</span><br><span class="line"></span><br><span class="line">4,开始编译且编译安装</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">5,配置ruby的环境变量</span><br><span class="line">vim /etc/profile </span><br><span class="line">写入如下配置</span><br><span class="line">PATH=你原本的PATH:/opt/ruby/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">6.安装ruby操作redis的模块</span><br><span class="line">1,下载ruby操作redis的模块</span><br><span class="line">wget http://rubygems.org/downloads/redis-3.3.0.gem</span><br><span class="line"></span><br><span class="line">2,安装</span><br><span class="line">gem install -l redis-3.3.0.gem</span><br><span class="line"></span><br><span class="line">3,搜索创建redis集群的命令</span><br><span class="line">find /opt  -name  redis-trib.rb</span><br><span class="line">/opt/redis-4.0.10/src/redis-trib.rb</span><br><span class="line"></span><br><span class="line">7.一键创建redis集群</span><br><span class="line">/opt/redis-4.0.10/src/redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br><span class="line">--replicas  进行身份授权 </span><br><span class="line">后面的1  代表，每个主节点，只有一个从节点</span><br><span class="line">默认将 7000  7001  70002  设置为主库</span><br><span class="line">将7003  7004  7005  设置为从库</span><br><span class="line"></span><br><span class="line">8.检查集群状态</span><br><span class="line">redis-cli -p 7000 cluster info</span><br><span class="line"></span><br><span class="line">9.测试集群节点，看是否能正常写入数据</span><br><span class="line">redis-cli -c -p 7000</span><br><span class="line">    -p  指定数据库端口</span><br><span class="line">    -c  指定开启集群模式</span><br><span class="line"></span><br><span class="line">set age 18  # 设置一个key会自动分配槽位，重定向到槽位所在的节点即代表成功</span><br><span class="line"></span><br><span class="line">在任意一个节点都可以get age，会自动重定向到 age 所在的节点。</span><br><span class="line"></span><br><span class="line">10.redis-cluster 会默认将不同的key，进行CRC16算法，进行分配到不同槽位</span><br><span class="line"></span><br><span class="line">11.数据正常重定向，即redis集群ok</span><br></pre></td></tr></table></figure>

<h3 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Zzbj/p/10280363.html">https://www.cnblogs.com/Zzbj/p/10280363.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/10360619.html">https://www.cnblogs.com/rjzheng/p/10360619.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Vernon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <a target="_blank" href="https://beian.miit.gov.cn">粤ICP备2025433887号</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
