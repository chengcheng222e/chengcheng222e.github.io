<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.cyblogs.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="简栈文化">
<meta property="og:url" content="http://www.cyblogs.com/page/10/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.cyblogs.com/page/10/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/10/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>简栈文化</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">简栈文化</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java技术人的成长之路~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vernon"
      src="/images/vernonchen.jpg">
  <p class="site-author-name" itemprop="name">Vernon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengcheng222e" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengcheng222e" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengcheng222e@gmail.com" title="E-Mail → mailto:chengcheng222e@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/25/2020/02/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/25/2020/02/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="post-title-link" itemprop="url">Java深拷贝和浅拷贝</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-25T00:00:00+08:00">2020-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="对象拷贝有哪些"><a href="#对象拷贝有哪些" class="headerlink" title="对象拷贝有哪些"></a>对象拷贝有哪些</h4><p>对象拷贝(Object Copy)就是将一个对象的属性拷贝到另一个有着相同类类型的对象中去。在程序中拷贝对象是很常见的，主要是为了在新的上下文环境中复用对象的部分或全部数据。</p>
<p>Java中有三种类型的对象拷贝：</p>
<ul>
<li>浅拷贝(Shallow Copy)</li>
<li>深拷贝(Deep Copy)</li>
<li>延迟拷贝(Lazy Copy)</li>
</ul>
<h4 id="理解浅拷贝"><a href="#理解浅拷贝" class="headerlink" title="理解浅拷贝"></a>理解浅拷贝</h4><h5 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h5><ul>
<li>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。<ul>
<li><p>如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
</li>
<li><p><img src="http://static.cyblogs.com/QQ20200226-210909@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200226-210909@2x.jpg"></p>
</li>
<li><p>在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj”（引用ContainedObject类型的对象）。当对SourceObject做浅拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及仍指向refObj本身的引用。由于”field1”是基本类型，所以只是将它的值拷贝给”field2”，但是由于”refObj”是一个引用类型, 所以CopiedObject指向”refObj”相同的地址。因此对SourceObject中的”refObj”所做的任何改变都会影响到CopiedObject。</p>
</li>
</ul>
</li>
</ul>
<h5 id="如何实现浅拷贝"><a href="#如何实现浅拷贝" class="headerlink" title="如何实现浅拷贝"></a>如何实现浅拷贝</h5><p>下面来看一看实现浅拷贝的一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> String name; </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Subject</span><span class="params">(String s)</span> &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String s)</span> &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 对象引用 </span></span><br><span class="line">   <span class="keyword">private</span> Subject subj; </span><br><span class="line">   <span class="keyword">private</span> String name; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String s, String sub)</span> &#123; </span><br><span class="line">      name = s; </span><br><span class="line">      subj = <span class="keyword">new</span> <span class="title class_">Subject</span>(sub); </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> Subject <span class="title function_">getSubj</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> subj; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String s)</span> &#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    *  重写clone()方法 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="comment">//浅拷贝 </span></span><br><span class="line">      <span class="keyword">try</span> &#123; </span><br><span class="line">         <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">super</span>.clone(); </span><br><span class="line">      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123; </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemoMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 原始对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stud</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;杨充&quot;</span>, <span class="string">&quot;潇湘剑雨&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象: &quot;</span> + stud.getName() + <span class="string">&quot; - &quot;</span> + stud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">clonedStud</span> <span class="operator">=</span> (Student) stud.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;拷贝对象: &quot;</span> + clonedStud.getName() + <span class="string">&quot; - &quot;</span> + clonedStud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始对象和拷贝对象是否一样：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象和拷贝对象是否一样: &quot;</span> + (stud == clonedStud));</span><br><span class="line">        <span class="comment">// 原始对象和拷贝对象的name属性是否一样</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象和拷贝对象的name属性是否一样: &quot;</span> + (stud.getName() == clonedStud.getName()));</span><br><span class="line">        <span class="comment">// 原始对象和拷贝对象的subj属性是否一样</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象和拷贝对象的subj属性是否一样: &quot;</span> + (stud.getSubj() == clonedStud.getSubj()));</span><br><span class="line"></span><br><span class="line">        stud.setName(<span class="string">&quot;小杨逗比&quot;</span>);</span><br><span class="line">        stud.getSubj().setName(<span class="string">&quot;潇湘剑雨大侠&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;更新后的原始对象: &quot;</span> + stud.getName() + <span class="string">&quot; - &quot;</span> + stud.getSubj().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;更新原始对象后的克隆对象: &quot;</span> + clonedStud.getName() + <span class="string">&quot; - &quot;</span> + clonedStud.getSubj().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#x27;127.0.0.1:57836&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">原始对象: 杨充 - 潇湘剑雨</span><br><span class="line">拷贝对象: 杨充 - 潇湘剑雨</span><br><span class="line">原始对象和拷贝对象是否一样: false</span><br><span class="line">原始对象和拷贝对象的name属性是否一样: true</span><br><span class="line">原始对象和拷贝对象的subj属性是否一样: true</span><br><span class="line">更新后的原始对象: 小杨逗比 - 潇湘剑雨大侠</span><br><span class="line">更新原始对象后的克隆对象: 杨充 - 潇湘剑雨大侠</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:57836&#x27;, transport: &#x27;socket&#x27;</span><br></pre></td></tr></table></figure>

<p>可以得出的结论</p>
<ul>
<li>在这个例子中，让要拷贝的类Student实现了Clonable接口并重写Object类的clone()方法，然后在方法内部调用super.clone()方法。从输出结果中我们可以看到，对原始对象stud的”name”属性所做的改变并没有影响到拷贝对象clonedStud，但是对引用对象subj的”name”属性所做的改变影响到了拷贝对象clonedStud。</li>
</ul>
<h4 id="理解深拷贝"><a href="#理解深拷贝" class="headerlink" title="理解深拷贝"></a>理解深拷贝</h4><h5 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h5><ul>
<li>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。<ul>
<li><img src="http://static.cyblogs.com/QQ20200226-212333@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200226-212333@2x.jpg"></li>
<li>在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj1”（引用ContainedObject类型的对象）。当对SourceObject做深拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及包含”refObj1”拷贝值的引用类型属性”refObj2” 。因此对SourceObject中的”refObj”所做的任何改变都不会影响到CopiedObject</li>
</ul>
</li>
</ul>
<h5 id="实现深拷贝案例"><a href="#实现深拷贝案例" class="headerlink" title="实现深拷贝案例"></a>实现深拷贝案例</h5><p>下面是实现深拷贝的一个例子。只是在浅拷贝的例子上做了一点小改动，Subject 和CopyTest 类都没有变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepStudent</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 对象引用 </span></span><br><span class="line">    <span class="keyword">private</span> Subject subj;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeepStudent</span><span class="params">(String s, String sub)</span> &#123;</span><br><span class="line">        name = s;</span><br><span class="line">        subj = <span class="keyword">new</span> <span class="title class_">Subject</span>(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Subject <span class="title function_">getSubj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> subj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写clone()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立</span></span><br><span class="line">        <span class="type">DeepStudent</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepStudent</span>(name, subj.getName());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#x27;127.0.0.1:60802&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">原始对象: 杨充 - 潇湘剑雨</span><br><span class="line">拷贝对象: 杨充 - 潇湘剑雨</span><br><span class="line">原始对象和拷贝对象是否一样: false</span><br><span class="line">原始对象和拷贝对象的name属性是否一样: true</span><br><span class="line">原始对象和拷贝对象的subj属性是否一样: true</span><br><span class="line">更新后的原始对象: 小杨逗比 - 潇湘剑雨大侠</span><br><span class="line">更新原始对象后的克隆对象: 杨充 - 潇湘剑雨大侠</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:60802&#x27;, transport: &#x27;socket&#x27;</span><br></pre></td></tr></table></figure>

<p>得出的结论</p>
<ul>
<li>很容易发现clone()方法中的一点变化。因为它是深拷贝，所以你需要创建拷贝类的一个对象。因为在Student类中有对象引用，所以需要在Student类中实现Cloneable接口并且重写clone方法。</li>
</ul>
<h4 id="序列化进行拷贝"><a href="#序列化进行拷贝" class="headerlink" title="序列化进行拷贝"></a>序列化进行拷贝</h4><h5 id="序列化属于深拷贝"><a href="#序列化属于深拷贝" class="headerlink" title="序列化属于深拷贝"></a>序列化属于深拷贝</h5><p>可能你会问，序列化是属于那种类型拷贝？答案是：通过序列化来实现深拷贝。可以思考一下，为何序列化对象要用深拷贝而不是用浅拷贝呢？</p>
<h5 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h5><p>可以序列化是干什么的?它将整个对象图写入到一个持久化存储文件中并且当需要的时候把它读取回来, 这意味着当你需要把它读取回来时你需要整个对象图的一个拷贝。这就是当你深拷贝一个对象时真正需要的东西。请注意，当你通过序列化进行深拷贝时，必须确保对象图中所有类都是可序列化的。</p>
<h5 id="序列化案例"><a href="#序列化案例" class="headerlink" title="序列化案例"></a>序列化案例</h5><p>看一下下面案例，很简单，只需要实现Serializable这个接口。Android中还可以实现Parcelable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColoredCircle</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> x; </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> y; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ColoredCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">      <span class="built_in">this</span>.x = x; </span><br><span class="line">      <span class="built_in">this</span>.y = y; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> x; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">      <span class="built_in">this</span>.x = x; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> y; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123; </span><br><span class="line">      <span class="built_in">this</span>.y = y; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span> </span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;x=&quot;</span> + x + <span class="string">&quot;, y=&quot;</span> + y; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DouBi</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8752043194511106066L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DouBi</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setY</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyDemoMain3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建原始的可序列化对象</span></span><br><span class="line">            <span class="type">DouBi</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DouBi</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;原始的对象 = &quot;</span> + c1);</span><br><span class="line">            <span class="type">DouBi</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 通过序列化实现深拷贝</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">            <span class="comment">// 序列化以及传递这个对象</span></span><br><span class="line">            oos.writeObject(c1);</span><br><span class="line">            oos.flush();</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bin);</span><br><span class="line">            <span class="comment">// 返回新的对象</span></span><br><span class="line">            c2 = (DouBi) ois.readObject();</span><br><span class="line">            <span class="comment">// 校验内容是否相同</span></span><br><span class="line">            System.out.println(<span class="string">&quot;复制后的对象   = &quot;</span> + c2);</span><br><span class="line">            <span class="comment">// 改变原始对象的内容</span></span><br><span class="line">            c1.setX(<span class="number">200</span>);</span><br><span class="line">            c1.setY(<span class="number">200</span>);</span><br><span class="line">            <span class="comment">// 查看每一个现在的内容</span></span><br><span class="line">            System.out.println(<span class="string">&quot;查看原始的对象 = &quot;</span> + c1);</span><br><span class="line">            System.out.println(<span class="string">&quot;查看复制的对象 = &quot;</span> + c2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception in main = &quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#x27;127.0.0.1:62095&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">原始的对象 = com.vernon.test.copy.DouBi@1134affc</span><br><span class="line">复制后的对象   = com.vernon.test.copy.DouBi@1b604f19</span><br><span class="line">查看原始的对象 = com.vernon.test.copy.DouBi@1134affc</span><br><span class="line">查看复制的对象 = com.vernon.test.copy.DouBi@1b604f19</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:62095&#x27;, transport: &#x27;socket&#x27;</span><br></pre></td></tr></table></figure>

<p>注意：需要做以下几件事儿:</p>
<ul>
<li><p>确保对象图中的所有类都是可序列化的</p>
</li>
<li><p>创建输入输出流</p>
</li>
<li><p>使用这个输入输出流来创建对象输入和对象输出流</p>
</li>
<li><p>将你想要拷贝的对象传递给对象输出流</p>
</li>
<li><p>从对象输入流中读取新的对象并且转换回你所发送的对象的类</p>
</li>
<li><p>得出的结论</p>
<ul>
<li>在这个例子中，创建了一个DouBi对象c1然后将它序列化 (将它写到ByteArrayOutputStream中). 然后我反序列化这个序列化后的对象并将它保存到c2中。随后我修改了原始对象c1。然后结果如你所见，c1不同于c2，对c1所做的任何修改都不会影响c2。</li>
<li>注意，序列化这种方式有其自身的限制和问题：因为无法序列化transient变量, 使用这种方法将无法拷贝transient变量。再就是性能问题。创建一个socket, 序列化一个对象, 通过socket传输它, 然后反序列化它，这个过程与调用已有对象的方法相比是很慢的。所以在性能上会有天壤之别。如果性能对你的代码来说是至关重要的，建议不要使用这种方式。它比通过实现Clonable接口这种方式来进行深拷贝几乎多花100倍的时间。</li>
</ul>
</li>
</ul>
<h4 id="延迟拷贝"><a href="#延迟拷贝" class="headerlink" title="延迟拷贝"></a>延迟拷贝</h4><ul>
<li>延迟拷贝是浅拷贝和深拷贝的一个组合，实际上很少会使用。这个以前几乎都没听说过，后来看书才知道有这么一种拷贝！</li>
<li>当最开始拷贝一个对象时，会使用速度较快的浅拷贝，还会使用一个计数器来记录有多少对象共享这个数据。当程序想要修改原始的对象时，它会决定数据是否被共享（通过检查计数器）并根据需要进行深拷贝。</li>
<li>延迟拷贝从外面看起来就是深拷贝，但是只要有可能它就会利用浅拷贝的速度。当原始对象中的引用不经常改变的时候可以使用延迟拷贝。由于存在计数器，效率下降很高，但只是常量级的开销。而且, 在某些情况下, 循环引用会导致一些问题。</li>
</ul>
<h4 id="如何选择拷贝方式"><a href="#如何选择拷贝方式" class="headerlink" title="如何选择拷贝方式"></a>如何选择拷贝方式</h4><ul>
<li>如果对象的属性全是基本类型的，那么可以使用浅拷贝。</li>
<li>如果对象有引用属性，那就要基于具体的需求来选择浅拷贝还是深拷贝。</li>
<li>意思是如果对象引用任何时候都不会被改变，那么没必要使用深拷贝，只需要使用浅拷贝就行了。如果对象引用经常改变，那么就要使用深拷贝。没有一成不变的规则，一切都取决于具体需求。</li>
</ul>
<h4 id="数组的拷贝"><a href="#数组的拷贝" class="headerlink" title="数组的拷贝"></a>数组的拷贝</h4><ul>
<li>数组除了默认实现了clone()方法之外，还提供了Arrays.copyOf方法用于拷贝，这两者都是浅拷贝。</li>
</ul>
<h5 id="基本数据类型数组"><a href="#基本数据类型数组" class="headerlink" title="基本数据类型数组"></a>基本数据类型数组</h5><p>如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] lNumbers1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>[] rNumbers1 = Arrays.copyOf(lNumbers1, lNumbers1.length);</span><br><span class="line">    rNumbers1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> lNumbers1[<span class="number">0</span>] == rNumbers1[<span class="number">0</span>];</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;lNumbers2[0]=&quot;</span> + lNumbers1[<span class="number">0</span>] + <span class="string">&quot;,rNumbers2[0]=&quot;</span> + rNumbers1[<span class="number">0</span>]+<span class="string">&quot;---&quot;</span>+first);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] lNumbers3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>[] rNumbers3 = lNumbers3.clone();</span><br><span class="line">    rNumbers3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">second</span> <span class="operator">=</span> lNumbers3[<span class="number">0</span>] == rNumbers3[<span class="number">0</span>];</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;lNumbers3[0]=&quot;</span> + lNumbers3[<span class="number">0</span>] + <span class="string">&quot;,rNumbers3[0]=&quot;</span> + rNumbers3[<span class="number">0</span>]+<span class="string">&quot;---&quot;</span>+second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">09.907</span> <span class="number">30316</span>-<span class="number">30316</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers2[<span class="number">0</span>]=<span class="number">0</span>,rNumbers2[<span class="number">0</span>]=<span class="number">1</span>---<span class="literal">false</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">09.907</span> <span class="number">30316</span>-<span class="number">30316</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers3[<span class="number">0</span>]=<span class="number">0</span>,rNumbers3[<span class="number">0</span>]=<span class="number">1</span>---<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="引用数据类型数组"><a href="#引用数据类型数组" class="headerlink" title="引用数据类型数组"></a>引用数据类型数组</h4><p>如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">    People[] lNumbers1 = <span class="keyword">new</span> <span class="title class_">People</span>[<span class="number">5</span>];</span><br><span class="line">    lNumbers1[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">    People[] rNumbers1 = lNumbers1;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> lNumbers1[<span class="number">0</span>].equals(rNumbers1[<span class="number">0</span>]);</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;lNumbers1[0]=&quot;</span> + lNumbers1[<span class="number">0</span>] + <span class="string">&quot;,rNumbers1[0]=&quot;</span> + rNumbers1[<span class="number">0</span>]+<span class="string">&quot;--&quot;</span>+first);</span><br><span class="line"></span><br><span class="line">    People[] lNumbers2 = <span class="keyword">new</span> <span class="title class_">People</span>[<span class="number">5</span>];</span><br><span class="line">    lNumbers2[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">    People[] rNumbers2 = Arrays.copyOf(lNumbers2, lNumbers2.length);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">second</span> <span class="operator">=</span> lNumbers2[<span class="number">0</span>].equals(rNumbers2[<span class="number">0</span>]);</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;lNumbers2[0]=&quot;</span> + lNumbers2[<span class="number">0</span>] + <span class="string">&quot;,rNumbers2[0]=&quot;</span> + rNumbers2[<span class="number">0</span>]+<span class="string">&quot;--&quot;</span>+second);</span><br><span class="line"></span><br><span class="line">    People[] lNumbers3 = <span class="keyword">new</span> <span class="title class_">People</span>[<span class="number">5</span>];</span><br><span class="line">    lNumbers3[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">    People[] rNumbers3 = lNumbers3.clone();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">third</span> <span class="operator">=</span> lNumbers3[<span class="number">0</span>].equals(rNumbers3[<span class="number">0</span>]);</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;lNumbers3[0]=&quot;</span> + lNumbers3[<span class="number">0</span>] + <span class="string">&quot;,rNumbers3[0]=&quot;</span> + rNumbers3[<span class="number">0</span>]+<span class="string">&quot;--&quot;</span>+third);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Holder holder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="type">int</span> holderValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">17.054</span> <span class="number">31093</span>-<span class="number">31093</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers1[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People@46a2c18,rNumbers1[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People@46a2c18--<span class="literal">true</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">17.054</span> <span class="number">31093</span>-<span class="number">31093</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers2[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People<span class="meta">@d344671</span>,rNumbers2[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People<span class="meta">@d344671</span>--<span class="literal">true</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">17.054</span> <span class="number">31093</span>-<span class="number">31093</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers3[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People@91e9c56,rNumbers3[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People@91e9c56--<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="集合的拷贝"><a href="#集合的拷贝" class="headerlink" title="集合的拷贝"></a>集合的拷贝</h4><ul>
<li>集合的拷贝也是我们平时经常会遇到的，一般情况下，我们都是用浅拷贝来实现，即通过构造函数或者clone方法。</li>
</ul>
<h5 id="集合浅拷贝"><a href="#集合浅拷贝" class="headerlink" title="集合浅拷贝"></a>集合浅拷贝</h5><p>构造函数和 clone() 默认都是浅拷贝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;People&gt; lPeoples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">    lPeoples.add(people1);</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;lPeoples[0]=&quot;</span> + lPeoples.get(<span class="number">0</span>));</span><br><span class="line">    ArrayList&lt;People&gt; rPeoples = (ArrayList&lt;People&gt;) lPeoples.clone();</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;rPeoples[0]=&quot;</span> + rPeoples.get(<span class="number">0</span>));</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lPeoples.get(<span class="number">0</span>).equals(rPeoples.get(<span class="number">0</span>));</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;比较两个对象&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Holder holder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> (People) <span class="built_in">super</span>.clone();</span><br><span class="line">            people.holder = (People.Holder) <span class="built_in">this</span>.holder.clone();</span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> holderValue;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-03-25 14:56:56.931 31454-31454/org.yczbj.ycrefreshview D/小杨逗比: lPeoples[0]=org.yczbj.ycrefreshview.MainActivity$People@46a2c18</span><br><span class="line">2019-03-25 14:56:56.931 31454-31454/org.yczbj.ycrefreshview D/小杨逗比: rPeoples[0]=org.yczbj.ycrefreshview.MainActivity$People@46a2c18</span><br><span class="line">2019-03-25 14:56:56.931 31454-31454/org.yczbj.ycrefreshview D/小杨逗比: 比较两个对象true</span><br></pre></td></tr></table></figure>

<h5 id="集合深拷贝"><a href="#集合深拷贝" class="headerlink" title="集合深拷贝"></a>集合深拷贝</h5><p>在某些特殊情况下，如果需要实现集合的深拷贝，那就要创建一个新的集合，然后通过深拷贝原先集合中的每个元素，将这些元素加入到新的集合当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;People&gt; lPeoples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">People</span> <span class="variable">people1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">    people1.holder = <span class="keyword">new</span> <span class="title class_">People</span>.Holder();</span><br><span class="line">    lPeoples.add(people1);</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;lPeoples[0]=&quot;</span> + lPeoples.get(<span class="number">0</span>));</span><br><span class="line">    ArrayList&lt;People&gt; rPeoples = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (People people : lPeoples) &#123;</span><br><span class="line">        rPeoples.add((People) people.clone());</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;rPeoples[0]=&quot;</span> + rPeoples.get(<span class="number">0</span>));</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> lPeoples.get(<span class="number">0</span>).equals(rPeoples.get(<span class="number">0</span>));</span><br><span class="line">    Log.d(<span class="string">&quot;小杨逗比&quot;</span>, <span class="string">&quot;比较两个对象&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Holder holder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> (People) <span class="built_in">super</span>.clone();</span><br><span class="line">            people.holder = (People.Holder) <span class="built_in">this</span>.holder.clone();</span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> holderValue;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-03-25 15:00:54.610 31670-31670/org.yczbj.ycrefreshview D/小杨逗比: lPeoples[0]=org.yczbj.ycrefreshview.MainActivity$People@46a2c18</span><br><span class="line">2019-03-25 15:00:54.610 31670-31670/org.yczbj.ycrefreshview D/小杨逗比: rPeoples[0]=org.yczbj.ycrefreshview.MainActivity$People@d344671</span><br><span class="line">2019-03-25 15:00:54.610 31670-31670/org.yczbj.ycrefreshview D/小杨逗比: 比较两个对象false</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c988a7ef265da6116246d11">https://juejin.im/post/5c988a7ef265da6116246d11</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/24/2020/02/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BBUnsafe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/24/2020/02/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BBUnsafe/" class="post-title-link" itemprop="url">Java程序员必须要了解的类Unsafe</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-24T00:00:00+08:00">2020-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Java是一个安全的编程语言，它能最大程度的防止程序员犯一些低级的错误（大部分是和内存管理有关的）。但凡是不是绝对的，使用Unsafe程序员就可以操作内存，因此可能带来一个安全隐患。</p>
<p>这篇文章是就快速学习下<code>sun.misc.Unsafe</code>的公共API和一些有趣的使用例子。</p>
<h4 id="Unsafe-实例化"><a href="#Unsafe-实例化" class="headerlink" title="Unsafe 实例化"></a>Unsafe 实例化</h4><p>在使用Unsafe之前我们需要先实例化它。但我们不能通过像<code>Unsafe unsafe = new Unsafe()</code>这种简单的方式来实现Unsafe的实例化，这是由于Unsafe的构造方法是私有的。Unsafe有一个静态的getUnsafe()方法，但是如果天真的以为调用该方法就可以的话，那你将遇到一个<code>SecurityException</code>异常，这是由于该方法只能在被信任的代码中调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cc</span> <span class="operator">=</span> sun.reflect.Reflection.getCallerClass(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (cc.getClassLoader() != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那Java是如何判断我们的代码是否是受信的呢？它就是通过判断加载我们代码的类加载器是否是根类加载器。</p>
<p>我们可是通过这种方法将我们自己的代码变为受信的，使用jvm参数<code>bootclasspath</code>。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath:/usr/jdk1<span class="number">.7</span><span class="number">.0</span>/jre/lib/rt.jar:. com.mishadoff.magic.UnsafeClient</span><br></pre></td></tr></table></figure>

<p><strong>但这种方式太难了</strong></p>
<p>Unsafe类内部有一个名为<code>theUnsafe</code>的私有实例变量，我们可以通过反射来获取该实例变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 忽略你的IDE提示. 例如, eclipse可能会报这样的错误”Access restriction…” 单如果你运行你的代码，会发现一切正常。如果还是还是提示错误，你可以通过如下的方式关闭该错误提示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Preferences -&gt; Java -&gt; Compiler -&gt; Errors/Warnings -&gt;</span><br><span class="line">Deprecated and restricted API -&gt; Forbidden reference -&gt; Warning           </span><br></pre></td></tr></table></figure>

<h4 id="Unsafe-API"><a href="#Unsafe-API" class="headerlink" title="Unsafe API"></a>Unsafe API</h4><p>类 <a target="_blank" rel="noopener" href="http://www.docjar.com/docs/api/sun/misc/Unsafe.html">sun.misc.Unsafe</a> 由150个方法组成。事实上这些方法只有几组是非常重要的用来操作不同的对象。下面我们就来看下这些方法中的一部分。</p>
<ol>
<li><strong>Info</strong> 仅仅是返回一个低级别的内存相关的信息<ul>
<li>addressSize</li>
<li>pageSize</li>
</ul>
</li>
<li><strong>Objects</strong>. 提供操作对象和对象字段的方法<ul>
<li>allocateInstance</li>
<li>objectFieldOffset</li>
</ul>
</li>
<li><strong>Classes</strong>. 提供针对类和类的静态字段操作的方法<ul>
<li>staticFieldOffset</li>
<li>defineClass</li>
<li>defineAnonymousClass</li>
<li>ensureClassInitialized</li>
</ul>
</li>
<li><strong>Arrays</strong>. 数组操作<ul>
<li>arrayBaseOffset</li>
<li>arrayIndexScale</li>
</ul>
</li>
<li>Synchronization. 低级别的同步原语<ul>
<li>monitorEnter</li>
<li>tryMonitorEnter</li>
<li>monitorExit</li>
<li>compareAndSwapInt</li>
<li>putOrderedInt</li>
</ul>
</li>
<li>Memory. 直接访问内存的方法<ul>
<li>allocateMemory</li>
<li>copyMemory</li>
<li>freeMemory</li>
<li>getAddress</li>
<li>getInt</li>
<li>putInt</li>
</ul>
</li>
</ol>
<h4 id="有趣的使用case"><a href="#有趣的使用case" class="headerlink" title="有趣的使用case"></a>有趣的使用case</h4><h5 id="跳过构造初始化"><a href="#跳过构造初始化" class="headerlink" title="跳过构造初始化"></a>跳过构造初始化</h5><p>allocateInstance方法可能是有用的,当你需要在构造函数中跳过对象初始化阶段或绕过安全检查又或者你想要实例化哪些没有提供公共构造函数的类时就可以使用该方法。考虑下面的类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> a; <span class="comment">// not initialized value</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">1</span>; <span class="comment">// initialization</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">a</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.a; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过构造函数，反射，Unsafe分别来实例化该类结果是不同的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">// constructor</span></span><br><span class="line">o1.a(); <span class="comment">// prints 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">A</span> <span class="variable">o2</span> <span class="operator">=</span> A.class.newInstance(); <span class="comment">// reflection</span></span><br><span class="line">o2.a(); <span class="comment">// prints 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">A</span> <span class="variable">o3</span> <span class="operator">=</span> (A) unsafe.allocateInstance(A.class); <span class="comment">// unsafe</span></span><br><span class="line">o3.a(); <span class="comment">// prints 0</span></span><br></pre></td></tr></table></figure>

<p>思考一下这些确保对<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Singleton_pattern">Singletons</a>模式的影响。</p>
<h5 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h5><p>对C程序员来说这中情况是很常见的。</p>
<p>思考一下一些简单的类是如何坚持访问规则的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Guard</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ACCESS_ALLOWED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">giveAccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span> == ACCESS_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码是非常安全的,调用giveAccess()检查访问规则。不幸的是对所有的客户端代码,它总是返回false。只有特权用户在某种程度上可以改变ACCESS_ALLOWED常量并且获得访问权限。</p>
<p>事实上,这不是真的。这是证明它的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Guard</span> <span class="variable">guard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Guard</span>();</span><br><span class="line">guard.giveAccess();   <span class="comment">// false, no access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bypass</span></span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> guard.getClass().getDeclaredField(<span class="string">&quot;ACCESS_ALLOWED&quot;</span>);</span><br><span class="line">unsafe.putInt(guard, unsafe.objectFieldOffset(f), <span class="number">42</span>); <span class="comment">// memory corruption</span></span><br><span class="line"></span><br><span class="line">guard.giveAccess(); <span class="comment">// true, access granted</span></span><br></pre></td></tr></table></figure>

<p>现在所有的客户端都没有访问限制了。</p>
<p>事实上同样的功能也可以通过反射来实现。但有趣的是, 通过上面的方式我们修改任何对象，即使我们没有持有对象的引用。</p>
<p>举个例子, 在内存中有另外的一个Guard对象，并且地址紧挨着当前对象的地址，我们就可以通过下面的代码来修改该对象的<code>ACCESS_ALLOWED</code>字段的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe.putInt(guard, <span class="number">16</span> + unsafe.objectFieldOffset(f), <span class="number">42</span>); <span class="comment">// memory corruption</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，我们没有使用任何指向该对象的引用，16是Guard对象在32位架构上的大小。我们也可以通过<code>sizeOf</code>方法来计算Guard对象的大小。</p>
<h5 id="sizeOf"><a href="#sizeOf" class="headerlink" title="sizeOf"></a>sizeOf</h5><p>使用<code>objectFieldOffset</code>方法我们可以实现C风格的sizeof方法。下面的方法实现返回对象的表面上的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sizeOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">u</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line">    HashSet&lt;Field&gt; fields = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Field&gt;();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> o.getClass();</span><br><span class="line">    <span class="keyword">while</span> (c != Object.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Field f : c.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((f.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                fields.add(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c = c.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get offset</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> u.objectFieldOffset(f);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; maxSize) &#123;</span><br><span class="line">            maxSize = offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((maxSize/<span class="number">8</span>) + <span class="number">1</span>) * <span class="number">8</span>;   <span class="comment">// padding</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法逻辑如下：收集所有包括父类在内的非静态字段，获得每个字段的偏移量，发现最大并添加填充。也许,我错过了一些东西，但是概念是明确的。</p>
<p>更简单的sizeof方法实现逻辑是：我们只读取该对象对应的class对象中关于大小的字段值。在<code>JVM 1.7 32 位</code>版本上该表示大小的字段偏移量是12。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sizeOf</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUnsafe().getAddress(</span><br><span class="line">        normalize(getUnsafe().getInt(object, <span class="number">4L</span>)) + <span class="number">12L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>normalize</code>是一个将有符号的int类型转为无符号的long类型的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">normalize</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value &gt;= <span class="number">0</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">return</span> (~<span class="number">0L</span> &gt;&gt;&gt; <span class="number">32</span>) &amp; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太棒了,这个方法返回的结果和我们之前的sizeof函数是相同的。</p>
<p>but it requires specifyng agent option in your JVM.</p>
<p>事实上，对于合适的，安全的，准确的sizeof函数最好使用<code>java.lang.instrument</code>包，但它需要特殊的JVM参数。</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>在实现了计算对象浅层大小的基础上，我们可以非常容易的添加对象的拷贝方法。标准的办法需要修改我们的代码和Cloneable。或者你可以实现自定义的对象拷贝函数，但它不会变为通用的函数。</p>
<p>浅拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object <span class="title function_">shallowCopy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> sizeOf(obj);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> toAddress(obj);</span><br><span class="line">    <span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> getUnsafe().allocateMemory(size);</span><br><span class="line">    getUnsafe().copyMemory(start, address, size);</span><br><span class="line">    <span class="keyword">return</span> fromAddress(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toAddress</code> 和 <code>fromAddress</code> 将对象转为它在内存中的地址或者从指定的地址内容转为对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">toAddress</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;obj&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">baseOffset</span> <span class="operator">=</span> getUnsafe().arrayBaseOffset(Object[].class);</span><br><span class="line">    <span class="keyword">return</span> normalize(getUnsafe().getInt(array, baseOffset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Object <span class="title function_">fromAddress</span><span class="params">(<span class="type">long</span> address)</span> &#123;</span><br><span class="line">    Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">baseOffset</span> <span class="operator">=</span> getUnsafe().arrayBaseOffset(Object[].class);</span><br><span class="line">    getUnsafe().putLong(array, baseOffset, address);</span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该拷贝函数可以用来拷贝任何类型的对象，因为对象的大小是动态计算的。</p>
<p><strong>注意</strong> 在完成拷贝动作后你需要将拷贝对象的类型强转为目标类型。</p>
<h5 id="隐藏密码"><a href="#隐藏密码" class="headerlink" title="隐藏密码"></a>隐藏密码</h5><p>在Unsafe的直接内存访问方法使用case中有一个非常有趣的用法就是删除内存中不想要的对象。</p>
<p>大多数获取用户密码的API方法的返回值不是byte[]就是char[]，这是为什么呢？</p>
<p>这完全是出于安全原因, 因为我们可以在不需要它们的时候将数组元素置为失效。如果我们获取的密码是字符串类型，则密码字符串是作为一个对象保存在内存中的。要将该密码字符串置为无效，我们只能讲字符串引用职位null，但是该字符串的内容任然存在内存直到GC回收该对象后。</p>
<p>这个技巧在内存创建一个假的大小相同字符串对象来替换原来的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;l00k@myHor$e&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(password.replaceAll(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;?&quot;</span>));</span><br><span class="line">System.out.println(password); <span class="comment">// l00k@myHor$e</span></span><br><span class="line">System.out.println(fake); <span class="comment">// ????????????</span></span><br><span class="line"></span><br><span class="line">getUnsafe().copyMemory(</span><br><span class="line">          fake, <span class="number">0L</span>, <span class="literal">null</span>, toAddress(password), sizeOf(password));</span><br><span class="line"></span><br><span class="line">System.out.println(password); <span class="comment">// ????????????</span></span><br><span class="line">System.out.println(fake); <span class="comment">// ????????????</span></span><br></pre></td></tr></table></figure>

<p>感觉安全了吗？</p>
<p>其实该方法不是真的安全。想要真的安全我们可以通过反射API将字符串对象中的字符数组<code>value</code>字段的值修改为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">stringValue</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">stringValue.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">char</span>[] mem = (<span class="type">char</span>[]) stringValue.get(password);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; mem.length; i++) &#123;</span><br><span class="line">  mem[i] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>在Java中本来是没有多重集成的。除非我们可以将任意的类型转为我们想要的任意类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">intClassAddress</span> <span class="operator">=</span> normalize(getUnsafe().getInt(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>), <span class="number">4L</span>));</span><br><span class="line"><span class="type">long</span> <span class="variable">strClassAddress</span> <span class="operator">=</span> normalize(getUnsafe().getInt(<span class="string">&quot;&quot;</span>, <span class="number">4L</span>));</span><br><span class="line">getUnsafe().putAddress(intClassAddress + <span class="number">36</span>, strClassAddress);</span><br></pre></td></tr></table></figure>

<p>这段代码将String类添加到Integer的超类集合中,所以我们的强转代码是没有运行时异常的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String) (Object) (<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">666</span>))</span><br></pre></td></tr></table></figure>

<p>有个问题是我们需要先将要转的对象转为Object，然后再转为我们想要的类型。这是为了欺骗编译器。</p>
<h4 id="动态类"><a href="#动态类" class="headerlink" title="动态类"></a>动态类</h4><p>We can create classes in runtime, for example from compiled .class file. To perform that read class contents to byte array and pass it properly to defineClass method.</p>
<p>我们可以在运行时创建类, 例如通过一个编译好的class文件。将class文件的内容读入到字节数组中然后将该数组传递到合适的<code>defineClass</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] classContents = getClassContent();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> getUnsafe().defineClass(</span><br><span class="line">              <span class="literal">null</span>, classContents, <span class="number">0</span>, classContents.length);</span><br><span class="line">    c.getMethod(<span class="string">&quot;a&quot;</span>).invoke(c.newInstance(), <span class="literal">null</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>读取class文件内如的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] getClassContent() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/mishadoff/tmp/A.class&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">    <span class="type">byte</span>[] content = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">    input.read(content);</span><br><span class="line">    input.close();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方式是非常有用的，如果你确实需要在运行时动态的创建类。比如生产代理类或切面类。</p>
<h4 id="抛出一个异常"><a href="#抛出一个异常" class="headerlink" title="抛出一个异常"></a>抛出一个异常</h4><p>不喜欢受检异常？这不是问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getUnsafe().throwException(<span class="keyword">new</span> <span class="title class_">IOException</span>());</span><br></pre></td></tr></table></figure>

<p>该方法抛出一个受检异常，但是你的代码不需要强制捕获该异常就像运行时异常一样。</p>
<h4 id="快速序列化"><a href="#快速序列化" class="headerlink" title="快速序列化"></a>快速序列化</h4><p>这种使用方式更实用。</p>
<p>每个人都知道java标准的序列化的功能速度很慢而且它还需要类拥有公有的构造函数。</p>
<p>外部序列化是更好的方式，但是需要定义针对待序列化类的schema。</p>
<p>非常流行的高性能序列化库，像<a target="_blank" rel="noopener" href="http://code.google.com/p/kryo/">kryo</a>是有使用限制的，比如在内存缺乏的环境就不合适。</p>
<p>但通过使用Unsafe类我们可以非常简单的实现完整的序列化功能。</p>
<p><strong>序列化</strong>：</p>
<ul>
<li>通过反射定义类的序列化。 这个可以只做一次。</li>
<li>通过Unsafe的<code>getLong</code>, <code>getInt</code>, <code>getObject</code>等方法获取字段真实的值。</li>
<li>添加可以恢复该对象的标识符。</li>
<li>将这些数据写入到输出</li>
</ul>
<p>当然也可以使用压缩来节省空间。</p>
<p><strong>反序列化</strong>:</p>
<ul>
<li>创建一个序列化类的实例，可以通过方法<code>allocateInstance</code>。因为该方法不需要任何构造方法。</li>
<li>创建schama, 和序列化类似</li>
<li>从文件或输入读取或有的字段</li>
<li>使用 <code>Unsafe</code> 的 <code>putLong</code>, <code>putInt</code>, <code>putObject</code>等方法来填充对象。</li>
</ul>
<p>Actually, there are much more details in correct inplementation, but intuition is clear.</p>
<p>事实上要正确实现序列化和反序列化需要注意很多细节，但是思路是清晰的。</p>
<p>这种序列化方式是非常快的。</p>
<p>顺便说一句，在 <code>kryo</code> 有许多使用<code>Unsafe</code>的尝试 <a target="_blank" rel="noopener" href="http://code.google.com/p/kryo/issues/detail?id=75">http://code.google.com/p/kryo/issues/detail?id=75</a></p>
<h4 id="大数组"><a href="#大数组" class="headerlink" title="大数组"></a>大数组</h4><p>如你所知Java数组长度的最大值是<code>Integer.MAX_VALUE</code>。使用直接内存分配我们可以创建非常大的数组，该数组的大小只受限于堆的大小。</p>
<p>这里有一个<code>SuperArray</code>的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BYTE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperArray</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        address = getUnsafe().allocateMemory(size * BYTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> i, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">        getUnsafe().putByte(address + i * BYTE, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">long</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getUnsafe().getByte(address + idx * BYTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">SUPER_SIZE</span> <span class="operator">=</span> (<span class="type">long</span>)Integer.MAX_VALUE * <span class="number">2</span>;</span><br><span class="line"><span class="type">SuperArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperArray</span>(SUPER_SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;Array size:&quot;</span> + array.size()); <span class="comment">// 4294967294</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    array.set((<span class="type">long</span>)Integer.MAX_VALUE + i, (<span class="type">byte</span>)<span class="number">3</span>);</span><br><span class="line">    sum += array.get((<span class="type">long</span>)Integer.MAX_VALUE + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Sum of 100 elements:&quot;</span> + sum);  <span class="comment">// 300</span></span><br></pre></td></tr></table></figure>

<p>事实上该技术使用了非堆内存<code>off-heap memory</code>，在 <code>java.nio</code> 包中也有使用。</p>
<p>通过这种方式分配的内存不在堆上，并且不受GC管理。因此需要小心使用<code>Unsafe.freeMemory()</code>。该方法不会做任何边界检查，因此任何不合法的访问可能就会导致JVM奔溃。</p>
<p>这种使用方式对于数学计算是非常有用的，因为代码可以操作非常大的数据数组。 同样的编写实时程序的程序员对此也非常感兴趣，因为不受GC限制，就不会因为GC导致非常大的停顿。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>关于并发编程使用Unsafe的只言片语。<code>compareAndSwap</code> 方法是原子的，可以用来实现高性能的无锁化数据结构。</p>
<p>举个例子，多个线程并发的更新共享的对象这种场景：</p>
<p>首先我们定义一个简单的接口 <code>Counter</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义工作线程 <code>CounterClient</code>, 它会使用 <code>Counter</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterClient</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Counter c;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterClient</span><span class="params">(Counter c, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            c.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">NUM_OF_THREADS</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">NUM_OF_INCREMENTS</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(NUM_OF_THREADS);</span><br><span class="line"><span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> ... <span class="comment">// creating instance of specific counter</span></span><br><span class="line"><span class="type">long</span> <span class="variable">before</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NUM_OF_THREADS; i++) &#123;</span><br><span class="line">    service.submit(<span class="keyword">new</span> <span class="title class_">CounterClient</span>(counter, NUM_OF_INCREMENTS));</span><br><span class="line">&#125;</span><br><span class="line">service.shutdown();</span><br><span class="line">service.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"><span class="type">long</span> <span class="variable">after</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;Counter result: &quot;</span> + c.getCounter());</span><br><span class="line">System.out.println(<span class="string">&quot;Time passed in ms:&quot;</span> + (after - before));</span><br></pre></td></tr></table></figure>

<p>第一个实现-没有同步的计数器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StupidCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">99542945</span></span><br><span class="line">Time passed in ms: <span class="number">679</span></span><br></pre></td></tr></table></figure>

<p>速度很多，但是没有对所有的线程进行协调所以结果是错误的。第二个版本，使用Java常见的同步方式来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SyncCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">10136</span></span><br></pre></td></tr></table></figure>

<p>彻底的同步当然会导致正确的结果。但是花费的时间令人沮丧。让我们试试 <code>ReentrantReadWriteLock</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">WriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>().writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        counter++;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">8065</span></span><br></pre></td></tr></table></figure>

<p>结果依然是正确的，时间也短。那使用原子的类呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">6552</span></span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicCounter</code>的效果更好一点。最后我们试试<code>Unsafe</code>的原子方法<code>compareAndSwapLong</code>看看是不是更进一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CASCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CASCounter</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        unsafe = getUnsafe();</span><br><span class="line">        offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(<span class="string">&quot;counter&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">before</span> <span class="operator">=</span> counter;</span><br><span class="line">        <span class="keyword">while</span> (!unsafe.compareAndSwapLong(<span class="built_in">this</span>, offset, before, before + <span class="number">1</span>)) &#123;</span><br><span class="line">            before = counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">6454</span></span><br></pre></td></tr></table></figure>

<p>开起来和使用原子类是一样的效果，难道原子类使用了<code>Unsafe</code>？答案是YES。</p>
<p>事实上该例子非常简单但表现出了<code>Unsafe</code>的强大功能。</p>
<p>就像前面提到的 <code>CAS</code>原语可以用来实现高效的无锁数据结构。实现的原理很简单：</p>
<ul>
<li>拥有一个状态</li>
<li>创建一个它的副本</li>
<li>修改该副本</li>
<li>执行 CAS 操作</li>
<li>如果失败就重复执行</li>
</ul>
<p>事实上，在真实的环境它的实现难度超过你的想象，这其中有需要类似ABA，指令重排序这样的问题。</p>
<p>如果你确实对此感兴趣，你可以参考关于无锁HashMap的精彩演示。</p>
<h4 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h4><p>Documentation for park method from Unsafe class contains longest English sentence I’ve ever seen:</p>
<blockquote>
<p>Block current thread, returning when a balancing unpark occurs, or a balancing unpark has already occurred, or the thread is interrupted, or, if not absolute and time is not zero, the given time nanoseconds have elapsed, or if absolute, the given deadline in milliseconds since Epoch has passed, or spuriously (i.e., returning for no “reason”). Note: This operation is in the Unsafe class only because unpark is, so it would be strange to place it elsewhere.</p>
</blockquote>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>尽管Unsafe有这么多有用的应用，但是尽力不要使用。当然了使用JDK中利用了Unsafe实现的类是可以的。或者你对你代码功力非常自信。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://leokongwq.github.io/2016/12/31/java-magic-unsafe.html">https://leokongwq.github.io/2016/12/31/java-magic-unsafe.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://dzone.com/articles/understanding-sunmiscunsafe">https://dzone.com/articles/understanding-sunmiscunsafe</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html</a></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/23/2020/02/Java%20volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/23/2020/02/Java%20volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">我们如何看SpringBoot的源代码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-23 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-23T00:00:00+08:00">2020-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Volatile简介"><a href="#Volatile简介" class="headerlink" title="Volatile简介"></a>Volatile简介</h4><p><code>volatile</code>被称为<strong>轻量级的synchronized</strong>，运行时开销比<code>synchronized</code>更小，在多线程并发编程中发挥着<strong>同步共享变量</strong>、<strong>禁止处理器重排序</strong>的重要作用。建议在学习<code>volatie</code>之前，先看一下Java内存模型<a target="_blank" rel="noopener" href="https://ddnd.cn/2019/03/11/java-memory-model/">《什么是Java内存模型？》</a>，因为<code>volatile</code>和Java内存模型有着莫大的关系。</p>
<h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>在学习<code>volatie</code>之前，需要补充下Java内存模型的相关(JMM)知识，我们知道Java线程的所有操作都是在工作区进行的，那么工作区和主存之间的变量是怎么进行交互的呢，可以用下面的图来表示。</p>
<p><img src="http://static.cyblogs.com/e0e01e43ly1g186enjfwfj20k80degmr.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;e0e01e43ly1g186enjfwfj20k80degmr.jpg"><br>Java通过几种原子操作完成<strong>工作区内存</strong>和<strong>主存</strong>的交互</p>
<ol>
<li>lock：作用于主存，把变量标识为线程独占状态。</li>
<li>unlock：作用于主存，解除变量的独占状态。</li>
<li>read：作用于主存，把一个变量的值通过主存传输到线程的工作区内存。</li>
<li>load：作用于工作区内存，把<code>read</code>操作传过来的变量值储存到工作区内存的变量副本中。</li>
<li>use：作用于工作内存，把工作区内存的变量副本传给执行引擎。</li>
<li>assign：作用于工作区内存，把从执行引擎传过来的值赋值给工作区内存的变量副本。</li>
<li>store：作用于工作区内存，把工作区内存的变量副本传给主存。</li>
<li>write：作用于主存，把<code>store</code>操作传过来的值赋值给主存变量。</li>
</ol>
<p><strong>这<code>8</code>个操作每个操作都是原子性的，但是几个操作连着一起就不是原子性了！</strong></p>
<h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><p>上面介绍了Java模型的<code>8</code>个操作，那么这<code>8</code>个操作和<code>volatile</code>又有着什么关系呢。</p>
<h5 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a>volatile的可见性</h5><p>什么是<strong>可见性</strong>，用一个例子来解释，先看一段代码，加入线程<code>1</code>先执行，线程<code>2</code>再执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">    <span class="keyword">do</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>线程<code>1</code>执行后会进入到一个死循环中，当线程<code>2</code>执行后，线程<code>1</code>的死循环就一定会马上结束吗？答案是不一定，因为线程<code>2</code>执行完<code>stop = true</code>后，并不会马上将变量<code>stop</code>的值<code>true</code>写回主存中，也就是上图中的<code>assign</code>执行完成之后，<code>store</code>和<code>write</code>并不会随着执行，<strong>线程<code>1</code>没有立即将修改后的变量的值更新到主存中</strong>，即使线程<code>2</code>及时将变量<code>stop</code>的值写回主存中了，<strong>线程<code>1</code>也没有了解到变量<code>stop</code>的值已被修改而去主存中重新获取</strong>，也就是线程<code>1</code>的<code>load</code>、<code>read</code>操作并不会马上执行造成线程<code>1</code>的工作区内存中的变量副本不是最新的。这两个原因造成了线程<code>1</code>的死循环也就不会马上结束。<br>那么如何避免上诉的问题呢？我们可以使用<code>volatile</code>关键字修饰变量<code>stop</code>，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">    <span class="keyword">do</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>这样线程<code>1</code>每次读取变量<code>stop</code>的时候都会先去主存中获取变量<code>stop</code>最新的值，线程<code>2</code>每次修改变量<code>stop</code>的值之后都会马上将变量的值写回主存中，这样也就不会出现上述的问题了。</p>
<p>那么关键字<code>volatie</code>是如何做到的呢？<code>volatie</code>规定了上述<code>8</code>个操作的规则</p>
<ol>
<li>只有当线程对变量执行的<strong>前一个操作</strong>是<code>load</code>时，线程才能对变量执行<code>use</code>操作；只有线程的后一个操作是<code>use</code>时，线程才能对变量执行<code>load</code>操作。即规定了<code>use</code>、<code>load</code>、<code>read</code>三个操作之间的约束关系，<strong>规定这三个操作必须连续的出现，保证了线程每次读取变量的值前都必须去主存获取最新的值</strong>。</li>
<li>只有当前程对变量执行的<strong>前一个操作</strong>是<code>assign</code>时，线程才能对变量执行<code>store</code>操作；只有线程的后一个操作是<code>store</code>时，线程才能对变量执行<code>assign</code>操作，即规定了<code>assign</code>、<code>store</code>、<code>write</code>三个操作之间的约束关系，<strong>规定了这三个操作必须连续的出现，保证线程每次修改变量后都必须将变量的值写回主存</strong>。</li>
</ol>
<p><code>volatile</code>的这两个规则，也正是保证了<strong>共享变量的可见性</strong>。</p>
<h5 id="volatile的有序性"><a href="#volatile的有序性" class="headerlink" title="volatile的有序性"></a>volatile的有序性</h5><p>有序性即程序执行的顺序按照代码的先后顺序执行，Java内存模型(JMM)允许编译器和处理器对指令进行重排序，但是规定了<code>as-if-serial</code>语义，即保证<strong>单线程</strong>情况下不管怎么重排序，程序的结果不能改变，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;  <span class="comment">//A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">//B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> pi * r * r; <span class="comment">//C</span></span><br></pre></td></tr></table></figure>

<p>上面的代码可能按照<code>A-&gt;B-&gt;C</code>顺序执行，也有可能按照<code>B-&gt;A-&gt;C</code>顺序执行，这两种顺序都不会影响程序的结果。但是不会以<code>C-&gt;A(B)-&gt;B(A)</code>的顺序去执行，因为<code>C</code>语句是依赖于<code>A</code>和<code>B</code>的，如果按照这样的顺序去执行就不能保证结果不变了(违背了<code>as-if-serial</code>)。</p>
<p>上面介绍的是单线程的执行，不管指令怎么重排序都不会影响结果，但是在多线程下就会出现问题了。<br>下面看个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">r = <span class="number">10</span>; <span class="comment">//A</span></span><br><span class="line">start = <span class="literal">true</span>; <span class="comment">//B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">if</span> (start) &#123;  <span class="comment">//C</span></span><br><span class="line">    s = pi * r * r;  <span class="comment">//D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程<code>1</code>和线程<code>2</code>同时执行，线程<code>1</code>的<code>A</code>和<code>B</code>的执行顺序可能是<code>A-&gt;B</code>或者<code>B-&gt;A</code>(因为A和B之间没有依赖关系，可以指令重排序)。如果线程<code>1</code>按照<code>A-&gt;B</code>的顺序执行，那么线程<code>2</code>执行后的结果s就是我们想要的正确结果，如果线程<code>1</code>按照<code>B-&gt;A</code>的顺序执行，那么线程<code>2</code>执行后的结果s可能就不是我们想要的结果了，因为线程<code>1</code>将变量<code>stop</code>的值修改为<code>true</code>后，线程<code>2</code>马上获取到<code>stop</code>为<code>true</code>然后执行<code>C</code>语句，然后执行<code>D</code>语句即<code>s = 3.14 * 0 * 0</code>，然后线程<code>1</code>再执行<code>B</code>语句，那么结果就是有问题了。</p>
<p>那么为了解决这个问题，我们可以在变量<code>true</code>加上关键字<code>volatile</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">r = <span class="number">10</span>; <span class="comment">//A</span></span><br><span class="line">start = <span class="literal">true</span>; <span class="comment">//B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">if</span> (start) &#123;  <span class="comment">//C</span></span><br><span class="line">    s = pi * r * r;  <span class="comment">//D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样线程<code>1</code>的执行顺序就只能是<code>A-&gt;B</code>了，因为关键字<strong>发挥了禁止处理器指令重排序的作用</strong>，所以线程<code>2</code>的执行结果就不会有问题了。</p>
<p>那么<code>volatile</code>是怎么实现禁止处理器重排序的呢？<br><strong>编译器会在编译生成字节码的时候，在加有<code>volatile</code>关键字的变量的指令进行插入内存屏障来禁止特定类型的处理器重排序</strong><br>我们先看<strong>内存屏障</strong>有哪些及发挥的作用<br><img src="http://static.cyblogs.com/e0e01e43ly1g191y6o3paj21620f5qd7.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;e0e01e43ly1g191y6o3paj21620f5qd7.jpg"></p>
<ol>
<li><code>StoreStore</code>屏障：禁止屏障上面变量的写和下面所有进行写的变量进行处理器重排序。</li>
<li><code>StoreLoad</code>屏障：禁止屏障上面变量的写和下面所有进行读的变量进行处理器重排序。</li>
<li><code>LoadLoad</code>屏障：禁止屏障上面变量的读和下面所有进行读的变量进行处理器重排序。</li>
<li><code>LoadStore</code>屏障：禁止屏障上面变量的读和下面所有进行写的变量进行处理器重排序。</li>
</ol>
<p>再看<code>volatile</code>是怎么插入屏障的</p>
<ol>
<li>在每个<code>volatile</code>变量的写<strong>前面</strong>插入一个<code>StoreStore</code>屏障。</li>
<li>在每个<code>volatile</code>变量的写<strong>后面</strong>插入一个<code>StoreLoad</code>屏障。</li>
<li>在每个<code>volatile</code>变量的读<strong>后面</strong>插入一个<code>LoadLoad</code>屏障。</li>
<li>在每个<code>volatile</code>变量的读<strong>后面</strong>插入一个<code>LoadStore</code>屏障。</li>
</ol>
<blockquote>
<p>注意：写操作是在<code>volatile</code><strong>前后</strong>插入一个内存屏障，而读操作是在<strong>后面</strong>插入两个内存屏障。</p>
</blockquote>
<p><img src="http://static.cyblogs.com/e0e01e43ly1g186ext5z1j20h809vjsv.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;e0e01e43ly1g186ext5z1j20h809vjsv.jpg"></p>
<p><strong><code>volatile</code>变量通过插入内存屏障禁止了处理器重排序，从而解决了多线程环境下处理器重排序的问题</strong>。</p>
<h5 id="volatile有没有原子性？"><a href="#volatile有没有原子性？" class="headerlink" title="volatile有没有原子性？"></a>volatile有没有原子性？</h5><p>上面分别介绍了<code>volatile</code>的可见性和有序性，那么<code>volatile</code>有原子性吗？我们先看一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们开启<code>10</code>个线程对<code>volatile</code>变量进行自增操作，每个线程对<code>volatile</code>变量执行<code>1000</code>次自增操作，那结果变量<code>inc</code>会是<code>10000</code>吗？答案是，变量<code>inc</code>的值基本都是小于<code>10000</code>。<br>可能你会有疑问，<code>volatile</code>变量<code>inc</code>不是保证了共享变量的可见性了吗，每次线程读取到的都是最新的值，是的没错，<strong>但是线程每次将值写回主存的时候并不能保证主存中的值没有被其他的线程修过过</strong>。</p>
<p><img src="http://static.cyblogs.com/WX20200212-225100@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200212-225100@2x.png"></p>
<p>如果所示：线程<code>1</code>在主存中获取了<code>i</code>的最新值(i&#x3D;1)，线程<code>2</code>也在主存中获取了<code>i</code>的最新值(i&#x3D;1，注意这时候线程<code>1</code>并未对变量<code>i</code>进行修改，所以<code>i</code>的值还是<code>1</code>)），然后线程<code>2</code>将i自增后写回主存，这时候主存中<code>i=2</code>，到这里还没有问题，然后线程<code>1</code>又对i进行了自增写回了主存，这时候主存中<code>i=2</code>，也就是对i做了2次自增操作，结果i的结果只自增了1，问题就出来了这里。</p>
<p>为什么会有这个问题呢，前面我们提到了Java内存模型和主存之间交互的<code>8</code>个操作都是原子性的，但是他们的操作连在一起就不是原子性了，而<code>volatile</code>关键字也只是保证了<code>use</code>、<code>load</code>、<code>read</code>三个操作连在一起时候的原子性，还有<code>assign</code>、<code>store</code>、<code>write</code>这三个操作连在一起时候的原子性，也就是<code>volatile</code>关键字<strong>保证了变量读操作的原子性和写操作的原子性，而变量的自增过程需要对变量进行读和写两个过程，而这两个过程连在一起就不是原子性操作了。</strong></p>
<p>所以说<code>volatile</code>变量对于变量的单独写操作&#x2F;读操作是保证了原子性的，而常说的原子性包括读写操作连在一起，所以说对于<code>volatile</code>不保证原子性的。那么如何解决上面程序的问题呢？只能给<code>increase</code>方法加锁，让在多线程情况下只有一个线程能执行<code>increase</code>方法，也就是保证了一个线程对变量的读写是原子性的。<strong>当然还有个更优的方案，就是利用读写都为原子性的<code>CAS</code>，利用<code>CAS</code>对<code>volatile</code>进行操作，既解决了<code>volatile</code>不保证原子性的问题，同时消耗也没加锁的方式大</strong></p>
<h5 id="volatile和CAS"><a href="#volatile和CAS" class="headerlink" title="volatile和CAS"></a>volatile和CAS</h5><p>学完<code>volatile</code>之后，是不是觉得<code>volatile</code>和<code>CAS</code>有种似曾相识的感觉？那它们之间有什么关系或者区别呢。</p>
<ol>
<li><code>volatile</code>只能保证共享变量的读和写操作单个操作的原子性，而<code>CAS</code>保证了共享变量的读和写两个操作一起的原子性(即CAS是原子性操作的)。</li>
<li><code>volatile</code>的实现基于<code>JMM</code>，而<code>CAS</code>的实现基于硬件。</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a target="_blank" rel="noopener" href="https://ddnd.cn/2019/03/19/java-volatile">https://ddnd.cn/2019/03/19/java-volatile</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/22/2020/02/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%20select%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/22/2020/02/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%20select%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">IO多路复用的 select、poll、epoll详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-22T00:00:00+08:00">2020-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前几篇文章讲述了IO的几种模式及netty的基本概念，netty基于多路复用模型下的reactor模式，对 大量连接、单个处理短且快 的场景很适用 。</p>
<p>那在往底层思考，linux对于IO又是如何处理的呢？</p>
<h4 id="C10K-问题"><a href="#C10K-问题" class="headerlink" title="C10K 问题"></a>C10K 问题</h4><p><a target="_blank" rel="noopener" href="http://www.52im.net/thread-566-1-1.html">http://www.52im.net/thread-566-1-1.html</a></p>
<p>最初的服务器都是基于进程&#x2F;线程模型的，新到来一个TCP连接，就需要分配1个进程（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。如果是C10K就要创建1万个进程，那么单机而言操作系统是无法承受的（往往出现效率低下甚至完全瘫痪）。如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大。基于上述考虑，如何突破单机性能局限，是高性能网络编程所必须要直面的问题。这些局限和问题最早被<code>Dan Kegel</code> 进行了归纳和总结，并首次成系统地分析和提出解决方案，后来这种普遍的网络现象和技术局限都被大家称为 <code>C10K</code> 问题。</p>
<p>C10K 问题的最大特点是：<strong>设计不够良好的程序，其性能和连接数及机器性能的关系往往是非线性的</strong>。</p>
<p>举个例子：如果没有考虑过 C10K 问题，一个经典的基于 select 的程序能在旧服务器上很好处理 1000 并发的吞吐量，它在 2 倍性能新服务器上往往处理不了并发 2000 的吞吐量。这是因为在策略不当时，大量操作的消耗和当前连接数 n 成线性相关。会导致单个任务的资源消耗和当前连接数的关系会是 O(n)。而服务程序需要同时对数以万计的socket 进行 I&#x2F;O 处理，积累下来的资源消耗会相当可观，这显然会导致系统吞吐量不能和机器性能匹配。</p>
<p>以上这就是典型的C10K问题在技术层面的表现。C10K问题本质上是操作系统的问题。对于Web1.0&#x2F;2.0时代的操作系统而言， 传统的同步阻塞I&#x2F;O模型都是一样的，处理的方式都是requests per second，并发10K和100的区别关键在于CPU。创建的进程线程多了，数据拷贝频繁（缓存I&#x2F;O、内核将数据拷贝到用户进程空间、阻塞）， 进程&#x2F;线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质！<br>可见，解决C10K问题的关键就是尽可能减少这些CPU等核心计算资源消耗，从而榨干单台服务器的性能，突破C10K问题所描述的瓶颈。</p>
<h4 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h4><h5 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h5><p>现在操作系统都是采用虚拟存储器，那么<strong>对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）</strong>。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为<strong>内核空间</strong>，一部分为<strong>用户空间</strong>。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<p><strong>处在内核空间称为内核态，用户空间称为用户态！ 内核的权限远大于用户空间权限，硬件、IO等等系统操作只能通过内核调用！</strong></p>
<h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。</p>
<h5 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h5><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态， <strong>此时是不占用CPU资源的</strong>。</p>
<h5 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h5><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<strong>I&#x2F;O的socket操作也是一种文件描述符fd</strong>。<br>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是<strong>文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统</strong>。</p>
<h5 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I&#x2F;O"></a>缓存 I&#x2F;O</h5><p>缓存 I&#x2F;O 又被称作标准 I&#x2F;O，大多数文件系统的默认 I&#x2F;O 操作都是缓存 I&#x2F;O。在 Linux 的缓存 I&#x2F;O 机制中，操作系统会将 I&#x2F;O 的数据缓存在文件系统的<strong>页缓存</strong>（ page cache ）中，也就是说，<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</strong></p>
<p><strong>缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</strong></p>
<h4 id="I-O-多路复用之select、poll、epoll详解"><a href="#I-O-多路复用之select、poll、epoll详解" class="headerlink" title="I&#x2F;O 多路复用之select、poll、epoll详解"></a>I&#x2F;O 多路复用之select、poll、epoll详解</h4><blockquote>
<p>详细部分可以参阅：<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000003063859%EF%BC%9B">https://segmentfault.com/a/1190000003063859；</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxy941011/article/details/80274233">https://blog.csdn.net/wxy941011/article/details/80274233</a></p>
</blockquote>
<p>select，poll，epoll都是IO多路复用的机制。**一个进程可以监视多个描述符，**一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。 本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>Netty与redis(单线程的下的I&#x2F;O多路复用) 使用epoll模式。</p>
<h5 id="select-poll的几大缺点"><a href="#select-poll的几大缺点" class="headerlink" title="select&#x2F;poll的几大缺点"></a>select&#x2F;poll的几大缺点</h5><ol>
<li><p>select的本质是采用32个整数的32位，即32*32&#x3D; 1024来标识，fd值为1-1024。</p>
<p>（总结： 句柄上限 + 重复初始化 + 逐个排查所有文件句柄状态效率不高）</p>
<ol>
<li>当fd的值超过1024限制时，就必须修改FD_SETSIZE（管理的句柄上限）的大小，这个时候就可以标识32*max值范围的fd。</li>
<li>在使用上，因为只有一个字段记录关注和发生事件，每次调用之前要重新初始化 fd_set 结构体。</li>
<li>select的触发方式是<strong>水平触发</strong>，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</li>
</ol>
</li>
<li><p>poll主要解决 select 的前两个问题，但还是得逐个排查所有文件句柄状态效率不高：</p>
<ol>
<li>通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制。</li>
<li>pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。</li>
</ol>
</li>
<li><p><strong>select&#x2F;poll 将这个fd列表维持在用户态, 每次调用时都需要把fd集合从用户态拷贝到内核态, 并在内核中遍历传递进来的所有fd； 返回的的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</strong></p>
</li>
</ol>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p>epoll是poll的一种优化，<strong>在内核中维持了fd的列表，只遍历发生事件的fd集合</strong>。<br>与poll&#x2F;select不同，epoll不再是一个单独的系统调用，而是由epoll_create&#x2F;epoll_ctl&#x2F;epoll_wait三个系统调用组成，epoll在2.6以后的内核才支持。</p>
<p>综合的来说：</p>
<p>epoll在<strong>内核</strong>中申请一个简易的文件系统，把原先的select&#x2F;poll调用分成了3个部分。连接的套接字（socket句柄）是采用红黑树的结构存储在内核cache中的，并给内核中断处理程序注册一个回调函数，告诉内核：如果这个句柄的中断到了，就把它放到准备就绪list链表里。当有事件准备就绪时，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了(epoll的基础是回调)。当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可；有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。</p>
<p>1）调用<strong>epoll_create</strong>建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源， 创建了红黑树和就绪链表)<br>2）调用<strong>epoll_ctl</strong>向epoll对象中添加这100万个连接的套接字 （如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据）<br>3）调用<strong>epoll_wait</strong>收集发生的事件的连接 （立刻返回准备就绪链表里的数据）</p>
<h5 id="两种模式LT和ET"><a href="#两种模式LT和ET" class="headerlink" title="两种模式LT和ET"></a>两种模式LT和ET</h5><p>ET是<strong>边缘触发</strong>，LT是<strong>水平触发</strong>，一个表示只有在变化的边际触发，一个表示在某个阶段都会触发。</p>
<p>当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回这个句柄。（从上面这段，可以看出，LT还有个回放的过程，低效了）</p>
<h4 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h4><p>eg.有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select&#x2F;poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select&#x2F;poll一般只能处理几千的并发连接。如果没有I&#x2F;O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I&#x2F;O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。处理的流越多，每一次无差别轮询时间就越长!</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/u/3434392/blog/3029255">https://my.oschina.net/u/3434392/blog/3029255</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/21/2020/02/HashMap%20JDK%201.8%20%E5%90%8E%E5%AE%83%E6%94%B9%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/21/2020/02/HashMap%20JDK%201.8%20%E5%90%8E%E5%AE%83%E6%94%B9%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/" class="post-title-link" itemprop="url">HashMap JDK 1.8 后它改了什么？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-21T00:00:00+08:00">2020-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>推荐一个咕泡学院的视频资源：链接:<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1SmSzrmfgbm6XgKZO7utKWg">https://pan.baidu.com/s/1SmSzrmfgbm6XgKZO7utKWg</a>  密码:e54x</p>
<p>先回答一下之前发布的《使用HashMap的时候小心点》同学不补充的问题，说最好说下HashMap在JDK8下是怎么解决死循环的问题的。</p>
<p>链表部分对应上面 transfer 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">  Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      next = e.next;</span><br><span class="line">      <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">              loHead = e;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              loTail.next = e;</span><br><span class="line">          loTail = e;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">              hiHead = e;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              hiTail.next = e;</span><br><span class="line">          hiTail = e;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">      loTail.next = <span class="literal">null</span>;</span><br><span class="line">      newTab[j] = loHead;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">      hiTail.next = <span class="literal">null</span>;</span><br><span class="line">      newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于扩容是按两倍进行扩，即 N 扩为 N + N，因此就会存在低位部分 0 - (N-1)，以及高位部分 N - (2N-1)， 所以这里分为 loHead (low Head) 和 hiHead (high head)。</p>
<p>通过上面的分析，不难发现循环的产生是因为新链表的顺序跟旧的链表是完全相反的，所以只要保证建新链时还是按照原来的顺序的话就不会产生循环。</p>
<p>JDK8是用 <code>head</code> 和 <code>tail</code> 来保证链表的顺序和之前一样，这样就不会产生循环引用。</p>
<h4 id="传统-HashMap-的缺点"><a href="#传统-HashMap-的缺点" class="headerlink" title="传统 HashMap 的缺点"></a>传统 HashMap 的缺点</h4><p>JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。</p>
<p>当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。</p>
<p>针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。</p>
<h4 id="新增的数据结构-–-红黑树"><a href="#新增的数据结构-–-红黑树" class="headerlink" title="新增的数据结构 – 红黑树"></a>新增的数据结构 – 红黑树</h4><p><img src="http://static.cyblogs.com/adc0e45d0065227fa3b6f01acad60528.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;adc0e45d0065227fa3b6f01acad60528.png"></p>
<p>JDK 1.8 中 HashMap 中除了链表节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry &#123;</span><br><span class="line">    <span class="comment">//哈希值，就是位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">//指向下一个几点的指针</span></span><br><span class="line">    Node next;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有另外一种节点：TreeNode，它是 1.8 新增的，属于数据结构中的 <strong>红黑树</strong>（不了解红黑树的同学可以 <a target="_blank" rel="noopener" href="http://blog.csdn.net/u011240877/article/details/53329023">点击这里了解红黑树</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry &#123;</span><br><span class="line">    TreeNode parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到就是个红黑树节点，有父亲、左右孩子、前一个元素的节点，还有个颜色值。</p>
<p>另外由于它继承自 LinkedHashMap.Entry ，而 LinkedHashMap.Entry 继承自 HashMap.Node ，因此还有额外的 6 个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承 LinkedHashMap.Entry 的</span></span><br><span class="line">Entry before, after;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.Node 的</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node next;</span><br></pre></td></tr></table></figure>

<h4 id="红黑树的三个关键参数"><a href="#红黑树的三个关键参数" class="headerlink" title="红黑树的三个关键参数"></a>红黑树的三个关键参数</h4><p>HashMap 中有三个关于红黑树的关键参数:</p>
<ul>
<li>TREEIFY_THRESHOLD</li>
<li>UNTREEIFY_THRESHOLD</li>
<li>MIN_TREEIFY_CAPACITY</li>
</ul>
<p>值及作用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个桶的树化阈值</span></span><br><span class="line"><span class="comment">//当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点</span></span><br><span class="line"><span class="comment">//这个值必须为 8，要不然频繁转换效率也不高</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个树的链表还原阈值</span></span><br><span class="line"><span class="comment">//当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构</span></span><br><span class="line"><span class="comment">//这个值应该比上面那个小，至少为 6，避免频繁转换</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表的最小树形化容量</span></span><br><span class="line"><span class="comment">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span></span><br><span class="line"><span class="comment">//否则桶内元素太多时会扩容，而不是树形化</span></span><br><span class="line"><span class="comment">//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h4 id="新增的操作：桶的树形化-treeifyBin"><a href="#新增的操作：桶的树形化-treeifyBin" class="headerlink" title="新增的操作：桶的树形化 treeifyBin()"></a>新增的操作：桶的树形化 treeifyBin()</h4><p>在<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/17">Java</a> 8 中，如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8 )，就使用红黑树来替换链表，从而提高速度。</p>
<p>这个替换的方法叫 treeifyBin() 即树形化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将桶内所有的 链表节点 替换成 红黑树节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node e;</span><br><span class="line">    <span class="comment">//如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)，就去新建/扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果哈希表中的元素个数超过了 树形化阈值，进行树形化</span></span><br><span class="line">        <span class="comment">// e 是哈希表中指定位置桶里的链表节点，从第一个开始</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">hd</span> <span class="operator">=</span> <span class="literal">null</span>, tl = <span class="literal">null</span>; <span class="comment">//红黑树的头、尾节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//新建一个树形节点，内容和当前链表节点 e 一致</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>) <span class="comment">//确定树头节点</span></span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);  </span><br><span class="line">        <span class="comment">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">replacementTreeNode</span><span class="params">(Node p, Node next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述操作做了这些事:</p>
<ul>
<li>根据哈希表中元素个数确定是扩容还是树形化</li>
<li>如果是树形化<ul>
<li>遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</li>
<li>然后让桶第一个元素指向新建的树头结点，替换桶的链表内容为树形内容</li>
</ul>
</li>
</ul>
<p>但是我们发现，之前的操作并没有设置红黑树的颜色值，现在得到的只能算是个二叉树。在 最后调用树形节点 hd.treeify(tab) 方法进行塑造红黑树，来看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node[] tab)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode)x.next;</span><br><span class="line">        x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123; <span class="comment">//头回进入循环，确定头结点，为黑色</span></span><br><span class="line">            x.parent = <span class="literal">null</span>;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//后面进入循环走的逻辑，x 指向树中的某个节点</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">kc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//又一个循环，从根节点开始，遍历所有节点跟当前节点 x 比较，调整位置，有点像冒泡排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph;        <span class="comment">//这个 dir </span></span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)  <span class="comment">//当比较节点的哈希值比 x 大时， dir 为 -1</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)  <span class="comment">//哈希值比 x 小时 dir 为 1</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 如果比较节点的哈希值、 x </span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//把 当前节点变成 x 的父亲</span></span><br><span class="line">                    <span class="comment">//如果当前比较节点的哈希值比 x 大，x 就是左孩子，否则 x 是右孩子 </span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">xp</span> <span class="operator">=</span> p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，将二叉树变为红黑树时，需要保证有序。这里有个双重循环，拿树中的所有节点和当前节点的哈希值进行对比(如果哈希值相等，就对比键，这里不用完全有序），然后根据比较结果确定在树种的位置。</p>
<h4 id="新增的操作：-红黑树中添加元素-putTreeVal"><a href="#新增的操作：-红黑树中添加元素-putTreeVal" class="headerlink" title="新增的操作： 红黑树中添加元素 putTreeVal()"></a>新增的操作： 红黑树中添加元素 putTreeVal()</h4><p>上面介绍了如何把一个桶中的链表结构变成红黑树结构。</p>
<p>在添加时，如果一个桶中已经是红黑树结构，就要调用红黑树的添加元素方法 putTreeVal()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode <span class="title function_">putTreeVal</span><span class="params">(HashMap map, Node[] tab,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">kc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//每次添加元素时，从根节点遍历，对比哈希值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;;) &#123;</span><br><span class="line">        <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))  </span><br><span class="line">        <span class="comment">//如果当前节点的哈希值、键和要添加的都一致，就返回当前节点（奇怪，不对比值吗？）</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点和要添加的节点哈希值相等，但是两个节点的键不是一个类，只好去挨个对比左右孩子 </span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode q, ch;</span><br><span class="line">                searched = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                    <span class="comment">//如果从 ch 所在子树中可以找到要添加的节点，就直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//哈希值相等，但键无法比较，只好通过特殊的方法给个结果</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//经过前面的计算，得到了当前节点和要插入节点的一个大小关系</span></span><br><span class="line">        <span class="comment">//要插入的节点比当前节点小就插到左子树，大就插到右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">xp</span> <span class="operator">=</span> p;</span><br><span class="line">     <span class="comment">//这里有个判断，如果当前节点还没有左孩子或者右孩子时才能插入，否则就进入下一轮循环 </span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">xpn</span> <span class="operator">=</span> xp.next;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">x</span> <span class="operator">=</span> map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                ((TreeNode)xpn).prev = x;</span><br><span class="line">            <span class="comment">//红黑树中，插入元素后必要的平衡调整操作</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法用于 a 和 b 哈希值相同但是无法比较时，直接根据两个引用的地址进行比较</span></span><br><span class="line"><span class="comment">//这里源码注释也说了，这个树里不要求完全有序，只要插入时使用相同的规则保持平衡即可</span></span><br><span class="line"> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tieBreakOrder</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">             -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以知道，HashMap 中往红黑树中添加一个新节点 n 时，有以下操作：</p>
<ul>
<li>从根节点开始遍历当前红黑树中的元素 p，对比 n 和 p 的哈希值；</li>
<li>如果哈希值相等并且键也相等，就判断为已经有这个元素（这里不清楚为什么不对比值）；</li>
<li>如果哈希值就通过其他信息，比如引用地址来给个大概比较结果，这里可以看到红黑树的比较并不是很准确，注释里也说了，只是保证个相对平衡即可；</li>
<li>最后得到哈希值比较结果后，如果当前节点 p 还没有左孩子或者右孩子时才能插入，否则就进入下一轮循环;</li>
<li>插入元素后还需要进行红黑树例行的平衡调整，还有确保根节点的领先地位。</li>
</ul>
<h4 id="新增的操作：-红黑树中查找元素-getTreeNode"><a href="#新增的操作：-红黑树中查找元素-getTreeNode" class="headerlink" title="新增的操作： 红黑树中查找元素 getTreeNode()"></a>新增的操作： 红黑树中查找元素 getTreeNode()</h4><p>HashMap 的查找方法是 get():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它通过计算指定 key 的哈希值后，调用内部方法 getNode()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node[] tab; Node first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 getNode() 方法就是根据哈希表元素个数与哈希值求模（<code>使用的公式是 (n - 1) &amp;hash</code>）得到 key 所在的桶的头结点，如果头节点恰好是红黑树节点，就调用红黑树节点的 getTreeNode() 方法，否则就遍历链表节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getTreeNode 方法使通过调用树形节点的 find() 方法进行查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从根节点根据 哈希值和 key 进行查找</span></span><br><span class="line"><span class="keyword">final</span> TreeNode <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class kc)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">int</span> ph, dir; K pk;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pl</span> <span class="operator">=</span> p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于之前添加时已经保证这个树是有序的，因此查找时基本就是折半查找，效率很高。</p>
<p>这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断 key 是否相等，相等就直接返回（也没有判断值哎）；不相等就从子树中递归查找。</p>
<h4 id="新增的操作：-树形结构修剪-split"><a href="#新增的操作：-树形结构修剪-split" class="headerlink" title="新增的操作： 树形结构修剪 split()"></a>新增的操作： 树形结构修剪 split()</h4><p>HashMap 中， resize() 方法的作用就是初始化或者扩容哈希表。当扩容时，如果当前桶中元素结构是红黑树，并且元素个数小于链表还原阈值 UNTREEIFY_THRESHOLD （默认为 6），就会把桶中的树形结构缩小或者直接还原（切分）为链表结构，调用的就是 split():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数介绍</span></span><br><span class="line"><span class="comment">//tab 表示保存桶头结点的哈希表</span></span><br><span class="line"><span class="comment">//index 表示从哪个位置开始修剪</span></span><br><span class="line"><span class="comment">//bit 要修剪的位数（哈希值）</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap map, Node[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">loHead</span> <span class="operator">=</span> <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">hiHead</span> <span class="operator">=</span> <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">TreeNode</span> <span class="variable">e</span> <span class="operator">=</span> b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode)e.next;</span><br><span class="line">        e.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果当前节点哈希值的最后一位等于要修剪的 bit 值</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//就把当前节点放到 lXXX 树中</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            <span class="comment">//然后 loTail 记录 e</span></span><br><span class="line">            loTail = e;</span><br><span class="line">            <span class="comment">//记录 lXXX 树的节点数量</span></span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//如果当前节点哈希值最后一位不是要修剪的</span></span><br><span class="line">                <span class="comment">//就把当前节点放到 hXXX 树中</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            <span class="comment">//记录 hXXX 树的节点数量</span></span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 lXXX 树的数量小于 6，就把 lXXX 树的枝枝叶叶都置为空，变成一个单节点</span></span><br><span class="line">        <span class="comment">//然后让这个桶中，要还原索引位置开始往后的结点都变成还原成链表的 lXXX 节点</span></span><br><span class="line">        <span class="comment">//这一段元素以后就是一个链表结构</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则让索引位置的结点指向 lXXX 树，这个树被修剪过，元素少了</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//同理，让 指定位置 index + bit 之后的元素</span></span><br><span class="line">        <span class="comment">//指向 hXXX 还原成链表或者修剪过的树</span></span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看到，HashMap 扩容时对红黑树节点的修剪主要分两部分，先分类、再根据元素个数决定是还原成链表还是精简一下元素仍保留红黑树结构。</p>
<p>1.分类</p>
<p>指定位置、指定范围，让指定位置中的元素 <code>（hash &amp; bit) == 0</code> 的，放到 lXXX 树中，不相等的放到 hXXX 树中。</p>
<p>2.根据元素个数决定处理情况</p>
<p>符合要求的元素（即 lXXX 树），在元素个数小于 6 时还原成链表，最后让哈希表中修剪的痛 tab[index] 指向 lXXX 树；在元素个数大于 6 时，还是用红黑树，只不过是修剪了下枝叶；</p>
<p>不符合要求的元素（即 hXXX 树）也是一样的操作，只不过最后它是放在了修剪范围外 tab[index + bit]。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JDK 1.8 以后哈希表的 添加、删除、查找、扩容方法都增加了一种 节点为 TreeNode 的情况：</p>
<ul>
<li>添加时，当桶中链表个数超过 8 时会转换成红黑树；</li>
<li>删除、扩容时，如果桶中结构为红黑树，并且树中元素个数太少的话，会进行修剪或者直接还原成链表结构；</li>
<li>查找时即使哈希函数不优，大量元素集中在一个桶中，由于有红黑树结构，性能也不会差。</li>
</ul>
<p>(图片来自：<a target="_blank" rel="noopener" href="http://tech.meituan.com/java-hashmap.html">tech.meituan.com&#x2F;java-hashma…</a>)</p>
<p><img src="https://user-gold-cdn.xitu.io/2016/11/29/f4b4ce0080649808815e6979d55b2915" alt="shixinzhang"></p>
<p>这篇文章根据源码分析了 HashMap 在 JDK 1.8 里新增的 TreeNode 的一些关键方法，可以看到，1.8 以后的 HashMap 结合了哈希表和红黑树的优点，不仅快速，而且在极端情况也能保证性能，设计者苦心孤诣可见一斑，写到这里不禁仰天长叹：什么时候我才能写出这么 NB 的代码啊！！！</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1120823">https://cloud.tencent.com/developer/article/1120823</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/entry/5839ad0661ff4b007ec7cc7a">https://juejin.im/entry/5839ad0661ff4b007ec7cc7a</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/20/2020/02/Hash%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/20/2020/02/Hash%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Hash算法和一致性Hash算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-20T00:00:00+08:00">2020-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h4><p><code>Hash</code>算法在路由算法应用中，为了保证数据均匀的分布，例如有<code>3</code>个桶，分别是<code>0</code>号桶，<code>1</code>号桶和<code>2</code>号桶；现在有<code>12</code>个球，怎么样才能让<code>12</code>个球平均分布到<code>3</code>个桶中呢？使用<code>Hash</code>算法的做法是，将<code>12</code>个球从<code>0</code>开始编号，得到这样的一个序列：<code>0，1，2，3，4，5，6，7，8，9，10，11</code>。将这个序列中的每个值模3，不管数字是什么，得到的结果都是<code>0,1,2</code>，不会超过<code>3</code>，将结果为<code>0</code>的数字放入<code>0</code>号桶，结果为<code>1</code>的数子放入<code>1</code>号桶，结果为<code>2</code>的数字放入2号桶，12个球就均匀的分布到<code>3</code>个桶中，<code>0,3,6,9,12</code>号球放入<code>0</code>号桶，<code>1,4,7,10</code>号球放入<code>1</code>号桶，<code>2,5,8,11</code>号球放入<code>2</code>号桶。</p>
<h4 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h4><p>一致性<code>Hash</code>算法在<code>1997</code>年由麻省理工学院提出的一种分布式哈希<code>（DHT）</code>实现算法，设计目标是为了解决因特网中的热点<code>（Hot Spot）</code>问题，初衷和<code>CARP</code>十分相似。一致性<code>Hash</code>修正了<code>CARP</code>使用的简单哈希算法带来的问题，使得分布式哈希<code>（DHT）</code>可以在<code>P2P</code>环境中真正得到应用。</p>
<p>一致性<code>Hash</code>算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对<code>2^32</code>取模，什么意思呢？简单来说，一致性<code>Hash</code>算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为<code>0-2^32-1</code>（即哈希值是一个32位无符号整形）。整个空间按<strong>顺时针方向组织</strong>，圆环的正上方的点代表<code>0，0</code>点右侧的第一个点代表<code>1</code>，以此类推，<code>2、3、4、5、6</code>……直到<code>2^32-1</code>，也就是说<code>0</code>点左侧的第一个点代表<code>2^32-1</code>， <code>0</code>和<code>2^32-1</code>在零点中方向重合，我们把这个由<code>2^32</code>个点组成的圆环称为<strong>Hash环</strong>。</p>
<p><img src="http://static.cyblogs.com/hash%E7%AE%97%E6%B3%95001.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;hash算法001.png"></p>
<h5 id="特性定义"><a href="#特性定义" class="headerlink" title="特性定义"></a>特性定义</h5><p>一致性<code>Hash</code>算法提出了在动态变化的<code>Cache</code>环境中，判定哈希算法好坏的四个定义：</p>
<p>**1、平衡性（Balance）：**平衡性是指哈希的结果能够尽可能分布在所有的缓冲<code>(Cache)</code>中去，这样可以使得所有的缓冲空间得到利用。很多哈希算法都能够满足这一条件。</p>
<p>**2、单调性（Monotonicity）：**单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应该能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会映射到旧的缓冲集合中的其他缓冲区。</p>
<p>**3、分散性（Spread）：**在分布式环境中，终端有可能看不到所有的缓冲，而只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上去，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应该能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p>
<p>**4、负载（Load）：**负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射到不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
<p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择<strong>服务器的IP或主机名</strong>作为<strong>关键字</strong>进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下： </p>
<img src="http://static.cyblogs.com/hash算法002.png" alt="http://static.cyblogs.com/hash算法002.png"/>

<p>接下来使用如下算法定位数据访问到相应服务器：将数据<code>key</code>使用相同的函数<code>Hash</code>计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p>
<p>例如我们有<code>Object A</code>、<code>Object B</code>、<code>Object C</code>、<code>Object D</code>四个数据对象，经过哈希计算后，在环空间上的位置如下： </p>
<img src="http://static.cyblogs.com/hash算法003.png" alt="http://static.cyblogs.com/hash算法003.png"/>

<p>根据一致性<code>Hash</code>算法，数据<code>A</code>会被定为到<code>Node A</code>上，<code>B</code>被定为到<code>Node B</code>上，<code>C</code>被定为到<code>Node C</code>上，<code>D</code>被定为到<code>Node D</code>上。</p>
<h5 id="容错和可扩展"><a href="#容错和可扩展" class="headerlink" title="容错和可扩展"></a>容错和可扩展</h5><p>现假设<code>Node C</code>不幸宕机，可以看到此时对象<code>A、B、D</code>不会受到影响，只有<code>C</code>对象被重定位到<code>Node D</code>。一般的，在一致性<code>Hash</code>算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：</p>
<img src="http://static.cyblogs.com/hash算法004.png" alt="http://static.cyblogs.com/hash算法004.png" />

<p>下面考虑另外一种情况，如果在系统中增加一台服务器<code>Node X</code>，如下图所示：</p>
<img src="http://static.cyblogs.com/hash算法005.png" alt="http://static.cyblogs.com/hash算法005.png" />

<p>此时对象<code>Object A、B、D</code>不受影响，只有对象<code>C</code>需要重定位到新的<code>Node X</code> ！一般的，在一致性<code>Hash</code>算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
<p>综上所述，一致性<code>Hash</code>算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<h5 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h5><p>一致性<code>Hash</code>算法在<strong>服务节点太少时</strong>，容易因为节点分部不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下： </p>
<p><img src="http://static.cyblogs.com/hash%E7%AE%97%E6%B3%95006.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;hash算法006.png"></p>
<p>此时必然造成大量数据集中到<code>Node A</code>上，而只有极少量会定位到<code>Node B</code>上。为了解决这种数据倾斜问题，一致性<code>Hash</code>算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在<code>服务器IP</code>或<code>主机名</code>的后面增加编号来实现。</p>
<p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “<code>Node A#1</code>”、“<code>Node A#2</code>”、“<code>Node A#3</code>”、“<code>Node B#1</code>”、“<code>Node B#2</code>”、“<code>Node B#3</code>”的哈希值，于是形成六个虚拟节点： </p>
<img src="http://static.cyblogs.com/hash算法007.png" alt="http://static.cyblogs.com/hash算法007.png" />

<p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“<code>Node A#1</code>”、“<code>Node A#2</code>”、“<code>Node A#3”</code>三个虚拟节点的数据均定位到<code>Node A</code>上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为<code>32</code>甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/19/2020/02/Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/19/2020/02/Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Dubbo负载均衡：一致性Hash的实现分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-19T00:00:00+08:00">2020-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/Dubbo/" itemprop="url" rel="index"><span itemprop="name">Dubbo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：FserSuN</p>
<p>来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Revivedsun/article/details/71022871">https://blog.csdn.net/Revivedsun/article/details/71022871</a></p>
<p>LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，以分摊压力。Dubbo中LoadBalance结构如下图。</p>
<p><img src="http://static.cyblogs.com/20170430135402902.jpeg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20170430135402902.jpeg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.rpc.cluster.LoadBalance </span><br><span class="line">接口提供了</span><br><span class="line">&lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException; </span><br><span class="line">通过该方法，进行结点选择。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance </span><br><span class="line">实现了一些公共方法，并定义抽象方法</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span>; </span><br><span class="line">该方法由具体的负载均衡实现类去实现。</span><br></pre></td></tr></table></figure>

<h4 id="一致性哈希负载均衡配置"><a href="#一致性哈希负载均衡配置" class="headerlink" title="一致性哈希负载均衡配置"></a>一致性哈希负载均衡配置</h4><p>具体的负载均衡实现类包括4种。分别是随机、轮训、最少活跃、一致性Hash<br>一致性哈希负载均衡配置</p>
<p>配置如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;consistenthash&quot;</span> /&gt;</span></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;consistenthash&quot;</span> /&gt;</span></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;consistenthash&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;consistenthash&quot;</span>/&gt;</span></span><br><span class="line">&lt;/dubbo:reference</span><br></pre></td></tr></table></figure>


<p>一致性Hash负载均衡涉及到两个主要的配置参数为hash.arguments 与hash.nodes。</p>
<p>hash.arguments ： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke(String s1,String s2); 若hash.arguments为1(默认值)，则仅取invoke的参数1（s1）来生成hashCode。</p>
<p>hash.nodes： 为结点的副本数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">缺省只对第一个参数Hash，如果要修改，请配置</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;hash.arguments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0,1&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">缺省用160份虚拟节点，如果要修改，请配置</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">&quot;hash.nodes&quot;</span> <span class="attr">value</span>=<span class="string">&quot;320&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Dubbo中一致性Hash的实现分析"><a href="#Dubbo中一致性Hash的实现分析" class="headerlink" title="Dubbo中一致性Hash的实现分析"></a>Dubbo中一致性Hash的实现分析</h4><p>dubbo的一致性哈希通过ConsistentHashLoadBalance类来实现。</p>
<p>ConsistentHashLoadBalance内部定义ConsistentHashSelector类，最终通过该类进行结点选择。ConsistentHashLoadBalance实现的doSelect方法来利用所创建的ConsistentHashSelector对象选择结点。</p>
<p>doSelect的实现如下。当调用该方法时，如果选择器不存在则去创建。随后通过ConsistentHashSelector的select方法选择结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取调用方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName();</span><br><span class="line">    <span class="comment">// 生成调用列表hashCode</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">identityHashCode</span> <span class="operator">=</span> System.identityHashCode(invokers);</span><br><span class="line">    <span class="comment">// 以调用方法名为key,获取一致性hash选择器</span></span><br><span class="line">    ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">    <span class="comment">// 若不存在则创建新的选择器</span></span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="literal">null</span> || selector.getIdentityHashCode() != identityHashCode) &#123;</span><br><span class="line">        <span class="comment">// 创建ConsistentHashSelector时会生成所有虚拟结点</span></span><br><span class="line">        selectors.put(key, <span class="keyword">new</span> <span class="title class_">ConsistentHashSelector</span>&lt;T&gt;(invokers, invocation.getMethodName(), identityHashCode));</span><br><span class="line">        <span class="comment">// 获取选择器</span></span><br><span class="line">        selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择结点</span></span><br><span class="line">    <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConsistentHashSelector在构造函数内部会创建replicaNumber个虚拟结点，并将这些虚拟结点存储于TreeMap。随后根据调用方法的参数来生成key，并在TreeMap中选择一个结点进行调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashSelector</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers; <span class="comment">// 虚拟结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>                       replicaNumber;   <span class="comment">// 副本数 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>                       identityHashCode;<span class="comment">// hashCode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[]                     argumentIndex;   <span class="comment">// 参数索引数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsistentHashSelector</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="type">int</span> identityHashCode)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建TreeMap 来保存结点</span></span><br><span class="line">        <span class="built_in">this</span>.virtualInvokers = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">        <span class="comment">// 生成调用结点HashCode</span></span><br><span class="line">        <span class="built_in">this</span>.identityHashCode = System.identityHashCode(invokers);</span><br><span class="line">        <span class="comment">// 获取Url </span></span><br><span class="line">        <span class="comment">// dubbo://169.254.90.37:20880/service.DemoService?anyhost=true&amp;application=srcAnalysisClient&amp;check=false&amp;dubbo=2.8.4&amp;generic=false&amp;interface=service.DemoService&amp;loadbalance=consistenthash&amp;methods=sayHello,retMap&amp;pid=14648&amp;sayHello.timeout=20000&amp;side=consumer&amp;timestamp=1493522325563</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line">        <span class="comment">// 获取所配置的结点数，如没有设置则使用默认值160</span></span><br><span class="line">        <span class="built_in">this</span>.replicaNumber = url.getMethodParameter(methodName, <span class="string">&quot;hash.nodes&quot;</span>, <span class="number">160</span>);</span><br><span class="line">        <span class="comment">// 获取需要进行hash的参数数组索引，默认对第一个参数进行hash</span></span><br><span class="line">        String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, <span class="string">&quot;hash.arguments&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">        argumentIndex = <span class="keyword">new</span> <span class="title class_">int</span>[index.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index.length; i ++) &#123;</span><br><span class="line">            argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建虚拟结点</span></span><br><span class="line">        <span class="comment">// 对每个invoker生成replicaNumber个虚拟结点，并存放于TreeMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 根据md5算法为每4个结点生成一个消息摘要，摘要长为16字节128位。</span></span><br><span class="line">                <span class="type">byte</span>[] digest = md5(invoker.getUrl().toFullString() + i);</span><br><span class="line">                <span class="comment">// 随后将128位分为4部分，0-31,32-63,64-95,95-128，并生成4个32位数，存于long中，long的高32位都为0</span></span><br><span class="line">                <span class="comment">// 并作为虚拟结点的key。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> hash(digest, h);</span><br><span class="line">                    virtualInvokers.put(m, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIdentityHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> identityHashCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择结点</span></span><br><span class="line">    <span class="keyword">public</span> Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据调用参数来生成Key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> toKey(invocation.getArguments());</span><br><span class="line">        <span class="comment">// 根据这个参数生成消息摘要</span></span><br><span class="line">        <span class="type">byte</span>[] digest = md5(key);</span><br><span class="line">        <span class="comment">//调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode</span></span><br><span class="line">        <span class="comment">//调用sekectForKey方法选择结点。</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = sekectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">toKey</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 由于hash.arguments没有进行配置，因为只取方法的第1个参数作为key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : argumentIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                buf.append(args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据hashCode选择结点</span></span><br><span class="line">    <span class="keyword">private</span> Invoker&lt;T&gt; <span class="title function_">sekectForKey</span><span class="params">(<span class="type">long</span> hash)</span> &#123;</span><br><span class="line">        Invoker&lt;T&gt; invoker;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">key</span> <span class="operator">=</span> hash;</span><br><span class="line">        <span class="comment">// 若HashCode直接与某个虚拟结点的key一样，则直接返回该结点</span></span><br><span class="line">        <span class="keyword">if</span> (!virtualInvokers.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 若不一致，找到一个最小上届的key所对应的结点。</span></span><br><span class="line">            SortedMap&lt;Long, Invoker&lt;T&gt;&gt; tailMap = virtualInvokers.tailMap(key);</span><br><span class="line">            <span class="comment">// 若存在则返回，例如hashCode落在图中[1]的位置</span></span><br><span class="line">            <span class="comment">// 若不存在，例如hashCode落在[2]的位置，那么选择treeMap中第一个结点</span></span><br><span class="line">            <span class="comment">// 使用TreeMap的firstKey方法，来选择最小上界。</span></span><br><span class="line">            <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">                key = virtualInvokers.firstKey();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                key = tailMap.firstKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        invoker = virtualInvokers.get(key);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(<span class="type">byte</span>[] digest, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="type">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) </span><br><span class="line">                | (digest[<span class="number">0</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>)) </span><br><span class="line">                &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] md5(String value) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bytes = value.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中 hash(byte[] digest, int number)方法用来生成hashCode。该函数将生成的结果转换为long类，这是因为生成的结果是一个32位数，若用int保存可能会产生负数。而一致性hash生成的逻辑环其hashCode的范围是在 0 - MAX_VALUE之间。因此为正整数，所以这里要强制转换为long类型，避免出现负数。</p>
<p>进行结点选择的方法为select,最后通过sekectForKey方法来选择结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择结点</span></span><br><span class="line"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(Invocation invocation)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据调用参数来生成Key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> toKey(invocation.getArguments());</span><br><span class="line">    <span class="comment">// 根据这个参数生成消息摘要</span></span><br><span class="line">    <span class="type">byte</span>[] digest = md5(key);</span><br><span class="line">    <span class="comment">//调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode</span></span><br><span class="line">    <span class="comment">//调用sekectForKey方法选择结点。</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = sekectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sekectForKey方法的实现如下。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title function_">sekectForKey</span><span class="params">(<span class="type">long</span> hash)</span> &#123;</span><br><span class="line">     Invoker&lt;T&gt; invoker;</span><br><span class="line">     <span class="type">Long</span> <span class="variable">key</span> <span class="operator">=</span> hash;</span><br><span class="line">     <span class="comment">// 若HashCode直接与某个虚拟结点的key一样，则直接返回该结点</span></span><br><span class="line">     <span class="keyword">if</span> (!virtualInvokers.containsKey(key)) &#123;</span><br><span class="line">         <span class="comment">// 若不在，找到一个最小上届的key所对应的结点。</span></span><br><span class="line">         SortedMap&lt;Long, Invoker&lt;T&gt;&gt; tailMap = virtualInvokers.tailMap(key);</span><br><span class="line">         <span class="comment">// 若存在则返回，例如hashCode落在图中[1]的位置</span></span><br><span class="line">         <span class="comment">// 若不存在，例如hashCode落在[2]的位置，那么选择treeMap中第一个结点</span></span><br><span class="line">         <span class="comment">// 使用TreeMap的firstKey方法，来选择最小上界。</span></span><br><span class="line">         <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">             key = virtualInvokers.firstKey();</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						 key = tailMap.firstKey();</span><br><span class="line">				 &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    invoker = virtualInvokers.get(key);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上(圆圈所表示)。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。</p>
<p><img src="http://static.cyblogs.com/20170430142247665.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20170430142247665.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/18/2020/02/Double%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%BA%E5%95%A5%E4%BC%9A%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/18/2020/02/Double%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%BA%E5%95%A5%E4%BC%9A%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6%EF%BC%9F/" class="post-title-link" itemprop="url">Double浮点数运算为啥会丢失精度？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-18 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-18T00:00:00+08:00">2020-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：王念博客</p>
<p>来源：<a target="_blank" rel="noopener" href="https://my.oschina.net/wangnian/blog/3064886">https://my.oschina.net/wangnian/blog/3064886</a></p>
<p>前言：在工作中，谈到有小数点的加减乘除都会想到用BigDecimal来解决，但是有很多人对于<code>double</code>或者<code>float</code>为啥会丢失精度一脸茫然。还有<code>BigDecimal</code>是怎么解决的？话不多说，我们开始。</p>
<h4 id="浮点数是啥？"><a href="#浮点数是啥？" class="headerlink" title="浮点数是啥？"></a>浮点数是啥？</h4><p> 浮点数是计算机用来表示小数的一种数据类型，采用科学计数法。在java中，double是双精度，64位，浮点数，默认是0.0d。float是单精度，32位.浮点数，默认是0.0f；</p>
<p> 在内存中存储</p>
<p><img src="https://oscimg.oschina.net/oscnet/ac189484da6532ca2c14a25665bc97072b9.jpg" alt="img"></p>
<p>float   符号位(1bit)  指数(8 bit)   尾数(23 bit)<br>double  符号位(1bit) 指数(11 bit)  尾数(52 bit)</p>
<p>float在内存中指数是8bit，由于阶码实际存储的是指数的移码，假设指数的真值是e,阶码为E，则有E&#x3D;e+(2^n-1 -1)。其中 2^n-1 -1是IEEE754标准规定的指数偏移量，根据这个公式我们可以得到 2^8 -1&#x3D;127。于是，float的指数范围为-128  +127，而double的指数范围为-1024 +1023。其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。</p>
<p>float的范围为-2^128 ~ +2^127，也即-3.40E+38 ~ +3.40E+38；<br>double的范围为-2^1024 ~ +2^1023，也即-1.79E+308 ~ +1.79E+308</p>
<h4 id="走进失真之科学计数法"><a href="#走进失真之科学计数法" class="headerlink" title="走进失真之科学计数法"></a>走进失真之科学计数法</h4><p> 我们先说说科学计数法，科学计数法是一种简化计数的方法，用来近似表示一个极大或极小且位数较多的数，对于位数较小的数值，科学计数法没有什么优势，但对于位数较多的数值其计数方法的优势就非常明显了。例如：光的速速是300000000米&#x2F;秒，全世界人口数大约是6100000000。类似光的速度和世界人口数这样大数值的数，读、写都很不方便，所以光的速度可以写成3<em>10^8，全世界人口数可以写成6.1</em>10^9。所以计算器用科学计数法表示光速是3E8，世界人口数大约是6.1E9。</p>
<p>我们小时候玩计算器喜欢疯狂的累加或者累减，到最后计算器就会显示下图。这个就是科学计数法显示的结果 </p>
<p><img src="https://oscimg.oschina.net/oscnet/c3bf5d2b1869e6754caa30e4f11c02a81cb.jpg" alt="img"></p>
<p>那图中真实的值是 -4.86*10^11&#x3D;-486000000000。十进制科学计数法要求有效数字的整数部分必须在【1，9】区间内。</p>
<h4 id="走进失真之精度"><a href="#走进失真之精度" class="headerlink" title="走进失真之精度"></a>走进失真之精度</h4><p>计算机在处理数据都涉及到数据的转换和各种复杂运算，比如，不同单位换算，不同进制（如二进制十进制）换算等，很多除法运算不能除尽，比如10÷3&#x3D;3.3333…..无穷无尽，而精度是有限的，3.3333333x3并不等于10，经过复杂的处理后得到的十进制数据并不精确，精度越高越精确。float和double的精度是由尾数的位数来决定的,其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。float：2^23 &#x3D; 8388608，一共七位，由于最左为1的一位省略了，这意味着最多能表示8位数： 2<em>8388608 &#x3D; 16777216 。有8位有效数字，但绝对能保证的为7位，也即*<em>float的精度为7~8位有效数字</em></em>；double：2^52 &#x3D; 4503599627370496，一共16位，同理，*<em>double的精度为16~17位</em>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/731e52b8ffaa28fdf67b3e97b0c18969d2f.jpg" alt="img"></p>
<p>当到达一定值自动开始使用科学计数法，并保留相关精度的有效数字，所以结果是个近似数,并且指数为整数。在十进制中小数有些是无法完整用二进制表示的。所以只能用有限位来表示，从而在存储时可能就会有误差。对于十进制的小数转换成二进制采用乘2取整法进行计算，取掉整数部分后，剩下的小数继续乘以2,直到小数部分全为0。</p>
<p>如遇到 </p>
<p><img src="https://oscimg.oschina.net/oscnet/ea0a68703cbec84b967ed448a06acf9415a.jpg" alt="img"></p>
<p>输出是 0.19999999999999998</p>
<p>double类型 0.3-0.1的情况。需要将0.3转成二进制在运算</p>
<p>0.3 * 2 &#x3D; 0.6 &#x3D;&gt; .0 (.6)取0剩0.6<br>0.6 * 2 &#x3D; 1.2 &#x3D;&gt; .01 (.2)取1剩0.2<br>0.2 * 2 &#x3D; 0.4 &#x3D;&gt; .010 (.4)取0剩0.4<br>0.4 * 2 &#x3D; 0.8 &#x3D;&gt; .0100 (.8) 取0剩0.8<br>0.8 * 2 &#x3D; 1.6 &#x3D;&gt; .01001 (.6)取1剩0.6<br>………….</p>
<p><img src="https://oscimg.oschina.net/oscnet/91e5aa515fd1299d321d85b838adbddd484.jpg" alt="img"></p>
<p> 看完上面，大概清楚了为啥浮点数会有精度问题。简单来说float和double类型主要是为了科学计算和工程计算而设计，他们执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近和计算而精心设计的。然而，他们并没有提供完全精确的结果，所以不应该被用于精确的结果的场合。浮点数达到一定大的数会自动使用科学计数法，这样的表示只是近似真实数而不等于真实数。当十进制小数位转换二进制的时候也会出现无限循环或者超过浮点数尾数的长度。</p>
<h4 id="那我们怎么用BigDecimal来解决？"><a href="#那我们怎么用BigDecimal来解决？" class="headerlink" title="那我们怎么用BigDecimal来解决？"></a>那我们怎么用BigDecimal来解决？</h4><p>大家看下面的两个输出</p>
<p><img src="https://oscimg.oschina.net/oscnet/4dad3f8db2d9a65b3091fdbb50465a274d1.jpg" alt="img"></p>
<p>输出结果：</p>
<p>0.299999999999999988897769753748434595763683319091796875<br>0.3</p>
<p>图上阿里的代码约束插件已经标注警告，让我使用<code>String</code>参数的构造方法创建<code>BigDecimal</code>。因为<code>double</code>不能精确地表示为0.3（任何有限长度的二进制），构造方法传递的值也是不完全等于0.3。<strong>大家在使用BigDecimal的时候一定要用String参数的构造方法来创建</strong>。说到这里，是木有还有好奇的宝宝有疑问，<code>BigDecimal</code>的原理是啥？为啥它就没有问题呢？其实原理很简单，<code>BigDecimal</code>是不可变的，可以用来表示任意精度的带符号十进制数。<code>double</code>之所以会出问题，是因为小数点转二进制丢失精度。**BigDecimal在处理的时候把十进制小数扩大N倍让它在整数上进行计算，并保留相应的精度信息。**至于<code>BigDecimal</code>是怎么保存的可以翻阅一下源代码。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/17/2020/02/CPU%E7%9A%84%E7%BC%93%E5%AD%98L1%E3%80%81L2%E3%80%81L3%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C%E5%A1%AB%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/17/2020/02/CPU%E7%9A%84%E7%BC%93%E5%AD%98L1%E3%80%81L2%E3%80%81L3%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C%E5%A1%AB%E5%85%85/" class="post-title-link" itemprop="url">CPU的缓存L1、L2、L3与缓存行填充</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-17T00:00:00+08:00">2020-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/" itemprop="url" rel="index"><span itemprop="name">CPU</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>L1，L2，L3</code> 指的都是<code>CPU</code>的缓存，他们比内存快，但是很昂贵，所以用作缓存，<code>CPU</code>查找数据的时候首先在L1，然后看<code>L2</code>，如果还没有，就到内存查找一些服务器还有<code>L3 Cache</code>，目的也是提高速度。</p>
<p>高速缓冲存储器<code>Cache</code>是位于<code>CPU</code>与内存之间的临时存储器，它的容量比内存小但交换速度快。在<code>Cache</code>中的数据是内存中的一小部分，但这一小部分是短时间内<code>CPU</code>即将访问的，当<code>CPU</code>调用大量数据时，就可避开内存直接从<code>Cache</code>中调用，从而加快读取速度。由此可见，在<code>CPU</code>中加入<code>Cache</code>是一种高效的解决方案，这样整个内存储器<code>（Cache+内存）</code>就变成了既有<code>Cache</code>的高速度，又有内存的大容量的存储系统了。<code>Cache</code>对<code>CPU</code>的性能影响很大，主要是因为<code>CPU</code>的数据交换顺序和<code>CPU</code>与<code>Cache</code>间的带宽引起的。</p>
<p><img src="http://static.cyblogs.com/20161111081230139.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111081230139.png"></p>
<h4 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h4><h5 id="1．-读取顺序"><a href="#1．-读取顺序" class="headerlink" title="1． 读取顺序"></a>1． 读取顺序</h5><p><code>CPU</code>要读取一个数据时，首先从<code>Cache</code>中查找，如果找到就立即读取并送给<code>CPU</code>处理；如果没有找到，就用相对慢的速度从内存中读取并送给<code>CPU</code>处理，同时把这个数据所在的数据块调入<code>Cache</code>中，可以使得以后对整块数据的读取都从<code>Cache</code>中进行，不必再调用内存。</p>
<p>正是这样的读取机制使<code>CPU</code>读取<code>Cache</code>的命中率非常高（大多数<code>CPU</code>可达90%左右），也就是说<code>CPU</code>下一次要读取的数据90%都在<code>Cache</code>中，只有大约10%需要从内存读取。这大大节省了<code>CPU</code>直接读取内存的时间，也使<code>CPU</code>读取数据时基本无需等待。总的来说，<code>CPU</code>读取数据的顺序是先Cache后内存。</p>
<h5 id="2．-缓存分类"><a href="#2．-缓存分类" class="headerlink" title="2． 缓存分类"></a>2． 缓存分类</h5><p>前面是把<code>Cache</code>作为一个整体来考虑的，现在要分类分析了。<code>Intel</code>从<code>Pentium</code>开始将<code>Cache</code>分开，通常分为<code>一级高速缓存L1</code>和<code>二级高速缓存L2</code>。</p>
<p>在以往的观念中，<code>L1 Cache</code>是集成在<code>CPU</code>中的，被称为片内<code>Cache</code>。在<code>L1</code>中还分数据<code>Cache（I-Cache）</code>和指令<code>Cache（D-Cache）</code>。它们分别用来存放数据和执行这些数据的指令，而且两个<code>Cache</code>可以同时被<code>CPU</code>访问，减少了争用Cache所造成的冲突，提高了处理器效能。</p>
<p><img src="http://static.cyblogs.com/20161111081336921.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111081336921.png"></p>
<p>在P4处理器中使用了一种先进的一级指令Cache——动态跟踪缓存。它直接和执行单元及动态跟踪引擎相连，通过动态跟踪引擎可以很快地找到所执行的指令，并且将指令的顺序存储在追踪缓存里，这样就减少了主执行循环的解码周期，提高了处理器的运算效率。</p>
<p>以前的<code>L2 Cache</code>没集成在<code>CPU</code>中，而在主板上或与<code>CPU</code>集成在同一块电路板上，因此也被称为<code>片外Cache</code>。但从PⅢ开始，由于工艺的提高<code>L2 Cache</code>被集成在<code>CPU</code>内核中，以相同于主频的速度工作，结束了<code>L2 Cache</code>与CPU大差距分频的历史，使<code>L2 Cache</code>与<code>L1 Cache</code>在性能上平等，得到更高的传输速度。<code>L2Cache</code>只存储数据，因此不分数据<code>Cache</code>和指令<code>Cache</code>。在<code>CPU</code>核心不变化的情况下，增加<code>L2 Cache</code>的容量能使性能提升，同一核心的<code>CPU</code>高低端之分往往也是在<code>L2 Cache</code>上做手脚，可见<code>L2 Cache</code>的重要性。现在<code>CPU</code>的<code>L1 Cache</code>与<code>L2 Cache</code>惟一区别在于读取顺序。</p>
<h5 id="3．-读取命中率"><a href="#3．-读取命中率" class="headerlink" title="3． 读取命中率"></a>3． 读取命中率</h5><p><code>CPU</code>在<code>Cache</code>中找到有用的数据被称为命中，当<code>Cache</code>中没有<code>CPU</code>所需的数据时（这时称为未命中），<code>CPU</code>才访问内存。从理论上讲，在一颗拥有2级<code>Cache</code>的<code>CPU</code>中，读取<code>L1 Cache</code>的命中率为<code>80%</code>。也就是说<code>CPU</code>从<code>L1 Cache</code>中找到的有用数据占数据总量的80%，剩下的20%从<code>L2 Cache</code>读取。由于不能准确预测将要执行的数据，读取L2的命中率也在80%左右（从L2读到有用的数据占总数据的16%）。那么还有的数据就不得不从内存调用，但这已经是一个相当小的比例了。在一些高端领域的<code>CPU</code>（像<code>Intel</code>的<code>Itanium</code>）中，我们常听到<code>L3 Cache</code>，它是为读取<code>L2 Cache</code>后未命中的数据设计的—种<code>Cache</code>，在拥有<code>L3 Cache</code>的<code>CPU</code>中，只有约5%的数据需要从内存中调用，这进一步提高了<code>CPU</code>的效率。</p>
<p>为了保证<code>CPU</code>访问时有较高的命中率，<code>Cache</code>中的内容应该按一定的算法替换。一种较常用的算法是“最近最少使用算法”（<code>LRU算法</code>），它是将最近一段时间内最少被访问过的行淘汰出局。因此需要为每行设置一个计数器，<code>LRU</code>算法是把命中行的计数器清零，其他各行计数器加1。当需要替换时淘汰行计数器计数值最大的数据行出局。这是一种高效、科学的算法，其计数器清零过程可以把一些频繁调用后再不需要的数据淘汰出<code>Cache</code>，提高<code>Cache</code>的利用率。</p>
<h4 id="缓存行填充"><a href="#缓存行填充" class="headerlink" title="缓存行填充"></a>缓存行填充</h4><p><code>CPU</code>访问内存时，并不是逐个字节访问，而是以字长为单位访问。比如32位的<code>CPU</code>，字长为4字节，那么<code>CPU</code>访问内存的单位也是4字节。</p>
<p>这么设计的目的，是减少<code>CPU</code>访问内存的次数，加大<code>CPU</code>访问内存的吞吐量。比如同样读取8个字节的数据，一次读取4个字节那么只需要读取2次。</p>
<p>我们来看看，编写程序时，变量在内存中是否按内存对齐的差异。有2个变量<code>word1、word2</code>：</p>
<p>图如下：</p>
<p><img src="http://static.cyblogs.com/WX20200211-152201@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200211-152201@2x.png"></p>
<p>我们假设<code>CPU</code>以<code>4字节</code>为单位读取内存。如果变量在内存中的布局按4字节对齐，那么读取a变量只需要读取一次内存，即<code>word1</code>；读取b变量也只需要读取一次内存，即<code>word2</code>。</p>
<p>而如果变量不做内存对齐，那么读取a变量也只需要读取一次内存，即<code>word1</code>；但是读取b变量时，由于b变量跨越了2个<code>word</code>，所以需要读取两次内存，分别读取<code>word1</code>和<code>word2</code>的值，然后将<code>word1</code>偏移取后3个字节，<code>word2</code>偏移取前1个字节，最后将它们做或操作，拼接得到b变量的值。</p>
<p>显然，内存对齐在某些情况下可以减少读取内存的次数以及一些运算，性能更高。</p>
<p>另外，由于内存对齐保证了读取b变量是单次操作，在多核环境下，原子性更容易保证。</p>
<p>但是内存对齐提升性能的同时，也需要付出相应的代价。由于变量与变量之间增加了填充，并没有存储真实有效的数据，所以占用的内存会更大。这也是一个典型的空间换时间的应用场景。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/karamos/article/details/80126704">https://blog.csdn.net/karamos/article/details/80126704</a></li>
<li><a target="_blank" rel="noopener" href="https://pengrl.com/p/20020/">https://pengrl.com/p/20020/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/16/2020/02/CPU%20Cache%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/16/2020/02/CPU%20Cache%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">CPU Cache与高性能编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-16 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-16T00:00:00+08:00">2020-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CPU/" itemprop="url" rel="index"><span itemprop="name">CPU</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="认识CPU-Cache"><a href="#认识CPU-Cache" class="headerlink" title="认识CPU Cache"></a>认识CPU Cache</h4><h5 id="CPU-Cache概述"><a href="#CPU-Cache概述" class="headerlink" title="CPU Cache概述"></a>CPU Cache概述</h5><p>随着CPU的频率不断提升，而内存的访问速度却没有质的突破，为了弥补访问内存的速度慢，充分发挥CPU的计算资源，提高CPU整体吞吐量，在CPU与内存之间引入了一级Cache。随着热点数据体积越来越大，一级Cache L1已经不满足发展的要求，引入了二级Cache L2，三级Cache L3。（注：若无特别说明，本文的Cache指CPU Cache，高速缓存）CPU Cache在存储器层次结构中的示意如下图：</p>
<p><img src="http://static.cyblogs.com/20161111081230139.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111081230139.png"></p>
<p>计算机早已进入多核时代，软件也越来越多的支持多核运行。一个处理器对应一个物理插槽，多处理器间通过QPI总线相连。一个处理器包含多个核，一个处理器间的多核共享L3 Cache。一个核包含寄存器、L1 Cache、L2 Cache，下图是Intel Sandy Bridge CPU架构，一个典型的NUMA多处理器结构：</p>
<p><img src="http://static.cyblogs.com/20161111081336921.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111081336921.png"></p>
<p>作为程序员，需要理解计算机存储器层次结构，它对应用程序的性能有巨大的影响。如果需要的程序是在CPU寄存器中的，指令执行时1个周期内就能访问到他们。如果在CPU Cache中，需要1<del>30个周期；如果在主存中，需要50</del>200个周期；在磁盘上，大概需要几千万个周期。充分利用它的结构和机制，可以有效的提高程序的性能。</p>
<p>以我们常见的X86芯片为例，Cache的结构下图所示：整个Cache被分为S个组，每个组是又由E行个最小的存储单元——Cache Line所组成，而一个Cache Line中有B（B&#x3D;64）个字节用来存储数据，即每个Cache Line能存储64个字节的数据，每个Cache Line又额外包含一个有效位(valid bit)、t个标记位(tag bit)，其中valid bit用来表示该缓存行是否有效；tag bit用来协助寻址，唯一标识存储在CacheLine中的块；而Cache Line里的64个字节其实是对应内存地址中的数据拷贝。根据Cache的结构题，我们可以推算出每一级Cache的大小为B×E×S。</p>
<p><img src="http://static.cyblogs.com/20161111081422178.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111081422178.png"></p>
<p>那么如何查看自己电脑CPU的Cache信息呢？</p>
<p>在windows下查看方式有多种方式，其中最直观的是，通过安装CPU-Z软件，直接显示Cache信息，如下图：</p>
<p><img src="http://static.cyblogs.com/20161111081516632.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111081516632.png"></p>
<p>此外，Windows下还有两种方法：</p>
<p>①Windows API调用GetLogicalProcessorInfo。<br>②通过命令行系统内部工具CoreInfo。</p>
<p>如果是Linux系统， 可以使用下面的命令查看Cache信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/devices/system/cpu/cpu0/cache/index0</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/20161111081643978.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111081643978.png"></p>
<p>还有lscpu等命令也可以查看相关信息,如果是Mac系统，可以用sysctl machdep.cpu 命令查看cpu信息。</p>
<p>如果我们用Java编程，还可以通过CacheSize API方式来获取Cache信息， CacheSize是一个谷歌的小项目，java语言通过它可以进行访问本机Cache的信息。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CacheNotFoundException &#123;</span><br><span class="line">    <span class="type">CacheInfo</span> <span class="variable">info</span> <span class="operator">=</span> CacheInfo.getInstance(); </span><br><span class="line">    <span class="type">CacheLevelInfo</span> <span class="variable">l1Datainf</span> <span class="operator">=</span> info.getCacheInformation(CacheLevel.L1, CacheType.DATA_CACHE);</span><br><span class="line">    System.out.println(<span class="string">&quot;第一级数据缓存信息：&quot;</span>+l1Datainf.toString());</span><br><span class="line">		<span class="type">CacheLevelInfo</span> <span class="variable">l1Instrinf</span> <span class="operator">=</span> info.getCacheInformation(CacheLevel.L1, CacheType.INSTRUCTION_CACHE);</span><br><span class="line">    System.out.println(<span class="string">&quot;第一级指令缓存信息：&quot;</span>+l1Instrinf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一级数据缓存信息：CacheLevelInfo [cacheLevel=L1, cacheType=DATA_CACHE, cacheSets=<span class="number">64</span>, cacheCoherencyLineSize=<span class="number">64</span>, cachePhysicalLinePartitions=<span class="number">1</span>, cacheWaysOfAssociativity=<span class="number">8</span>, isFullyAssociative=<span class="literal">false</span>, isSelfInitializing=<span class="literal">true</span>, totalSizeInBytes=<span class="number">32768</span>]</span><br><span class="line"></span><br><span class="line">第一级指令缓存信息：CacheLevelInfo [cacheLevel=L1, cacheType=INSTRUCTION_CACHE, cacheSets=<span class="number">64</span>, cacheCoherencyLineSize=<span class="number">64</span>, cachePhysicalLinePartitions=<span class="number">1</span>, cacheWaysOfAssociativity=<span class="number">8</span>, isFullyAssociative=<span class="literal">false</span>, isSelfInitializing=<span class="literal">true</span>, totalSizeInBytes=<span class="number">32768</span>]</span><br><span class="line">还可以查询L2、L3级缓存的信息，这里不做示例。从打印的信息和CPU-Z显示的信息可以看出，本机的Cache信息是一致的，L1数据/指令缓存大小都为：C=B×E×S=<span class="number">64</span>×<span class="number">8</span>×<span class="number">64</span>=<span class="number">32768</span>字节=32KB。</span><br></pre></td></tr></table></figure>

<h4 id="Cache-Line伪共享及解决方案"><a href="#Cache-Line伪共享及解决方案" class="headerlink" title="Cache Line伪共享及解决方案"></a>Cache Line伪共享及解决方案</h4><h5 id="Cache-Line伪共享分析"><a href="#Cache-Line伪共享分析" class="headerlink" title="Cache Line伪共享分析"></a>Cache Line伪共享分析</h5><p>说伪共享前，先看看Cache Line 在java编程中使用的场景。如果CPU访问的内存数据不在Cache中（一级、二级、三级），这就产生了Cache Line miss问题，此时CPU不得不发出新的加载指令，从内存中获取数据。通过前面对Cache存储层次的理解，我们知道一旦CPU要从内存中访问数据就会产生一个较大的时延，程序性能显著降低，所谓远水救不了近火。为此我们不得不提高Cache命中率，也就是充分发挥局部性原理。</p>
<p>局部性包括时间局部性、空间局部性。时间局部性：对于同一数据可能被多次使用，自第一次加载到Cache Line后，后面的访问就可以多次从Cache Line中命中，从而提高读取速度（而不是从下层缓存读取）。空间局部性：一个Cache Line有64字节块，我们可以充分利用一次加载64字节的空间，把程序后续会访问的数据，一次性全部加载进来，从而提高Cache Line命中率（而不是重新去寻址读取）。</p>
<p>看个例子：内存地址是连续的数组（利用空间局部性），能一次被L1缓存加载完成。</p>
<p>如下代码，长度为16的row和column数组，在Cache Line 64字节数据块上内存地址是连续的，能被一次加载到Cache Line中，所以在访问数组时，Cache Line命中率高，性能发挥到极致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span>[] row, <span class="type">int</span>[] column)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ ) &#123;</span><br><span class="line">        sum += row[i] * column[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>而上面例子中变量i则体现了时间局部性，i作为计数器被频繁操作，一直存放在寄存器中，每次从寄存器访问，而不是从主存甚至磁盘访问。虽然连续紧凑的内存分配带来高性能，但并不代表它一直都能带来高性能。如果把它放在多线程中将会发生什么呢？如图：</p>
<p><img src="http://static.cyblogs.com/20161111081903485.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111081903485.png"></p>
<p>数据X、Y、Z被加载到同一Cache Line中，线程A在Core1修改X，线程B在Core2上修改Y。根据MESI大法，假设是Core1是第一个发起操作的CPU核，Core1上的L1 Cache Line由S（共享）状态变成M（修改，脏数据）状态，然后告知其他的CPU核，图例则是Core2，引用同一地址的Cache Line已经无效了；当Core2发起写操作时，首先导致Core1将X写回主存，Cache Line状态由M变为I（无效），而后才是Core2从主存重新读取该地址内容，Cache Line状态由I变成E（独占），最后进行修改Y操作， Cache Line从E变成M。可见多个线程操作在同一Cache Line上的不同数据，相互竞争同一Cache Line，导致线程彼此牵制影响，变成了串行程序，降低了并发性。此时我们则需要将共享在多线程间的数据进行隔离，使他们不在同一个Cache Line上，从而提升多线程的性能。</p>
<h5 id="Cache-Line伪共享处理方案"><a href="#Cache-Line伪共享处理方案" class="headerlink" title="Cache Line伪共享处理方案"></a>Cache Line伪共享处理方案</h5><p>处理伪共享的两种方式：</p>
<p>增大数组元素的间隔使得不同线程存取的元素位于不同的cache line上。典型的空间换时间。（Linux cache机制与之相关）<br>在每个线程中创建全局数组各个元素的本地拷贝，然后结束后再写回全局数组。<br>在Java类中，最优化的设计是考虑清楚哪些变量是不变的，哪些是经常变化的，哪些变化是完全相互独立的，哪些属性一起变化。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">long</span> modifyTime;</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="type">long</span> createTime;</span><br><span class="line">    <span class="type">char</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>假如业务场景中，上述的类满足以下几个特点：</p>
<p>当value变量改变时，modifyTime肯定会改变<br>createTime变量和key变量在创建后，就不会再变化。<br>flag也经常会变化，不过与modifyTime和value变量毫无关联。<br>当上面的对象需要由多个线程同时的访问时，从Cache角度来说，就会有一些有趣的问题。当我们没有加任何措施时，Data对象所有的变量极有可能被加载在L1缓存的一行Cache Line中。在高并发访问下，会出现这种问题：</p>
<p><img src="http://static.cyblogs.com/20161111082043281.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111082043281.png"></p>
<p>如上图所示，每次value变更时，根据MESI协议，对象其他CPU上相关的Cache Line全部被设置为失效。其他的处理器想要访问未变化的数据(key 和 createTime)时，必须从内存中重新拉取数据，增大了数据访问的开销。</p>
<p>Padding 方式<br>正确的方式应该将该对象属性分组，将一起变化的放在一组，与其他属性无关的属性放到一组，将不变的属性放到一组。这样当每次对象变化时，不会带动所有的属性重新加载缓存，提升了读取效率。在JDK1.8以前，我们一般是在属性间增加长整型变量来分隔每一组属性。被操作的每一组属性占的字节数加上前后填充属性所占的字节数，不小于一个cache line的字节数就可以达到要求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataPadding</span>&#123;</span><br><span class="line">    <span class="type">long</span> a1,a2,a3,a4,a5,a6,a7,a8;<span class="comment">//防止与前一个对象产生伪共享</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">long</span> modifyTime;</span><br><span class="line">    <span class="type">long</span> b1,b2,b3,b4,b5,b6,b7,b8;<span class="comment">//防止不相关变量伪共享;</span></span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="type">long</span> c1,c2,c3,c4,c5,c6,c7,c8;<span class="comment">//</span></span><br><span class="line">    <span class="type">long</span> createTime;</span><br><span class="line">    <span class="type">char</span> key;</span><br><span class="line">    <span class="type">long</span> d1,d2,d3,d4,d5,d6,d7,d8;<span class="comment">//防止与下一个对象产生伪共享</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过填充变量，使不相关的变量分开</p>
<h5 id="Contended注解方式"><a href="#Contended注解方式" class="headerlink" title="Contended注解方式"></a>Contended注解方式</h5><p>在JDK1.8中，新增了一种注解@sun.misc.Contended，来使各个变量在Cache line中分隔开。注意，jvm需要添加参数-XX:-RestrictContended才能开启此功能<br>用时，可以在类前或属性前加上此注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类前加上代表整个类的每个变量都会在单独的cache line中</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;restriction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContendedData</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">long</span> modifyTime;</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="type">long</span> createTime;</span><br><span class="line">    <span class="type">char</span> key;</span><br><span class="line">&#125;</span><br><span class="line">或者这种：</span><br><span class="line"><span class="comment">// 属性前加上时需要加上组标签</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;restriction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContendedGroupData</span> &#123;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;group1&quot;</span>)</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;group1&quot;</span>)</span><br><span class="line">    <span class="type">long</span> modifyTime;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;group2&quot;</span>)</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;group3&quot;</span>)</span><br><span class="line">    <span class="type">long</span> createTime;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;group3&quot;</span>)</span><br><span class="line">    <span class="type">char</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>采取上述措施图示：</p>
<p><img src="http://static.cyblogs.com/20161111082403755.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111082403755.png"></p>
<p>JDK1.8 ConcurrentHashMap的处理<br>java.util.concurrent.ConcurrentHashMap在这个如雷贯耳的Map中，有一个很基本的操作问题，在并发条件下进行++操作。因为++这个操作并不是原子的，而且在连续的Atomic中，很容易产生伪共享（false sharing）。所以在其内部有专门的数据结构来保存long型的数据:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（openjdk\jdk\src\share\classes\java\util\concurrent\ConcurrentHashMap.java line:<span class="number">2506</span>）：</span><br><span class="line"><span class="comment">/* ---------------- Counter support -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">CounterCell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    CounterCell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到该类中，是通过@sun.misc.Contended达到防止false sharing的目的</p>
<h5 id="JDK1-8-Thread-的处理"><a href="#JDK1-8-Thread-的处理" class="headerlink" title="JDK1.8 Thread 的处理"></a>JDK1.8 Thread 的处理</h5><p>java.lang.Thread在java中，生成随机数是和线程有着关联。而且在很多情况下，多线程下产生随机数的操作是很常见的，JDK为了确保产生随机数的操作不会产生false sharing ,把产生随机数的三个相关值设为独占cache line。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">（openjdk\jdk\src\share\classes\java\lang\Thread.java line:<span class="number">2023</span>）</span><br><span class="line"><span class="comment">// The following three initially uninitialized fields are exclusively</span></span><br><span class="line"><span class="comment">// managed by class java.util.concurrent.ThreadLocalRandom. These</span></span><br><span class="line"><span class="comment">// fields are used to build the high-performance PRNGs in the</span></span><br><span class="line"><span class="comment">// concurrent code, and we can not risk accidental false sharing.</span></span><br><span class="line"><span class="comment">// Hence, the fields are isolated with @Contended.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The current seed for a ThreadLocalRandom */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;tlr&quot;</span>)</span><br><span class="line"><span class="type">long</span> threadLocalRandomSeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;tlr&quot;</span>)</span><br><span class="line"><span class="type">int</span> threadLocalRandomProbe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">&quot;tlr&quot;</span>)</span><br><span class="line"><span class="type">int</span> threadLocalRandomSecondarySeed;</span><br></pre></td></tr></table></figure>
<h4 id="Java中对Cache-line经典设计"><a href="#Java中对Cache-line经典设计" class="headerlink" title="Java中对Cache line经典设计"></a>Java中对Cache line经典设计</h4><h5 id="Disruptor框架"><a href="#Disruptor框架" class="headerlink" title="Disruptor框架"></a>Disruptor框架</h5><h6 id="认识Disruptor"><a href="#认识Disruptor" class="headerlink" title="认识Disruptor"></a>认识Disruptor</h6><p>LMAX是在英国注册并受到FCA监管的外汇黄金交易所。也是欧洲第一家也是唯一一家采用多边交易设施Multilateral Trading Facility（MTF）拥有交易所牌照和经纪商牌照的欧洲顶级金融公司。LMAX的零售金融交易平台，是建立在JVM平台上，核心是一个业务逻辑处理器，它能够在一个线程里每秒处理6百万订单。业务逻辑处理器的核心就是Disruptor（注，本文Disruptor基于当前最新3.3.6版本），这是一个Java实现的并发组件，能够在无锁的情况下实现网络的Queue并发操作，它确保任何数据只由一个线程拥有以进行写访问，从而消除写争用的设计， 这种设计被称作“破坏者”，也是这样命名这个框架的。</p>
<p>Disruptor是一个线程内通信框架，用于线程里共享数据。与LinkedBlockingQueue类似，提供了一个高速的生产者消费者模型，广泛用于批量IO读写，在硬盘读写相关的程序中应用的十分广泛，Apache旗下的HBase、Hive、Storm等框架都有在使用Disruptor。LMAX 创建Disruptor作为可靠消息架构的一部分，并将它设计成一种在不同组件中共享数据非常快的方法。Disruptor运行大致流程入下图：</p>
<p><img src="http://static.cyblogs.com/20161111082723254.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111082723254.png"></p>
<p>图中左侧（Input Disruptor部分）可以看作多生产者单消费者模式。外部多个线程作为多生产者并发请求业务逻辑处理器（Business Logic Processor），这些请求的信息经过Receiver存放在粉红色的圆环中，业务处理器则作为消费者从圆环中取得数据进行处理。右侧（Output Disruptor部分）则可看作单生产者多消费者模式。业务逻辑处理器作为单生产者，发布数据到粉红色圆环中，Publisher作为多个消费者接受业务逻辑处理器的结果。这里两处地方的数据共享都是通过那个粉红色的圆环，它就是Disruptor的核心设计RingBuffer。</p>
<h6 id="Disruptor特点"><a href="#Disruptor特点" class="headerlink" title="Disruptor特点"></a>Disruptor特点</h6><p>1、无锁机制。<br>2、没有CAS操作，避免了内存屏障指令的耗时。<br>3、避开了Cache line伪共享的问题，也是Disruptor部分主要关注的主题。</p>
<h5 id="Disruptor对伪共享的处理"><a href="#Disruptor对伪共享的处理" class="headerlink" title="Disruptor对伪共享的处理"></a>Disruptor对伪共享的处理</h5><h6 id="RingBuffer类"><a href="#RingBuffer类" class="headerlink" title="RingBuffer类"></a>RingBuffer类</h6><p>RingBuffer类（即上节中粉红色的圆环）的类关系图如下：</p>
<p><img src="http://static.cyblogs.com/20161111082805708.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111082805708.png"></p>
<p>通过源码分析，RingBuffer的父类，RingBufferFields采用数组来实现存放线程间的共享数据。下图，第57行，entries数组。</p>
<p><img src="http://static.cyblogs.com/20161111082838223.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111082838223.png"></p>
<p>前面分析过数组比链表、树更具有缓存友好性，此处不做细表。不使用LinkedBlockingQueue队列，是基于无锁机制的考虑。详细分析可参考，并发编程网的翻译。这里我们主要分析RingBuffer的继承关系中的填充，解决缓存伪共享问题。如下图：</p>
<p><img src="http://static.cyblogs.com/20161111082919849.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111082919849.png"></p>
<p><img src="http://static.cyblogs.com/20161111082958287.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111082958287.png"></p>
<p>依据JVM对象继承关系中父类属性与子类属性，内存地址连续排列布局，RingBufferPad的protected long p1,p2,p3,p4,p5,p6,p7;作为缓存前置填充，RingBuffer中的protected long p1,p2,p3,p4,p5,p6,p7;作为缓存后置填充。这样任意线程访问RingBuffer时，RingBuffer放在父类RingBufferFields的属性，都是独占一行Cache line不会产生伪共享问题。如图，RingBuffer的操作字段在RingBufferFields中，使用rbf标识：</p>
<p><img src="http://static.cyblogs.com/20161111083200062.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111083200062.png"></p>
<p>按照一行缓存64字节计算，前后填充56字节（7个long），中间大于等于8字节的内容都能独占一行Cache line，此处rbf是大于8字节的。</p>
<h6 id="Sequence类"><a href="#Sequence类" class="headerlink" title="Sequence类"></a>Sequence类</h6><p>Sequence类用来跟踪RingBuffer和事件处理器的增长步数，支持多个并发操作包括CAS指令和写指令。同时使用了Padding方式来实现，如下为其类结构图及Padding的类。</p>
<p>Sequence里在volatile long value前后放置了7个long padding，来解决伪共享的问题。示意如图，此处Value等于8字节：</p>
<p>也许读者应该会认为这里的图示比上面RingBuffer的图示更好理解，这里的操作属性只有一个value，两个图相互结合就更能理解了。</p>
<h6 id="Sequencer的实现"><a href="#Sequencer的实现" class="headerlink" title="Sequencer的实现"></a>Sequencer的实现</h6><p>在RingBuffer构造函数里面存在一个Sequencer接口，用来遍历数据，在生产者和消费者之间传递数据。Sequencer有两个实现类，单生产者模式的实现SingleProducerSequencer与多生产者模式的实现MultiProducerSequencer。它们的类结构如图：</p>
<p>单生产者是在Cache line中使用padding方式实现，源码如下：</p>
<p><img src="http://static.cyblogs.com/20161111084637099.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111084637099.png"></p>
<p>多生产者则是使用 sun.misc.Unsafe来实现的。如下图：</p>
<p><img src="http://static.cyblogs.com/20161111084621458.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161111084621458.png"></p>
<h4 id="总结与使用示例"><a href="#总结与使用示例" class="headerlink" title="总结与使用示例"></a>总结与使用示例</h4><p>可见padding方式在Disruptor中是处理伪共享常见的方式，JDK1.8的@Contended很好的解决了这个问题，不知道Disruptor后面的版本是否会考虑使用它。</p>
<p>Disruptor使用示例代码参考地址。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>7个示例科普CPU Cache：<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/10249.html">http://coolshell.cn/articles/10249.html</a><br>Linux Cache 机制：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/liloke/archive/2011/11/20/2255737.html">http://www.cnblogs.com/liloke/archive/2011/11/20/2255737.html</a><br>《深入理解计算机系统》：第六章部分<br>Disruptor官方文档：<a target="_blank" rel="noopener" href="https://github.com/LMAX-Exchange/disruptor/tree/master/docs">https://github.com/LMAX-Exchange/disruptor/tree/master/docs</a><br>Disruptor并发编程网文档翻译：<a target="_blank" rel="noopener" href="http://ifeve.com/disruptor/">http://ifeve.com/disruptor/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Vernon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <a target="_blank" href="https://beian.miit.gov.cn">粤ICP备2025433887号</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
