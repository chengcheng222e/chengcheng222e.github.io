<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.cyblogs.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="简栈文化">
<meta property="og:url" content="http://www.cyblogs.com/page/8/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.cyblogs.com/page/8/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>简栈文化</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">简栈文化</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java技术人的成长之路~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vernon"
      src="/images/vernonchen.jpg">
  <p class="site-author-name" itemprop="name">Vernon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengcheng222e" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengcheng222e" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengcheng222e@gmail.com" title="E-Mail → mailto:chengcheng222e@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/09/2020/03/ArrayList%E4%B8%AD%E5%87%A0%E4%B8%AA%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E4%BA%8B%E6%83%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/09/2020/03/ArrayList%E4%B8%AD%E5%87%A0%E4%B8%AA%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E4%BA%8B%E6%83%85/" class="post-title-link" itemprop="url">ArrayList中几个不为人知的事情</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-09 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-09T00:00:00+08:00">2020-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天学习下<code>ArrayList</code>的源代码，不同于其他人写的博客，很多都是翻译源代码中的注释，然后直接贴到文章中去。小编打算换一种书写风格，带着问题看源码可能收获会更大，本文将围绕着下面几个问题展开讨论。</p>
<h3 id="一、问题产生"><a href="#一、问题产生" class="headerlink" title="一、问题产生"></a>一、问题产生</h3><ul>
<li>1、为什么<code>ArrayList</code>集合中存储元素的容器声明为<code>transient Object[] elementData;</code>？</li>
<li>2、既然<code>ArrayList</code>可以自动扩容，那么它的扩容机制是怎样实现的？</li>
<li>3、调用<code>ArrayList</code>的<code>iterator()</code>返回的迭代器是怎样的？</li>
<li>4、采用<code>ArrayList</code>的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出<code>ConcurrentModificationException</code>,我们该如何避免？</li>
<li>5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么<code>ArrayList</code>的数组拷贝是怎么实现的？</li>
<li>6、<code>ArrayList</code>中的序列化机制</li>
</ul>
<p>小编对<code>ArrayList</code>源码大概浏览了之后，总结出以上几个问题，带着这些问题，让我们一起翻开源码解决吧！</p>
<h3 id="二、问题解答"><a href="#二、问题解答" class="headerlink" title="二、问题解答"></a>二、问题解答</h3><h5 id="1、为什么ArrayList集合中存储元素的容器声明为transient-Object-elementData-？"><a href="#1、为什么ArrayList集合中存储元素的容器声明为transient-Object-elementData-？" class="headerlink" title="1、为什么ArrayList集合中存储元素的容器声明为transient Object[] elementData;？"></a>1、为什么<code>ArrayList</code>集合中存储元素的容器声明为<code>transient Object[] elementData;</code>？</h5><p><code>ArrayList</code>是一个集合容器，既然是一个容器，那么肯定需要存储某些东西，既然需要存储某些东西，那总得有一个存储的地方吧！就好比说你需要装一吨的水，总得有个池子给你装吧！或者说你想装几十毫升水，总得那个瓶子或者袋子给你装吧！区别就在于不同大小的水，我们需要的容器大小也不相同而已！</p>
<p>既然<code>ArrayList</code>已经支持泛型了，那么为什么<code>ArrayList</code>源码的容器定义为什么还要定义成下面的<code>Object[]</code>类型呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>其实无论你采用<code>transient E[] elementData;</code>的方式声明，或者是采用<code>transient Object[] elementData;</code>声明，都是允许的，差别在于前者要求我们我们在具体实例化<code>elementData</code>时需要做一次类型转换，而这次类型转换要求我们程序员保证这种转换不会出现任何错误。为了提醒程序员关注可能出现的类型转换异常，编译器会发出一个<code>Type safety: Unchecked cast from String[] to E[]</code>警告,这样讲不知道会不会很懵比，下面的代码告诉你：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 声明数组，类型为E[]</span></span><br><span class="line">    E[] DATAS;</span><br><span class="line">    <span class="comment">// 初始化数组，必须做一次类型转换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    	DATAS = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getDATAS</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> DATAS[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDATAS</span><span class="params">(E[] dATAS)</span> &#123;</span><br><span class="line">    	DATAS = dATAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在<code>1</code>处我们声明了<code>E[]</code>数组，具体类型取决于你传入<code>E</code>的实际类型，但是要注意，当你对<code>DATAS</code>进行初始化时，你不能像下面这样初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E[] DATAS = <span class="keyword">new</span> <span class="title class_">E</span>[<span class="number">10</span>]; <span class="comment">// 这句代码将报错</span></span><br></pre></td></tr></table></figure>

<p>也就是说，<strong>泛型数组是不能具体化的</strong>，也就是不能通过<code>new 泛型[size];</code>的方式进行具体化，那么怎么解决呢？有两种方式：</p>
<ul>
<li><p>1、进行前面说的做一次转换，但不推荐</p>
<p>就像上面代码所展示的，我们可以初始化成<code>Object[]</code>类型之后再转换成<code>E[]</code>，但前提是你得保证这次转换不会出现任何错误，通常我们不建议这样子写！</p>
</li>
<li><p>2、直接声明为<code>Object[]</code></p>
<p>这种方式也是<code>ArrayList</code>源码的定义方式，那么我们来看看<code>ArrayList</code>是怎么初始化的：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处直接new Object[]，不会出现任何错误</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有一点还需要注意，但你调用<code>ArrayList</code>的<code>toArray</code>方法将集合转换为对象数组时，有可能出现意想不到的结果，具体可参考小编的另外一篇博文。</p>
<p><strong>总结：</strong> 总的来说，我们要知道泛型数组是不能具体化的，以及其解决办法！你可能会很好奇我为什么没有讲<code>transient</code>，这个小编放到下面序列化反序列化时讲。</p>
<h5 id="2、既然ArrayList可以自动扩容，那么它的扩容机制是怎样实现的？"><a href="#2、既然ArrayList可以自动扩容，那么它的扩容机制是怎样实现的？" class="headerlink" title="2、既然ArrayList可以自动扩容，那么它的扩容机制是怎样实现的？"></a>2、既然<code>ArrayList</code>可以自动扩容，那么它的扩容机制是怎样实现的？</h5><p>有时候，我们得保证当增加水的时，原来的容器也可以装入新的的水而不至于溢出，也就是<code>ArrayList</code>的自动扩容机制。我们可以想象，假如列表大小为10，那么正常情况下只能装10个元素，我们很好奇在此之后调用<code>add()</code>方法时底层做了什么神奇的事，所以我们看看<code>add()</code>方法是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保内部容量大小，size指的是当前列表的实际元素个数</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面方法可以看出先判断内部容量是否足够满足<code>size + 1</code>个元素，如果可以，就直接<code>elementData[size++] = e;</code>，否则就需要扩容，那么怎么扩容呢?我们到<code>ensureCapacityInternal()</code>方法看看，这里有一点很重要，请记住下面的参数:</p>
<ul>
<li><code>minCapacity</code>永远代表增加之后实际的总元素个数</li>
<li><code>newCapacity</code>永远表示列表能够满足存储<code>minCapacity</code>个元素列表所需要扩容的大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 校验内部容量大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法只有首次调用时会用到，不然默认返回 minCapacity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里如果成立，表示该ArrayList是刚刚初始化，还没有add进任何元素</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容，elementData.length表示列表的空间总大小，不是列表的实际元素个数，size才是列表的实际元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面会判断集合是否刚刚初始化，即还没有调用过<code>add()</code>方法，如果成立，则将集合默认扩容至10，<code>DEFAULT_CAPACITY</code>的值为10，取最大值。最后一个方法的<code>grow()</code>成立的条件是容器的元素大于10且没有可用空间，即需要扩容了，我们再看看<code>grow()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取旧的列表大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 扩容之后的新的容器大小，默认增加一半 ..............................1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩容一半之后还不足，则新的容器大小等于minCapacity.............................2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新的容器大小比MAX_ARRAY_SIZE还大，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 数组拷贝操作</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大不能超过Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>1</code>处<code>&gt;&gt;</code>表示右移，也就是相当于除以2，减为一半，<code>2</code>处可能调用<code>addAll()</code>方法时成立。</p>
<p>下面我们列举几种情况：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>情况描述</th>
<th>调用add()?</th>
<th>调用addAll(size)? + size大小</th>
<th>执行结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>列表刚初始化</td>
<td>是</td>
<td>否</td>
<td>初始化一个长度为10的列表，即容器扩容至10个单位</td>
</tr>
<tr>
<td>2</td>
<td>列表实际元素个数为10，实际大小也为10，此时调用add操作</td>
<td>是</td>
<td>否</td>
<td>容器扩容至15，容器元素个数为11，即有4个位置空闲</td>
</tr>
<tr>
<td>3</td>
<td>列表实际元素个数为10，列表长度也为10，此时调用addAll操作</td>
<td>否</td>
<td>是 + 5</td>
<td>容器扩容至15，没有空余</td>
</tr>
<tr>
<td>4</td>
<td>列表实际元素个数为5，列表长度为10，此时调用addAll()操作</td>
<td>否</td>
<td>是 + 10</td>
<td>容器扩容至15，没有空余</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<p>扩容机制如下：</p>
<ul>
<li>1、先默认将列表大小<code>newCapacity</code>增加原来一半，即如果原来是10，则新的大小为15；</li>
<li>2、如果新的大小<code>newCapacity</code>依旧不能满足<code>add</code>进来的元素总个数<code>minCapacity</code>,则将列表大小改为和<code>minCapacity</code>一样大；即如果扩大一半后<code>newCapacity</code>为15，但<code>add</code>进来的总元素个数<code>minCapacity</code>为20，则15明显不能存储20个元素，那么此时就将<code>newCapacity</code>大小扩大到20，刚刚好存储20个元素；</li>
<li>3、如果扩容后的列表大小大于<code>2147483639</code>,也就是说大于<code>Integer.MAX_VALUE - 8</code>,此时就要做额外处理了，因为实际总元素大小有可能比<code>Integer.MAX_VALUE</code>还要大，当实际总元素大小<code>minCapacity</code>的值大于<code>Integer.MAX_VALUE</code>，即大于<code>2147483647</code>时，此时<code>minCapacity</code>的值将变为负数，因为int是有符号的，当超过最大值时就变为负数</li>
</ul>
<p>小编认为，上面第3点也体现了一种智慧，即当一样东西有可能出错时，我们应该提前对其做处理，而不要等到错误发生时再对其进行处理。也就是我们运维要做监控的目的。</p>
<h5 id="3、调用ArrayList的iterator-返回的迭代器是怎样的？"><a href="#3、调用ArrayList的iterator-返回的迭代器是怎样的？" class="headerlink" title="3、调用ArrayList的iterator()返回的迭代器是怎样的？"></a>3、调用<code>ArrayList</code>的<code>iterator()</code>返回的迭代器是怎样的？</h5><p>我们都知道所有集合都是<code>Collection</code>接口的实现类，又因为<code>Collection</code>继承了<code>Iterable</code>接口，因此所有集合都是可迭代的。我们常常会采用集合的迭代器来遍历集合元素，就像下面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// 获取集合的迭代器对象</span></span><br><span class="line">Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    System.err.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过调用集合的<code>iterator()</code>方法获取集合的迭代器对象，那么在<code>ArrayList</code>中，<code>iterator()</code>方法是怎么实现的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超级简单，原来是新建了一个叫<code>Itr</code>的对象那么这个<code>Itr</code>又是什么呢？打开源码我们发现<code>Itr</code>类其实是<code>ArrayList</code>的一个内部类，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;......................... <span class="number">1</span></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;...&#125;<span class="comment">// 具体实现被我删除了</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该迭代器实现了<code>Iterator</code>接口并实现了相关方法，提供我们对集合的遍历能力。总结：<code>ArrayList</code>的迭代器默认是其内部类实现，实现一个自定义迭代器只需要实现<code>Iterator</code>接口并实现相关方法即可。而实现<code>Iterable</code>接口表示该实现类具有像<code>for-each loop</code>迭代遍历的能力。</p>
<h5 id="4、采用ArrayList的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出ConcurrentModificationException-我们该如何避免？"><a href="#4、采用ArrayList的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出ConcurrentModificationException-我们该如何避免？" class="headerlink" title="4、采用ArrayList的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出ConcurrentModificationException,我们该如何避免？"></a>4、采用<code>ArrayList</code>的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出<code>ConcurrentModificationException</code>,我们该如何避免？</h5><p>上面第3小节我们查看了<code>ArrayList</code>迭代器的源代码，我们都知道，如果在迭代的过程中调用非迭代器内部的<code>remove</code>或者<code>clear</code>方法将会抛出<code>ConcurrentModificationException</code>异常，那到底是为什么呢？我们一起来看看。首先这里设计两个很重要的变量，一个是<code>expectedModCount</code>,另一个是<code>modCount</code>,<code>expectedModCount</code>在集合内部迭代器中定义，就像上面第三小节源码<code>1</code>处所示，<code>modCount</code>在<code>AbstractList</code>中定义。就像第三小节<code>1</code>处所看到的，默认两者是相等的，即<code>expectedModCount = modCount</code>,只有当其不想等的情况下就会抛出异常。真的是不想等就抛异常吗？我们来看看迭代器内部的<code>next</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在迭代前会对两个变量进行检查</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体检查</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出确实是当它们两者之间不想等时就报错，问题来了，那么什么时候会导致它们不想等呢？不急，我们来看看<code>ArrayList</code>的<code>remove</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 这里会修改modCount的值</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出当调用<code>remove()</code>方法时确实是修改了<code>modCount</code>的值，导致报错。那我们怎么做才能不报错有想在迭代过程中增加或者删除数据呢？答案是使用迭代器内部的<code>remove()</code>方法。</p>
<p><strong>总结：</strong></p>
<p>迭代器迭代集合时不能对被迭代集合进行修改，原因是<code>modCount</code>和<code>expectedModCount</code>两个变量值不想等导致的！</p>
<h5 id="5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么ArrayList的数组拷贝是怎么实现的？"><a href="#5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么ArrayList的数组拷贝是怎么实现的？" class="headerlink" title="5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么ArrayList的数组拷贝是怎么实现的？"></a>5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么<code>ArrayList</code>的数组拷贝是怎么实现的？</h5><p>在<code>ArrayList</code>中对集合的拷贝是通过调用<code>Arrays</code>的<code>copyOf</code>方法实现的，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());................<span class="number">.2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt; newType) &#123;</span><br><span class="line">    <span class="comment">// 在创建新数组对象之前会先对传入的数据类型进行判定</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后还调用了<code>System</code>的<code>arraycopy</code>方法。</p>
<h5 id="6、ArrayList中的序列化机制"><a href="#6、ArrayList中的序列化机制" class="headerlink" title="6、ArrayList中的序列化机制"></a>6、<code>ArrayList</code>中的序列化机制</h5><p>第一小节我们知道<code>ArrayList</code>存储数据的定义方式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>我们会觉得非常奇怪，这是一个集合存储元素的核心，却声明为<code>transient</code>,是不是就说就不序列化了？这不科学呀！其实集合存储的数据还是会序列化的，具体我们看看<code>ArrayList</code>中的<code>writeObject</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">writeObject</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个地方做一个序列化操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看出<code>ArrayList</code>其实是有对<code>elementData</code>进行序列化的，只不过这样做的原因是因为<code>elementData</code>中可能会有很多的null元素，为了不把null元素也序列化出去，所以自定义了<code>writeObject</code>和<code>readObject</code>方法。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b2c5eefe51d4558c0442e95">https://juejin.im/post/5b2c5eefe51d4558c0442e95</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/08/2020/03/%E4%B8%BA%E4%BB%80%E4%B9%8832%E4%BD%8D%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%A4%A7%E5%8F%AA%E8%83%BD%E6%94%AF%E6%8C%814GB%E5%86%85%E5%AD%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/08/2020/03/%E4%B8%BA%E4%BB%80%E4%B9%8832%E4%BD%8D%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%A4%A7%E5%8F%AA%E8%83%BD%E6%94%AF%E6%8C%814GB%E5%86%85%E5%AD%98%EF%BC%9F/" class="post-title-link" itemprop="url">为什么32位的操作系统最大只能支持4GB内存？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-08 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-08T00:00:00+08:00">2020-03-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>也许大家对这个问题都不陌生，实际装过系统用过电脑的朋友可能都有这样的经历：自己电脑配的是4G的内存条，可是装完系统之后发现电脑上显示的只有3.2G左右可用内存，其它的内存跑到哪去了？网上也有很多朋友给出了一些解释，大部分我觉得都没有解释得很清楚，今天我们就来看一下其中的具体缘由。</p>
<p>在此之前先来了解一些计算机系统结构和PC硬件方面的一些知识。</p>
<h4 id="总线结构和主板的构成"><a href="#总线结构和主板的构成" class="headerlink" title="总线结构和主板的构成"></a>总线结构和主板的构成</h4><p>　　说起总线大家肯定不陌生，而且大家平时肯定跟它打过交道，我们在用U盘拷贝数据的时候先要把U盘通过USB接口与电脑相连才能拷贝。USB接口实际上就是一种总线，一般称这种总线为USB总线（也叫做通用串行总线）。在很久之前是没有USB总线的，那个时候每个外设各自采用自己的接口标准，举个最简单的例子：鼠标生产厂商采用鼠标特有的接口，键盘生产厂商用键盘特有的接口，这样一来的话，PC机上就必须提供很多接口，这样一来增加了硬件设计难度和成本，直到后来USB接口的出现，它统一了很多外设接口的标准，不仅使得用户可以很方便地连接一些外设，更增强了PC的可扩展性。所以现在大家看到的鼠标、键盘、U盘、打印机等等这些外设都可以直接通过USB接口直接插到电脑上的。</p>
<p>　　在计算机系统中总线是非常重要的一个概念，正是因为有了总线，所有的组成部件才能一起正常协同分工合作。在很久以前的PC机中，采用的是三总线结构，即：数据总线、地址总线、控制总线。它们分别用来传输不同类型的数据，数据总线用来传输数据，地址总线用来传输地址，控制总线用来传输一些控制信号。下面这幅图很清楚地展示了三总线结构：</p>
<p>　　<img src="http://static.cyblogs.com/31150701-f52612011e054b0db388487517007dc1.jpg" alt="img"></p>
<p>随着时代的发展，这种简单的总线结构逐渐被淘汰。下面这幅图是现代计算采用的结构：</p>
<p>　　<img src="http://static.cyblogs.com/31162602-cb2675a3eb5b4b199adc9c3eefcaa167.jpg" alt="img"></p>
<p>　　事实上这也是现代主板所采用的结构，当然可能部分地方有略微不同（大体结构是差不多的），仔细观察过主板构成的朋友可能对上面一幅图很熟悉。在主板上主要有两大主要部分：北桥（North Bridge也称Host Bridge）和南桥（South Bridge）。北桥主要负责CPU和内存、显卡这些部件的数据传送，而南桥主要负责I&#x2F;O设备、外部存储设备以及BIOS之间的通信。现在有些主板已经没有北桥了，因为芯片厂商已经把北桥所负责的功能直接集成到CPU中了（不过暂且我们以上副图的模型来讨论）。</p>
<p>　　在上副图中，我没有画出 数据总线和地址总线等，因为在某些总线标准中它们被集成到一起了，比如在PCI总线中，地址总线和数据总线总是分时复用的（也就是说假如PCI总线有32位数据总线，这32位总线在某个时刻可以充当数据总线的作用，在下一时刻可以充当地址总线的作用）。有的总线同时提供了数据总线和地址总线。</p>
<p>　　下面来说一下几个主要总线和南北桥的作用：</p>
<p>　　FSB总线：即前端总线（Front Side Bus），CPU和北桥之间的桥梁，CPU和北桥传递的所有数据必须经过FSB总线，可以这么说FSB总线的频率直接影响到CPU访问内存的速度。</p>
<p>　　北桥：北桥是CPU和内存、显卡等部件进行数据交换的唯一桥梁，也就是说CPU想和其他任何部分通信必须经过北桥。北桥芯片中通常集成的还有内存控制器等，用来控制与内存的通信。现在的主板上已经看不到北桥了，它的功能已经被集成到CPU当中了。</p>
<p>　　PCI总线：PCI总线是一种高性能局部总线，其不受CPU限制，构成了CPU和外设之间的高速通道。比如现在的显卡一般都是用的PCI插槽，PCI总线传输速度快，能够很好地让显卡和CPU进行数据交换。</p>
<p>　　南桥：主要负责I&#x2F;O设备之间的通信，CPU要想访问外设必须经过南桥芯片。</p>
<p>　　在了解了这些基础东西之后，下面来讲解一下为何32位系统最大只支持4GB内存。</p>
<h4 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h4><p>　　在使用计算机时，其最大支持的内存是由  操作系统 和 硬件 两方面决定的。</p>
<p>　　先说一下硬件方面的因素，在上面已经提到了地址总线，在计算机中 CPU的地址总线数目 决定了CPU 的 寻址 范围，这种由地址总线对应的地址称作为物理地址。假如CPU有32根地址总线（一般情况下32位的CPU的地址总线是32位，也有部分32位的CPU地址总线是36位的，比如用做服务器的CPU），那么提供的可寻址物理地址范围 为 232&#x3D;4GB（在这里要注意一点，我们平常所说的32位CPU和64位CPU指的是CPU一次能够处理的数据宽度，即位宽，不是地址总线的数目）。自从64位CPU出现之后，一次便能够处理64位的数据了，其地址总线一般采用的是36位或者40位（即CPU能够寻址的物理地址空间为64GB或者1T）。在CPU访问其它任何部件的时候，都需要一个地址，就像一个快递员送快递，没有地址他是不知道往哪里送达的，举个例子，CPU想从显存单元读取数据，必须知道要读取的显存单元的实际物理地址才能实现读取操作，同样地，从内存条上的内存单元读取数据也需要知道内存单元的物理地址。换句话说，CPU访问任何存储单元必须知道其物理地址。</p>
<p>　　用户在使用计算机时能够访问的最大内存不单是由CPU地址总线的位数决定的，还需要考虑操作系统的实现。实际上用户在使用计算机时，进程所访问到的地址是逻辑地址，并不是真实的物理地址，这个逻辑地址是操作系统提供的，CPU在执行指令时需要先将指令的逻辑地址变换为物理地址才能对相应的存储单元进行数据的读取或者写入（注意逻辑地址和物理地址是一一对应的）。</p>
<p>　　对于32位的windows操作系统，其逻辑地址编码采用的地址位数是32位的，那么操作系统所提供的逻辑地址寻址范围是4GB，而在intel x86架构下，采用的是内存映射技术(Memory-Mapped I&#x2F;O, MMIO)，也就说将4GB逻辑地址中一部分要划分出来与BIOS ROM、CPU寄存器、I&#x2F;O设备这些部件的物理地址进行映射，那么逻辑地址中能够与内存条的物理地址进行映射的空间肯定没有4GB了，看下面这幅图就明白了：</p>
<p>　　<img src="http://static.cyblogs.com/31172853-72c5552567954880964132f5b487c036.jpg" alt="img"></p>
<p>　　所以当我们装了32位的windows操作系统，即使我们买了4GB的内存条，实际上能被操作系统访问到的肯定小于4GB，一般情况是3.2GB左右。假如说地址总线位数没有32位，比如说是20位，那么CPU能够寻址到1MB的物理地址空间，此时操作系统即使能支持4GB的逻辑地址空间并且假设内存条是4GB的，能够被用户访问到的空间不会大于1MB（当然此处不考虑虚拟内存技术），所以用户能够访问到的最大内存空间是由硬件和操作系统两者共同决定的，两者都有制约关系。</p>
<p>　　对于64位的操作系统，其逻辑地址编码采用的地址位数是40位，能够最大支持1T的逻辑地址空间。考虑一种情况，假如CPU是64位的，地址总线位数是40位，操作系统也是64位的，逻辑地址编码采用的地址位数也是40位，内存条大小是64GB，那么是不是内存条的64GB全部都能被利用了呢？答案是不一定，因为这里面还要考虑一个因素就是内存控制器，内存控制器位于北桥之内（现在基本都是放在CPU里面了），内存控制器的实际连接内存的地址线决定了可以支持的内存容量，也就是说内存控制器与内存槽实际连接的地址线如果没有40位的话，是无法完全利用64GB的内存条的存储空间的。当然对于内存控制器这个问题几乎可以不用考虑，因为现在大多数的内存控制器至少都采用的是40位地址总线。</p>
<p>　　关于这个问题就说这么多了，有兴趣深入研究的朋友可以自己查阅更多的资料。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html">https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/07/2020/03/%E8%B0%88%E8%B0%88JDK%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/07/2020/03/%E8%B0%88%E8%B0%88JDK%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">谈谈JDK堆外内存的创建和回收</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-07T00:00:00+08:00">2020-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>堆外内存的优势在于IO操作，相比堆内存可以减少一次copy和gc的次数。下面通过源码去了解堆外内存的分配和回收。一般分配堆外内存通过<code>ByteBuffer allocateDirect(int capacity)</code>方法，其内部是通过如下构造函数来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;               </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);<span class="comment">// mark, pos, lim, cap</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123; <span class="comment">// 修改内存起始地址</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用父类的构造方法初始化ByteBuffer的四个基本属性，接下来reserveMemory方法是判断堆外剩余内存是否满足。这里的剩余并不是系统真是的剩余内存，参数-XX:MaxDirectMemorySize指定JVM最多可用的堆外内存。</p>
<p>如果堆外内存不足，则触发System.gc,这里有些难已理解，明明是堆外内存不足，System.gc的作用是建议VM进行full gc，再怎么说也是堆内存的回收。这里先保留这个疑问，继续往下看。</p>
<p>根据VM参数判断是否内存页对齐计算真实分配内存的大小,由-XX:+PageAlignDirectMemory控制，默认为false。allocateMemory是真正分配内存如果失败则回收内存。setMemory为填充内存。</p>
<p>接下来根据是否内存页对齐来计算内存的起始地址。我们知道HeapByteBuffer是基于byte数组来实现，不需要我们去考虑回收由JVM去处理。但是堆外内存JVM无法想堆内存那样回收，因此就有了Cleaner和Deallocator的存在。</p>
<p>每一个DirectBytebuffer都对应一个Deallocator和Cleaner对象，而Deallocator是Cleaner的一个属性。Deallocator继承了Runnable接口，当然run方法内部是释放内存的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 修改堆外内存的占用大小</span></span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析Cleaner之前我们先复习下PhantomReference(虚引用)</p>
<p>虚引用，正如其名，对一个对象而言，这个引用形同虚设，有和没有一样。如果一个对象与GC Roots之间仅存在虚引用，则称这个对象为虚可达（phantom reachable）对象。<br>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。</p>
<p>Cleaner继承自PhantomReference,在谈谈Java Reference的原理中介绍了Reference框架的大体逻辑，在PendingHandlerThread会把Pending list的引用对象移入Reference Queue,这个过程中如果Reference是Cleaner类型，那么会执行clean方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.thunk.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                        (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>thunk是Deallocator类型，也就是说它run方法最终是由PendingHandlerThread线程执行的。这就是JDK的自动回收堆外内存。</p>
<p>thunk是Deallocator类型，也就是说它run方法最终是由PendingHandlerThread线程执行的。这就是JDK的自动回收堆外内存。</p>
<p>总结一下：DirectByteBuffer对象指向堆外的内存，它保存了一块内存的基本属性和Cleaner和Deallocator对象等。占用的空间相比堆外内存只是冰山一角，当DirectByteBuffer对象被回收，Cleaner对象也就是虚引用被加入到Pending list，PendingHandlerThread线程执行Cleaner的clean方法，最终释放堆外内存。这也就解释了为什么执行gc可以回收堆外内存了。也可以手动释放，首先拿到DirectByteBuffer的Cleaner对象，执行它的clean方法。</p>
<p>由于cleaner是private访问权限，所以自然想到使用反射来实现。<br>DirectByteBuffer实现了DirectBuffer接口，这个接口有cleaner方法可以获取cleaner对象</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/TheLudlows/article/details/101061407">https://blog.csdn.net/TheLudlows/article/details/101061407</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/06/2020/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%20cloud%E6%BA%90%E7%A0%81%E7%AF%87%E4%B9%8BFeign%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/06/2020/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%20cloud%E6%BA%90%E7%A0%81%E7%AF%87%E4%B9%8BFeign%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">深入理解Spring Cloud源码篇之Feign源码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-06 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-06T00:00:00+08:00">2020-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Feign简介"><a href="#Feign简介" class="headerlink" title="Feign简介"></a>Feign简介</h4><p>​       在上一篇文章中分析了<code>Eureka</code>的注册、续约、服务剔除、服务自我保护等机制，地址在<a target="_blank" rel="noopener" href="https://blog.csdn.net/lgq2626/article/details/80288992">https://blog.csdn.net/lgq2626/article/details/80288992</a> 。这篇分析<code>SpringCloud</code>的<code>feign</code>。<code>SpringCloud</code>微服务项目之间调用是通过httprest请求来进行服务调用的，之前我们会用到<code>HttpClient</code>等工具来进行服务请求，<code>Spring</code>对这种请求进行了处理，封装成了可声明式的<code>web</code>客户端，使得编写web客户端更容易，<code>feign</code>还支持可插拔的编码器和解码器，<code>Spring</code>在用的时候增加了对<code>@requestMapping</code>的处理，同时，<code>SpringCloud</code>还对<code>feign</code>集成了注册中心<code>（eureka）</code>和客户端负载均衡<code>（ribbon）</code>，使得我们拥有一个客户端负载均衡的<code>web</code>请求客户端。</p>
<h4 id="Feign在项目中的配置和使用"><a href="#Feign在项目中的配置和使用" class="headerlink" title="Feign在项目中的配置和使用"></a>Feign在项目中的配置和使用</h4><p>​       在Springcloud中使用feign的时候，需要在配置类中加入一个@EnableFeignClients注解。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="comment">//springboot 启动类</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span><span class="comment">//开启eureka扫描</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//开启eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>配置feign调用客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;xxx-server&quot;,configuration = FeignConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ConsumerSmsService</span> <span class="keyword">extends</span> <span class="title class_">SMSService</span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/sms/smsMessage&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    RespSMSDto <span class="title function_">sendSms</span><span class="params">(ReqSMSDto smsReqDto)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>经过上面的配置，直接在项目里面注入容器调用接口就可以了。</p>
<h4 id="Feign源码分析"><a href="#Feign源码分析" class="headerlink" title="Feign源码分析"></a>Feign源码分析</h4><p>​       在<code>@EnableFeignClients</code>标签中，<code>import</code>了一个<code>FeignClientsRegistrar</code>类，那么这个<code>FeignClientsRegistrar#registerBeanDefinitions()</code>在什么时候调用的呢？跟着<code>Spring</code>的源码走下去，看过源码的人都会直接看到<code>AbstractApplicationContext#refresh()</code>方法，整体整理一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">				<span class="comment">// 扫描本项目里面的java文件，把bean对象封装成BeanDefinitiaon对象，然后调用DefaultListableBeanFactory#registerBeanDefinition()方法把beanName放到DefaultListableBeanFactory 的 List&lt;String&gt; beanDefinitionNames 中去</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在这里调用到FeignClientsRegistrar对象的registerBeanDefinitions()方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从DefaultListableBeanFactory里面的beanDefinitionNames中找到所有实现了BeanPostProcessor接口的方法，如果有排序进行排序后放到list中</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Spring的国际化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Spring的IOC、ID处理。Spring的AOP。事务都是在IOC完成之后调用了BeanPostProcessor#postProcessBeforeInitialization()和postProcessBeforeInitialization()方法，AOP(事务)就是在这里处理的</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行完之后调用实现了所有LifecycleProcessor接口的类的onRefresh()方法，同时调用所有观察了ApplicationEvent接口的事件(观察者模式)</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到所有实现了DisposableBean接口的方法，调用了destroy()方法，这就是bean的销毁</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		根据上面整理的代码发现，<code>FeignClientsRegistrar#registerBeanDefinitions()</code>方法是在扫描完<code>bean</code>之后，只放了一个<code>beanname</code>的情况下， 并没有进行<code>IOC</code>注册的时候调用的，这就是<code>Spring</code>动态扩展<code>Bean</code>，实现<code>BeanDefinitionRegistryPostProcessor</code>接口的所有方法也会在这里调用下<code>postProcessBeanDefinitionRegistry()</code>方法。关于<code>Spring</code>的东西就分析到这里。下面回到正题，分析<code>FeignClientsRegistrar#registerBeanDefinitions()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">        BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    registerDefaultConfiguration(metadata, registry);<span class="comment">//扫描EnableFeignClients标签里配置的信息，注册到beanDefinitionNames中。</span></span><br><span class="line">    registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationTypeFilter</span> <span class="variable">annotationTypeFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(FeignClient.class);</span><br><span class="line">        <span class="comment">//省略代码...根据EnableFeignClients配置的basePackages找到包下所有FeignClient注解的类，Spring的Commponet也是这么干的</span></span><br><span class="line">		<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">				Set&lt;BeanDefinition&gt; candidateComponents = scanner.findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">                    <span class="type">AnnotatedBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                    <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> beanDefinition.getMetadata();</span><br><span class="line">                    Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                            <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line"> 										Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                        .getAnnotationAttributes(</span><br><span class="line">                                FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getClientName(attributes);</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 关键地方：Feign子容器概念：</span></span><br><span class="line"><span class="comment">                 * 在注入FeignAutoConfiguration类的时候，注入了一个FeignContext对象，这个就是Feign的子容器。</span></span><br><span class="line"><span class="comment">                 * 这里面装了List&lt;FeignClientSpecification&gt;对象，FeignClientSpecification对象的实质就是在<span class="doctag">@feignClient</span>上配置的name为key，value为configuration对象的值</span></span><br><span class="line"><span class="comment">                 * 比如feignclient 这样配置的<span class="doctag">@FeignClient</span>(url=&quot;https://api.weixin.qq.com&quot;,name=&quot;$&#123;usercenter.name&#125;&quot;, configuration = UserCenterFeignConfiguration.class, primary= false)</span></span><br><span class="line"><span class="comment">                 * 那么在FeignContext中就会出现一个FeignClientSpecification&#123;name=&#x27;sms-server&#x27;, configuration=[class com.jfbank.sms.configuration.FeignConfiguration]&#125;这样的数据。</span></span><br><span class="line"><span class="comment">                 *  这个地方比较关键，主要是因为后期对feign客户端的编码解码会用到自定义的类</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//这个方法就是在ioc容器中塞入一个FeignClientSpecification对象，从而构建FeignContext子容器。</span></span><br><span class="line">                registerClientConfiguration(registry, name,</span><br><span class="line">                        attributes.get(<span class="string">&quot;configuration&quot;</span>));       </span><br><span class="line">                <span class="comment">//重点分析这个</span></span><br><span class="line">                registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry, AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> annotationMetadata.getClassName();</span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">definition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean.class);<span class="comment">//对FeignClientFactoryBean对象生成一个BeanDefinition对象</span></span><br><span class="line">    ...读取配置</span><br><span class="line">    <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> name + <span class="string">&quot;FeignClient&quot;</span>;</span><br><span class="line">    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">primary</span> <span class="operator">=</span> (Boolean)attributes.get(<span class="string">&quot;primary&quot;</span>); <span class="comment">// has a default, won&#x27;t be null</span></span><br><span class="line"></span><br><span class="line">    beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">qualifier</span> <span class="operator">=</span> getQualifier(attributes);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">        alias = qualifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, className,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; alias &#125;);</span><br><span class="line">    <span class="comment">//注册到beanDefinitionNames中对象</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		读过Dubbo源码的同学都知道，当在<code>DubboNamespaceHandler</code>中解析<code>reference</code>标签的时候，传入了一个<code>ReferenceBean</code>对象，把<code>xml</code>中配置的属性都塞到这个对象上，也是装到了<code>beanDefinitionNames</code>中，然后发现<code>ReferenceBean</code>类和<code>FeignClientFactoryBean</code>都实现了<code>FactoryBean</code>的接口，并且里面都有<code>getObject()</code>和<code>getObjectType()</code>方法。当接口调用到这个<code>feign</code>客户端的时候，会从<code>IOC</code>中读取这个<code>FeignClientFactoryBean</code>并且调用<code>getObject</code>方法。下面就是分析<code>getObject</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FeignContext</span> <span class="variable">context</span> <span class="operator">=</span> applicationContext.getBean(FeignContext.class);</span><br><span class="line">        <span class="comment">//从上文中的子容器中获取编码器，解码器等自定义类，然后封装一个Feign.Builder类</span></span><br><span class="line">        Feign.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> feign(context);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(<span class="built_in">this</span>.url)) &#123;<span class="comment">//当@FeignClient没有配置url的时候</span></span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">            url = <span class="string">&quot;http://&quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            url = <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">        url += cleanPath();</span><br><span class="line">        <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(<span class="built_in">this</span>.type,</span><br><span class="line">                <span class="built_in">this</span>.name, url));<span class="comment">//集成了ribbon客户端负载均衡,下一篇分析</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当@FeignClient配置了url的时候</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.url) &amp;&amp; !<span class="built_in">this</span>.url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = <span class="string">&quot;http://&quot;</span> + <span class="built_in">this</span>.url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="built_in">this</span>.url + cleanPath();</span><br><span class="line">    <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> getOptional(context, Client.class);</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">            <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">            <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">            client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">        &#125;</span><br><span class="line">        builder.client(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Targeter</span> <span class="variable">targeter</span> <span class="operator">=</span> get(context, Targeter.class);</span><br><span class="line">    <span class="keyword">return</span> targeter.target(<span class="built_in">this</span>, builder, context, <span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(<span class="built_in">this</span>.type, <span class="built_in">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看配置了<code>url</code>的，指定了<code>url</code>的<code>feignclient</code>解析，一直跟着代码跟到了<code>Feign.Builder#target()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">target</span><span class="params">(Target&lt;T&gt; target)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> Feign <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">  SynchronousMethodHandler.<span class="type">Factory</span> <span class="variable">synchronousMethodHandlerFactory</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SynchronousMethodHandler</span>.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                           logLevel, decode404);</span><br><span class="line">  <span class="type">ParseHandlersByName</span> <span class="variable">handlersByName</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ParseHandlersByName</span>(contract, options, encoder, decoder,</span><br><span class="line">                              errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReflectiveFeign</span>(handlersByName, invocationHandlerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接看<code>ReflectiveFeign#newInstance()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReflectiveFeign#newInstance()</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> &#123;</span><br><span class="line">	<span class="comment">//动态代理的handler类目前穿进来的是ParseHandlersByName类，所以这里要看ParseHandlersByName#apply()直接看下一个方法</span></span><br><span class="line">	Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">	Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Method, MethodHandler&gt;();</span><br><span class="line">	List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;DefaultMethodHandler&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;<span class="comment">//默认方法会走到这里，比如toString()，hashCode()等方法</span></span><br><span class="line">      <span class="type">DefaultMethodHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMethodHandler</span>(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//这里才是装配的调用类，上文分析到计息的handler是SynchronousMethodHandler#invoke()</span></span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> factory.create(target, methodToHandler);</span><br><span class="line">  <span class="type">T</span> <span class="variable">proxy</span> <span class="operator">=</span> (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;target.type()&#125;, handler);<span class="comment">//jdk动态代理</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ParseHandlersByName#apply类，构建动态代理的handler</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title function_">apply</span><span class="params">(Target key)</span> &#123;</span><br><span class="line">    List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">    Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, MethodHandler&gt;();</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">      BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">      <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="literal">null</span>) &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> <span class="title class_">BuildFormEncodedTemplateFromArgs</span>(md, encoder);<span class="comment">//通过自定义的encoder去解析参数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="literal">null</span>) &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> <span class="title class_">BuildEncodedTemplateFromArgs</span>(md, encoder);<span class="comment">//通过自定义的encoder去解析参数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> <span class="title class_">BuildTemplateByResolvingArgs</span>(md);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建handler，再看Factory#create()方法，下一个方法</span></span><br><span class="line">      result.put(md.configKey(),factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//Factory#create(),构建一个SynchronousMethodHandler去处理请求，调用invoke方法</span></span><br><span class="line"><span class="keyword">public</span> MethodHandler <span class="title function_">create</span><span class="params">(Target&lt;?&gt; target, MethodMetadata md,</span></span><br><span class="line"><span class="params">        RequestTemplate.Factory buildTemplateFromArgs,</span></span><br><span class="line"><span class="params">        Options options, Decoder decoder, ErrorDecoder errorDecoder)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SynchronousMethodHandler</span>(target, client, retryer, requestInterceptors, logger,</span><br><span class="line">                  logLevel, md, buildTemplateFromArgs, options, decoder,</span><br><span class="line">                  errorDecoder, decode404);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SynchronousMethodHandler#invoke()方法：实际调用的方法</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);<span class="comment">//构建requestTemplate对象</span></span><br><span class="line">    <span class="type">Retryer</span> <span class="variable">retryer</span> <span class="operator">=</span> <span class="built_in">this</span>.retryer.clone();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> executeAndDecode(template);<span class="comment">//下面不分析了，就是执行execute方法并且解码饭后返回值</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">        retryer.continueOrPropagate(e);</span><br><span class="line">        <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">          logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Feign源码总结"><a href="#Feign源码总结" class="headerlink" title="Feign源码总结"></a>Feign源码总结</h4><p> 从读取注解到注入IOC容器，再到编码参数，发起请求，解码结果，整个封装过程都对我们开发带来了极大得便利，此文只是分析了feign带有url参数得解析方式，集成eureka和ribbon的在<a target="_blank" rel="noopener" href="https://blog.csdn.net/lgq2626/article/details/80481514%E4%B8%AD%E5%81%9A%E4%BA%86%E5%88%86%E6%9E%90%E3%80%82%E4%B8%8B%E9%9D%A2%E6%B5%81%E7%A8%8B%E5%9B%BE%E6%80%BB%E7%BB%93%E4%B8%8B%E6%B5%81%E7%A8%8B%EF%BC%9A">https://blog.csdn.net/lgq2626/article/details/80481514中做了分析。下面流程图总结下流程：</a><br><img src="http://static.cyblogs.com/20180525131939613.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180525131939613.png"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lgq2626/article/details/80392914">https://blog.csdn.net/lgq2626/article/details/80392914</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/05/2020/03/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/05/2020/03/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">深入分析CMS垃圾收集器原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-05T00:00:00+08:00">2020-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前文已经讲过，<code>CMS</code>是老年代垃圾收集器，在收集过程中可以与用户线程并发操作。它可以与<code>Serial</code>收集器和<code>Parallel New</code>收集器搭配使用。<code>CMS</code>牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。</p>
<h4 id="CMS相关参数"><a href="#CMS相关参数" class="headerlink" title="CMS相关参数"></a>CMS相关参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>默认值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>boolean</td>
<td>false</td>
<td>老年代采用CMS收集器收集</td>
</tr>
<tr>
<td>–XX:ParallelGCThreads&#x3D;n</td>
<td>int</td>
<td>(ncpus &lt;&#x3D; 8) ? ncpus : 3 + ((ncpus * 5) &#x2F; 8)</td>
<td>老年代采用CMS收集器收集</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>int</td>
<td>92</td>
<td>年代堆空间的使用率。比如value&#x3D;75意味着第一次CMS垃圾收集会在老年代被占用75%时被触发。</td>
</tr>
<tr>
<td>-XX：+UseCMSInitiatingOccupancyOnly</td>
<td>boolean</td>
<td>false</td>
<td>只用设定的回收阈值(上面指定的70%),如果不指定,JVM仅在第一次使用设定值,后续则自动调整</td>
</tr>
</tbody></table>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><h5 id="周期性GC"><a href="#周期性GC" class="headerlink" title="周期性GC"></a>周期性GC</h5><p>由后台线程<code>ConcurrentMarkSweepThread</code>循环判断（默认2s）是否需要触发。</p>
<p>如果没有设置<code>-XX:+UseCMSInitiatingOccupancyOnly</code>，虚拟机会根据收集的数据决定是否触发<br>老年代使用率达到阈值 <code>CMSInitiatingOccupancyFraction</code>，默认92%。<br>永久代的使用率达到阈值 <code>CMSInitiatingPermOccupancyFraction</code>，默认92%，前提是开启 <code>CMSClassUnloadingEnabled</code>。<br>新生代的晋升担保失败。</p>
<h5 id="主动触发"><a href="#主动触发" class="headerlink" title="主动触发"></a>主动触发</h5><p><code>YGC</code>过程发生<code>Promotion Failed</code>，进而对老年代进行回收<br>比如执行了<code>System.gc()</code>，前提是没有参数<code>ExplicitGCInvokesConcurrent</code></p>
<h4 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h4><h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><p>这是<code>CMS</code>中两次<code>stop-the-world</code>事件中的一次。这一步的作用是标记存活的对象，有两部分：</p>
<p>标记老年代中所有的<code>GC Roots</code>对象<br>标记年轻代中活着的对象引用到的老年代的对象</p>
<p><code>CMS-initial-mark：961330K（1572864K）</code>指标记时老年代的已用空间和总空间</p>
<h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><p>该阶段<code>GC</code>线程和应用线程并发执行，遍历<code>InitialMarking</code>阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: 2.787/3.329 secs] [Times: user=12.12 sys=0.64, real=3.33 secs]</span><br></pre></td></tr></table></figure>

<p>第一行<code>CMS-concurrent-mark-start</code>标识标记阶段开始。第二行中的“2.787&#x2F;3.329 secs”表示标记阶段的耗时。<br>表示花费了2.787cpu时间，3.329系统时间。</p>
<h5 id="预清理阶段"><a href="#预清理阶段" class="headerlink" title="预清理阶段"></a>预清理阶段</h5><p>由于在并发标记阶段，应用线程和<code>GC</code>线程是并发执行的，因此可能产生新的对象或对象关系发生变化，例如：</p>
<p>新生代的对象晋升到老年代；<br>直接在老年代分配对象；<br>老年代对象的引用关系发生变更；</p>
<p><img src="http://static.cyblogs.com/20190702174034511.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20190702174034511.png"></p>
<p>该阶段会把上述对象所在的<code>Card</code>标识为<code>Dirty</code>，后续只需扫描这些<code>Dirty Card</code>的对象，避免扫描整个老年代。<br>标记<code>dirty card</code> 能够到达的对象</p>
<p><img src="http://static.cyblogs.com/20190702180248905.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20190702180248905.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: 0.342/0.477 secs] [Times: user=1.79 sys=0.10, real=0.48 secs]</span><br></pre></td></tr></table></figure>

<h5 id="可终止的预处理"><a href="#可终止的预处理" class="headerlink" title="可终止的预处理"></a>可终止的预处理</h5><p>该阶段发生的前提是，新生代<code>Eden</code>区的内存使用量大于参数<code>CMSScheduleRemarkEdenSizeThreshold</code> 默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段。<br>在该阶段，主要循环的做两件事：</p>
<p>处理 <code>From</code> 和 <code>To</code> 区的对象，标记可达的老年代对象<br>和上一个阶段一样，扫描处理<code>Dirty Card</code>中的对象</p>
<h5 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h5><p>暂停所有用户线程，重新扫描堆中的对象，进行可达性分析,标记活着的对象。有了前面的基础，这个阶段的工作量被大大减轻，停顿时间因此也会减少。注意这个阶段是多线程的。</p>
<p>遍历新生代对象，重新标记<br>根据<code>GC Roots</code>，重新标记<br>遍历老年代的<code>Dirty Card</code>，重新标记，这里的<code>Dirty Card</code>大部分已经在<code>clean</code>阶段处理过</p>
<h5 id="并发清理"><a href="#并发清理" class="headerlink" title="并发清理"></a>并发清理</h5><p>通过以上5个阶段的标记，老年代所有存活的对象已经被标记并且现在要通过<code>Garbage Collector</code>采用清扫的方式回收那些不能用的对象了。<br>这个阶段主要是清除那些没有标记的对象并且回收空间；<br>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><h5 id="减少remark阶段停顿"><a href="#减少remark阶段停顿" class="headerlink" title="减少remark阶段停顿"></a>减少remark阶段停顿</h5></li>
</ol>
<p>  一般<code>CMS</code>的<code>GC</code>耗时80%都在remark阶段，如果发现<code>remark</code>阶段停顿时间很长，可以尝试添加该参数：<br>  <code>-XX:+CMSScavengeBeforeRemark</code>。在执行<code>remark</code>操作之前先做一次<code>Young GC</code>，目的在于减少年轻代对老年代的无效引用，降低<code>remark</code>时的开销。</p>
<ol start="2">
<li><h5 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h5></li>
</ol>
<p>  <code>CMS</code>是基于标记-清除算法的，<code>CMS</code>只会删除无用对象，不会对内存做压缩，会造成内存碎片，这时候我们需要用到这个参数：<code>-XX:CMSFullGCsBeforeCompaction=n</code><br>  意思是说在上一次<code>CMS</code>并发<code>GC</code>执行过后，到底还要再执行多少次<code>full GC</code>才会做压缩。默认是0</p>
<ol start="3">
<li><h5 id="Concurrent-mode-failure"><a href="#Concurrent-mode-failure" class="headerlink" title="Concurrent mode failure"></a>Concurrent mode failure</h5></li>
</ol>
<p>  这个异常发生在cms正在回收的时候。执行<code>CMS GC</code>的过程中，同时业务线程也在运行，当年轻带空间满了，执行<code>YGC</code>时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时<code>CMS</code>还没有机会回收老年带产生的，或者在做<code>Minor GC</code>的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。</p>
<ul>
<li><p>过早提升与提升失败<br>在 <code>Minor GC</code> 过程中，<code>Survivor Unused</code> 可能不足以容纳 <code>Eden</code> 和另一个 <code>Survivor</code> 中的存活对象， 那么多余的将被移到老年代， 称为过早提升（<code>Premature Promotion</code>）,这会导致老年代中短期存活对象的增长， 可能会引发严重的性能问题。 再进一步，如果老年代满了， <code>Minor GC</code> 后会进行 <code>Full GC</code>， 这将导致遍历整个堆， 称为提升失败（<code>Promotion Failure</code>）。</p>
</li>
<li><p>早提升的原因<br><code>Survivor</code>空间太小，容纳不下全部的运行时短生命周期的对象，如果是这个原因，可以尝试将<code>Survivor</code>调大，否则端生命周期的对象提升过快，导致老年代很快就被占满，从而引起频繁的<code>full gc</code>；<br>对象太大，<code>Survivor</code>和<code>Eden</code>没有足够大的空间来存放这些大对象。</p>
</li>
<li><p>提升失败原因<br>当提升的时候，发现老年代也没有足够的连续空间来容纳该对象。为什么是没有足够的连续空间而不是空闲空间呢？老年代容纳不下提升的对象有两种情况：</p>
<ul>
<li>老年代空闲空间不够用了；</li>
<li>老年代虽然空闲空间很多，但是碎片太多，没有连续的空闲空间存放该对象。</li>
</ul>
</li>
<li><p>解决方法<br>如果是因为内存碎片导致的大对象提升失败，cms需要进行空间整理压缩；<br>如果是因为提升过快导致的，说明Survivor 空闲空间不足，那么可以尝试调大 Survivor；<br>如果是因为老年代空间不够导致的，尝试将CMS触发的阈值调低。</p>
</li>
</ul>
<p>REF：<a target="_blank" rel="noopener" href="https://juejin.im/post/5c39920b6fb9a049e82bbf94">https://juejin.im/post/5c39920b6fb9a049e82bbf94</a></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/TheLudlows/article/details/93140810">https://blog.csdn.net/TheLudlows/article/details/93140810</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/04/2020/03/%E4%BD%A0%E6%B8%85%E6%A5%9A%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%9A%84%E8%B0%83%E6%95%B4%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4corePoolSize%E4%B8%8EmaximumPoolSize%E5%90%97%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/04/2020/03/%E4%BD%A0%E6%B8%85%E6%A5%9A%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%9A%84%E8%B0%83%E6%95%B4%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4corePoolSize%E4%B8%8EmaximumPoolSize%E5%90%97%EF%BC%9F/" class="post-title-link" itemprop="url">你清楚如何动态的调整动态调整corePoolSize与maximumPoolSize吗？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-04 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-04T00:00:00+08:00">2020-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>线程池<code>ThreadPoolExecutor</code>在运行的过程中，业务并发量变动，需要不停服务调整线程池的线程数，<code>ThreadPoolExecutor</code>支持动态调整<code>corePoolSize</code>与<code>maximumPoolSize</code>的值。</p>
<h5 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadChangeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">10l</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                        Thread.sleep(1l);</span></span><br><span class="line"><span class="comment">                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">                    &#125;*/</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;------------core:\t&quot;</span> + executor.getCorePoolSize() + <span class="string">&quot;\tactive:\t&quot;</span> + executor.getActiveCount() + <span class="string">&quot;\tmax:\t&quot;</span> + executor.getMaximumPoolSize());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">20</span>) &#123;</span><br><span class="line">                executor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">                executor.setMaximumPoolSize(<span class="number">9</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">100</span>) &#123;</span><br><span class="line">                executor.shutdown();</span><br><span class="line">                System.out.println(<span class="string">&quot;=============================================&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序运行中动态修改线程池<code>corePoolSize</code>与<code>maximumPoolSize</code>的值</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="线程池参数调大"><a href="#线程池参数调大" class="headerlink" title="线程池参数调大"></a>线程池参数调大</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCorePoolSize</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> corePoolSize - <span class="built_in">this</span>.corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="comment">//核心线程调小，中断空闲任务，否则线程池的当前任务结束，自动调小</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="comment">//核心线程数调大后，从队列取任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t really know how many new threads are &quot;needed&quot;.</span></span><br><span class="line">        <span class="comment">// As a heuristic, prestart enough new workers (up to new</span></span><br><span class="line">        <span class="comment">// core size) to handle the current number of tasks in</span></span><br><span class="line">        <span class="comment">// queue, but stop if queue becomes empty while doing so.</span></span><br><span class="line">        <span class="comment">//队列大小是否可以取任务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Math.min(delta, workQueue.size());</span><br><span class="line">        <span class="comment">//队列有任务就取，否则break</span></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="literal">null</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaximumPoolSize</span><span class="params">(<span class="type">int</span> maximumPoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="comment">//中断空闲任务，否则线程池的当前任务结束，自动调小</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码看出：线程池的调节时直接设置<code>corePoolSize</code>与<code>maximumPoolSize</code>的值</p>
<p>其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workerCountOf(ctl.get())</span><br></pre></td></tr></table></figure>


<p>代表工作任务线程数，参考我的博客JDK8线程池-ThreadPoolExecutor源码解析</p>
<p>调大<code>corePoolSize</code>与<code>maximumPoolSize</code>，线程池运行过程中自动生效，线程池处理逻辑增强。</p>
<h5 id="线程池调小"><a href="#线程池调小" class="headerlink" title="线程池调小"></a>线程池调小</h5><p>调小<code>corePoolSize</code>与<code>maximumPoolSize</code>均会执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interruptIdleWorkers();</span><br></pre></td></tr></table></figure>

<h6 id="跟踪interruptIdleWorkers源码"><a href="#跟踪interruptIdleWorkers源码" class="headerlink" title="跟踪interruptIdleWorkers源码"></a>跟踪interruptIdleWorkers源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">()</span> &#123;</span><br><span class="line">    interruptIdleWorkers(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">interruptIdleWorkers</span><span class="params">(<span class="type">boolean</span> onlyOne)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//workers是所有已存在的线程，包括空闲线程</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="comment">//这里注意，非常关键，加锁w.tryLock()</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从上面的参数onlyOne is false</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>workers</code>注意：是一个<code>HashSet</code>，存放规则：</p>
<p>核心线程优先占满，即使核心线程有空闲，新任务来了会优先开启新的线程而不是复用，核心线程仅在占满才会复用，然后使用队列，最后使用<code>max</code>线程，<code>max</code>线程数对应的<code>workers</code>会动态变化，</p>
<p>参考我的博客<code>JDK8</code>线程池-<code>ThreadPoolExecutor</code>源码解析</p>
<h6 id="线程池任务执行源码"><a href="#线程池任务执行源码" class="headerlink" title="线程池任务执行源码"></a>线程池任务执行源码</h6><p>我们看<code>ThreadPoolExecutor</code>执行任务的源码，参考我的博客<code>JDK8</code>线程池-<code>ThreadPoolExecutor</code>源码解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里注意，加锁了，非常关键</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//任务执行</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出在任务拿出来后，立即加锁</p>
<p>包括任务执行的过程都是加锁的。</p>
<h6 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    runWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br></pre></td></tr></table></figure>
<p>使用了AQS，自定义了加锁方式CAS模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> </span><br><span class="line">			<span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> </span><br><span class="line">			<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看出使用<code>tryAcquire</code>和<code>tryRelease</code>，均重写方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compareAndSetState(0, 1)</code></p>
<p>使用上面的代码加锁，意味着线程执行过程中都是加锁的，不会被销毁，只会销毁空闲线程，或者当前线程执行结束销毁。</p>
<p>线程池调小<code>corePoolSize</code>与<code>maximumPoolSize</code>对当前正在执行的任务没有影响。</p>
<h5 id="调节队列大小"><a href="#调节队列大小" class="headerlink" title="调节队列大小"></a>调节队列大小</h5><p>队列是不可以动态调整的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>线程池<code>corePoolSize</code>与<code>maximumPoolSize</code>调大注意<code>max</code>线程数不要调过大，计算机资源是有限的。</p>
</li>
<li><p>线程池的队列初始化大小注意，不能动态调节，队列占用的是堆内存，注意JVM的内存大小与GC能力，尽量减小大对象的存在。</p>
</li>
<li><p>线程池<code>corePoolSize</code>与<code>maximumPoolSize</code>和队列调小注意，线程池的处理能力减弱，可能会执行拒绝策略。</p>
</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fenglllle/article/details/84473345">https://blog.csdn.net/fenglllle/article/details/84473345</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/03/2020/03/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%AD%E6%98%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%9B%AA%E8%8A%B1%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/03/2020/03/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%AD%E6%98%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%9B%AA%E8%8A%B1%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">理解数据仓库中星型模型和雪花模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-03 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-03T00:00:00+08:00">2020-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在数据仓库的建设中，一般都会围绕着星型模型和雪花模型来设计表关系或者结构。下面我们先来理解这两种模型的概念。</p>
<h4 id="星型模型"><a href="#星型模型" class="headerlink" title="星型模型"></a>星型模型</h4><p><img src="http://static.cyblogs.com/1345516634_6388.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;1345516634_6388.jpg"></p>
<p>​		星型模是一种多维的数据关系，它由一个事实表和一组维表组成。每个维表都有一个维作为主键，所有这些维的主键组合成事实表的主键。强调的是对维度进行预处理，将多个维度集合到一个事实表，形成一个宽表。这也是我们在使用hive时，经常会看到一些大宽表的原因，大宽表一般都是事实表，包含了维度关联的主键和一些度量信息，而维度表则是事实表里面维度的具体信息，使用时候一般通过join来组合数据，相对来说对OLAP的分析比较方便。</p>
<h4 id="雪花模型"><a href="#雪花模型" class="headerlink" title="雪花模型"></a>雪花模型</h4><p><img src="http://static.cyblogs.com/1345516734_4305.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;1345516734_4305.jpg"></p>
<p>​		当有一个或多个维表没有直接连接到事实表上，而是通过其他维表连接到事实表上时，其图解就像多个雪花连接在一起，故称雪花模型。雪花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的 “层次 “ 区域，这些被分解的表都连接到主维度表而不是事实表。雪花模型更加符合数据库范式，减少数据冗余，但是在分析数据的时候，操作比较复杂，需要join的表比较多所以其性能并不一定比星型模型高。</p>
<h4 id="星型模型和雪花模型对比"><a href="#星型模型和雪花模型对比" class="headerlink" title="星型模型和雪花模型对比"></a>星型模型和雪花模型对比</h4><table>
<thead>
<tr>
<th>属性</th>
<th>星型模型</th>
<th>雪花模型</th>
</tr>
</thead>
<tbody><tr>
<td>数据总量</td>
<td>多</td>
<td>少</td>
</tr>
<tr>
<td>可读性</td>
<td>容易</td>
<td>差</td>
</tr>
<tr>
<td>表个数</td>
<td>少</td>
<td>多</td>
</tr>
<tr>
<td>查询速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>冗余度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>对实时表的情况</td>
<td>增加宽度</td>
<td>字段比较少，冗余底</td>
</tr>
<tr>
<td>扩展性</td>
<td>差</td>
<td>好</td>
</tr>
</tbody></table>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>​		星型模型的设计方式主要带来的好处是能够提升查询效率，因为生成的事实表已经经过预处理，主要的数据都在事实表里面，所以只要扫描实时表就能够进行大量的查询，而不必进行大量的join，其次维表数据一般比较少，在join可直接放入内存进行join以提升效率，除此之外，星型模型的事实表可读性比较好，不用关联多个表就能获取大部分核心信息，设计维护相对比较简答。</p>
<p>雪花模型的设计方式是比较符合数据库范式的理念，设计方式比较正规，数据冗余少，但在查询的时候可能需要join多张表从而导致查询效率下降，此外规范化操作在后期维护比较复杂。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​		通过上面的对比，我们可以发现数据仓库大多数时候是比较适合使用星型模型构建底层数据Hive表，通过大量的冗余来提升查询效率，星型模型对OLAP的分析引擎支持比较友好，这一点在Kylin中比较能体现。而雪花模型在关系型数据库中如MySQL，Oracle中非常常见，尤其像电商的数据库表。在数据仓库中雪花模型的应用场景比较少，但也不是没有，所以在具体设计的时候，可以考虑是不是能结合两者的优点参与设计，以此达到设计的最优化目的。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010454030/article/details/74589791">https://blog.csdn.net/u010454030/article/details/74589791</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/02/2020/03/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%AE%80%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/02/2020/03/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%AE%80%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">聚集索引和非聚集索引简析与对比</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-02 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-02T00:00:00+08:00">2020-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="聚集（clustered）索引，也叫聚簇索引"><a href="#聚集（clustered）索引，也叫聚簇索引" class="headerlink" title="聚集（clustered）索引，也叫聚簇索引"></a>聚集（clustered）索引，也叫聚簇索引</h4><p>定义：数据行的<strong>物理顺序</strong>与列值（一般是主键的那一列）的<strong>逻辑顺序</strong>相同，一个表中只能拥有一个聚集索引。</p>
<p><img src="http://static.cyblogs.com/20181225211503670.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20181225211503670.png"></p>
<p>注：第一列的地址表示该行数据在<strong>磁盘中的物理地址</strong>，后面三列才是我们SQL里面用的表里的列，其中id是主键，建立了聚集索引。</p>
<p>结合上面的表格就可以理解这句话了吧：数据行的物理顺序与列值的顺序相同，如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。</p>
<p><img src="http://static.cyblogs.com/20181225211504802.png" alt="聚集索引实际存放的示意图"></p>
<p>从上图可以看出聚集索引的好处了，索引的<strong>叶子节点就是对应的数据节点</strong>（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，后面会详细讲。因此在查询方面，聚集索引的速度往往会更占优势。</p>
<h5 id="创建聚集索引"><a href="#创建聚集索引" class="headerlink" title="创建聚集索引"></a>创建聚集索引</h5><p>如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。</p>
<ul>
<li>创建表的时候指定主键（注意：SQL Sever默认主键为聚集索引，也可以指定为非聚集索引，而MySQL里主键就是聚集索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> t1(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary key</span>,</span><br><span class="line">    name nvarchar(<span class="number">255</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建表后添加聚集索引</li>
</ul>
<p>MySQL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary <span class="title function_">key</span><span class="params">(colum_name)</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，最好还是在创建表的时候添加聚集索引，由于聚集索引的物理顺序上的特殊性，因此如果再在上面创建索引的时候会根据索引列的排序移动全部数据行上面的顺序，会非常地耗费时间以及性能。</p>
<h4 id="非聚集（unclustered）索引"><a href="#非聚集（unclustered）索引" class="headerlink" title="非聚集（unclustered）索引"></a>非聚集（unclustered）索引</h4><p>定义：该索引中索引的 <strong>逻辑顺序与磁盘上行的物理存储顺序不同</strong> ，一个表中可以拥有多个非聚集索引。</p>
<p>其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的<strong>偏旁字典</strong>，他结构顺序与实际存放顺序不一定一致。</p>
<p><img src="http://static.cyblogs.com/2018122521150563.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;2018122521150563.png"></p>
<h5 id="非聚集索引的二次查询问题"><a href="#非聚集索引的二次查询问题" class="headerlink" title="非聚集索引的二次查询问题"></a>非聚集索引的二次查询问题</h5><p>非聚集索引<strong>叶节点</strong>仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行<strong>第二次的查询</strong>，查询节点上对应的数据行的数据。</p>
<p>有表t1：</p>
<p><img src="http://static.cyblogs.com/20181225211503873.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20181225211503873.png"></p>
<p>其中有 聚集索引<code>clustered index(id)</code>，非聚集索引<code>index(username)</code>。</p>
<p>使用以下语句进行查询，不需要进行二次查询，直接就可以从非聚集索引的节点里面就可以获取到查询列的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, username <span class="keyword">from</span> t1 <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;小明&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> t1 <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;小明&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是使用以下语句进行查询，就需要二次的查询去获取原数据行的score：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> username, score <span class="keyword">from</span> t1 <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;小明&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在<code>SQL Server</code>里面查询效率如下所示，<code>Index Seek</code>就是索引所花费的时间，<code>Key Lookup</code>就是二次查询所花费的时间。可以看的出二次查询所花费的查询开销占比很大，达到50%。</p>
<p>这篇博客有一个简单示例：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jiadajing267/article/details/54581262">https://blog.csdn.net/jiadajing267/article/details/54581262</a></p>
<p><strong>总结如下：</strong></p>
<table>
<thead>
<tr>
<th>动作描述</th>
<th>使用聚集索引</th>
<th>使用非聚集索引</th>
</tr>
</thead>
<tbody><tr>
<td>列经常被分组排序</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>返回某范围内的数据</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>一个或极少不同值</td>
<td>不应</td>
<td>不应</td>
</tr>
<tr>
<td>小数目的不同值</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>大数目的不同值</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>频繁更新的列</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>外键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>主键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>频繁修改索引列</td>
<td>不应</td>
<td>应</td>
</tr>
</tbody></table>
<h4 id="我们需要搞清楚以下几个问题"><a href="#我们需要搞清楚以下几个问题" class="headerlink" title="我们需要搞清楚以下几个问题"></a>我们需要搞清楚以下几个问题</h4><p>第一：聚集索引的约束是唯一性，是否要求字段也是唯一的呢？   <strong>不要求唯一！</strong></p>
<p>分析：如果认为是的朋友，可能是受系统默认设置的影响，一般我们指定一个表的主键，如果这个表之前没有聚集索引，同时建立主键时候没有强制指定使用非聚集索引，SQL会默认在此字段上创建一个聚集索引，而主键都是唯一的，所以理所当然的认为创建聚集索引的字段也需要唯一。</p>
<p>结论：聚集索引可以创建在任何一列你想创建的字段上，这是从理论上讲，实际情况并不能随便指定，否则在性能上会是恶梦。</p>
<p>第二：为什么聚集索引可以创建在任何一列上，如果此表没有主键约束，即有可能存在重复行数据呢？</p>
<p>粗一看，这还真是和聚集索引的约束相背，但实际情况真可以创建聚集索引。</p>
<p>分析其原因是：如果未使用 <code>UNIQUE</code> 属性创建聚集索引，数据库引擎将向表自动添加一个四字节 <code>uniqueifier</code> 列。必要时，数据库引擎 将向行自动添加一个 <code>uniqueifier</code> 值，使每个键唯一。此列和列值供内部使用，用户不能查看或访问。</p>
<p>第三：是不是聚集索引就一定要比非聚集索引性能优呢?</p>
<p>如果想查询学分在60-90之间的学生的学分以及姓名，在学分上创建聚集索引是否是最优的呢？</p>
<p>答：否。既然只输出两列，我们可以在学分以及学生姓名上创建联合非聚集索引，此时的索引就形成了覆盖索引，即索引所存储的内容就是最终输出的数据，这种索引在比以学分为聚集索引做查询性能更好。</p>
<p>第四：在数据库中通过什么描述聚集索引与非聚集索引的？</p>
<p>索引是通过二叉树的形式进行描述的，我们可以这样区分聚集与非聚集索引的区别：聚集索引的叶节点就是<strong>最终的数据节点</strong>，而非聚集索引的叶节仍然是<strong>索引节点</strong>，但它有一个指向最终数据的指针。</p>
<p>第五：在主键是创建聚集索引的表在数据插入上为什么比主键上创建非聚集索引表速度要慢？</p>
<p>　　有了上面第四点的认识，我们分析这个问题就有把握了，在有主键的表中插入数据行，由于有主键唯一性的约束，所以需要保证插入的数据没有重复。我们来比较下主键为聚集索引和非聚集索引的查找情况：聚集索引由于索引叶节点就是数据页，所以如果想检查主键的唯一性，需要遍历所有数据节点才行，但非聚集索引不同，由于非聚集索引上已经包含了主键值，所以查找主键唯一性，只需要遍历所有的索引页就行（索引的存储空间比实际数据要少），这比遍历所有数据行减少了不少IO消耗。这就是为什么主键上创建非聚集索引比主键上创建聚集索引在插入数据时要快的真正原因。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29373285/article/details/85254407">https://blog.csdn.net/qq_29373285/article/details/85254407</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/01/2020/03/%E5%9F%BA%E4%BA%8ECanal%E5%92%8CKafka%E5%AE%9E%E7%8E%B0MySQL%E7%9A%84Binlog%E8%BF%91%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/01/2020/03/%E5%9F%BA%E4%BA%8ECanal%E5%92%8CKafka%E5%AE%9E%E7%8E%B0MySQL%E7%9A%84Binlog%E8%BF%91%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">基于Canal和Kafka实现MySQL的Binlog近实时同步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-01T00:00:00+08:00">2020-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Canal/" itemprop="url" rel="index"><span itemprop="name">Canal</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Canal/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Canal/Kafka/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>近段时间，业务系统架构基本完备，数据层面的建设比较薄弱，因为笔者目前工作重心在于搭建一个小型的数据平台。优先级比较高的一个任务就是需要近实时同步业务系统的数据（包括保存、更新或者软删除）到一个另一个数据源，持久化之前需要清洗数据并且构建一个相对合理的便于后续业务数据统计、标签系统构建等扩展功能的数据模型。基于当前团队的资源和能力，优先调研了<code>Alibaba</code>开源中间件<code>Canal</code>的使用。</p>
<p><img src="http://static.cyblogs.com/m-w-c-1.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;m-w-c-1.png"></p>
<p>这篇文章简单介绍一下如何快速地搭建一套<code>Canal</code>相关的组件。</p>
<h4 id="关于Canal"><a href="#关于Canal" class="headerlink" title="关于Canal"></a>关于Canal</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>下面的简介和下一节的原理均来自于<a target="_blank" rel="noopener" href="https://github.com/alibaba/canal">Canal</a>项目的<code>README</code>：</p>
<p><img src="http://static.cyblogs.com/m-w-c-2.png" alt="img"></p>
<p><code>Canal[kə&#39;næl]</code>，译意为水道&#x2F;管道&#x2F;沟渠，主要用途是基于<code>MySQL</code>数据库增量日志解析，提供增量数据订阅和消费。早期阿里巴巴因为杭州和美国双机房部署，存在跨机房同步的业务需求，实现方式主要是基于业务<code>trigger</code>获取增量变更。从 2010 年开始，业务逐步尝试数据库日志解析获取增量变更进行同步，由此衍生出了大量的数据库增量订阅和消费业务。</p>
<p>基于日志增量订阅和消费的业务包括：</p>
<ul>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>索引构建和实时维护（拆分异构索引、倒排索引等）</li>
<li>业务<code>Cache</code>刷新</li>
<li>带业务逻辑的增量数据处理</li>
</ul>
<h5 id="Canal的工作原理"><a href="#Canal的工作原理" class="headerlink" title="Canal的工作原理"></a>Canal的工作原理</h5><p><code>MySQL</code>主备复制原理：</p>
<p><img src="http://static.cyblogs.com/m-w-c-3.png" alt="img"></p>
<ul>
<li><code>MySQL</code>的<code>Master</code>实例将数据变更写入二进制日志（<code>binary log</code>，其中记录叫做二进制日志事件<code>binary log events</code>，可以通过<code>show binlog events</code>进行查看）</li>
<li><code>MySQL</code>的<code>Slave</code>实例将<code>master</code>的<code>binary log events</code>拷贝到它的中继日志（<code>relay log</code>）</li>
<li><code>MySQL</code>的<code>Slave</code>实例重放<code>relay log</code>中的事件，将数据变更反映它到自身的数据</li>
</ul>
<p><code>Canal</code>的工作原理如下：</p>
<ul>
<li><code>Canal</code>模拟<code>MySQL Slave</code>的交互协议，伪装自己为<code>MySQL Slave</code>，向<code>MySQL Master</code>发送<code>dump</code>协议</li>
<li><code>MySQL Master</code>收到<code>dump</code>请求，开始推送<code>binary log</code>给<code>Slave</code>（即<code>Canal</code>）</li>
<li><code>Canal</code>解析<code>binary log</code>对象（原始为<code>byte</code>流），并且可以通过连接器发送到对应的消息队列等中间件中</li>
</ul>
<h5 id="关于Canal的版本和部件"><a href="#关于Canal的版本和部件" class="headerlink" title="关于Canal的版本和部件"></a>关于Canal的版本和部件</h5><p>截止笔者开始编写本文的时候（<code>2020-03-05</code>），<code>Canal</code>的最新发布版本是<code>v1.1.5-alpha-1</code>（<code>2019-10-09</code>发布的），最新的正式版是<code>v1.1.4</code>（<code>2019-09-02</code>发布的）。其中，<code>v1.1.4</code>主要添加了鉴权、监控的功能，并且做了一些列的性能优化，此版本集成的连接器是<code>Tcp</code>、<code>Kafka</code>和<code>RockerMQ</code>。而<code>v1.1.5-alpha-1</code>版本已经新增了<code>RabbitMQ</code>连接器，但是此版本的<code>RabbitMQ</code>连接器暂时不能定义连接<code>RabbitMQ</code>的端口号，不过此问题已经在<code>master</code>分支中修复（具体可以参看源码中的<code>CanalRabbitMQProducer</code>类的提交记录）。换言之，<code>v1.1.4</code>版本中目前能使用的内置连接器只有<code>Tcp</code>、<code>Kafka</code>和<code>RockerMQ</code>三种，如果想尝鲜使用<code>RabbitMQ</code>连接器，可以选用下面的两种方式之一：</p>
<ul>
<li>选用<code>v1.1.5-alpha-1</code>版本，但是无法修改<code>RabbitMQ</code>的<code>port</code>属性，默认为<code>5672</code>。</li>
<li>基于<code>master</code>分支自行构建<code>Canal</code>。</li>
</ul>
<p>目前，<code>Canal</code>项目的活跃度比较高，但是考虑到功能的稳定性问题，笔者建议选用稳定版本在生产环境中实施，当前可以选用<code>v1.1.4</code>版本，<strong>本文的例子用选用的就是<code>v1.1.4</code>版本，配合<code>Kafka</code>连接器使用</strong>。<code>Canal</code>主要包括三个核心部件：</p>
<ul>
<li><code>canal-admin</code>：后台管理模块，提供面向<code>WebUI</code>的<code>Canal</code>管理能力。</li>
<li><code>canal-adapter</code>：适配器，增加客户端数据落地的适配及启动功能，包括<code>REST</code>、日志适配器、关系型数据库的数据同步（表对表同步）、<code>HBase</code>数据同步、<code>ES</code>数据同步等等。</li>
<li><code>canal-deployer</code>：发布器，核心功能所在，包括<code>binlog</code>解析、转换和发送报文到连接器中等等功能都由此模块提供。</li>
</ul>
<p>一般情况下，<code>canal-deployer</code>部件是必须的，其他两个部件按需选用即可。</p>
<h4 id="部署所需的中间件"><a href="#部署所需的中间件" class="headerlink" title="部署所需的中间件"></a>部署所需的中间件</h4><p>搭建一套可以用的组件需要部署<code>MySQL</code>、<code>Zookeeper</code>、<code>Kafka</code>和<code>Canal</code>四个中间件的实例，下面简单分析一下部署过程。选用的虚拟机系统是<code>CentOS7</code>。</p>
<h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><p>为了简单起见，选用<code>yum</code>源安装（官方链接是<code>https://dev.mysql.com/downloads/repo/yum</code>）：</p>
<p><img src="http://static.cyblogs.com/m-w-c-4.png" alt="img"></p>
<p>mysql80-community-release-el7-3虽然包名带了mysql80关键字，其实已经集成了MySQL主流版本5.6、5.7和8.x等等的最新安装包仓库</p>
<p>选用的是最新版的<code>MySQL8.x</code>社区版，下载<code>CentOS7</code>适用的<code>rpm包</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /data/mysql</span><br><span class="line">wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line">// 下载完毕之后</span><br><span class="line">sudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>此时列举一下<code>yum</code>仓库里面的<code>MySQL</code>相关的包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# yum repolist all | grep mysql</span><br><span class="line">mysql-cluster-7.5-community/x86_64 MySQL Cluster 7.5 Community   disabled</span><br><span class="line">mysql-cluster-7.5-community-source MySQL Cluster 7.5 Community - disabled</span><br><span class="line">mysql-cluster-7.6-community/x86_64 MySQL Cluster 7.6 Community   disabled</span><br><span class="line">mysql-cluster-7.6-community-source MySQL Cluster 7.6 Community - disabled</span><br><span class="line">mysql-cluster-8.0-community/x86_64 MySQL Cluster 8.0 Community   disabled</span><br><span class="line">mysql-cluster-8.0-community-source MySQL Cluster 8.0 Community - disabled</span><br><span class="line">mysql-connectors-community/x86_64  MySQL Connectors Community    enabled:    141</span><br><span class="line">mysql-connectors-community-source  MySQL Connectors Community -  disabled</span><br><span class="line">mysql-tools-community/x86_64       MySQL Tools Community         enabled:    105</span><br><span class="line">mysql-tools-community-source       MySQL Tools Community - Sourc disabled</span><br><span class="line">mysql-tools-preview/x86_64         MySQL Tools Preview           disabled</span><br><span class="line">mysql-tools-preview-source         MySQL Tools Preview - Source  disabled</span><br><span class="line">mysql55-community/x86_64           MySQL 5.5 Community Server    disabled</span><br><span class="line">mysql55-community-source           MySQL 5.5 Community Server -  disabled</span><br><span class="line">mysql56-community/x86_64           MySQL 5.6 Community Server    disabled</span><br><span class="line">mysql56-community-source           MySQL 5.6 Community Server -  disabled</span><br><span class="line">mysql57-community/x86_64           MySQL 5.7 Community Server    disabled</span><br><span class="line">mysql57-community-source           MySQL 5.7 Community Server -  disabled</span><br><span class="line">mysql80-community/x86_64           MySQL 8.0 Community Server    enabled:    161</span><br><span class="line">mysql80-community-source           MySQL 8.0 Community Server -  disabled</span><br></pre></td></tr></table></figure>

<p>编辑<code>/etc/yum.repos.d/mysql-community.repo</code>文件（<code>[mysql80-community]</code>块中<code>enabled设置为1</code>，其实默认就是这样子，不用改，如果要选用<code>5.x</code>版本则需要修改对应的块）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysql80-community]</span><br><span class="line">name=MySQL 8.0 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/7/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure>

<p>然后安装<code>MySQL</code>服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure>

<p>这个过程比较漫长，因为需要下载和安装5个<code>rpm</code>安装包（或者是所有安装包组合的压缩包<code>mysql-8.0.18-1.el7.x86_64.rpm-bundle.tar</code>）。如果网络比较差，也可以直接从官网手动下载后安装：</p>
<p><img src="http://static.cyblogs.com/m-w-c-5.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 下载下面5个rpm包 common --&gt; libs --&gt; libs-compat --&gt; client --&gt; server</span><br><span class="line">mysql-community-common</span><br><span class="line">mysql-community-libs</span><br><span class="line">mysql-community-libs-compat</span><br><span class="line">mysql-community-client</span><br><span class="line">mysql-community-server</span><br><span class="line"></span><br><span class="line">// 强制安装</span><br><span class="line">rpm -ivh mysql-community-common-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line">rpm -ivh mysql-community-libs-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line">rpm -ivh mysql-community-libs-compat-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line">rpm -ivh mysql-community-client-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line">rpm -ivh mysql-community-server-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br></pre></td></tr></table></figure>

<p>安装完毕之后，启动<code>MySQL</code>服务，然后搜索<code>MySQL</code>服务的<code>root</code>账号的临时密码用于首次登陆（<code>mysql -u root -p</code>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 启动服务，关闭服务就是service mysqld stop</span><br><span class="line">service mysqld start</span><br><span class="line">// 查看临时密码 cat /var/log/mysqld.log</span><br><span class="line">[root@localhost log]# cat /var/log/mysqld.log </span><br><span class="line">2020-03-02T06:03:53.996423Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.18) initializing of server in progress as process 22780</span><br><span class="line">2020-03-02T06:03:57.321447Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: &gt;kjYaXENK6li</span><br><span class="line">2020-03-02T06:04:00.123845Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.18) starting as process 22834</span><br><span class="line">// 登录临时root用户，使用临时密码</span><br><span class="line">[root@localhost log]# mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>接下来做下面的操作：</p>
<ul>
<li>修改<code>root</code>用户的密码：<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;QWqw12!@&#39;;</code>（注意密码规则必须包含大小写字母、数字和特殊字符）</li>
<li>更新<code>root</code>的<code>host</code>，切换数据库<code>use mysql;</code>，指定<code>host</code>为<code>%</code>以便可以让其他服务器远程访问<code>UPDATE USER SET HOST = &#39;%&#39; WHERE USER = &#39;root&#39;;</code></li>
<li>赋予<code>&#39;root&#39;@&#39;%&#39;</code>用户，所有权限，执行<code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;;</code></li>
<li>改变<code>root&#39;@&#39;%</code>用户的密码校验规则以便可以使用<code>Navicat</code>等工具访问：<code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;QWqw12!@&#39;;</code></li>
</ul>
<p><img src="http://static.cyblogs.com/m-w-c-6.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;m-w-c-6.png"></p>
<p>操作完成之后，就可以使用<code>root</code>用户远程访问此虚拟机上的<code>MySQL</code>服务。最后确认是否开启了<code>binlog</code>（注意一点是<code>MySQL8.x</code>默认开启<code>binlog</code>）<code>SHOW VARIABLES LIKE &#39;%bin%&#39;;</code>：</p>
<p><img src="http://static.cyblogs.com/m-w-c-7.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;m-w-c-7.png"></p>
<p>最后在<code>MySQL</code>的<code>Shell</code>执行下面的命令，新建一个用户名<code>canal</code>密码为<code>QWqw12!@</code>的新用户，赋予<code>REPLICATION SLAVE</code>和 <code>REPLICATION CLIENT</code>权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER canal IDENTIFIED BY &#x27;QWqw12!@&#x27;;</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">ALTER USER &#x27;canal&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;QWqw12!@&#x27;;</span><br></pre></td></tr></table></figure>

<p>切换回去<code>root</code>用户，创建一个数据库<code>test</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `test` CHARSET `utf8mb4` COLLATE `utf8mb4_unicode_ci`;</span><br></pre></td></tr></table></figure>

<h5 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h5><p><code>Canal</code>和<code>Kafka</code>集群都依赖于<code>Zookeeper</code>做服务协调，为了方便管理，一般会独立部署<code>Zookeeper</code>服务或者<code>Zookeeper</code>集群。笔者这里选用<code>2020-03-04</code>发布的<code>3.6.0</code>版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">midkr /data/zk</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建数据目录</span></span><br><span class="line">midkr /data/zk/data</span><br><span class="line">cd /data/zk</span><br><span class="line">wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz</span><br><span class="line">tar -zxvf apache-zookeeper-3.6.0-bin.tar.gz</span><br><span class="line">cd apache-zookeeper-3.6.0-bin/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg &amp;&amp; vim zoo.cfg</span><br></pre></td></tr></table></figure>

<p>把<code>zoo.cfg</code>文件中的<code>dataDir</code>设置为<code>/data/zk/data</code>，然后启动<code>Zookeeper</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]# sh /data/zk/apache-zookeeper-3.6.0-bin/bin/zkServer.sh start</span><br><span class="line">/usr/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /data/zk/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<p>这里注意一点，要启动此版本的<code>Zookeeper</code>服务必须本地安装好<code>JDK8+</code>，这一点需要自行处理。启动的默认端口是<code>2181</code>，启动成功后的日志如下：</p>
<p><img src="http://static.cyblogs.com/m-w-c-8.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;m-w-c-8.png"></p>
<h5 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h5><p><code>Kafka</code>是一个高性能分布式消息队列中间件，它的部署依赖于<code>Zookeeper</code>。笔者在此选用<code>2.4.0</code>并且<code>Scala</code>版本为<code>2.13</code>的安装包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/kafka</span><br><span class="line">mkdir /data/kafka/data</span><br><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.4.0/kafka_2.13-2.4.0.tgz</span><br><span class="line">tar -zxvf kafka_2.13-2.4.0.tgz</span><br></pre></td></tr></table></figure>

<p>由于解压后<code>/data/kafka/kafka_2.13-2.4.0/config/server.properties</code>配置中对应的<code>zookeeper.connect=localhost:2181</code>已经符合需要，不必修改，需要修改日志文件的目录<code>log.dirs</code>为<code>/data/kafka/data</code>。然后启动<code>Kafka</code>服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /data/kafka/kafka_2.13-2.4.0/bin/kafka-server-start.sh /data/kafka/kafka_2.13-2.4.0/config/server.properties</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/m-w-c-9.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;m-w-c-9.png"></p>
<p>这样启动一旦退出控制台就会结束<code>Kafka</code>进程，可以添加<code>-daemon</code>参数用于控制<code>Kafka</code>进程后台不挂断运行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /data/kafka/kafka_2.13-2.4.0/bin/kafka-server-start.sh -daemon /data/kafka/kafka_2.13-2.4.0/config/server.properties</span><br></pre></td></tr></table></figure>

<h5 id="安装和使用Canal"><a href="#安装和使用Canal" class="headerlink" title="安装和使用Canal"></a>安装和使用Canal</h5><p>终于到了主角登场，这里选用<code>Canal</code>的<code>v1.1.4</code>稳定发布版，只需要下载<code>deployer</code>模块：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/canal</span><br><span class="line">cd /data/canal</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里注意一点，Github在国内被墙，下载速度极慢，可以先用其他下载工具下载完再上传到服务器中</span></span><br><span class="line">wget https://github.com/alibaba/canal/releases/download/canal-1.1.4/canal.deployer-1.1.4.tar.gz</span><br><span class="line">tar -zxvf canal.deployer-1.1.4.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压后的目录如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- bin   # 运维脚本</span><br><span class="line">- conf  # 配置文件</span><br><span class="line">  canal_local.properties  # canal本地配置，一般不需要动</span><br><span class="line">  canal.properties        # canal服务配置</span><br><span class="line">  logback.xml             # logback日志配置</span><br><span class="line">  metrics                 # 度量统计配置</span><br><span class="line">  spring                  # spring-实例配置，主要和binlog位置计算、一些策略配置相关，可以在canal.properties选用其中的任意一个配置文件</span><br><span class="line">  example                 # 实例配置文件夹，一般认为单个数据库对应一个独立的实例配置文件夹</span><br><span class="line">    instance.properties   # 实例配置，一般指单个数据库的配置</span><br><span class="line">- lib   # 服务依赖包</span><br><span class="line">- logs  # 日志文件输出目录</span><br></pre></td></tr></table></figure>

<p>在开发和测试环境建议把<code>logback.xml</code>的日志级别修改为<code>DEBUG</code>方便定位问题。这里需要关注<code>canal.properties</code>和<code>instance.properties</code>两个配置文件。<code>canal.properties</code>文件中，需要修改：</p>
<ul>
<li>去掉<code>canal.instance.parser.parallelThreadSize = 16</code>这个配置项的<strong>注释</strong>，也就是启用此配置项，和实例解析器的线程数相关，不配置会表现为阻塞或者不进行解析。</li>
<li><code>canal.serverMode</code>配置项指定为<code>kafka</code>，可选值有<code>tcp</code>、<code>kafka</code>和<code>rocketmq</code>（<code>master</code>分支或者最新的的<code>v1.1.5-alpha-1</code>版本，可以选用<code>rabbitmq</code>），默认是<code>kafka</code>。</li>
<li><code>canal.mq.servers</code>配置需要指定为<code>Kafka</code>服务或者集群<code>Broker</code>的地址，这里配置为<code>127.0.0.1:9092</code>。</li>
</ul>
<blockquote>
<p>canal.mq.servers在不同的canal.serverMode有不同的意义。<br>kafka模式下，指Kafka服务或者集群Broker的地址，也就是bootstrap.servers<br>rocketmq模式下，指NameServer列表<br>rabbitmq模式下，指RabbitMQ服务的Host和Port</p>
</blockquote>
<p>其他配置项可以参考下面两个官方<code>Wiki</code>的链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/canal/wiki/Canal-Kafka-RocketMQ-QuickStart">Canal-Kafka-RocketMQ-QuickStart</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/canal/wiki/AdminGuide">AdminGuide</a></li>
</ul>
<p><code>instance.properties</code>一般指一个数据库实例的配置，<code>Canal</code>架构支持一个<code>Canal</code>服务实例，处理多个数据库实例的<code>binlog</code>异步解析。<code>instance.properties</code>需要修改的配置项主要包括：</p>
<ul>
<li><p><code>canal.instance.mysql.slaveId</code>需要配置一个和<code>Master</code>节点的服务<code>ID</code>完全不同的值，这里笔者配置为<code>654321</code>。</p>
</li>
<li><p>配置数据源实例，包括地址、用户、密码和目标数据库：</p>
<ul>
<li><code>canal.instance.master.address</code>，这里指定为<code>127.0.0.1:3306</code>。</li>
<li><code>canal.instance.dbUsername</code>，这里指定为<code>canal</code>。</li>
<li><code>canal.instance.dbPassword</code>，这里指定为<code>QWqw12!@</code>。</li>
<li>新增<code>canal.instance.defaultDatabaseName</code>，这里指定为<code>test</code>（需要在<code>MySQL</code>中建立一个<code>test</code>数据库，见前面的流程）。</li>
</ul>
</li>
<li><p><code>Kafka</code>相关配置，这里暂时使用静态<code>topic</code>和单个<code>partition</code>：</p>
</li>
<li><p><code>canal.mq.topic</code>，这里指定为<code>test</code>，<strong>也就是解析完的<code>binlog</code>结构化数据会发送到<code>Kafka</code>的命名为<code>test</code>的<code>topic</code>中</strong>。</p>
<ul>
<li><code>canal.mq.partition</code>，这里指定为<code>0</code>。</li>
</ul>
</li>
</ul>
<p>配置工作做好之后，可以启动<code>Canal</code>服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh /data/canal/bin/startup.sh </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看服务日志</span></span><br><span class="line">tail -100f /data/canal/logs/canal/canal</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看实例日志  -- 一般情况下，关注实例日志即可</span></span><br><span class="line">tail -100f /data/canal/logs/example/example.log</span><br></pre></td></tr></table></figure>

<p>启动正常后，见实例日志如下：</p>
<p><img src="http://static.cyblogs.com/m-w-c-10.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;m-w-c-10.png"></p>
<p>在<code>test</code>数据库创建一个订单表，并且执行几个简单的<code>DML</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use `test`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">order</span>`</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">BIGINT</span> <span class="keyword">UNIQUE</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    order_id    <span class="type">VARCHAR</span>(<span class="number">64</span>)    <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;订单ID&#x27;</span>,</span><br><span class="line">    amount      <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;订单金额&#x27;</span>,</span><br><span class="line">    create_time DATETIME       <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> uniq_order_id (`order_id`)</span><br><span class="line">) COMMENT <span class="string">&#x27;订单表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">order</span>`(order_id, amount) <span class="keyword">VALUES</span> (<span class="string">&#x27;10086&#x27;</span>, <span class="number">999</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">order</span>` <span class="keyword">SET</span> amount <span class="operator">=</span> <span class="number">10087</span> <span class="keyword">WHERE</span> order_id <span class="operator">=</span> <span class="string">&#x27;10086&#x27;</span>;</span><br><span class="line"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span> `<span class="keyword">order</span>` <span class="keyword">WHERE</span> order_id <span class="operator">=</span> <span class="string">&#x27;10086&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个时候，可以利用<code>Kafka</code>的<code>kafka-console-consumer</code>或者<code>Kafka Tools</code>查看<code>test</code>这个<code>topic</code>的数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /data/kafka/kafka_2.13-2.4.0/bin/kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --from-beginning --topic test</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/m-w-c-11.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;m-w-c-11.png"></p>
<p>具体的数据如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// test数据库建库脚本</span><br><span class="line">&#123;&quot;data&quot;:null,&quot;database&quot;:&quot;`test`&quot;,&quot;es&quot;:1583143732000,&quot;id&quot;:1,&quot;isDdl&quot;:false,&quot;mysqlType&quot;:null,&quot;old&quot;:null,&quot;pkNames&quot;:null,&quot;sql&quot;:&quot;CREATE DATABASE `test` CHARSET `utf8mb4` COLLATE `utf8mb4_unicode_ci`&quot;,&quot;sqlType&quot;:null,&quot;table&quot;:&quot;&quot;,&quot;ts&quot;:1583143930177,&quot;type&quot;:&quot;QUERY&quot;&#125;</span><br><span class="line"></span><br><span class="line">// order表建表DDL</span><br><span class="line">&#123;&quot;data&quot;:null,&quot;database&quot;:&quot;test&quot;,&quot;es&quot;:1583143957000,&quot;id&quot;:2,&quot;isDdl&quot;:true,&quot;mysqlType&quot;:null,&quot;old&quot;:null,&quot;pkNames&quot;:null,&quot;sql&quot;:&quot;CREATE TABLE `order`\n(\n    id          BIGINT UNIQUE PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,\n    order_id    VARCHAR(64)    NOT NULL COMMENT &#x27;订单ID&#x27;,\n    amount      DECIMAL(10, 2) NOT NULL DEFAULT 0 COMMENT &#x27;订单金额&#x27;,\n    create_time DATETIME       NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,\n    UNIQUE uniq_order_id (`order_id`)\n) COMMENT &#x27;订单表&#x27;&quot;,&quot;sqlType&quot;:null,&quot;table&quot;:&quot;order&quot;,&quot;ts&quot;:1583143958045,&quot;type&quot;:&quot;CREATE&quot;&#125;</span><br><span class="line"></span><br><span class="line">// INSERT</span><br><span class="line">&#123;&quot;data&quot;:[&#123;&quot;id&quot;:&quot;1&quot;,&quot;order_id&quot;:&quot;10086&quot;,&quot;amount&quot;:&quot;999.0&quot;,&quot;create_time&quot;:&quot;2020-03-02 05:12:49&quot;&#125;],&quot;database&quot;:&quot;test&quot;,&quot;es&quot;:1583143969000,&quot;id&quot;:3,&quot;isDdl&quot;:false,&quot;mysqlType&quot;:&#123;&quot;id&quot;:&quot;BIGINT&quot;,&quot;order_id&quot;:&quot;VARCHAR(64)&quot;,&quot;amount&quot;:&quot;DECIMAL(10,2)&quot;,&quot;create_time&quot;:&quot;DATETIME&quot;&#125;,&quot;old&quot;:null,&quot;pkNames&quot;:[&quot;id&quot;],&quot;sql&quot;:&quot;&quot;,&quot;sqlType&quot;:&#123;&quot;id&quot;:-5,&quot;order_id&quot;:12,&quot;amount&quot;:3,&quot;create_time&quot;:93&#125;,&quot;table&quot;:&quot;order&quot;,&quot;ts&quot;:1583143969460,&quot;type&quot;:&quot;INSERT&quot;&#125;</span><br><span class="line"></span><br><span class="line">// UPDATE</span><br><span class="line">&#123;&quot;data&quot;:[&#123;&quot;id&quot;:&quot;1&quot;,&quot;order_id&quot;:&quot;10086&quot;,&quot;amount&quot;:&quot;10087.0&quot;,&quot;create_time&quot;:&quot;2020-03-02 05:12:49&quot;&#125;],&quot;database&quot;:&quot;test&quot;,&quot;es&quot;:1583143974000,&quot;id&quot;:4,&quot;isDdl&quot;:false,&quot;mysqlType&quot;:&#123;&quot;id&quot;:&quot;BIGINT&quot;,&quot;order_id&quot;:&quot;VARCHAR(64)&quot;,&quot;amount&quot;:&quot;DECIMAL(10,2)&quot;,&quot;create_time&quot;:&quot;DATETIME&quot;&#125;,&quot;old&quot;:[&#123;&quot;amount&quot;:&quot;999.0&quot;&#125;],&quot;pkNames&quot;:[&quot;id&quot;],&quot;sql&quot;:&quot;&quot;,&quot;sqlType&quot;:&#123;&quot;id&quot;:-5,&quot;order_id&quot;:12,&quot;amount&quot;:3,&quot;create_time&quot;:93&#125;,&quot;table&quot;:&quot;order&quot;,&quot;ts&quot;:1583143974870,&quot;type&quot;:&quot;UPDATE&quot;&#125;</span><br><span class="line"></span><br><span class="line">// DELETE</span><br><span class="line">&#123;&quot;data&quot;:[&#123;&quot;id&quot;:&quot;1&quot;,&quot;order_id&quot;:&quot;10086&quot;,&quot;amount&quot;:&quot;10087.0&quot;,&quot;create_time&quot;:&quot;2020-03-02 05:12:49&quot;&#125;],&quot;database&quot;:&quot;test&quot;,&quot;es&quot;:1583143980000,&quot;id&quot;:5,&quot;isDdl&quot;:false,&quot;mysqlType&quot;:&#123;&quot;id&quot;:&quot;BIGINT&quot;,&quot;order_id&quot;:&quot;VARCHAR(64)&quot;,&quot;amount&quot;:&quot;DECIMAL(10,2)&quot;,&quot;create_time&quot;:&quot;DATETIME&quot;&#125;,&quot;old&quot;:null,&quot;pkNames&quot;:[&quot;id&quot;],&quot;sql&quot;:&quot;&quot;,&quot;sqlType&quot;:&#123;&quot;id&quot;:-5,&quot;order_id&quot;:12,&quot;amount&quot;:3,&quot;create_time&quot;:93&#125;,&quot;table&quot;:&quot;order&quot;,&quot;ts&quot;:1583143981091,&quot;type&quot;:&quot;DELETE&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>可见<code>Kafka</code>的名为<code>test</code>的<code>topic</code>已经写入了对应的结构化<code>binlog</code>事件数据，可以编写消费者监听<code>Kafka</code>对应的<code>topic</code>然后对获取到的数据进行后续处理。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这篇文章大部分篇幅用于介绍其他中间件是怎么部署的，这个问题侧面说明了<code>Canal</code>本身部署并不复杂，它的配置文件属性项比较多，但是实际上需要自定义和改动的配置项是比较少的，也就是说明了它的运维成本和学习成本并不高。后面会分析基于结构化<code>binlog</code>事件做<code>ELT</code>和持久化相关工作以及<code>Canal</code>的生产环境可用级别<code>HA</code>集群的搭建。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="http://www.throwable.club/2020/03/07/canal-kafka-mysql-binlog-sync-guide/">http://www.throwable.club/2020/03/07/canal-kafka-mysql-binlog-sync-guide/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/28/2020/02/Kafka%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90-Kafka%20High%20Availability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/28/2020/02/Kafka%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90-Kafka%20High%20Availability/" class="post-title-link" itemprop="url">Kafka设计解析-Kafka High Availability</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-28T00:00:00+08:00">2020-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:57:28" itemprop="dateModified" datetime="2025-06-25T09:57:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="1-Kafka简介"><a href="#1-Kafka简介" class="headerlink" title="1. Kafka简介"></a>1. Kafka简介</h4><p>Kafka是一种分布式的，基于发布&#x2F;订阅的消息系统。主要设计目标如下：</p>
<ol>
<li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输</li>
<li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输</li>
<li>同时支持离线数据处理和实时数据处理</li>
<li>Scale out：支持在线水平扩展</li>
</ol>
<h4 id="2-Kafka架构"><a href="#2-Kafka架构" class="headerlink" title="2. Kafka架构"></a>2. Kafka架构</h4><p><strong>Broker</strong>：Kafka集群包含一个或多个服务器，这种服务器被称为broker</p>
<p><strong>Topic</strong>：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>
<p><strong>Partition</strong>：Parition是物理上的概念，每个Topic包含一个或多个Partition.</p>
<p><strong>Producer</strong>：负责发布消息到Kafka broker</p>
<p><strong>Consumer</strong>：消息消费者，向Kafka broker读取消息的客户端。</p>
<p><strong>Consumer Group</strong>：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>
<h4 id="3-Kafka拓扑结构"><a href="#3-Kafka拓扑结构" class="headerlink" title="3. Kafka拓扑结构"></a>3. Kafka拓扑结构</h4><p><img src="http://static.cyblogs.com/KafkaArchitecture.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;KafkaArchitecture.png"></p>
<p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个<a target="_blank" rel="noopener" href="http://zookeeper.apache.org/">Zookeeper</a>集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。 </p>
<h4 id="4-Delivery-Guarantee"><a href="#4-Delivery-Guarantee" class="headerlink" title="4. Delivery Guarantee"></a>4. Delivery Guarantee</h4><p>　　有这么几种可能的delivery guarantee：</p>
<ul>
<li><code>At most once</code> 消息可能会丢，但绝不会重复传输</li>
<li><code>At least one</code> 消息绝不会丢，但可能会重复传输</li>
<li><code>Exactly once</code> 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。</li>
</ul>
<h4 id="5-Kafka-HA设计解析"><a href="#5-Kafka-HA设计解析" class="headerlink" title="5. Kafka HA设计解析"></a>5. Kafka HA设计解析</h4><h5 id="5-1-Replica复制算法"><a href="#5-1-Replica复制算法" class="headerlink" title="5.1 Replica复制算法"></a>5.1 Replica复制算法</h5><p>​	为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。一个典型的部署方式是一个Topic的Partition数量大于Broker的数量。同时为了提高Kafka的容错能力，也需要将同一个Partition的Replica尽量分散到不同的机器。实际上，如果所有的Replica都在同一个Broker上，那一旦该Broker宕机，该Partition的所有Replica都无法工作，也就达不到HA的效果。同时，如果某个Broker宕机了，需要保证它上面的负载可以被均匀的分配到其它幸存的所有Broker上。</p>
<ol>
<li>将所有Broker（假设共n个Broker）和待分配的Partition排序</li>
<li>将第i个Partition分配到第（i mod n）个Broker上</li>
<li>将第i个Partition的第j个Replica分配到第（(i + j) mod n）个Broker上</li>
</ol>
<h5 id="5-2-Broker活着的判定"><a href="#5-2-Broker活着的判定" class="headerlink" title="5.2 Broker活着的判定"></a>5.2 Broker活着的判定</h5><p>kafka判定broker是否活着，通过以下2个方式：</p>
<ol>
<li>和zk的session没有断（通过心跳来维系）</li>
<li>follower能及时将leader消息复制过来，不能落后太多（例如默认lag超过4000就会踢出ISR）</li>
</ol>
<h5 id="5-3-所有Replica都不工作的情况"><a href="#5-3-所有Replica都不工作的情况" class="headerlink" title="5.3 所有Replica都不工作的情况"></a>5.3 所有Replica都不工作的情况</h5><p>如果所有副本都出问题，一般有两种选择：</p>
<ol>
<li>等待ISR中的任一个Replica“活”过来，并且选它作为Leader（一致性好，但是可用性差）</li>
<li>选择第一个“活”过来的Replica（不一定是ISR中的）作为Leader（一致性差，但是可用性相比第一种方式好）</li>
</ol>
<h5 id="5-4-Propagate消息"><a href="#5-4-Propagate消息" class="headerlink" title="5.4 Propagate消息"></a>5.4 Propagate消息</h5><p>​		Producer在发布消息到某个Partition时，先通过 Metadata （通过 Broker 获取并且缓存在 Producer 内） 找到该 Partition 的Leader，然后无论该Topic的Replication Factor为多少（也即该Partition有多少个Replica），Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。<br>为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费。但考虑到这种场景非常少见，可以认为这种方式在性能和数据持久化上做了一个比较好的平衡。</p>
<h5 id="5-5-ACK前需要保证有多少个备份"><a href="#5-5-ACK前需要保证有多少个备份" class="headerlink" title="5.5 ACK前需要保证有多少个备份"></a>5.5 ACK前需要保证有多少个备份</h5><p>​		和大部分分布式系统一样，Kafka处理失败需要明确定义一个Broker是否“活着”。对于Kafka而言，Kafka存活包含两个条件，一是它必须维护与Zookeeper的session(这个通过Zookeeper的Heartbeat机制来实现)。二是Follower必须能够及时将Leader的消息复制过来，不能“落后太多”。<br>　　Leader会跟踪与其保持同步的Replica列表，该列表称为ISR（即in-sync Replica）。如果一个Follower宕机，或者落后太多，Leader将把它从ISR中移除。这里所描述的“落后太多”指Follower复制的消息落后于Leader后的条数超过预定值（该值可在$KAFKA_HOME&#x2F;config&#x2F;server.properties中通过<code>replica.lag.max.messages</code>配置，其默认值是4000）或者Follower超过一定时间（该值可在$KAFKA_HOME&#x2F;config&#x2F;server.properties中通过<code>replica.lag.time.max.ms</code>来配置，其默认值是10000）未向Leader发送fetch请求。。<br>　　Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率（高吞吐率是Kafka非常重要的一个特性）。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下如果Follower都复制完都落后于Leader，而如果Leader突然宕机，则会丢失数据。而Kafka的这种使用ISR的方式则很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，这样极大的提高复制性能（批量写磁盘），极大减少了Follower与Leader的差距。</p>
<h4 id="6-分区Leader选举方法"><a href="#6-分区Leader选举方法" class="headerlink" title="6. 分区Leader选举方法"></a>6. 分区Leader选举方法</h4><p>一般比较容易想到的一个方法是：所有Follower都在Zookeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（Zookeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。</p>
<p>该方法会存在3个问题：</p>
<ol>
<li>split-brain 这是由Zookeeper的特性引起的，虽然Zookeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致</li>
<li>herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整</li>
<li>Zookeeper负载过重 每个Replica都要为此在Zookeeper上注册一个Watch，当集群规模增加到几千个Partition时Zookeeper负载会过重。</li>
</ol>
<p>改进的方法——所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比Zookeeper Queue的方式更高效）通知需为此作出响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。</p>
<h4 id="7-各组件Failover过程"><a href="#7-各组件Failover过程" class="headerlink" title="7. 各组件Failover过程"></a>7. 各组件Failover过程</h4><h5 id="Broker-failover过程"><a href="#Broker-failover过程" class="headerlink" title="Broker failover过程"></a>Broker failover过程</h5><ol>
<li>Controller在Zookeeper注册Watch，一旦有Broker宕机（这是用宕机代表任何让系统认为其die的情景，包括但不限于机器断电，网络不可用，GC导致的Stop The World，进程crash等），其在Zookeeper对应的znode会自动被删除，Zookeeper会fire Controller注册的watch，Controller读取最新的幸存的Broker</li>
<li>Controller决定set_p，该集合包含了宕机的所有Broker上的所有Partition</li>
<li>对set_p中的每一个Partition</li>
</ol>
<p>　　3.1 从&#x2F;brokers&#x2F;topics&#x2F;[topic]&#x2F;partitions&#x2F;[partition]&#x2F;state读取该Partition当前的ISR　　</p>
<p>​		3.2 决定该Partition的新Leader。如果当前ISR中有至少一个Replica还幸存，则选择其中一个作为新Leader，新的ISR则包含当前ISR中所有幸存的Replica。否则选择该Partition中任意一个幸存的Replica作为新的Leader以及ISR（该场景下可能会有潜在的数据丢失）。如果该Partition的所有Replica都宕机了，则将新的Leader设置为-1。　　</p>
<p>3.3 将新的Leader，ISR和新的leader_epoch及controller_epoch写入&#x2F;brokers&#x2F;topics&#x2F;[topic]&#x2F;partitions&#x2F;[partition]&#x2F;state。注意，该操作只有其version在3.1至3.3的过程中无变化时才会执行，否则跳转到3.1</p>
<ol>
<li>直接通过RPC向set_p相关的Broker发送LeaderAndISRRequest命令。Controller可以在一个RPC操作中发送多个命令从而提高效率。</li>
</ol>
<p>　　Broker failover顺序图如下所示。</p>
<p><img src="http://static.cyblogs.com/kafka_broker_failover.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;kafka_broker_failover.png"></p>
<h5 id="Controller-failure过程"><a href="#Controller-failure过程" class="headerlink" title="Controller failure过程"></a>Controller failure过程</h5><ol>
<li>Controller在Zookeeper的<code>/brokers/ids</code>节点上注册Watch。一旦有Broker宕机（本文用宕机代表任何让Kafka认为其Broker die的情景，包括但不限于机器断电，网络不可用，GC导致的Stop The World，进程crash等），其在Zookeeper对应的Znode会自动被删除，Zookeeper会fire Controller注册的Watch，Controller即可获取最新的幸存的Broker列表。</li>
<li>Controller决定set_p，该集合包含了宕机的所有Broker上的所有Partition。</li>
<li>对set_p中的每一个Partition：<br>　　3.1 从<code>/brokers/topics/[topic]/partitions/[partition]/state</code>读取该Partition当前的ISR。<br>   　　3.2 决定该Partition的新Leader。如果当前ISR中有至少一个Replica还幸存，则选择其中一个作为新Leader，新的ISR则包含当前ISR中所有幸存的Replica。否则选择该Partition中任意一个幸存的Replica作为新的Leader以及ISR（该场景下可能会有潜在的数据丢失）。如果该Partition的所有Replica都宕机了，则将新的Leader设置为-1。<br>   　　3.3 将新的Leader，ISR和新的<code>leader_epoch</code>及<code>controller_epoch</code>写入<code>/brokers/topics/[topic]/partitions/[partition]/state</code>。注意，该操作只有Controller版本在3.1至3.3的过程中无变化时才会执行，否则跳转到3.1。</li>
<li>直接通过RPC向set_p相关的Broker发送LeaderAndISRRequest命令。Controller可以在一个RPC操作中发送多个命令从而提高效率。<br>　　Broker failover顺序图如下所示。</li>
</ol>
<p><img src="http://static.cyblogs.com/kafka_broker_failover.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;kafka_broker_failover.png"></p>
<h4 id="Partition重新分配"><a href="#Partition重新分配" class="headerlink" title="Partition重新分配"></a>Partition重新分配</h4><p>管理工具发出重新分配Partition请求后，会将相应信息写到<code>/admin/reassign_partitions</code>上，而该操作会触发ReassignedPartitionsIsrChangeListener，从而通过执行回调函数KafkaController.onPartitionReassignment来完成以下操作：</p>
<ol>
<li>将Zookeeper中的AR（Current Assigned Replicas）更新为OAR（Original list of replicas for partition） + RAR（Reassigned replicas）。</li>
<li>强制更新Zookeeper中的leader epoch，向AR中的每个Replica发送LeaderAndIsrRequest。</li>
<li>将RAR - OAR中的Replica设置为NewReplica状态。</li>
<li>等待直到RAR中所有的Replica都与其Leader同步。</li>
<li>将RAR中所有的Replica都设置为OnlineReplica状态。</li>
<li>将Cache中的AR设置为RAR。</li>
<li>若Leader不在RAR中，则从RAR中重新选举出一个新的Leader并发送LeaderAndIsrRequest。若新的Leader不是从RAR中选举而出，则还要增加Zookeeper中的leader epoch。</li>
<li>将OAR - RAR中的所有Replica设置为OfflineReplica状态，该过程包含两部分。第一，将Zookeeper上ISR中的OAR - RAR移除并向Leader发送LeaderAndIsrRequest从而通知这些Replica已经从ISR中移除；第二，向OAR - RAR中的Replica发送StopReplicaRequest从而停止不再分配给该Partition的Replica。</li>
<li>将OAR - RAR中的所有Replica设置为NonExistentReplica状态从而将其从磁盘上删除。</li>
<li>将Zookeeper中的AR设置为RAR。</li>
<li>删除<code>/admin/reassign_partition</code>。</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a target="_blank" rel="noopener" href="http://www.jasongj.com/2015/04/24/KafkaColumn2/">http://www.jasongj.com/2015/04/24/KafkaColumn2/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.jasongj.com/2015/06/08/KafkaColumn3/">http://www.jasongj.com/2015/06/08/KafkaColumn3/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Vernon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <a target="_blank" href="https://beian.miit.gov.cn">粤ICP备2025433887号</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
