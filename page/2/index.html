<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.cyblogs.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="简栈文化">
<meta property="og:url" content="http://www.cyblogs.com/page/2/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.cyblogs.com/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>简栈文化</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">简栈文化</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java技术人的成长之路~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vernon"
      src="/images/vernonchen.jpg">
  <p class="site-author-name" itemprop="name">Vernon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengcheng222e" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengcheng222e" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengcheng222e@gmail.com" title="E-Mail → mailto:chengcheng222e@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2021/03/25/2021/03/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/25/2021/03/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">Kafka消费者组是什么？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-25T00:00:00+08:00">2021-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 10:05:09" itemprop="dateModified" datetime="2025-06-25T10:05:09+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Kafka/" itemprop="url" rel="index"><span itemprop="name">Kafka</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="一、Kafka消费者组是什么？"><a href="#一、Kafka消费者组是什么？" class="headerlink" title="一、Kafka消费者组是什么？"></a>一、Kafka消费者组是什么？</h4><p><code>Consumer Group</code> 是<code>Kafka</code>提供的可扩展且具有容错性的消费者机制。在组内多个消费者实例(<code>Consumer Instance</code> ),它们共享一个公共的ID即 <code>Group ID</code> 。组内的所有消费者协调在一起消费订阅主题（<code>Subscribed Topics</code>）的所有分区(<code>Partition</code>)。当然一个分区只能有同一个消费者组的一个<code>Consumer</code> 实例消费。<br><code>Consumer Group</code> 有三个特性：</p>
<ul>
<li><code>Consumer Group</code> 下可以有一个或多个<code>Consumer</code> 实例。 这里的实例可以是一个单独的进程，也可以是同一进程下的线程；</li>
<li><code>Group ID</code> 是一个字符串， 在Kafka集群中唯一标识，<code>Consumer Group</code>；</li>
<li><code>Consumer Group</code><br>下所有实例订阅主体的单个分区，只能分配给组内某个<code>Consumer</code>实例消费。同一个分区消息可能被多个<code>Group</code> 消费。</li>
</ul>
<h4 id="二、Kafka消费者组解决了哪些问题？"><a href="#二、Kafka消费者组解决了哪些问题？" class="headerlink" title="二、Kafka消费者组解决了哪些问题？"></a>二、Kafka消费者组解决了哪些问题？</h4><p>传统的消息系统中，有两种消息引擎模型：点对点模型（消息队列）、发布&#x2F;订阅模型<br>传统的两种消息系统各有优势，我们里对比一下：</p>
<ul>
<li>传统的消息队列模型的缺陷在于消息一旦被消费，就会从队列中删除，而且只能被下游的一个<code>Consumer</code>消费。严格的说这不是它的缺陷，<br>这是它的一个特性。但很显然这种模型的伸缩性（<code>Scalability</code>）很差，因为下游的多个<code>Consumer</code> 都要“抢”<br>这个共享消息队列的消息；</li>
<li>发布&#x2F;订阅模型,允许消息被多个<code>Consumer</code> 消费，但它的问题也是伸缩性不高，因为订阅者都必须订阅所有主体的所有分区。</li>
</ul>
<p><code>Kafka</code> 为规避传统消息两种模型的缺点，引入了 <code>Consumer Group</code> 机制：</p>
<ul>
<li>当 <code>Consumer Group</code> 订阅多个主题后，组内的每个实例不要求一定要订阅主题的所有分区，它只会消费部分分区中的消息；</li>
<li><code>Consumer Group</code> 之间彼此队里，互不影响，它们可以订阅同一组主题而互不干涉。加上<code>Broker</code>端的消息留存机制，<code>Kafka</code>的<code>Consumer Group</code> 完美的避开了伸缩性差的问题；</li>
<li><code>kafka</code> 是用<code>Consumer Group</code>机制，实现了，传统两大消息引擎。如果所有实例属于同一个<code>Group</code>，那么它实现的就是消息队列模型；如果所有实例分别属于不同的<code>Group</code>，且订阅了相同的主题，那么它就实现了发布&#x2F;订阅模型；</li>
</ul>
<h4 id="三、Consumer-Group-实例数量多少才合理？"><a href="#三、Consumer-Group-实例数量多少才合理？" class="headerlink" title="三、Consumer Group 实例数量多少才合理？"></a>三、Consumer Group 实例数量多少才合理？</h4><p>最理想的情况是<code>Consumer</code>实例的数量应该等于该<code>Group</code>订阅主题的分区总数。例如：<code>Consumer Group</code> 订阅了 3个主题，分别是<code>A、B、C</code>，它们的分区数依次是<code>1、2、3</code>，那么通常情况下，为该<code>Group</code> 设置<code>6</code>个<code>Consumer</code>实例是比较理想的情形。</p>
<p>如果设置小于或大于<code>6</code>的实例可以吗？当然可以，如果你有<code>3</code>个实例，那么平均下来每个实例大约消费<code>2</code>个分区<code>（6/3=2）</code>;如果你设置了<code>9</code>个实例，那么很遗憾，有<code>3</code>个实例（<code>9-6=3</code>）将不会被分配任何分区，它们永远处于空闲状态。</p>
<h4 id="四、消费位移"><a href="#四、消费位移" class="headerlink" title="四、消费位移"></a>四、消费位移</h4><p>消费者在消费的过程中要记录自己消费了多少数据，即消费位置信息，在<code>Kafka</code>中叫：位移（<code>offset</code>）。<br>看上去该Offset就是一个数字而已，其实对于Consumer Group 而言，它是一组KV对，Key是分区，V对应Consumer 消费该分区的最新位移。<br>老版本的<code>Consumer Group</code>把位移保存在<code>Zookeeper</code>中。将位移保存在<code>Zookeeper</code>外部系统显然好处是减少了<code>Kafka Broker</code> 端的状态保存开销。现在比较流行的提法是将服务器节点做成无状态的， 这样可以自由扩缩容，实现超强的伸缩性。不过在实际使用场景中，发现<code>ZooKeeper</code> 这类元框架并不是适合进行频繁的写更新，而<code>Consumer Group</code> 的位移更新却是一个非常频繁的操作。 这种大吞吐量的写操作极大的拖慢了<code>ZooKeeper</code> 集群的性能，在新版本的<code>Consumer Group</code> 中，<code>Kafka</code> 社区采用了将<code>Consumer Group</code> 位移保存在<code>Broker</code> 端的内部主题中。</p>
<h4 id="五、Rebalance"><a href="#五、Rebalance" class="headerlink" title="五、Rebalance"></a>五、Rebalance</h4><p><code>Rebalance</code> 本质上是一种协议，规定了一个<code>Consumer Group</code> 下所有<code>Consumer</code> 如何达成一致，来分配订阅<code>Topic</code>的每个分区。比如：某个<code>Group</code> 下有20个<code>Consumer</code> 实例， 它订阅了一个具有100个分区的<code>Topic</code>。正常情况下，Kafka 平均会为每个<code>Consumer</code> 分配5个分区。这个分配的过程叫<code>Rebalance</code>。<br><code>Consumer Group</code>触发 <code>Rebalance</code>有三种情况：</p>
<ul>
<li>组成员数量发生变化，比如有新的<code>Consumer</code> 实例加入组或离开组，抑或是有<code>Consumer</code>实例崩溃被“踢出”组。</li>
<li>订阅主题数量发生变更。 <code>Consumer Group</code> 可以使用正则表达式订阅主题，比如<br><code>consumer.subscribe(Pattern.complile(“t.*c”))</code>就表明该<code>Group</code>订阅所有<code>t</code>开头，字母<code>c</code>结尾的主题。在<code>Consumer Group</code> 运行时，新创建一个满足这样条件的主题，那么会触发订阅该主题所有<code>Group</code> 开始<code>Rebalance</code>。</li>
<li>订阅主题分区数发生变化，<code>Kakfka</code> 一个主题，当分区数增加时，就会触发订阅该主题的所有<code>Group</code>开启<code>Rebalance</code>。</li>
</ul>
<p><code>Consumer Group</code> 发生<code>Rebalance</code> 的过程：某个 <code>Consumer Group</code> 下有两个<code>Consumer</code> ，比如<code>A</code>和<code>B</code>，当第三个成员<code>C</code>加入时，<code>Kafka</code>会触发<code>Rebalance</code>，并根据默认的分配策重新分配<code>A、B、C</code>分配分区，如下图：<br><img src="http://static.cyblogs.com/kafka_rebalance.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;kafka_rebalance.png"></p>
<p>注意：目前<code>Rebalance</code> 的设计是所有<code>Consumer</code>实例共同参与，全部重新分配所有分区，<code>Rebalance</code>过程所有<code>Consumer</code> 实例都会停止消费，等待<code>Rebalance</code> 完成。<code>Rebalance</code> 很慢，一个<code>Group</code> 内有几百个<code>Consumer</code>实例，成功进行一次<code>Rebalance</code>需要好几个小时。 目前社区没有终极解决方案，最好的解决方案是规避<code>Rebalane</code>的发生。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36918149/article/details/99656156">https://blog.csdn.net/qq_36918149/article/details/99656156</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2021/03/01/2021/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E9%87%8D%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/01/2021/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E9%87%8D%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">为什么会有重排序？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-01T00:00:00+08:00">2021-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 10:05:09" itemprop="dateModified" datetime="2025-06-25T10:05:09+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>在讲重排序之前，先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with leetcode-cn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 验证重排序代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/3/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 15:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileSerialCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">				<span class="comment">// 用set来保存数据，保证不会重复</span></span><br><span class="line">        Set&lt;String&gt; resultSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                a = y;</span><br><span class="line">                x = <span class="number">1</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                b = x;</span><br><span class="line">                y = <span class="number">1</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            one.start();</span><br><span class="line">            two.start();</span><br><span class="line">            one.join();</span><br><span class="line">            two.join();</span><br><span class="line">          	<span class="comment">// 等待2个线程都跑完了再把结果添加到Set中去</span></span><br><span class="line">            resultSet.add(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span><br><span class="line">            System.out.println(resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面一段代码是非常经典来讲CPU对指令重排序的案例。因为我们经过一段时间的Run出的结果很惊讶：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a=0,b=0, a=1,b=0, a=0,b=1, a=1,b=1]</span><br></pre></td></tr></table></figure>

<p>对于<code>a=1,b=1</code>的出现，是会让人非常的奇怪的。出现这个情况，那代码执行的顺序可能是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">     a = y; <span class="comment">// 第3步</span></span><br><span class="line">     x = <span class="number">1</span>; <span class="comment">// 第1步</span></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">     b = x; <span class="comment">// 第4步</span></span><br><span class="line">     y = <span class="number">1</span>; <span class="comment">// 第2步</span></span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// 也就是说，在2个线程中，都出现了下面的代码执行到了上面的代码前面去了。</span></span><br></pre></td></tr></table></figure>

<p>如果是这样子的话，那我们还敢写多线程的代码吗？如果没有一定的规范与约定，那肯定是没人可以写好代码。</p>
<p>其实这些约定都是在<code>JSR-133内存模型与线程规范</code>里面，它就像是Java的产品需求文档或者说明书。</p>
<p><img src="http://static.cyblogs.com/Jietu20210327-174611.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210327-174611.jpg"></p>
<p>百度云盘：链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1cO5d95Za8lyz8dMaN0i9lA">https://pan.baidu.com/s/1cO5d95Za8lyz8dMaN0i9lA</a>  密码: l08w ,大家可以去下载查阅，这些都比较底层，并不能几句话，几篇文章可以讲清楚。</p>
<h4 id="为什么会重排序"><a href="#为什么会重排序" class="headerlink" title="为什么会重排序?"></a>为什么会重排序?</h4><p>看完上面，你可能会有疑问，为什么会有重排序呢?</p>
<p>我的程序按照我自己的逻辑写下来好好的没啥问题， Java 虚拟机为什么动我的程序逻辑?</p>
<p>你想想 <code>CPU</code> 、内存这些都是非常宝贵的资源， Java 虚拟机如果在重排序之后没啥效果，肯定也不会做这种费力不讨好的事情。</p>
<p>Java 虚拟机之所以要进行重排序就是为了提高程序的性能。你写的程序，简简单单一行代码，到底层可能需要使用不同的硬件，比如一个指令需要同时使用 <code>CPU</code> 和打印机设备，但是此时 CPU 的任务完成了，打印机的任务还没完成，这个时候怎么办呢? 不让 CPU 执行接下来的指令吗? CPU 的时间那么宝贵，你不让它工作，确定不是在浪费它的生命?</p>
<p>重排序：重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如下图所示：</p>
<p><img src="http://static.cyblogs.com/20180326170243607.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180326170243607.png"></p>
<ul>
<li>上述的1属于编译器重排序</li>
<li>2和3属于处理器重排序</li>
</ul>
<p>这些重排序可能会导致多线程程序出现内存可见性问题。在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是<code>as-if-serial</code>语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<h4 id="重排序带来的问题"><a href="#重排序带来的问题" class="headerlink" title="重排序带来的问题"></a>重排序带来的问题</h4><p>回到文章刚开始举的那个例子，重排序提高了 CPU 的利用率没错，提高了程序性能没错，但是我的程序得到的结果可能是错误的啊，这是不是就有点儿得不偿失了?</p>
<p>因为重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</p>
<p>凡是问题，都有办法解决，要是没有，那就再想想。</p>
<p>它是怎么解决的呢? 这就需要来说说，顺序一致性<strong>内存模型</strong>和 <strong>JMM (Java Memory Model ， Java 内存模型)</strong></p>
<p>我们知道Java线程的所有操作都是在工作区进行的，那么工作区和主存之间的变量是怎么进行交互的呢，可以用下面的图来表示。</p>
<p><img src="http://static.cyblogs.com/e0e01e43ly1g186enjfwfj20k80degmr.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;e0e01e43ly1g186enjfwfj20k80degmr.jpg"><br>Java通过几种原子操作完成<strong>工作区内存</strong>和<strong>主存</strong>的交互</p>
<ol>
<li>lock：作用于主存，把变量标识为线程独占状态。</li>
<li>unlock：作用于主存，解除变量的独占状态。</li>
<li>read：作用于主存，把一个变量的值通过主存传输到线程的工作区内存。</li>
<li>load：作用于工作区内存，把<code>read</code>操作传过来的变量值储存到工作区内存的变量副本中。</li>
<li>use：作用于工作内存，把工作区内存的变量副本传给执行引擎。</li>
<li>assign：作用于工作区内存，把从执行引擎传过来的值赋值给工作区内存的变量副本。</li>
<li>store：作用于工作区内存，把工作区内存的变量副本传给主存。</li>
<li>write：作用于主存，把<code>store</code>操作传过来的值赋值给主存变量。</li>
</ol>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p><code>as-if-serial</code>语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器、<code>runtime</code>和处理器都必须遵守<code>as-if-serial</code>语义。</p>
<p>为了遵守<code>as-if-serial</code>语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。<code>as-if-serial</code>语义把单线程程序保护了起来，<code>as-if-serial</code>语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>终于讲到了 <code>happens-before</code> ,先来看 <code>happens-before</code> 关系的定义：</p>
<ul>
<li>如果一个操作 <code>happens-before</code> 另一个操作，那么第一个操作的执行结果就会对第二个操作可见</li>
<li>两个操作之间如果存在 <code>happens-before</code> 关系，并不意味着 <code>Java</code> 平台的具体实现就必须按照 <code>happens-before</code> 关系指定的顺序来执行。如果重排序之后的执行结果，与按照 <code>happens-before</code> 关系来执行的结果一直，那么 <code>JMM</code> 也允许这样的重排序</li>
</ul>
<p>看到这儿，你是不是觉得，这个怎么和 <code>as-if-serial</code> 语义一样呢。没错， <code>happens-before</code> 关系本质上和 <code>as-if-serial</code> 语义是一回事。</p>
<p><code>as-if-serial</code> 语义保证的是单线程内重排序之后的执行结果和程序代码本身应该出现的结果是一致的， <code>happens-before</code> 关系保证的是正确同步的多线程程序的执行结果不会被重排序改变。</p>
<p>一句话来总结就是：如果操作 A <code>happens-before</code> 操作 B ，那么操作 A 在内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。</p>
<p>在 <code>Java</code> 中，对于 <code>happens-before</code> 关系，有以下规定：</p>
<ul>
<li>程序顺序规则：一个线程中的每一个操作， <code>happens-before</code> 于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁， <code>happens-before</code> 于随后对这个锁的加锁</li>
<li><code>volatile</code> 变量规则：对一个 <code>volatile</code> 域的写， <code>happens-before</code> 与任意后续对这个 <code>volatile</code> 域的读</li>
<li>传递性：如果 A <code>happens-before</code> B ， 且 B <code>happens-before</code> C ，那么 A <code>happens-before</code> C</li>
<li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>（启动线程B），那么A线程的<code>ThreadB.start()</code>操作<code>happens-before</code>于线程B中的任意操作。</li>
<li><code>join()</code>规则：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作<code>happens-before</code>于线程A从ThreadB.join()操作成功返回。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://developer.51cto.com/art/202005/617587.htm">https://developer.51cto.com/art/202005/617587.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ym123456677/article/details/79700623">https://blog.csdn.net/ym123456677/article/details/79700623</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2021/02/27/2021/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%99%E4%B9%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%AE%B2Paxos%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/27/2021/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%99%E4%B9%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%AE%B2Paxos%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">第一次这么通俗易懂的讲Paxos算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-27 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-27T00:00:00+08:00">2021-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 10:05:09" itemprop="dateModified" datetime="2025-06-25T10:05:09+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Paxos解决什么问题"><a href="#Paxos解决什么问题" class="headerlink" title="Paxos解决什么问题"></a>Paxos解决什么问题</h4><p>大家对<code>Paxos</code>的看法基本是“晦涩难懂”，虽然论文和网上文章也很多，但总觉得“云山雾罩”，也不知道其具体原理以及到底能解决什么问题。</p>
<p>究其原因，一方面是很多<code>Paxos</code>的资料都是在通过形式化的证明去论证算法的正确性，自然艰深晦涩；另一方面，基于<code>Paxos</code>的成熟工程实践并不多。本章试图由浅入深，从问题出发，一点点地深入<code>Paxos</code>的世界。</p>
<h5 id="一个基本的并发问题"><a href="#一个基本的并发问题" class="headerlink" title="一个基本的并发问题"></a>一个基本的并发问题</h5><p>先看一个基本的并发问题，如图116所示。假设有一个KV存储集群，三个客户端并发地向集群发送三个请求。请问，最后在get（X）的时候，X应该等于几？</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-000345.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210228-000345.jpg"></p>
<p>图116（K，V）集群多写答案是：X&#x3D;1、X&#x3D;3或X&#x3D;5都是对的！但X&#x3D;4是错的！因为从客户端角度来看，三个请求是并发的，但三个请求到达服务器的顺序是不确定的，所以最终三个结果都有可能。</p>
<p>这里有很关键的一点：把答案换一种说法，即如果最终集群的结果是X&#x3D;1，那么当Client1发送X&#x3D;1的时候，服务器返回X&#x3D;1；当Client2发送X&#x3D;3的时候，服务器返回X&#x3D;1；当Client3发送X&#x3D;5的时候，服务器返回X&#x3D;1。相当于Client1的请求被接受了，Client2、Client3的请求被拒绝了。如果集群最终结果是X&#x3D;3或者X&#x3D;5，是同样的道理。而这正是<code>Paxos</code>协议的一个特点。</p>
<h5 id="什么是“时序”"><a href="#什么是“时序”" class="headerlink" title="什么是“时序”"></a>什么是“时序”</h5><p>把问题进一步细化：假设KV集群有三台机器，机器之间互相通信，把自己的值传播给其他机器，三个客户端分别向三台机器发送三个请求，如图117所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-000644.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210228-000644.jpg"></p>
<p>图117三台机器组成的（K，V）集群多写示意图假设每台机器都把收到的请求按日志存下来（包括客户端的请求和其他Node的请求）。当三个请求执行完毕后，三台机器的日志分别应该是什么顺序？</p>
<p>结论是：不管顺序如何，只要三台机器的日志顺序是一样的，结果就是正确的。如图118所示，总共有3的全排列，即6种情况，都是正确的。比如第1种情况，三台机器存储的日志顺序都是X&#x3D;1、X&#x3D;3、X&#x3D;5，在最终集群里，X的值肯定等于5。其他情况类似。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-000811.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210228-000811.jpg"></p>
<p>而下面的情况就是错误的：机器1的日志顺序是1、3、5，因此最终的值就是X&#x3D;5；机器2是3、5、1，最终值是X&#x3D;1；机器3的日志顺序是1、5、3，最终值是X&#x3D;3。三台机器关于X的值不一致，如图109所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-000852.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210228-000852.jpg"></p>
<p>通过这个简单的例子就能对“时序”有一个直观的了解：虽然三个客户端是并发的，没有先后顺序，但到了服务器的集群里必须保证三台机器的日志顺序是一样的，这就是所谓的“分布式一致性”。</p>
<h5 id="Paxos解决什么"><a href="#Paxos解决什么" class="headerlink" title="Paxos解决什么"></a>Paxos解决什么</h5><p>问题在例子中，Node1收到了X&#x3D;1之后，复制给Node2和Node3；Node2收到X&#x3D;3之后，复制给Node1和Node3；Node3收到X&#x3D;5之后，复制给Node1和Node2。</p>
<p>客户端是并发的，三个Node之间的复制也是并发的，如何保证三个Node最终的日志顺序是一样的呢？也就是图118中6种正确情况中的1种。</p>
<p>比如Node1先收到客户端的X&#x3D;1，之后收到Node3的X&#x3D;5，最后收到Node2的X&#x3D;3；Node2先收到客户端的X&#x3D;3，之后收到Node1的X&#x3D;1，最后收到Node3的X&#x3D;5……</p>
<p>如何保证三个Node中存储的日志顺序一样呢？这正是接下来要讲的<code>Paxos</code>要解决的问题！</p>
<h4 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h4><p>在上文谈到了复制日志的问题，每个Node存储日志序列，Node之间保证日志完全一样。可能有人会问：为何要存储日志，直接存储最终的数据不就行了吗？</p>
<p>可以把一个变量X或一个对象看成一个状态机。每一次写请求，就是一次导致状态机发生变化的事件，也就是日志。</p>
<p>以上文中最简单的一个变量X为例，假设只有一个Node，3个客户端发送了三个修改X的指令，最终X的状态就是6，如图1110所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-001101.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210228-001101.jpg"></p>
<p>图1110状态机X示意图把变量X扩展成MySQL数据库，客户端发送各种DML操作，这些操作落盘成Binlog。然后Binlog被应用，生成各种数据库表格（状态机），如图1111所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-001145.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210228-001145.jpg"></p>
<p>这里涉及一个非常重要的思想：要选择持久化变化的“事件流（也就是日志流）”，而不是选择持久化“数据本身”（也就是状态机）。为何要这么做呢？原因有很多，列举如下：</p>
<p>（1）日志只有一种操作，就是append。而数据或状态一直在变化，可以add、delete、update。把三种操作转换成了一种，对于持久化存储来说简单了很多！</p>
<p>（2）假如要做多机之间数据同步，如果直接同步状态，状态本身可能有一个很复杂的数据结构（比如关系数据库的关联表、树、图），并且状态也一直在变化，要保证多个机器数据一致，要做数据比对，就很麻烦；而如果同步日志，日志是一个一维的线性序列，要做数据比对，则非常容易！</p>
<p>总之，无论从持久化，还是数据同步角度来看，存储状态机的输入事件流（日志流），都比存储状态机本身更容易。</p>
<p>基于这种思路，可以把状态机扩展为复制状态机。状态机的原理是：一样的初始状态+一样的输入事件&#x3D;一样的最终状态。因此，要保证多个Node的状态完全一致，只要保证多个Node的日志流是一样的即可！即使这个Node宕机，只需重启和重放日志流，就能恢复之前的状态，如图1012所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-001253.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210228-001253.jpg"></p>
<p>因此，就回到了上文最后的问题：复制日志！复制日志&#x3D;复制任何数据（复制任何状态机）。因为任何复杂的数据（状态机）都可以通过日志生成！</p>
<h4 id="一个朴素而深刻的思想"><a href="#一个朴素而深刻的思想" class="headerlink" title="一个朴素而深刻的思想"></a>一个朴素而深刻的思想</h4><p><code>Paxos</code>的出现先经过了<code>Basic Paxos</code>的形式化证明，之后再有<code>Multi Paxos</code>，最后是应用场景。因为最开始没有先讲应用场景，所以直接看<code>Basic Paxos</code>的证明会很晦涩。本文将反过来，就以上文最后提出的问题为例，先介绍应用场景，再一步步倒推出<code>Paxos</code>和<code>Multi Paxos</code>。</p>
<p>当三个客户端并发地发送三个请求时，图118所示的6种可能的结果都是对的。因此，要找一种算法保证虽然每个客户端是并发地发送请求，但最终三个Node记录的日志的顺序是相同的，也就是图108所示的任取一种场景即可。</p>
<p>这里提出一个朴素而深刻的说法：全世界对数字1，2，3，4，5，……顺序的认知是一样的！所有人、所有机器，对这个的认知都是一样的！</p>
<p>当我说2的时候，全世界的人，都知道2排在1的后面、3的前面！2代表一个位置，这个位置一定在（1，3）之间。</p>
<p>把这个朴素的想法应用到计算机里面多个Node之间复制日志，会变成如下这样。当Node1收到X&#x3D;1的请求时，假设要把它存放到日志中1号位置，存放前先询问另外两台机器1号位置是否已经存放了X&#x3D;3或X&#x3D;5；如果1号位置被占了，则询问2号位置……依此类推。如果1号位置没有被占，就把X&#x3D;1存放到1号位置，同时告诉另外两个Node，把X&#x3D;1存放到它们各自的1号位置！同样，Node2和Node3按此执行。</p>
<p>这里的关键思想是：虽然每个Node接收到的请求顺序不同，但它们对于日志中1号位置、2号位置、3号位置的认知是一样的，大家一起保证1号位置、2号位置、3号位置存储的数据一样！</p>
<p>在例子中可以看到，每个Node在存储日志之前先要问一下其他Node，之后再决定把这条日志写到哪个位置。这里有两个阶段：先问，再做决策，也就是<code>Paxos</code>2PC的原型！</p>
<p>把问题进一步拆解，不是复制三条日志，只复制一条。先确定三个Node的第1号日志，看有什么问题？</p>
<p>Node1询问后发现1号位置没有被占，因此它打算把X&#x3D;1传播给Node2和Node3；同一时刻，Node2询问后发现1号位置也没有被占，因此它打算把X&#x3D;3传播给Node1和Node3；同样，Node3也打算把X&#x3D;5传播给Node1和Node2。</p>
<p>结果不就冲突了吗？会发现不要说多条日志，就算是只确定第1号位置的日志，都是个问题！</p>
<p>而Basic<code>Paxos</code>正是用来解决这个问题的。</p>
<p>首先，1号位置要么被Node1占领，大家都存放X&#x3D;1；要么被Node2占领，大家都存放X&#x3D;3；要么是被Node3占领，大家都存放X&#x3D;5，少数服从多数！为了达到这个目的，Basic<code>Paxos</code>提出了一个方法，这个方法包括两点：</p>
<p>第1，Node1在填充1号位置的时候，发现1号位置的值被大多数确定了，比如是X&#x3D;5（node3占领了1号位置，Node2跟从了Node3），则Node1就接受这个事实：1号位置不能用了，也得把自己的1号位置赋值成X&#x3D;5。然后看2号位置能否把X&#x3D;1存进去。同样地，如果2号也被占领了，就只能把它们的值拿过来填在自己的2号位置。只能再看3号位置是否可行……</p>
<p>第2，当发现1号位置没有被占，就锁定这个位置，不允许其他Node再占这个位置！除非它的权利更大。如果发现1号位置为空，在提交的时候发现1号位置被其他Node占了，就会提交失败，重试，尝试第二个位置，第三个位置……</p>
<p>所以，为了让1号位置日志一样，可能要重试好多次，每个节点都会不断重试2PC。这样不断重试2PC，直到最终各方达成一致的过程，就是<code>Paxos</code>协议执行的过程，也就是一个<code>Paxos</code>instance，最终确定一个值。而Multi<code>Paxos</code>就是重复这个过程，确定一系列值，也就是日志中的每一条！</p>
<p>接下来将基于这种思想详细分析<code>Paxos</code>算法本身。</p>
<h4 id="BasicPaxos算法"><a href="#BasicPaxos算法" class="headerlink" title="BasicPaxos算法"></a>Basic<code>Paxos</code>算法</h4><p>在前面的场景中提到三个Client并发地向三个Node发送三条写指令。对应到<code>Paxos</code>协议，就是每个Node同时充当了两个角色：Proposer和Acceptor。在实现过程中，一般这两个角色是在同一个进程里面的。</p>
<p>当Node1收到Client1发送的X&#x3D;1的指令时，Node1就作为一个Proposer向所有的Acceptor（自己和其他两个Node）提议把X&#x3D;1日志写到三个Node上面。</p>
<p>同理，当Node2收到Client2发送的X&#x3D;3的指令，Node2就作为一个Proposer向所有的Acceptor提议；Node3同理。</p>
<p>下面详细阐述<code>Paxos</code>的算法细节。首先，每个Acceptor需要持久化三个变量（minProposalId，acceptProposalId，acceptValue）。在初始阶段：minProposalId&#x3D;acceptProposalId&#x3D;0，acceptValue&#x3D;null。然后，算法有两个阶段：P1（Prepare阶段）和P2（Accept阶段）。</p>
<h5 id="P1（Prepare阶段）"><a href="#P1（Prepare阶段）" class="headerlink" title="P1（Prepare阶段）"></a>P1（Prepare阶段）</h5><p><img src="http://static.cyblogs.com/Jietu20210227-234242.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210227-234242.jpg"></p>
<p>Prepare阶段P1a：Proposer广播prepare（n），其中n是本机生成的一个自增ID，不需要全局有序，比如可以用时间戳+IP。P1b：Acceptor收到prepare（n），做如下决策：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n &gt; minProposalId，回复Yes</span><br><span class="line">	同时，minProposalId=n（持久化）</span><br><span class="line">	返回(acceptProposalId，acceptValue)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	回复 No</span><br></pre></td></tr></table></figure>

<p>P1c：Proposer如果收到半数以上的yes，则取acceptorProposalId最大的acceptValue作为v，进入第二个阶段，即开始广播accept（n，v）。如果acceptor返回的都是null，则取自己的值作为v，进入第二个阶段！否则，n自增，重复P1a。</p>
<h5 id="P2（Accept阶段）"><a href="#P2（Accept阶段）" class="headerlink" title="P2（Accept阶段）"></a>P2（Accept阶段）</h5><p><img src="http://static.cyblogs.com/Jietu20210227-234722.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210227-234722.jpg"></p>
<p>P2a：Proposer广播accept（n，v）。这里的n就是P1阶段的n，v可能是自己的值，也可能是第1阶段的acceptValue。P2b：Acceptor收到accept（n，v），做如下决策：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n &gt; minProposalId，回复Yes。同时</span><br><span class="line">	minProposalId=acceptProposalId=n（持久化）</span><br><span class="line">	acceptValue=value</span><br><span class="line">	<span class="keyword">return</span> minProposalId</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	回复 No</span><br></pre></td></tr></table></figure>

<p>P2c：Proposer如果收到半数以上的yes，并且minProposalId&#x3D;n，则算法结束。否则，n自增，重复P1a。</p>
<p>通过分析算法，会发现Basic<code>Paxos</code>有两个问题：</p>
<p>（1）<code>Paxos</code>是一个“不断循环”的2PC。在P1C或者P2C阶段，算法都可能失败，重新进行P1a。这就是通常所说的“活锁”问题，即可能陷入不断循环。</p>
<p>（2）每确定一个值，至少需要两次RTT（两个阶段，两个网络来回）+两次写盘，性能也是个问题。而接下来要讲的Multi<code>Paxos</code>就是要解决这两个问题。</p>
<h4 id="MultiPaxos算法"><a href="#MultiPaxos算法" class="headerlink" title="MultiPaxos算法"></a>Multi<code>Paxos</code>算法</h4><h5 id="问题1：活锁问题"><a href="#问题1：活锁问题" class="headerlink" title="问题1：活锁问题"></a>问题1：活锁问题</h5><p>在前面已经知道，Basic<code>Paxos</code>是一个不断循环的2PC。所以如果是多个客户端写多个机器，每个机器都是Proposer，会导致并发冲突很高，也就是每个节点都可能执行多次循环才能确定一条日志。极端情况是每个节点都在无限循环地执行2PC，也就是所谓的“活锁问题”。</p>
<p>为了减少并发冲突，可以变多写为单写，选出一个Leader，只让Leader充当Proposer。其他机器收到写请求，都把写请求转发给Leader；或者让客户端把写请求都发给Leader。</p>
<p>Leader的选举方法很多，下面列举两种：</p>
<p><strong>方案1：无租约的Leader选举</strong></p>
<p>Lamport在他的论文中给出了一个Leader选举的简单算法，算法如下：</p>
<p>（1）每个节点有一个编号，选取编号最大的节点为Leader；</p>
<p>（2）每个节点周期性地向其他节点发送心跳，假设周期为Tms；</p>
<p>（3）如果一个节点在最近的2Tms内还没有收到比自己编号更大的节点发来的心跳，则自己变为Leader；</p>
<p>（4）如果一个节点不是Leader，则收到请求之后转发给Leader。可以看出，这个算法很简单，但因为网络超时原因，很可能出现多个Leader，但这并不影响Multi<code>Paxos</code>协议的正确性，只是增大并发写冲突的概率。我们的算法并不需要强制保证，任意时刻只能有一个Leader。</p>
<p><strong>方案2：有租约的Leader选举</strong></p>
<p>另外一种方案是严格保证任意时刻只能有一个leader，也就是所谓的“租约”。租约的意思是在一个限定的期限内，某台机器一直是Leader。即使这个机器宕机，Leader也不能切换。必须等到租期到期之后，才能开始选举新的Leader。这种方式会带来短暂的不可用，但保证了任意时刻只会有一个Leader。具体实现方式可以参见<code>Paxos</code>Lease。</p>
<h5 id="问题2：性能问题"><a href="#问题2：性能问题" class="headerlink" title="问题2：性能问题"></a>问题2：性能问题</h5><p>我们知道Basic<code>Paxos</code>是一个无限循环的2PC，一条日志的确认至少需要两个RTT+两次落盘（一次是Prepare的广播与回复，一次是Accept的广播与回复）。如果每条日志都要两个RTT+两次落盘，这个性能就很差了。而Multi<code>Paxos</code>在选出Leader之后，可以把2PC优化成1PC，也就只需要一个RTT+一次落盘了。</p>
<p>基本思路是当一个节点被确认为Leader之后，它先广播一次Prepare，一旦超过半数同意，之后对于收到的每条日志直接执行Accept操作。在这里，Perpare不再是对一条日志的控制了，而是相对于拿到了整个日志的控制权。一旦这个Leader拿到了整个日志的控制权，后面就直接略过Prepare，直接执行Accept。</p>
<p>如果有新的Leader出现怎么办呢？新的Leader肯定会先发起Prepare，导致minProposalId变大。这时旧的Leader的广播Accept肯定会失败，旧的Leader会自己转变成一个普通的Acceptor，新的Leader把旧的顶替掉了。</p>
<p>下面是具体的实现细节：在Basic<code>Paxos</code>中，2PC的具体参数形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepare(n)</span><br><span class="line">accept(n,v)</span><br></pre></td></tr></table></figure>

<p>在Multi<code>Paxos</code>中，增加一个日志的index参数，即变成了如下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepare(n,index)</span><br><span class="line">accept(n,v,index)</span><br></pre></td></tr></table></figure>

<h5 id="问题3：被choose的日志，状态如何同步给其他机器"><a href="#问题3：被choose的日志，状态如何同步给其他机器" class="headerlink" title="问题3：被choose的日志，状态如何同步给其他机器"></a>问题3：被choose的日志，状态如何同步给其他机器</h5><p>对于一条日志，当Proposer（也就是Leader）接收到多数派对Accept请求的同意后，就知道这条日志被“choose”了，也就是被确认了，不能再更改！</p>
<p>但只有Proposer知道这条日志被确认了，其他的Acceptor并不知道这条日志被确认了。如何把这个信息传递给其他Accepotor呢？</p>
<p><strong>方案1：Proposer主动通知</strong></p>
<p>给accept再增加一个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept(n,v,index,firstUnchooseIndex)</span><br></pre></td></tr></table></figure>

<p>Proposer在广播accept的时候，额外带来一个参数firstUnchosenIndex&#x3D;7。意思是7之前的日志都已经“choose”了。Acceptor收到这种请求后，检查7之前的日志，如果发现7之前的日志符合以下条件：acceptedProposal[i]&#x3D;&#x3D;request.proposal（也就是第一个参数n），就把该日志的状态置为choose。</p>
<p><strong>解决方案2：Acceptor被动查询</strong></p>
<p>当一个Acceptor被选为Leader后，对于所有未确认的日志，可以逐个再执行一遍<code>Paxos</code>，来判断该条日志被多数派确</p>
<p>认的值是多少。</p>
<p>因为Basic<code>Paxos</code>有一个核心特性：一旦一个值被确定后，无论再执行多少遍<code>Paxos</code>，该值都不会改变！因此，再执行1遍<code>Paxos</code>，相当于向集群发起了一次查询！</p>
<p>至此，Multi<code>Paxos</code>算法就介绍完了。回顾这个算法，有两个精髓：</p>
<p><strong>精髓之1：一个强一致的“P2P网络”</strong></p>
<p>任何一条日志，只有两种状态（choose，unchoose）。当然，还有一种状态就是applied，也就是被确认的日志被apply到状态机。这种状态跟<code>Paxos</code>协议关系不大。</p>
<p>choose状态就是这条日志，被多数派接受，不可更改；</p>
<p>unchoose就是还不确定，引用阿里OceanBase团队某工程师的话，就是“薛定谔的猫”，或者“最大commit原则”。一条unchoose的日志可能是已经被choose了，只是该节点还不知道；也可能是还没有被choose。要想确认，那就再执行一次<code>Paxos</code>，也就是所谓的“最大commit原则”。</p>
<p>整个Multi<code>Paxos</code>就是类似一个P2P网络，所有节点互相双向同步，对所有unchoose的日志进行不断确认的过程！在这个网络中可以出现多个Leader，可能出现多个Leader来回切换的情况，这都不影响算法的正确性！</p>
<p><strong>精髓之2：“时序”</strong></p>
<p>Multi<code>Paxos</code>保证了所有节点的日志顺序一模一样，但对于每个节点自身来说，可以认为它的日志并没有所谓的“顺序”。什么意思呢？</p>
<p>（1）假如一个客户端连续发送了两条日志a，b（a没有收到回复，就发出了b）。对于服务器来讲，存储顺序可能是a、b，也可能是b、a，还可能在a、b之间插入了其他客户端发来的日志！</p>
<p>（2）假如一个客户端连续发送了两条日志a、b（a收到回复之后，再发出的b）。对于服务器来讲，存储顺序可能是a、b；也可能是a、xxx、b（a与b之间插入了其他客户端的日志），但不会出现b在a的前面。</p>
<p>所以说，所谓的“时序”，只有在单个客户端串行地发送日志时，才有所谓的顺序。多个客户端并发地写，服务器又是并发地对每条日志执行<code>Paxos</code>，整体看起来就没有所谓的“顺序”。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li>文章摘自《软件架构设计》余春龙&#x2F;著</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2021/02/19/2021/02/%E6%8B%A5%E6%9C%89%E4%B8%80%E5%A5%97%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/19/2021/02/%E6%8B%A5%E6%9C%89%E4%B8%80%E5%A5%97%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">拥有一套属于自己的Spring源码环境</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-19T00:00:00+08:00">2021-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 10:05:09" itemprop="dateModified" datetime="2025-06-25T10:05:09+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Spring</code>是一个非常优秀的开源项目，而且基本是互联网的标配。随着这几年的源码阅读习惯，有用一套自己的源码阅读笔记项目已经是水到渠成。今天就来在本地编译一份，以便于后面记录核心笔记用。</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><h5 id="1-准备好源代码"><a href="#1-准备好源代码" class="headerlink" title="1.准备好源代码"></a>1.准备好源代码</h5><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework">https://spring.io/projects/spring-framework</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/mirrors/Spring-Framework">https://gitee.com/mirrors/Spring-Framework</a> (推荐，毕竟速度快，而且每天会跟<code>github</code>同步一次)</li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/vernon/Spring-Framework">https://gitee.com/vernon/Spring-Framework</a> (为了自己可以提交代码，必须要<code>fork</code>一份)</li>
</ul>
<p>为什么贴这些<code>url</code>地址，是因为提醒我们所有人，官网与<code>github</code>是我们最先关注的地方。</p>
<p><code>gradle.properties</code></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version</span>=<span class="string">5.3.5-SNAPSHOT</span></span><br><span class="line"><span class="attr">org.gradle.jvmargs</span>=<span class="string">-Xmx1536M</span></span><br><span class="line"><span class="attr">org.gradle.caching</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">org.gradle.parallel</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">kotlin.stdlib.default.dependency</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>从上面可以看出来，我们现在用到是<code>spring 5.3.5-SNAPSHOT</code>版本。后面会遇到一些编译问题，避免大家踩坑，我直接说。这里依赖的JDK需要在JDK11。</p>
<h5 id="2-JDK准备"><a href="#2-JDK准备" class="headerlink" title="2.JDK准备"></a>2.JDK准备</h5><p>下载<code>JDK11</code>的版本：<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html">https://www.oracle.com/java/technologies/javase-jdk11-downloads.html</a></p>
<p>但是，但是，但是官网的实在是太慢了，所以我这里就直接改为<code>openjdk11</code>了。传送门：<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/">https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/</a> 下载速度就看你家里的带宽了，我基本在<code>3M+</code>左右~ </p>
<p><img src="http://static.cyblogs.com/Jietu20210219-223632.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210219-223632.jpg"></p>
<p>没有对比就没有伤害啊。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-223756.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210219-223756.jpg"></p>
<p>配置好项目中使用的<code>JDK</code>版本，这边因为诉求不一样，平时基本还是用的<code>JDK8</code>。</p>
<h5 id="3-Gradle安装"><a href="#3-Gradle安装" class="headerlink" title="3.Gradle安装"></a>3.Gradle安装</h5><p>因为我这里是<code>Mac</code>系统，所以一般的软件我都会采用<code>brew</code>来实现，因为实在太方便了。一行命令搞定~</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gradle</span><br></pre></td></tr></table></figure>

<p>下面是我安装的gradle信息，是最新的版本6.7。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gradle -v</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 6.7</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Build time:   2020-10-14 16:13:12 UTC</span><br><span class="line">Revision:     312ba9e0f4f8a02d01854d1ed743b79ed996dfd3</span><br><span class="line">Kotlin:       1.3.72</span><br><span class="line">Groovy:       2.5.12</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.8 compiled on May 10 2020</span><br><span class="line">JVM:          1.8.0_172 (Oracle Corporation 25.172-b11)</span><br><span class="line">OS:           Mac OS X 10.15.7 x86_64</span><br></pre></td></tr></table></figure>

<h5 id="4-Intellij-IDEA-2020"><a href="#4-Intellij-IDEA-2020" class="headerlink" title="4.Intellij IDEA 2020"></a>4.Intellij IDEA 2020</h5><p>因为<code>spring</code>在代码中有对<code>Kotlin</code>有一些依赖（低版本的可能会出现依赖问题），建议搭建升级到比价新的版本。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-224353@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210219-224353@2x.jpg"></p>
<h4 id="构建源码"><a href="#构建源码" class="headerlink" title="构建源码"></a>构建源码</h4><p>因为<code>spring</code>依赖与<code>gradle</code>，而且都是国外的网站，相对来说网速会非常的慢。这里也是采用更换镜像的方式来加速处理。</p>
<p><code>build.gradle</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">	<span class="comment">// 优先本地</span></span><br><span class="line">	mavenLocal()</span><br><span class="line">	maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/nexus/content/groups/public/&#x27;</span> &#125; <span class="comment">//阿里云</span></span><br><span class="line">	maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;</span> &#125;</span><br><span class="line">	maven &#123; url <span class="string">&quot;https://repo.spring.io/snapshot&quot;</span> &#125; <span class="comment">// Reactor</span></span><br><span class="line"></span><br><span class="line">	mavenCentral()</span><br><span class="line">	maven &#123; url <span class="string">&quot;https://repo.spring.io/libs-spring-framework-build&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>settings.gradle</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">	<span class="comment">// 新增配置</span></span><br><span class="line">	maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/nexus/content/groups/public/&#x27;</span> &#125; <span class="comment">//阿里云</span></span><br><span class="line">	maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/nexus/content/repositories/jcenter&#x27;</span> &#125;</span><br><span class="line">	maven &#123; url <span class="string">&quot;https://repo.spring.io/snapshot&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">	gradlePluginPortal()</span><br><span class="line">	maven &#123; url <span class="string">&#x27;https://repo.spring.io/plugins-release&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置一下<code>gradle</code>的参数</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-224901.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210219-224901.jpg"></p>
<h4 id="构建成功验证"><a href="#构建成功验证" class="headerlink" title="构建成功验证"></a>构建成功验证</h4><p>找到<code>ApplicationContext</code>接口，显示它的一个类关系图。如果出现下图所示类图界面说明构建成功了！(构建过程就是找依赖对象的过程)</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-173001@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210219-173001@2x.jpg"></p>
<h4 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h4><p>查看官方<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/import-into-idea.md">import-into-idea.md</a>文档，如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Precompile spring-oxm with ./gradlew :spring-oxm:compileTestJava</span><br><span class="line">2.Import into IntelliJ (File -&gt; New -&gt; Project from Existing Sources -&gt; Navigate to directory -&gt; Select build.gradle)</span><br><span class="line">3.When prompted exclude the spring-aspects module (or after the import via File-&gt; Project Structure -&gt; Modules)</span><br><span class="line">4.Code away</span><br></pre></td></tr></table></figure>

<h5 id="1-编译spring-oxm模块"><a href="#1-编译spring-oxm模块" class="headerlink" title="1.编译spring-oxm模块"></a>1.编译spring-oxm模块</h5><p>先编译<code>spring-oxm</code>下的<code>compileTestjava</code>，点击右上角<code>gradle</code>打开编译视图，找到<code>spring-oxm</code>模块，然后在<code>other</code>下找到<code>compileTestjava</code>，双击即可！</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-225904.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210219-225904.jpg"></p>
<h5 id="2-编译spring-core模块"><a href="#2-编译spring-core模块" class="headerlink" title="2.编译spring-core模块"></a>2.编译spring-core模块</h5><p>利用同样的方式，编译<code>spring-core</code>模块，出现<code>BUILD SUCCESSFUL</code>代码成功。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-230123.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210219-230123.jpg"></p>
<h5 id="3-都编译完成且成功之后，开始编译整个工程"><a href="#3-都编译完成且成功之后，开始编译整个工程" class="headerlink" title="3.都编译完成且成功之后，开始编译整个工程"></a>3.都编译完成且成功之后，开始编译整个工程</h5><p>打开右侧<code>Gradle</code>插件 <code>spring-&gt;build-&gt;build</code>。<br>编译时间，每个人电脑的性能不一样，所需时间也不一样。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-231519.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210219-231519.jpg"></p>
<p>我这里基本上全部成功，但是在<code>Task :spring-webflux:test</code>模块有一个<code>test</code>跑失败。算是有一点小瑕疵，但不影响整个编译。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-231701.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210219-231701.jpg"></p>
<h4 id="源码测试"><a href="#源码测试" class="headerlink" title="源码测试"></a>源码测试</h4><p>构建成功了，源码编译成功了，能否用还不知道，还要测试通过才说明源码可以用了。直接在<code>spring-context</code>里面创建我们的一个<code>service</code>，然后通过<code>ApplicationContext</code>去获取它，并执行它的一个方法。</p>
<p><img src="http://static.cyblogs.com/Jietu20210220-090140.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210220-090140.jpg"></p>
<p>代码部分我已经<code>push</code>上去了：<a target="_blank" rel="noopener" href="https://gitee.com/vernon/Spring-Framework%EF%BC%8C%E5%90%8E%E7%BB%AD%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%87%AA%E7%94%B1%E8%87%AA%E5%9C%A8%E7%9A%84%E5%9C%A8%E4%B8%8A%E9%9D%A2%E6%A0%87%E6%B3%A8%E4%BB%A5%E5%8F%8A%E9%AA%8C%E8%AF%81%E4%BA%86%E3%80%82">https://gitee.com/vernon/Spring-Framework，后续就可以自由自在的在上面标注以及验证了。</a> </p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44730681/article/details/107390331">https://blog.csdn.net/weixin_44730681/article/details/107390331</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/122732323">https://zhuanlan.zhihu.com/p/122732323</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2021/01/31/2021/01/Redis%E4%BA%8C%E5%80%BC%E7%8A%B6%E6%80%81%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/31/2021/01/Redis%E4%BA%8C%E5%80%BC%E7%8A%B6%E6%80%81%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Redis二值状态统计的巧妙使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-31 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-31T00:00:00+08:00">2021-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 10:05:09" itemprop="dateModified" datetime="2025-06-25T10:05:09+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h4><p>这里的二值状态就是指集合元素的取值就只有 0 和 1 两种。在签到打卡的场景中，我们只用记录：</p>
<ul>
<li>签到（1）</li>
<li>未签到（0）</li>
</ul>
<p>所以它就是非常典型的二值状态，在签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p>
<p>这个时候，我们就可以选择 <code>Bitmap</code>。这是 <code>Redis</code> 提供的扩展数据类型。我来给你解释一下它的实现原理。<code>Bitmap</code> 本身是用 <code>String</code> 类型作为底层数据结构实现的一种统计二值状态的数据类型。<code>String</code> 类型是会保存为二进制的字节数组，所以，<code>Redis</code> 就把字节数组的每个 <code>bit</code> 位利用起来，用来表示一个元素的二值状态。</p>
<p>你可以把 <code>Bitmap</code> 看作是一个 <code>bit</code> 数组。<code>Bitmap</code> 提供了 <code>GETBIT/SETBIT</code> 操作，使用一个偏移值 <code>offset</code> 对 <code>bit</code> 数组的某一个 <code>bit</code> 位进行读和写。不过，需要注意的是，<code>Bitmap</code> 的偏移量是从 0 开始算的，也就是说 <code>offset</code> 的最小值是 0。当使用 <code>SETBIT</code> 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。</p>
<p>Bitmap 还提供了 <code>BITCOUNT</code> 操作，用来统计这个 bit 数组中所有“1”的个数。那么，具体该怎么用 <code>Bitmap</code> 进行签到统计呢？我还是借助一个具体的例子来说明。</p>
<h4 id="统计一个人签到"><a href="#统计一个人签到" class="headerlink" title="统计一个人签到"></a>统计一个人签到</h4><p>假设我们要统计 <code>ID 3000</code> 的用户在 2020 年 8 月份的签到情况，就可以按照下面的步骤进行操作。</p>
<ul>
<li><p>第一步，执行下面的命令，记录该用户 8 月 3 号已签到。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT uid:sign:3000:202008 2 1 </span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，检查该用户 8 月 3 日是否签到。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT uid:sign:3000:202008 2 </span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步，统计该用户在 8 月份的签到次数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT uid:sign:3000:202008</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样，我们就知道该用户在 8 月份的签到情况了，是不是很简单呢？</p>
<h4 id="1-亿个用户-10-天的签到"><a href="#1-亿个用户-10-天的签到" class="headerlink" title="1 亿个用户 10 天的签到"></a>1 亿个用户 10 天的签到</h4><p>接下来，你可以再思考一个问题：如果记录了 1 亿个用户 10 天的签到情况，你有办法统计出这 10 天连续签到的用户总数吗？</p>
<p>在介绍具体的方法之前，我们要先知道，<code>Bitmap</code> 支持用 <code>BITOP</code> 命令对多个 <code>Bitmap</code> 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 <code>Bitmap</code> 中。</p>
<p>我以按位“与”操作为例来具体解释一下。从下图中，可以看到，三个 <code>Bitmap</code>： <code>bm1</code>、<code>bm2</code> 和 <code>bm3</code>，对应 bit 位做“与”操作，结果保存到了一个新的 Bitmap 中（示例中，这个结果 Bitmap 的 key 被设为“resmap”）。</p>
<p><img src="https://static001.geekbang.org/resource/image/41/7a/4151af42513cf5f7996fe86c6064f97a.jpg" alt="https:&#x2F;&#x2F;static001.geekbang.org&#x2F;resource&#x2F;image&#x2F;41&#x2F;7a&#x2F;4151af42513cf5f7996fe86c6064f97a.jpg"></p>
<p>回到刚刚的问题，在统计 1 亿个用户连续 10 天的签到情况时，你可以把每天的日期作为 key，每个 key 对应一个 1 亿位的 <code>Bitmap</code>，每一个 bit 对应一个用户当天的签到情况。</p>
<p>接下来，我们对 10 个 <code>Bitmap</code> 做“与”操作，得到的结果也是一个 <code>Bitmap</code>。在这个 <code>Bitmap</code> 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。最后，我们可以用 <code>BITCOUNT</code> 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。</p>
<p>现在，我们可以计算一下记录了 10 天签到情况后的内存开销。每天使用 1 个 1 亿位的 <code>Bitmap</code>，大约占 <code>12MB</code> 的内存（10^8&#x2F;8&#x2F;1024&#x2F;1024），10 天的 <code>Bitmap</code> 的内存开销约为 <code>120MB</code>，内存压力不算太大。不过，在实际应用时，最好对 Bitmap 设置过期时间，让 <code>Redis</code> 自动删除不再需要的签到记录，以节省内存开销。</p>
<p>所以，如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。在记录海量数据时，<code>Bitmap</code> 能够有效地节省内存空间。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/280680">https://time.geekbang.org/column/article/280680</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2021/01/27/2021/01/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BMYSQL%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E5%BA%93Sakila/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/27/2021/01/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BMYSQL%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E5%BA%93Sakila/" class="post-title-link" itemprop="url">了解一下MYSQL官方数据库Sakila</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-27 00:00:00" itemprop="dateCreated datePublished" datetime="2021-01-27T00:00:00+08:00">2021-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 10:05:09" itemprop="dateModified" datetime="2025-06-25T10:05:09+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>我们通过Docker快速的拉取一个环境，这样子对于学习来说成本比价低。直接参照<a target="_blank" rel="noopener" href="https://hub.docker.com/r/mysql/mysql-server/">https://hub.docker.com/r/mysql/mysql-server/</a> 来做就好了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">快速拉取一个mysql的image</span></span><br><span class="line">➜  ~ docker pull mysql/mysql-server</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from mysql/mysql-server</span><br><span class="line">501550cfd5c0: Pull complete</span><br><span class="line">e0509d775110: Pull complete</span><br><span class="line">d5a01765d011: Pull complete</span><br><span class="line">970507e942eb: Pull complete</span><br><span class="line">Digest: sha256:0bb21c0f1aa9296e7deafacec5703b80e4d923dfdfcaa2efbe0c8377a8592128</span><br><span class="line">Status: Downloaded newer image for mysql/mysql-server:latest</span><br><span class="line">docker.io/mysql/mysql-server:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动mysql容器</span></span><br><span class="line">➜  ~ docker run --name=mysql1 -d mysql/mysql-server:latest</span><br><span class="line">780c312f6fa1d3b001cb7c97fddb7df39fea61f27732b5fb9b59d5a29b12cfde</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看CONTAINER</span></span><br><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS                       NAMES</span><br><span class="line">780c312f6fa1        mysql/mysql-server:latest   &quot;/entrypoint.sh mysq…&quot;   59 seconds ago      Up 58 seconds (healthy)   3306/tcp, 33060-33061/tcp   mysql1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看默认的密码</span></span><br><span class="line">➜  ~ docker logs mysql1 2&gt;&amp;1 | grep GENERATED</span><br><span class="line">[Entrypoint] GENERATED ROOT PASSWORD: enohmYS*ecvISAqYh@GafRoDP3v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接登录进去</span></span><br><span class="line">➜  ~ docker exec -it mysql1 mysql -uroot -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 17</span><br><span class="line">Server version: 8.0.23</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改一下容易记忆的密码，方便下次来使用</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>这是我认为非常快速的一个环境搭建的方式。</p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>一般像Orace、MySQL这些好的软件都会提供一些官网的数据来让方便学习着来学习。<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/index-about.html">https://dev.mysql.com/doc/index-about.html</a> </p>
<p><img src="http://static.cyblogs.com/Jietu20210127-205659@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210127-205659@2x.jpg"></p>
<p>那我们就下载<code>sakila database</code>来学习一下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show tables;</span></span><br><span class="line">+----------------------------+</span><br><span class="line">| Tables_in_sakila           |</span><br><span class="line">+----------------------------+</span><br><span class="line">| actor                      |//演员表</span><br><span class="line">| address                    |//地址表</span><br><span class="line">| category                   |//影片的分类</span><br><span class="line">| city                       |//城市信息</span><br><span class="line">| country                    |//国家信息</span><br><span class="line">| customer                   |//观看影片的用户信息</span><br><span class="line">| film                       |//影片信息</span><br><span class="line">| film_actor                 |//影片演员关联表</span><br><span class="line">| film_category              |//影片分类关联表</span><br><span class="line">| film_text                  |//影片的文本信息，更新film的时候通过触发器保持film_text的同步</span><br><span class="line">| inventory                  |//库存信息</span><br><span class="line">| language                   |//影片的语言</span><br><span class="line">| payment                    |//租赁付款信息</span><br><span class="line">| rental                     |//某个影片库存的租赁信息</span><br><span class="line">| staff                      |//商店员工信息</span><br><span class="line">| store                      |//影片的商店信息</span><br><span class="line">+----------------------------+</span><br><span class="line">22 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>整体的来看一下数据的一个关系</p>
<p><img src="http://static.cyblogs.com/sakila.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;sakila.png"></p>
<h4 id="通过Sakila了解一些索引问题"><a href="#通过Sakila了解一些索引问题" class="headerlink" title="通过Sakila了解一些索引问题"></a>通过Sakila了解一些索引问题</h4><p><img src="http://static.cyblogs.com/Jietu20210127-213735.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20210127-213735.jpg"></p>
<p>这里会有一个非常奇怪的问题，就是第一条sql竟然走了<code>idx_actor_last_name</code>索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>可以理解为是走的B+树，叶子节点里面刚好存储的是主键，而主键刚好是actor_id，select的时候刚好是主键一个值吗？</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50682992">https://zhuanlan.zhihu.com/p/50682992</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/12/31/2020/12/%E5%86%99%E5%9C%A82020%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/31/2020/12/%E5%86%99%E5%9C%A82020%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/" class="post-title-link" itemprop="url">写在2020年最后一天</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-31 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-31T00:00:00+08:00">2020-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 10:05:09" itemprop="dateModified" datetime="2025-06-25T10:05:09+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">总结</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>2020年，感觉真的是一个不平凡的年。是时间流逝非常快的一年，也是成长最快的一年。感谢身边所有的人~</p>
<h4 id="谈口罩"><a href="#谈口罩" class="headerlink" title="谈口罩"></a>谈口罩</h4><p>还记得年初的时候，怕被疫情隔在家里了，正月初三就开车到了深圳。那时候听新闻说可能要带半年或者一年的口罩，当时感觉不可思议，根本不可能。现在一年已经已经过去了，但口罩还依然要继续……</p>
<p>说到口罩，记得刚刚开始在老家带口罩的时候，家里好多人不理解，为什么要戴口罩？（估计跟很多老美一样，觉得不尊重，觉得自己没病等）到了“恐慌”的时候，家里人比我们更着急，更加上心。在这次疫情中，真的也是感受到了人间百态，看到了白衣天使的伟大，看到了一些黑心的商家，看到了那些平凡的人做着不平凡的事儿，感受到了近些年来祖国的伟大（非常感谢国内短视频）。</p>
<p>今年给我最大的感受是繁忙、成长、充实，总的来说是收获的一年吧。</p>
<h4 id="写作与公众号"><a href="#写作与公众号" class="headerlink" title="写作与公众号"></a>写作与公众号</h4><p>年初的时候开启了我的个人公共账号「简栈文化」，一共发表了文章112篇，几乎全部都是跟技术相关的，在编写与梳理这些知识的时候，内心是充满热情与喜悦的。特别是大家去催更的时候，或者有问题请教你的时候，跟你讨论的时候，所有的熬夜与辛苦都是值得的，因为你获得的知识与朋友。后面也是因为工作原因，更新就慢慢的停了下来，但内心一直牵挂着写作这件事儿。</p>
<h4 id="谈工作"><a href="#谈工作" class="headerlink" title="谈工作"></a>谈工作</h4><p>今年可以说自己是换了工作，也可以说自己没有换工作，因为做的事情不同了，从楼上换到了楼下，但最大的老板还是同样的老板。不过，还是真的很感谢保险与国际的同事，都给了我很大的帮助、鼓励、肯定。在保险从事的是信贷相关的业务，从小白变成了有一丝丝信贷经验的从业者，也有着自己的小团队，而且氛围非常好，非常的优秀。到国际做的是证券业务，团队又是从0开始搭建，业务又不是很熟悉，感觉一下突然回到了4年前。经过了4个月左右的时间，终于又把团队搭建起来了，同时也在努力的去学习业务与技术。更重要的，我自己对自己的要求更高了，想做的更好。这次的团队跟之前一样，无可挑剔，更加的棒~</p>
<h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>这一年虽然看的书籍不是特别多（差不多12本），但是因为这一年的写作原因，内心是非常愿意静下来去好好看一本的。不管是技术的书籍，还是人物传记的书籍，总能在从中学到一些东西，哪怕只有其中只有某一句话、一件事儿、一个技术难点、一个技巧也是非常开心的。现在看书主要是在Kindle上面，技术书籍就会买纸质版本的，非常棒的书籍纸质版与电子版都买，还是为了图方便。不管如何，只要找到自己喜欢的方式，做任何事情都是对的~</p>
<h4 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h4><p>这一年，跟我老婆吵架非常的少，但记忆中好像也有这么1<del>2次是比较严重的，但都能很快过去。都说一个成功男人的背后一定有一个优秀的女人，我非常赞同。我觉得在思想上，我家那位比我要强，我是属于追赶她的情况。今年，一起去南京休闲游完了几天，特别喜欢这种慢悠悠，自由自在的旅行。一转眼，我们已经认识了10年，本想2人在很久以前就一直筹划着要过一个非常难忘的10周年，为此要做很多的准备，也是因为工作忙碌的原因，算是过了一个开心的10周年吧。这一年我从以前什么都不管慢慢开始的变为想去用心准备点什么，付出一点什么。为了明年去更多的没有去过的地方，特此还跟我老婆买了南航的随心飞，希望能去更多的地方看看这个美好的世界，去更多的地方打打卡。这几天还对摄影有点兴趣，日后可以好好学习学习</del></p>
<h4 id="健康-保险"><a href="#健康-保险" class="headerlink" title="健康&amp;保险"></a>健康&amp;保险</h4><p>最近2年左右的时间，真的听说了太多太多亲人们身体不好做手术的，家里的老奶奶、舅姥姥等去世的消息。其实人到30~40岁之间，应该是蛮有经济压力的，自己的梦想还有很多未实现，爸爸妈妈的年纪也开始慢慢到了一个体质变弱、疾病变多的情况，所以今年我们为2边的家人都配置了意外险、百万医疗险，为自己也配置了这些，也终于在2020年的最后一天为我们俩配置了重疾险（本来想着买港险的，可这疫情一拖就是一年）。虽然这些保险远远还不够，但是也不用太着急，首先有了基本的保障，后面再慢慢的去添加就好了。起码，真的哪天有意外来临，也不会变得很被动。</p>
<h4 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h4><p>今年一年跟我老婆也获得一些新朋友，特别是公共的朋友。在深圳这个城市，能够找到一些私下要好的朋友是很难的，因为大家的生活节奏都很快，大部分都不认识隔壁的邻居是谁，每天都是很早的去上班，很晚才回家来。如果有一些私下的朋友，节假日的时候可以一起凑个饭局，一起郊游，一起钓个鱼什么的都是一件很幸福的事情。所以，珍惜现在已有的好朋友，结交更多更优秀的人。</p>
<p>我知道立再多的flag也不如把一个flag做好来的重要，我希望自己在2021年里能更多知道自己的内心，知道自己追求的是什么？如何让自己的内心世界丰富起来，如果让自己做任何的事情都不会被别人牵着鼻子走，如何去影响、号召更多的其他人一起来做事。</p>
<p>2021年给自己的目的是：抓重点、求突破、顾家庭。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/12/04/2020/12/Controller%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%86%99%E6%88%90%E4%BA%86private%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/04/2020/12/Controller%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%86%99%E6%88%90%E4%BA%86private%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Controller里面方法不小心写成了private的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-04 00:00:00" itemprop="dateCreated datePublished" datetime="2020-12-04T00:00:00+08:00">2020-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 10:05:09" itemprop="dateModified" datetime="2025-06-25T10:05:09+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><p>今天本来是为了解决一个<code>Apollo</code>配置与<code>Code</code>同时变更不一致问题，我需要去通过<code>SPI</code>的方式去重写<code>Apollo</code>刷新<code>Remote</code>配置。所以，我就写一个很小的<code>DEMO</code>来验证每次变更<code>Apollo</code>配置对我服务端的取数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarketConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;market.test.chenyuan&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String testName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应在<code>Apollo</code>的配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">market.test.name</span> = <span class="string">Test1111</span></span><br></pre></td></tr></table></figure>

<p><code>Controller</code>层的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MarketConfig marketConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/sayHello&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123; <span class="comment">// 注意，这里由于我的不小心写成了private</span></span><br><span class="line">    <span class="keyword">return</span> marketConfig.getMarketTestName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我就发起请求来验证我的取数，结果给我报了<code>NullpointException</code>的异常。因为这种代码几乎每天都在写，一下次说我的<code>Bean</code>没有注入进来，还有点方。</p>
<p>然后，我细心的<code>debug</code>了看了一下。如图所示：</p>
<p><img src="http://static.cyblogs.com/Jietu20201204-085800.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20201204-085800.jpg"></p>
<p>图片可以说明：</p>
<ul>
<li><p><code>Spring</code>容器100%已经存在了<code>MarketConfig</code>的<code>Bean</code>对象；</p>
</li>
<li><p>但是<code>MarketConfig</code>在该<code>Controller</code>里面100%没有注入进来 ；</p>
</li>
<li><p><code>this</code>显示出了一个代理的路径；</p>
<p>于是，我在同样的<code>Controller</code>去请求另外一个<code>Method</code>，但可以正常访问。</p>
</li>
</ul>
<p><img src="http://static.cyblogs.com/Jietu20201204-090305.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Jietu20201204-090305.jpg"></p>
<ul>
<li><code>Spring</code>容器100%已经存在了<code>MarketConfig</code>的<code>Bean</code>对象；</li>
<li>而且是可以确定这次<code>MarketConfig</code>是有注入进来的（没有展示图，不太方便）</li>
<li><code>this</code>直接是显示的自己的地址</li>
</ul>
<p>由于我就比较了一下方法的区别，最主要的区别点就是在于一个是<code>private</code>，另外一个是<code>public</code>。</p>
<p>其实，这里我就很快明白了。因为我们这边在<code>Controller</code>层做了一些AOP来做监控与埋点。现阶段主要用的是<code>CAT</code>（现在做了很多的一些封装，后面可以分享下，如何做到无浸入性以及与<code>Apollo</code>的打通）。</p>
<p><code>AOP</code> 里面用的是反射机制，用<code>private</code>修饰的类是注入失败的，因为拿不到，只能用<code>public</code>或者<code>protected</code>修饰。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31451081/article/details/84100575">https://blog.csdn.net/qq_31451081/article/details/84100575</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/11/24/2020/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%B0%E5%BA%95%E6%98%AFRC%E8%BF%98%E6%98%AFRR%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/24/2020/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%B0%E5%BA%95%E6%98%AFRC%E8%BF%98%E6%98%AFRR%EF%BC%9F/" class="post-title-link" itemprop="url">MySQL数据库隔离级别到底是RC还是RR？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-24T00:00:00+08:00">2020-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:58:47" itemprop="dateModified" datetime="2025-06-25T09:58:47+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h4><p><code>MySQL</code> 的默认事务隔离级别为 <code>Repeatable Read</code>。而 <code>ORACLE</code>、<code>SQLServer</code> 等的默认隔离级别使用的是 <code>Read Committed</code> 模式，为什么呢？</p>
<p>开始我们的内容，相信大家一定遇到过下面的一个面试场景</p>
<blockquote>
<p>面试官：“讲讲 mysql 有几个事务隔离级别？”</p>
<p>你：“读未提交，读已提交，可重复读，串行化四个！默认是可重复读”<br>面试官：“为什么 mysql 选可重复读作为默认的隔离级别？”<br>(你面露苦色，不知如何回答！)<br>面试官:“你们项目中选了哪个隔离级别？为什么？”<br>你：“当然是默认的可重复读，至于原因…呃…”<br>(然后你就可以回去等通知了！)</p>
</blockquote>
<p>为了避免上述尴尬的场景，请继续往下阅读！<br><code>Mysql</code> 默认的事务隔离级别是可重复读 (<code>Repeatable Read</code>)，那互联网项目中 <code>Mysql</code> 也是用默认隔离级别，不做修改么？<br><code>OK</code>，不是的，我们在项目中一般用读已提交 (<code>Read Commited</code>) 这个隔离级别！<br><code>what</code>！居然是读已提交，网上不是说这个隔离级别存在不可重复读和幻读问题么？不用管么？好，带着我们的疑问开始本文！</p>
<p>我们先来思考一个问题，在 <code>Oracle</code>，<code>SqlServer</code> 中都是选择读已提交 (Read Commited) 作为默认的隔离级别，为什么 <code>Mysql</code> 不选择读已提交 (<code>Read Commited</code>) 作为默认隔离级别，而选择可重复读 (<code>Repeatable Read</code>) 作为默认的隔离级别呢？</p>
<h4 id="Why-Why-Why"><a href="#Why-Why-Why" class="headerlink" title="Why?Why?Why?"></a>Why?Why?Why?</h4><p>这个是有历史原因的，当然要从我们的主从复制开始讲起了！<br>主从复制，是基于什么复制的？<br>是基于 <code>binlog</code> 复制的！这里不想去搬 <code>binlog</code> 的概念了，就简单理解为 <code>binlog</code> 是一个记录数据库更改的文件吧～<br><code>binlog</code> 有几种格式？<br>OK，三种，分别是：</p>
<ul>
<li><code>statement</code>: 记录的是修改 <code>SQL</code> 语句</li>
<li>row：记录的是每行实际数据的变更</li>
<li><code>mixed</code>：statement 和 <code>row</code> 模式的混合</li>
</ul>
<p>那 <code>Mysql</code> 在 5.0 这个版本以前，<code>binlog</code> 只支持 <code>STATEMENT</code> 这种格式！而这种格式在读已提交 (<code>Read Commited</code>) 这个隔离级别下主从复制是有 <code>bug</code> 的，因此 <code>Mysql</code> 将可重复读 (<code>Repeatable Read</code>) 作为默认的隔离级别！<br>接下来，就要说说当 <code>binlog</code> 为 <code>STATEMENT</code> 格式，且隔离级别为读已提交 (<code>Read Commited</code>) 时，有什么 <code>bug</code> 呢？如下图所示，在主 (master) 上执行如下事务</p>
<p><img src="http://static.cyblogs.com/image_editor_38dbfa43-6a3f-4812-a26c-c9dc984d4ccc.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;image_editor_38dbfa43-6a3f-4812-a26c-c9dc984d4ccc.jpg"></p>
<p>此时在主 (<code>master</code>) 上执行下列语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test；</span><br></pre></td></tr></table></figure>


<p>输出如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">±–+</span><br><span class="line">| b |</span><br><span class="line">±–+</span><br><span class="line">| 3 |</span><br><span class="line">±–+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>


<p>但是，你在此时在从 (<code>slave</code>) 上执行该语句，得出输出如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty set</span><br></pre></td></tr></table></figure>


<p>这样，你就出现了主从不一致性的问题！原因其实很简单，就是在 <code>master</code> 上执行的顺序为先删后插！而此时 <code>binlog</code> 为 STATEMENT 格式，它记录的顺序为先插后删！从 (<code>slave</code>) 同步的是 <code>binglog</code>，因此从机执行的顺序和主机不一致！就会出现主从不一致！</p>
<h4 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>解决方案有两种！</p>
<ul>
<li>隔离级别设为可重复读 (<code>Repeatable Read</code>), 在该隔离级别下引入间隙锁。当 <code>Session 1</code> 执行 <code>delete</code> 语句时，会锁住间隙。那么，<code>Ssession 2</code> 执行插入语句就会阻塞住！</li>
<li>将 binglog 的格式修改为 <code>row</code> 格式，此时是基于行的复制，自然就不会出现 sql 执行顺序不一样的问题！奈何这个格式在 <code>mysql5.1</code> 版本开始才引入。因此由于历史原因，<code>mysql</code> 将默认的隔离级别设为可重复读 (<code>Repeatable Read</code>)，保证主从复制不出问题！</li>
</ul>
<p>那么，当我们了解完 <code>mysql</code> 选可重复读 (<code>Repeatable Read</code>) 作为默认隔离级别的原因后，接下来我们将其和读已提交 (<code>Read Commited</code>) 进行对比，来说明为什么在互联网项目为什么将隔离级别设为读已提交(<code>Read Commited</code>)！</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>OK，我们先明白一点！项目中是不用读未提交 (<code>Read UnCommitted</code>) 和串行化 (Serializable) 两个隔离级别，原因有二</p>
<p>采用读未提交 (<code>Read UnCommitted</code>), 一个事务读到另一个事务未提交读数据，这个不用多说吧，从逻辑上都说不过去！<br>采用串行化 (<code>Serializable</code>)，每个次读操作都会加锁，快照读失效，一般是使用 <code>mysql</code> 自带分布式事务功能时才使用该隔离级别！(笔者从未用过 <code>mysql</code> 自带的这个功能，因为这是 <code>XA</code> 事务，是强一致性事务，性能不佳！互联网的分布式方案，多采用最终一致性的事务解决方案！)<br>也就是说，我们该纠结都只有一个问题，究竟隔离级别是用读已经提交呢还是可重复读？<br>接下来对这两种级别进行对比，讲讲我们为什么选读已提交 (<code>Read Commited</code>) 作为事务隔离级别！<br>假设表结构如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `test` (</span><br><span class="line">	`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">	`color` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">	 <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>


<p>数据如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">±—±------+</span><br><span class="line">| id | color |</span><br><span class="line">±—±------+</span><br><span class="line">| 1 | red |</span><br><span class="line">| 2 | white |</span><br><span class="line">| 5 | red |</span><br><span class="line">| 7 | white |</span><br><span class="line">±—±------+</span><br></pre></td></tr></table></figure>


<p>为了便于描述，下面将</p>
<ul>
<li>可重复读 (<code>Repeatable Read</code>)，简称为 <code>RR</code>；</li>
<li>读已提交 (Read Commited)，简称为 <code>RC</code>；</li>
</ul>
<p><strong>缘由一</strong></p>
<p>在 <code>RR</code> 隔离级别下，存在间隙锁，导致出现死锁的几率比 <code>RC</code> 大的多！<br>此时执行语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>RR</code> 隔离级别下，存在间隙锁，可以锁住 <code>(2,5)</code> 这个间隙，防止其他事务插入数据！而在 <code>RC</code> 隔离级别下，不存在间隙锁，其他事务是可以插入数据！</p>
<p>在 <code>RC</code> 隔离级别下并不是不会出现死锁，只是出现几率比 <code>RR</code> 低而已！</p>
<p><strong>缘由二</strong></p>
<p>在 <code>RR</code> 隔离级别下，条件列未命中索引会锁表！而在 <code>RC</code> 隔离级别下，只锁行<br>此时执行语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> color <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span> <span class="keyword">where</span> color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span>;</span><br></pre></td></tr></table></figure>


<p>在 <code>RC</code> 隔离级别下，其先走聚簇索引，进行全部扫描。加锁如下：</p>
<p><img src="http://static.cyblogs.com/image_editor_4485ac7d-e85b-4b76-962e-5d420e1ac0a4.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;image_editor_4485ac7d-e85b-4b76-962e-5d420e1ac0a4.png"></p>
<p>但在实际中，<code>MySQL</code> 做了优化，在 <code>MySQL Server</code> 过滤条件，发现不满足后，会调用 <code>unlock_row</code> 方法，把不满足条件的记录放锁。<br>实际加锁如下</p>
<p><img src="http://static.cyblogs.com/image_editor_d329942e-3fd7-4a88-b6ae-b294989c34b5.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;image_editor_d329942e-3fd7-4a88-b6ae-b294989c34b5.png"></p>
<p>然而，在 <code>RR</code> 隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上，如下所示</p>
<p><img src="http://static.cyblogs.com/image_editor_b504b652-9960-495a-a5ce-37826d0acdc7.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;image_editor_b504b652-9960-495a-a5ce-37826d0acdc7.jpg"></p>
<p><strong>缘由三</strong></p>
<p>在 <code>RC</code> 隔离级别下，半一致性读 (<code>semi-consistent</code>) 特性增加了 <code>update</code> 操作的并发性！<br>在 <code>5.1.15</code> 的时候，<code>innodb</code> 引入了一个概念叫做 “<code>semi-consistent</code>”，减少了更新同一行记录时的冲突，减少锁等待。<br>所谓半一致性读就是，一个 <code>update</code> 语句，如果读到一行已经加锁的记录，此时 <code>InnoDB</code> 返回记录最近提交的版本，由 <code>MySQL</code> 上层判断此版本是否满足 <code>update</code> 的 <code>where</code> 条件。若满足 (需要更新)，则 <code>MySQL</code> 会重新发起一次读操作，此时会读取行的最新版本 (并加锁)！<br>具体表现如下:<br>此时有两个 <code>Session</code>：<code>Session1</code> 和 <code>Session2</code>！<br><code>Session1</code> 执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> color <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span> <span class="keyword">where</span> color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>先不 <code>Commit</code> 事务！<br>与此同时 <code>Ssession2</code> 执行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> test <span class="keyword">set</span> color <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span> <span class="keyword">where</span> color <span class="operator">=</span> <span class="string">&#x27;white&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>Session2</code> 尝试加锁的时候，发现行上已经存在锁，<code>InnoDB</code> 会开启 <code>semi-consistent read</code>，返回最新的 <code>committed</code> 版本 (1,red)，(2，white)，(5,red)，(7,white)。<code>MySQL</code> 会重新发起一次读操作，此时会读取行的最新版本 (并加锁)!<br>而在 <code>RR</code> 隔离级别下，<code>Session2</code> 只能等待！</p>
<h4 id="两个疑问"><a href="#两个疑问" class="headerlink" title="两个疑问"></a>两个疑问</h4><p>在 <code>RC</code> 级别下，不可重复读问题需要解决么？<br>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！<code>Oracle</code> 的默认隔离级别就是 <code>RC</code>，你们改过 Oracle 的默认隔离级别么？</p>
<p>在 <code>RC</code> 级别下，主从复制用什么 <code>binlog</code> 格式？<br>OK, 在该隔离级别下，用的 <code>binlog</code> 为 <code>row</code> 格式，是基于行的复制！<code>Innodb</code> 的创始人也是建议 <code>binlog</code> 使用该格式！</p>
<h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><ul>
<li>数据库默认隔离级别: <code>mysql —repeatable、oracle，sql server —read commited</code></li>
<li><code>mysql binlog</code> 的格式三种：<code>statement</code>、<code>row</code>、<code>mixed</code></li>
<li>为什么 <code>mysql</code> 用的是 <code>repeatable</code> 而不是 <code>read committed:</code> 在 <code>5.0</code> 之前只有 <code>statement</code> 一种格式，而主从复制存在了大量的不一致（<code>bug</code>），故选用 <code>repeatable</code>。</li>
<li>为什么其他数据库默认的隔离级别都会选用 <code>read commited</code> 原因有二：<code>repeatable</code> 存在间隙锁会使死锁的概率增大，在 <code>RR</code> 隔离级别下，条件列未命中索引会锁表！而在 <code>RC</code> 隔离级别下，只锁行</li>
<li>在 <code>RC</code> 级用别下，主从复制用什么 <code>binlog</code> 格式：<code>row</code> 格式，是基于行的复制！如果使用 <code>statement</code> 格式，会导致主从不一致。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/10510174.html">https://www.cnblogs.com/rjzheng/p/10510174.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/digdeep/p/4968453.html">https://www.cnblogs.com/digdeep/p/4968453.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/11/17/2020/11/%E5%B8%A6%E4%BD%A0%E7%9C%8BEureka%E6%BA%90%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/17/2020/11/%E5%B8%A6%E4%BD%A0%E7%9C%8BEureka%E6%BA%90%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-17T00:00:00+08:00">2020-11-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:58:47" itemprop="dateModified" datetime="2025-06-25T09:58:47+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Eureka/" itemprop="url" rel="index"><span itemprop="name">Eureka</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>首先，我们来看一下Eureka的架构图，有一个整体的认识。传送门：<a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a></p>
<p><img src="http://static.cyblogs.com/eureka_architecture.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;eureka_architecture.png"></p>
<h4 id="Eureka核心功能"><a href="#Eureka核心功能" class="headerlink" title="Eureka核心功能"></a>Eureka核心功能</h4><p><strong>服务注册</strong></p>
<p>在微服务启动时，首先，服务提供者需要将自己的服务注册到服务注册中心，服务提供者在启动的时候会发送<code>REST</code>请求将自己注册到服务注册中心上，并带上一些元信息。服务注册中心接收到<code>REST</code>请求，会将元信息存储在一个双层<code>Map</code>中，第一层<code>key</code>是服务名，第二层<code>key</code>是具体服务的实例名。</p>
<p>注意：在服务注册时，需要确认一下<code>eureka.client.register-with-eureka=true</code>是否正确，如果为false是禁止向服务注册中心注册的。</p>
<p><strong>服务同步</strong></p>
<p>当服务成功的注册到了注册中心之后，由于注册中心可能是高可用的集群，那么我们的服务可能只注册到了一个集群中的一个注册中心上，被一个注册中心所维护，而不被另外一个注册中心所维护，那么这个时候，我们就需要将这个注册中心的信息同步给集群中其他的注册中心，这就叫服务同步。那么他是如何实现的呢？</p>
<p>由于在集群中，一个注册中心互为其他注册中心的服务，当服务提供者请求到一个服务注册中心后，它会将请求转发到其他服务注册中心，实现注册中心之间的服务同步。</p>
<p>通过服务同步，服务提供者的服务信息可以通过集群中的任何一个服务注册中心获取。</p>
<p><strong>服务续约</strong></p>
<p>在注册完成后。服务提供者会维护一个心跳告诉注册中心服务，心跳间隔大约是<code>30S</code>，防止注册中心剔除服务， 正常情况下，如果<code>Eureka Server</code>在<code>90秒</code>没有收到<code>Eureka</code>客户的续约，它会将实例从其注册表中删除。这个过程称为服务续约。</p>
<p><strong>服务获取</strong></p>
<p>当一切的注册相关工作完成后，我们自然要获取服务清单，那么如何获取服务呢？ 启动服务消费者后，消费者会发送一个<code>REST</code>请求给服务注册中心，来获取上面注册的服务清单。 而服务注册中心会维护一份只读清单返回给消费者客户端，该缓存清单<code>30s</code>更新一次。</p>
<p><strong>服务调用</strong></p>
<p>消费者获取服务清单后，可以通过服务名获取到具体服务实例与实例的元数据信息。这个时候，我们可以通过<code>Ribbon</code>调用我们的目标服务，默认采用轮询的方式，从而实现负载均衡。</p>
<p><strong>服务下线</strong></p>
<p>当我们需要对服务实例进行正常的关闭操作时，它会触发一个服务下线的<code>REST</code>请求给服务端。注册中心接收到请求后，将该服务状态置为<code>DOWN</code>，并把下线时间传播出去。</p>
<p><strong>失效剔除</strong></p>
<p>有的时候，我们的服务意外挂掉了，那么<code>Eureka</code>如何识别出我们异常的服务，并将其剔除呢？</p>
<p>服务注册中心启动时会创建定时任务，默认<code>60s</code>一次，将当前清单中超时（<code>90s</code>）没有续约的服务剔除。</p>
<p><strong>自我保护</strong></p>
<p>当失效剔除机制引入的时候，就会有一个问题，如果一个地区网络特别不稳定，那么服务可能不会续约，但我们还需要这个服务存在。这个时候，我们怎么解决呢？</p>
<p>还好，<code>Eureka</code>拥有自我保护机制，可以很好的解决这个问题。<code>Eureka Server</code>在运行期间，会统计心跳失败的比例在<code>15分钟</code>之内是否低于<code>85%</code>，如果低于，就会将当前实例注册信息保护起来，同时提示一个警告，一旦进入保护模式，<code>Eureka Server</code>将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据。也就是不会注销任何微服务。 但是保护机制也有可能会出现问题，导致服务实例不能够被正确剔除。比如在保护期间，实例出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败。 </p>
<h4 id="源码细节与验证"><a href="#源码细节与验证" class="headerlink" title="源码细节与验证"></a>源码细节与验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postInit</span><span class="params">()</span> &#123;</span><br><span class="line">  renewsLastMin.start();</span><br><span class="line">  <span class="keyword">if</span> (evictionTaskRef.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">    evictionTaskRef.get().cancel();</span><br><span class="line">  &#125;</span><br><span class="line">  evictionTaskRef.set(<span class="keyword">new</span> <span class="title class_">EvictionTask</span>());</span><br><span class="line">  <span class="comment">// 服务剔除，private long evictionIntervalTimerInMs = 60 * 1000;</span></span><br><span class="line">  evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">                         serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">                         serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/98572822">https://zhuanlan.zhihu.com/p/98572822</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Vernon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <a target="_blank" href="https://beian.miit.gov.cn">粤ICP备2025433887号</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
