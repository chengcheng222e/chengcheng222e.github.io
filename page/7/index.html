<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.cyblogs.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="简栈文化">
<meta property="og:url" content="http://www.cyblogs.com/page/7/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.cyblogs.com/page/7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>简栈文化</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">简栈文化</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java技术人的成长之路~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vernon"
      src="/images/vernonchen.jpg">
  <p class="site-author-name" itemprop="name">Vernon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengcheng222e" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengcheng222e" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengcheng222e@gmail.com" title="E-Mail → mailto:chengcheng222e@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/19/2020/03/Reactor%E6%A8%A1%E5%9E%8B%E7%9A%84Java%20NIO%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/19/2020/03/Reactor%E6%A8%A1%E5%9E%8B%E7%9A%84Java%20NIO%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Reactor模型的Java NIO实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-19 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-19T00:00:00+08:00">2020-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>实现Reactor模型可分为以下三种：</p>
<ul>
<li>单线程模型</li>
<li>单Reactor多线程模型</li>
<li>主从Reactor多线程模型。</li>
</ul>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>Reactor单线程模型，指的是所有的IO操作都在同一个线程上面完成，线程的职责如下：</p>
<ul>
<li><p>作为NIO服务端，接收客户端的TCP连接；</p>
</li>
<li><p>作为NIO客户端，向服务端发起TCP连接；</p>
</li>
<li><p>读取通信对端的请求或者应答消息；</p>
</li>
<li><p>向通信对端发送消息请求或者应答消息。</p>
</li>
</ul>
<p>由于Reactor模式使用的是异步非阻塞IO，所有的IO操作都不会导致阻塞，理论上一个线程可以独立处理所有IO相关的操作。从架构层面看，一个NIO线程确实可以完成其承担的职责。例如，通过Acceptor接收客户端的TCP连接请求消息，链路建立成功之后，通过Dispatch将对应的ByteBuffer派发到指定的Handler上进行消息解码。用户线程可以通过消息编码通过NIO线程将消息发送给客户端。</p>
<h5 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reactor1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">1234</span>));</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">acceptServerSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> acceptServerSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;accept from &quot;</span>+socketChannel.socket().getInetAddress().toString());</span><br><span class="line">                  <span class="comment">//  LOGGER.info(&quot;Accept request from &#123;&#125;&quot;, socketChannel.getRemoteAddress());</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable() &amp;&amp; key.isValid()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                        key.cancel();</span><br><span class="line">                        System.out.println(<span class="string">&quot;Received invalide data, close the connection&quot;</span>);</span><br><span class="line">                        <span class="comment">//LOGGER.info(&quot;Received invalide data, close the connection&quot;);</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Received message&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">                    <span class="comment">//LOGGER.info(&quot;Received message &#123;&#125;&quot;, new String(buffer.array()));</span></span><br><span class="line">                &#125;</span><br><span class="line">                keys.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        SocketChannel socketChannel;</span><br><span class="line">        socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//socketChannel.configureBlocking(false);</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>));</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);<span class="comment">//可以方便地修改日期格式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> dateFormat.format( now );</span><br><span class="line">        <span class="type">byte</span>[] requst = str.getBytes();</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(requst.length);</span><br><span class="line">        buffer.put(requst);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用场景却不合适，主要原因如下：</p>
<p>一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；<br>当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；<br>可靠性问题：一旦NIO线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。<br>为了解决这些问题，演进出了Reactor多线程模型。</p>
<h4 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h4><p>经典Reactor模式中，尽管一个线程可同时监控多个请求（Channel），但是所有读&#x2F;写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势,同时读&#x2F;写操作也会阻塞对新连接请求的处理。当获取到IO的读写事件之后，交由线程池来处理，这样可以减小主reactor的性能开销，从而更专注的做事件分发工作了，从而提升整个应用的吞吐。<br><img src="http://static.cyblogs.com/20180720174300266.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180720174300266.png"></p>
<p><strong>Reactor多线程模型的特点：</strong></p>
<ol>
<li><p>有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求；</p>
</li>
<li><p>网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送；</p>
</li>
<li><p>1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。</p>
</li>
</ol>
<p>在绝大多数场景下，Reactor多线程模型都可以满足性能需求；</p>
<h5 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reactor2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">1234</span>));</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(selector.selectNow() &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; sets = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = sets.iterator();</span><br><span class="line">            <span class="keyword">while</span>(keys.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                keys.remove();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">Serverchannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> Serverchannel.accept();</span><br><span class="line">                    channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;accept from &quot;</span>+channel.socket().getInetAddress().toString());</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isValid()&amp;&amp;key.isReadable()) &#123;</span><br><span class="line">                    pool.submit(<span class="keyword">new</span> <span class="title class_">Processor</span>(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    SelectionKey key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Processor</span><span class="params">(SelectionKey key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (count &lt;  <span class="number">0</span>) &#123;</span><br><span class="line">            key.cancel();</span><br><span class="line">            socketChannel.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Received invalide data, close the connection&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Received message&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">            System.out.println(<span class="string">&quot;current thread&quot;</span>+Thread.currentThread().toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在极个别特殊场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型-主从Reactor多线程模型。</p>
<h4 id="多个Reactor模式（主从Reactor）"><a href="#多个Reactor模式（主从Reactor）" class="headerlink" title="多个Reactor模式（主从Reactor）"></a>多个Reactor模式（主从Reactor）</h4><p>Netty中使用的Reactor模式，引入了多Reactor，也即一个主Reactor负责监控所有的连接请求，多个子Reactor负责监控并处理读&#x2F;写请求，减轻了主Reactor的压力，降低了主Reactor压力太大而造成的延迟。并且每个子Reactor分别属于一个独立的线程，每个成功连接后的Channel的所有操作由同一个线程处理。这样保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换，同时也方便了监控请求响应状态。</p>
<p><strong>多个Reactor模式架构图</strong><br><img src="http://static.cyblogs.com/2018072113140256.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;2018072113140256.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainReactor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">1234</span>));</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">coreNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        FollowerReactor[] followers = <span class="keyword">new</span> <span class="title class_">FollowerReactor</span>[coreNum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;coreNum; i++) &#123;</span><br><span class="line">            followers[i] = <span class="keyword">new</span> <span class="title class_">FollowerReactor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(selector.select()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            <span class="keyword">for</span>(SelectionKey key:keys) &#123;</span><br><span class="line">                keys.remove(key);</span><br><span class="line">                <span class="keyword">if</span>(key.isValid()&amp;&amp;key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel1</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel1.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Accept request:&quot;</span> + socketChannel.socket().getInetAddress());</span><br><span class="line">                    <span class="type">FollowerReactor</span> <span class="variable">follower</span> <span class="operator">=</span> followers[++index%coreNum];</span><br><span class="line">                    follower.register(socketChannel);</span><br><span class="line">                    <span class="comment">//follower.wakeUp();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是主Reactor，子Reactor根据前机器可用核数的两倍（与Netty默认的子Reactor个数一致）。对于每个成功连接的SocketChannel，通过round robin的方式交给不同的子Reactor。子Reactor的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FollowerReactor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span>Executors.newFixedThreadPool(</span><br><span class="line">            <span class="number">2</span>*Runtime.getRuntime().availableProcessors());</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> ClosedChannelException &#123;</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeUp</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FollowerReactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        select();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(<span class="number">500</span>)&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(count&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                            channel.close();</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            System.out.println(channel+<span class="string">&quot;-&gt;red end !&quot;</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(channel+<span class="string">&quot;,size is 0 !&quot;</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            System.out.println(channel+<span class="string">&quot;,message is :&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子Reactor中创建了一个静态的线程池，且线程池的大小为机器核数的两倍，每个字Reactor包换一个Selector实例，同事每次创建一个子Reactor都提交一个任务到线程池，阻塞到selector方法，直到新的channel注册到该Selector上，才继续执行。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/TheLudlows/article/details/81136359">https://blog.csdn.net/TheLudlows/article/details/81136359</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/18/2020/03/MYSQL%20MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/18/2020/03/MYSQL%20MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">MYSQL MVCC实现原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-18 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-18T00:00:00+08:00">2020-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>MySQL是现在最流行的关系型数据库(RDB)的选择，创建一个应用时，无论是用户数据还是订单数据，使用关系型数据库存储是最可靠稳定的选择，借助RDB提供的可靠性、事务等功能，为应用提供完善的支持。MySQL是开源软件，可以免费使用，MySQL在发展多年后越来越成熟，成为大部分公司的数据库首选。MySQL采用插件式的存储引擎架构，5.5版本后默认使用InnoDB存储引擎。</p>
<h4 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h4><p>MySQL从概念上可以分为四层:</p>
<ul>
<li><strong>第一层是接入层：</strong> 不同语言的客户端通过mysql的协议与mysql服务器进行连接通信，接入层进行权限验证、连接池管理、线程管理等。</li>
<li><strong>第二层是服务层：</strong> 包括sql解析器、sql优化器、数据缓冲、缓存等。</li>
<li><strong>第三层是存储引擎层：</strong> mysql中存储引擎是基于表的。</li>
<li><strong>第四层是系统文件层：</strong> 保存数据、索引、日志等。<br><img src="http://static.cyblogs.com/mysql-arch.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;mysql-arch.png"></li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC是<code>Multi Version Concurrency Control</code>的简称，代表多版本并发控制。为什么需要MVCC，还要从数据库事务的ACID特性说起。<br>相信很多朋友都了解ACID，它们分别代表了</p>
<ul>
<li>Atomicity(原子性)</li>
<li>Consistency(一致性)</li>
<li>Isolation(隔离性)</li>
<li>Durability(持久性)</li>
</ul>
<p>原子性表示一个事务的操作结果要么全部执行要么全部不执行。</p>
<p>一致性表示事务总是从一个一致的状态转换到另一个一致的状态。</p>
<p>隔离性表示一个事务的修改结果在什么时间能够被其他事务看到，SQL1992规范中对隔离性定义了不同的隔离级别，分为读未提交(READ UNCOMMITED),事务能够看到其他事务没有提及的修改，当另一个事务又回滚了修改后的情况又被称为脏读dirty read。<br>读已提交<code>（READ COMMITTED）</code>，事务能够看到其他事务提交后的修改，这时会出现一个事务内两次读取数据可能因为其他事务提交的修改导致不一致的情况，称为不可重复读。 可重复读<code>（REPEATABLE READ）</code>，在两次读取时读取到的数据的状态是一致的，和序列化<code>（SERIALIZABLE）</code>可重复读中可能出现第二次读读到第一次没有读到的数据，也就是被其他事务插入的数据，这种情况称为幻读<code>phantom read</code>，序列化级别中不能出现幻读。<br>隔离级别依次增强，但是导致的问题是并发能力的减弱。各种数据库厂商会对各个隔离级别进行实现。和<code>Java</code>中的多线程问题相同，数据库通常使用锁来实现隔离性。<br>		最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。所以就使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够，又提出了能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务<code>session</code>会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能。</p>
<h4 id="InnoDB与MVCC"><a href="#InnoDB与MVCC" class="headerlink" title="InnoDB与MVCC"></a>InnoDB与MVCC</h4><p>MySQL中的InnoDB存储引擎的特性有，默认隔离级别<code>REPEATABLE READ</code>，行级锁，实现了MVCC，Consistent nonlocking read(默认读不加锁，一致性非锁定读)，Insert Buffer，Adaptive Hash Index，DoubleWrite，Cluster Index。<br>上面列举了这么多，表示InnoDB有很多特性、很快。<br>InnoDB中通过UndoLog实现了数据的多版本，而并发控制通过锁来实现。<br>Undo Log除了实现MVCC外，还用于事务的回滚。</p>
<h4 id="Redo-log，bin-log，Undo-log"><a href="#Redo-log，bin-log，Undo-log" class="headerlink" title="Redo log，bin log，Undo log"></a>Redo log，bin log，Undo log</h4><p>MySQL Innodb中存在多种日志，除了错误日志、查询日志外，还有很多和数据持久性、一致性有关的日志。<br>binlog，是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的，另外通过解析binlog能够实现mysql到其他数据源（如ElasticSearch)的数据复制。<br>redo log记录了数据操作在物理层面的修改，mysql中使用了大量缓存，缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘，当内存和磁盘的数据不一致时，称内存中的数据为脏页(dirty page)。为了保证数据的安全性，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中，redo log是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。这样实现了事务的原子性、一致性和持久性。</p>
<p>Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。</p>
<p>redo log 和binlog的一致性，为了防止写完binlog但是redo log的事务还没提交导致的不一致，innodb 使用了两阶段提交<br>大致执行序列为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InnoDB prepare  （持有prepare_commit_mutex）；</span><br><span class="line">write/sync Binlog；</span><br><span class="line">InnoDB <span class="title function_">commit</span> <span class="params">(写入COMMIT标记后释放prepare_commit_mutex)</span>。</span><br></pre></td></tr></table></figure>

<h4 id="MVCC实现"><a href="#MVCC实现" class="headerlink" title="MVCC实现"></a>MVCC实现</h4><p><code>innodb</code>中通过B+树作为索引的数据结构，并且主键所在的索引为<code>ClusterIndex</code>(聚簇索引)，<code>ClusterIndex</code>中的叶子节点中保存了对应的数据内容。一个表只能有一个主键，所以只能有一个聚簇索引，如果表没有定义主键，则选择第一个非NULL唯一索引作为聚簇索引，如果还没有则生成一个隐藏id列作为聚簇索引。<br>除了<code>Cluster Index</code>外的索引是<code>Secondary Index</code>(辅助索引)。辅助索引中的叶子节点保存的是聚簇索引的叶子节点的值。<br><code>InnoDB</code>行记录中除了刚才提到的<code>rowid</code>外，还有<code>trx_id</code>和<code>db_roll_ptr</code>，<code>trx_id</code>表示最近修改的事务的id，<code>db_roll_ptr</code>指向<code>undo segment</code>中的<code>undo log</code>。<br>新增一个事务时事务id会增加，<code>trx_id</code>能够表示事务开始的先后顺序。</p>
<p><code>Undo log</code>分为<code>Insert</code>和<code>Update</code>两种，<code>delete</code>可以看做是一种特殊的<code>update</code>，即在记录上修改删除标记。<br><code>update undo log</code>记录了数据之前的数据信息，通过这些信息可以还原到之前版本的状态。<br>当进行插入操作时，生成的Insert undo log在事务提交后即可删除，因为其他事务不需要这个<code>undo log</code>。<br>进行删除修改操作时，会生成对应的<code>undo log</code>，并将当前数据记录中的<code>db_roll_ptr</code>指向新的<code>undo log</code><br><img src="http://static.cyblogs.com/undolog.png" alt="undolog"></p>
<h4 id="数据可见性判断"><a href="#数据可见性判断" class="headerlink" title="数据可见性判断"></a>数据可见性判断</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `testunique` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT，</span><br><span class="line">  `uid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>，</span><br><span class="line">  `ukey` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>，</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)，</span><br><span class="line">  KEY `id_uid` (`uid`)，</span><br><span class="line">  KEY `index_key` (`ukey`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">70</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>隔离级别REPEATABLE READ</p>
<table>
<thead>
<tr>
<th align="left">session1</th>
<th align="left">session2</th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">select * from testunique;</td>
</tr>
<tr>
<td align="left">insert into testunique values(NULL，NULL，1);</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">select * from testunique;</td>
</tr>
<tr>
<td align="left">commit</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">select * from testunique;</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">commit</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">select * from testunique;</td>
</tr>
</tbody></table>
<p>只有当session2 commit之后的查询才能查到session1插入的数据</p>
<p>事务可见性的处理过程:<br><img src="http://static.cyblogs.com/readview-visible.png" alt="undo-view"><br>RR级别下一个事务开始后第一个<code>snapshot read</code>的时候，会将当期活动的事务id记录下来，记录到<code>read view</code>中。RC级别则是每次<code>snapshot read</code>都会创建一个新的<code>read view</code>。<br>假设当前，<code>read view</code>中最大的事务id为<code>tmax</code>，最小为<code>tmin</code>。则判断一个数据是否可见以及对应的版本的方法为。<br>如果该行中的<code>trx_id</code>，赋值给<code>tid</code>，如果tid和当前事务id相等或小于<code>tmin</code>，说明是事务内发生的或开启前的修改，则直接返回该版本数据; 如果<br><code>trx_id</code>大于<code>tmax</code>，则查看该版本的<code>db_roll_ptr</code>中的<code>trx_id</code>，赋值给tid并从头开始判断。如果<code>tid</code>小于<code>tmax</code>并且不在<code>read view</code>中，则返回，否则中回滚段中找出<code>undo log</code>的<code>trx_id</code>，赋值给tid从头判断。</p>
<p>所以可见性是，只有当第一次读之前提交的修改和自己的修改可见，其他的均不可见。</p>
<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f692d4f8a53e">https://www.jianshu.com/p/f692d4f8a53e</a></li>
<li><a target="_blank" rel="noopener" href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/">https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/17/2020/03/Mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/17/2020/03/Mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">Mongodb分片集群部署</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-17T00:00:00+08:00">2020-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Mongodb/" itemprop="url" rel="index"><span itemprop="name">Mongodb</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Mongodb分片概括"><a href="#Mongodb分片概括" class="headerlink" title="Mongodb分片概括"></a>Mongodb分片概括</h4><ul>
<li>分片在多台服务器上分布数据的方法， Mongodb使用分片来支持具有非常大的数据集和高吞吐量的操作的部署</li>
<li>具有大数据集和高吞吐量应用程序的数据库系统，可以挑战单台服务器的容量。<br> 例如，高查询率可以耗尽服务器的cpu容量，工作集大小大于系统的RAM强制磁盘驱动器的I&#x2F;O容量，</li>
<li>有两种方法来解决系统增长：垂直和水平缩放。<ul>
<li>垂直缩放 涉及增加的单个服务器的容量，例如使用更强大的CPU，加入更多的RAM，或增加的存储空间量。可用技术中的限制可能限制单个机器对于给定工作负载足够强大。此外，基于云的提供商具有基于可用硬件配置的硬上限。因此，对于垂直缩放存在实际的最大值。</li>
<li>包括将系统数据和负载在多个服务器，添加额外的服务器，需要增加容量。虽然单个机器的总速度或容量可能不高，但是每个机器处理整个工作负载的子集，潜在地提供比单个高速大容量服务器更好的效率。扩展部署的容量仅需要根据需要添加额外的服务器，这可以是比单个机器的高端硬件低的总体成本。权衡是基础设施的复杂性和部署的维护。</li>
</ul>
</li>
<li>Mongodb的支持水平扩展，分片。</li>
</ul>
<h5 id="分片目的"><a href="#分片目的" class="headerlink" title="分片目的"></a>分片目的</h5><p>对于单台数据库服务器，庞大的数据量及高吞吐量的应用程序对它而言无疑是个巨大的挑战。频繁的CRUD操作能够耗尽服务器的CPU资源，快速的数据增长也会让硬盘存储无能为力，最终内存无法满足数据需要导致大量的I&#x2F;O，主机负载严重。为了解决这种问题，对于数据库系统一般有两种方法：<strong>垂直扩展</strong>和<strong>分片（水平扩展）。</strong></p>
<p><strong>【垂直扩展</strong>】：添加更多的CPU和存储资源来增加系统性能。这种方式缺点是：拥有大量CPU和RAM资源的高端机器比普通PC机器昂贵得太多，而且单点故障会影响整个系统的服务。</p>
<p><strong>【分片】</strong>：相反地，分片将大的数据集分配到多台主机上，每个分片是一个独立的数据库，这些分片整体上构成一个完整的逻辑数据库。分片减少了每台服务器上的数据操作量，随着集群的增长，每台分片处理越来越少的数据，结果，增加了系统整体服务能力。另外，分片还减少了每台服务器需要存储的数据量。</p>
<h5 id="MongoDB中的分片"><a href="#MongoDB中的分片" class="headerlink" title="MongoDB中的分片"></a>MongoDB中的分片</h5><p>MongoDB通过配置分片集群来支持分片，一个分片集群包括以下几个组件：分片，查询路由，配置服务器</p>
<ul>
<li>**分片：**用来存储数据，为了提供系统可用性和数据一致性，一个生产环境的分片集群，通常每个分片是一个副本集。</li>
<li><strong>查询路由</strong>：指客户端应用访问每个分片的路径。</li>
<li><strong>配置服务器</strong>：存储集群的元数据，这些数据包含了集群数据集到各分片的映射关系。查询路由就是通过这些元数据到特定的分片上执行指定的数据操作。（从v3.2开始，配置服务器也可以作为副本集，但是必须使用<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.cnblogs.com/wiredtiger.html"><em>WiredTiger</em></a>存储引擎，反对使用3个镜像实例作为配置服务器）</li>
</ul>
<h5 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h5><p>MongoDB的数据划分，是以集合级别为标准。分片通过shard key来划分集合数据。</p>
<ul>
<li><strong>shard key：</strong></li>
</ul>
<p>为了对集合分片，你需要指定一个shard key。shard key既可以是集合的每个文档的索引字段也可以是集合中每个文档都有的组合索引字段。MongoDB将shard keys值按照块（chunks）划分，并且均匀的将这些chunks分配到各个分片上。MongoDB使用<strong>基于范围划分</strong>或<strong>基于散列划分</strong>来划分chunks的。</p>
<ul>
<li><strong>基于范围划分</strong>：</li>
</ul>
<p>MongoDB通过shard key值将数据集划分到不同的范围就称为基于范围划分。对于数值型的shard key：你可以虚构一条从负无穷到正无穷的直线（理解为x轴），每个shard key 值都落在这条直线的某个点上，然后MongoDB把这条线划分为许多更小的没有重复的范围成为块（chunks），一个chunk就是就某些最小值到最大值的范围。</p>
<ul>
<li><strong>基于散列划分：</strong></li>
</ul>
<p>MongoDB计算每个字段的hash值，然后用这些hash值建立chunks。</p>
<ul>
<li><strong>基于范围和基于散列划分的性能比较：</strong></li>
</ul>
<p>基于范围划分对于范围查询比较高效。假设在shard key上进行范围查询，查询路由很容易能够知道哪些块与这个范围重叠，然后把相关查询按照这个路线发送到仅仅包含这些chunks的分片。但是基于范围划分很容易导致数据不均匀分布，这样会削弱分片集群的功能。例如当shard key是个成直线上升的字段，如时间。那么，所有在给定时间范围内的请求都会映射到相同的chunk，也就是相同的分片上。这种情况下，小部分的分片将会承受大多数的请求，那么系统整体扩展并不理想。</p>
<p>相反的，基于散列划分是以牺牲高效范围查询为代价，它能够均匀的分布数据，散列值能够保证数据随机分布到各个分片上。</p>
<ul>
<li><strong>使用标签来自定义数据分布</strong></li>
</ul>
<p>MongoDB允许DBA们通过标签标记分片的方式直接平衡数据分布策略，DBA可以创建标签并且将它们与shard key值的范围进行关联，然后分配这些标签到各个分片上，最终平衡器转移带有标签标记的数据到对应的分片上，确保集群总是按标签描述的那样进行数据分布。标签是控制平衡器行为及集群中块分布的主要方法</p>
<h5 id="维持数据分布平衡"><a href="#维持数据分布平衡" class="headerlink" title="维持数据分布平衡"></a>维持数据分布平衡</h5><p>新加入的数据及服务器都会导致集群数据分布不平衡，MongoDB采用两种方式确保数据分布的平衡：</p>
<ul>
<li><strong>拆分</strong></li>
</ul>
<p>拆分是一个后台进程，防止块变得太大。当一个块增长到指定块大小的时候，拆分进程就会块一分为二，整个拆分过程是高效的。不会涉及到数据的迁移等操作。</p>
<ul>
<li><strong>平衡</strong></li>
</ul>
<p>平衡器是一个后台进程，管理块的迁移。平衡器能够运行在集群任何的mongd实例上。当集群中数据分布不均匀时，平衡器就会将某个分片中比较多的块迁移到拥有块较少的分片中，直到数据分片平衡为止。举个例子：如果集合users有100个块在分片1里，50个块在分片2中，那么平衡器就会将分片1中的块迁移到分片2中，直到维持平衡。</p>
<p>分片采用后台操作的方式管理着源分片和目标分片之间块的迁移。在迁移的过程中，源分片中的块会将所有文档发送到目标分片中，然后目标分片会获取并应用这些变化。最后，更新配置服务器上关于块位置元数据。</p>
<ul>
<li><strong>从集群中增加和删除分片</strong></li>
</ul>
<p>添加新分片到集群中会产生数据不平衡，因为新分片中没有块，当MongoDB开始迁移数据到新分片中时，等到数据分片平衡恐怕需要点时间。</p>
<p>当删除一个分片时，平衡器将会把分片中所有块迁移到另一个分片中，在完成这些迁移并更新元数据后，你就可以安全的删除分片了。</p>
<h4 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h4><ul>
<li><p>一个mongodb分片集群由以下几部分组成</p>
<p><img src="http://static.cyblogs.com/10506346-13c6d148967b44c0.jpg" alt="img"></p>
</li>
<li><p><code>shard</code> 每个shard包含分片数据的子集，每个shard可以部署一个副本集<br> 一台机器的一个数据表 Collection1 存储了 1T 数据，压力太大了！在分给4个机器后，每个机器都是256G，则分摊了集中在一台机器的压力。也许有人问一台机器硬盘加大一点不就可以了，为什么要分给四台机器呢？不要光想到存储空间，实际运行的数据库还有硬盘的读写、网络的IO、CPU和内存的瓶颈。在mongodb集群只要设置好了分片规则，通过mongos操作数据库就能自动把对应的数据操作请求转发到对应的分片机器上。在生产环境中分片的片键可要好好设置，这个影响到了怎么把数据均匀分到多个分片机器上，不要出现其中一台机器分了1T，其他机器没有分到的情况，这样还不如不分片！</p>
</li>
</ul>
<p><img src="http://static.cyblogs.com/10506346-e50031975b9199c4.jpg" alt="img"></p>
<ul>
<li><code>mongos</code> MongoS充当一个查询的路由器，提供客户端应用程序和所述分片簇之间的接口,mongos作为数据库集群请求的入口，所有的请求都是通过mongos来进行协调的，不需要在应用程序添加一个路由选择器，mongos自己就是一个请求分发中心，它负责把对应的数据请求转发到对应的shard服务器上，在生产环境中通常有多个monogs作为请求的入口，防止其中一个挂掉所有mongos请求都没有办法操作</li>
<li><code>config servers</code> 为集群配置的服务器存储元数据和配置设置，从Mongodb3.4开始，配置服务器必须部署为复制集，mongos本身没有物理存储分片服务器和数据路由信息，只是缓存在内存当中，配置服务器则实际存储这些数据，mongos第一次启动或者关掉重启会从configserver中加载配置信息，以后如果配置信息有变化会通过所有的mongos更新自己的状态，这样mongs就能继续准确路由，在生产环境中通常有多个config server配置服务器，因为它存储了分片路由的元数据，如果就一个如果挂掉一个，整个mongodb基础就会挂掉。</li>
</ul>
<h5 id="片键"><a href="#片键" class="headerlink" title="片键"></a>片键</h5><ul>
<li><p>片键<br> 1、在分发集合中文件时，mongodb的分区使用的收集片键关键，在片键由存在目标集合中的每个文档中的一个不可变或多个字段<br> 2、在分割集合的时候选择片键，<font color=red>分片键完成之后是不能更改的</font>，分片集合只能有1个片键，到片键的非空集合，集合必须有一个索引，与片键启动，对于空空集合，如果集合尚未具有指定分片键的相关索引，则Mongodb会创建索引<br> 3、分片键的选择会影响分片集群的性能和效率以及可伸缩性，具有最佳可能的硬件可以通过分片达到瓶颈，片键和其支持指数的选择也可以影响数据的拆分，但集群可以使用<br> 4、片键决定了集群中一个集合的文件咋不同的片键中的分布，片键字段必须被索引，且在集合中的每条记录都不能为空，可以是单个字段或者是复合字段<br> 5、Mongodb使用片键的范围是吧数据分布在分片中，每个范围，又称为数据块，定义了一个不重叠的片键范围Mongodb把数据块与他们存储的文档分布到集群中的不同分布中，当一个数据块的大小超过数据块最大大小的时候，Mongodb会宜聚片键的范围将数据块分裂为更小的数据块</p>
<p><img src="http://static.cyblogs.com/10506346-573cd236b695d18e.png" alt="img"></p>
</li>
<li><p>片键的使用语法<br> 1、在分片集合，必须制定目标集合和片键的<code>sh.shardCollection()</code></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.shardCollection(namespace<span class="punctuation">,</span> key)</span><br></pre></td></tr></table></figure>

<p>2、哈希片键使用单字段的哈希索引进行数据在分片之间的平均分发，<code>除数取余</code>和<code>一致性哈希</code><br> 3、被选为片键的字段必须有足够大的基数，或者有足够多的不同的值，对于单调的递增的字段如果<code>ObjectID</code>或是时间戳，哈希索引效果更好<br> 4、如果在一个空集合创建哈希片键，Mongodb会自动创建并迁移数据块，以保证每个分片上都有两个数据块，也可以执行<code>shardCollection</code>指定<code>numInitialChunks</code>参数以控制初始化时Mongodb创建数据块数目，或者手动调用<code>split</code>命令在分片上分裂数据块<br> 5、对使用了哈希片键分片的集合进行请求时，Mongodb会自动计算哈希值，应用不需要解析哈希值</p>
<h4 id="shard集群部署"><a href="#shard集群部署" class="headerlink" title="shard集群部署"></a>shard集群部署</h4><ul>
<li><p>部署ip规划</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">172.17.237.33:30001    config1</span><br><span class="line">172.17.237.34:30002    config2</span><br><span class="line">172.17.237.36:30003    config3</span><br><span class="line">172.17.237.37:40000    mongos</span><br><span class="line">172.17.237.38:50000    shard1</span><br><span class="line">172.17.237.39:50001    shard2</span><br><span class="line">172.17.237.40:50002    shard3</span><br><span class="line">172.17.237.41:60000    sha1</span><br><span class="line">172.17.237.42:60001    sha2</span><br><span class="line">172.17.237.43:60002    sha3</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="配置config-server-副本集"><a href="#配置config-server-副本集" class="headerlink" title="配置config server 副本集"></a>配置config server 副本集</h5><ul>
<li>配置confi1配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db2]<span class="comment"># vim config1.conf </span></span><br><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db1]<span class="comment"># vim configsvr.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>1/log/db1.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>1/db1.pid</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">30000</span>  </span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>1/data</span><br><span class="line">configsvr=<span class="literal">true</span>   <span class="comment"># 在配置文件添加此项就行</span></span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=config</span><br></pre></td></tr></table></figure>

<ul>
<li>配置confi2配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db2]<span class="comment"># vim config2.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>2/log/db2.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>2/db2.pid</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">30001</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>2/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=config</span><br><span class="line">configsvr=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置confi3配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db2]<span class="comment"># vim config3.conf</span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>3/log/db3.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>3/db3.pid</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">30002</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>3/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=config</span><br><span class="line">configsvr=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动config server</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@My-Dev bin]# ./mongod -f /home/mongodb/test/db1/config1.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 5260</span><br><span class="line">child process started successfully, parent exiting</span><br><span class="line"></span><br><span class="line">[root@My-Dev bin]# ./mongod -f /home/mongodb/test/db2/config2.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 5202</span><br><span class="line">child process started successfully, parent exiting</span><br><span class="line"></span><br><span class="line">[root@My-Dev bin]# ./mongod -f /home/mongodb/test/db3/config3.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 4260</span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure>

<ul>
<li>配置config副本集</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line"></span><br><span class="line">&gt; config = &#123; _<span class="type">id</span>:<span class="string">&quot;config&quot;</span>,members:[ &#123;_<span class="type">id</span>:<span class="number">0</span>,host:<span class="string">&quot;conf1:30000&quot;</span>&#125;, &#123;_<span class="type">id</span>:<span class="number">1</span>,host:<span class="string">&quot;conf2:30001&quot;</span>&#125;, &#123;_<span class="type">id</span>:<span class="number">2</span>,host:<span class="string">&quot;conf3:30002&quot;</span>&#125;] &#125;        #定义副本集</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;config&quot;</span>,</span><br><span class="line">    <span class="string">&quot;members&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;host&quot;</span> : <span class="string">&quot;conf1:30000&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;host&quot;</span> : <span class="string">&quot;conf2:30001&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;host&quot;</span> : <span class="string">&quot;conf3:30002&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.initiate(config)     #初始化副本集</span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置mongos"><a href="#配置mongos" class="headerlink" title="配置mongos"></a>配置mongos</h5><ul>
<li>添加配置mongos配置文件<br> 遇到坑了，在启动mongos的时候启动失败，结果是mongodb3.0以后的版本<code>config server</code>必须是复制集才行，结果我的版本是3.4最新的版本，所以说还需要添加两台<code>confi server</code></li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db4]<span class="comment"># vim  mongos.conf </span></span><br><span class="line"></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>4/log/db4.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>4/db4.pid</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">40004</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">configdb=mongos/<span class="number">172.17</span>.<span class="number">237.33</span><span class="symbol">:</span><span class="number">30000</span>,<span class="number">172.17</span>.<span class="number">237.34</span><span class="symbol">:</span><span class="number">30001</span>,<span class="number">172.17</span>.<span class="number">237.36</span><span class="symbol">:</span><span class="number">30002</span>   <span class="comment">#如果有多个mongo confi的话就用逗号分隔开 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动mongos</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongos -f /home/mongodb/test/db4/mongos.conf </span></span><br><span class="line">about to fork child process, waiting until server <span class="keyword">is</span> ready <span class="keyword">for</span> connections.</span><br><span class="line">forked process: <span class="number">6268</span></span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure>

<h5 id="shard2副本集集群部署"><a href="#shard2副本集集群部署" class="headerlink" title="shard2副本集集群部署"></a>shard2副本集集群部署</h5><ul>
<li>配置sha配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db8]<span class="comment"># more shard21.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>8/log/db8.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>8/db8.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">60000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>8/data </span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=sha</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db9]<span class="comment"># more shard22.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>9/log/db9.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>9/db9.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">60001</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>9/data </span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=sha</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db10]<span class="comment"># more shard23.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>10/log/db10.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>10/db10.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">60002</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>10/data </span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=sha</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动shard</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db8/shard21.conf </span></span><br><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db9/shard22.conf </span></span><br><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db10/shard23.conf </span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置shard2副本集集群</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin </span><br><span class="line">switched to db admin</span><br><span class="line">&gt; sha = &#123; _<span class="type">id</span>:<span class="string">&quot;sha&quot;</span>,members:[ &#123;_<span class="type">id</span>:<span class="number">0</span>,host:<span class="string">&quot;sha1:60000&quot;</span>&#125;, &#123;_<span class="type">id</span>:<span class="number">1</span>,host:<span class="string">&quot;sha2:60001&quot;</span>&#125;, &#123;_<span class="type">id</span>:<span class="number">2</span>,host:<span class="string">&quot;sha3:60002&quot;</span>&#125;]&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;sha&quot;</span>,</span><br><span class="line">    <span class="string">&quot;members&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;host&quot;</span> : <span class="string">&quot;sha1:60000&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;host&quot;</span> : <span class="string">&quot;sha2:60001&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;host&quot;</span> : <span class="string">&quot;sha3:60002&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.initiate(sha)</span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="shard1副本集集群部署"><a href="#shard1副本集集群部署" class="headerlink" title="shard1副本集集群部署"></a>shard1副本集集群部署</h5><ul>
<li>配置shard配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db5]<span class="comment"># vim shard1.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>5/log/db5.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>5/db5.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">50000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>5/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=shard</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db6]<span class="comment"># vim shard2.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>6/log/db6.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>6/db6.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">50001</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>6/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=shard</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root<span class="variable">@My</span>-<span class="title class_">Dev</span> db7]<span class="comment"># vim shard3.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>7/log/db7.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>7/db7.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">50002</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>7/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=shard</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动shard</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db7/shard1.conf </span></span><br><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db7/shard2.conf </span></span><br><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db7/shard3.conf </span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置shard2副本集集群</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; shard = &#123; _<span class="type">id</span>:<span class="string">&quot;shard&quot;</span>,members:[ &#123;_<span class="type">id</span>:<span class="number">0</span>,host:<span class="string">&quot;shard1:50000&quot;</span>&#125;, &#123;_<span class="type">id</span>:<span class="number">1</span>,host:<span class="string">&quot;shard2:50001&quot;</span>&#125;, &#123;_<span class="type">id</span>:<span class="number">2</span>,host:<span class="string">&quot;shard3:50002&quot;</span>&#125;] &#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;shard&quot;</span>,</span><br><span class="line">    <span class="string">&quot;members&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;host&quot;</span> : <span class="string">&quot;shard1:50000&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;host&quot;</span> : <span class="string">&quot;shard2:50001&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;host&quot;</span> : <span class="string">&quot;shard3:50002&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.initiate(shard)</span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="分片配置"><a href="#分片配置" class="headerlink" title="分片配置"></a>分片配置</h5><ul>
<li>分片集合中是否有数据<br> 默认第一个添加的shard就是主shard，存放没有被分割的shard就是主shard<br> 在创建分片的时，必须在索引中创建的，如果这个集合中有数据，则首先自己先创建索引，然后进行分片，如果是分片集合中没有数据的话，则就不需要创建索引，就可以分片</li>
<li>登陆mongos配置分片，向分区集群中添加shard服务器和副本集</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongo mongos:40004    #登陆到mongos中</span></span><br><span class="line"></span><br><span class="line">mongos&gt; sh.status()  <span class="meta">#查看分片状态</span></span><br><span class="line">--- Sharding Status --- </span><br><span class="line">  sharding version: &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;minCompatibleVersion&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;currentVersion&quot;</span> : <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;clusterId&quot;</span> : ObjectId(<span class="string">&quot;589b0cff36b0915841e2a0a2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">  active mongoses:</span><br><span class="line">    <span class="string">&quot;3.4.1&quot;</span> : <span class="number">1</span></span><br><span class="line"> autosplit:</span><br><span class="line">    Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">    Currently enabled:  yes</span><br><span class="line">    Currently running:  no</span><br><span class="line">        Balancer <span class="keyword">lock</span> taken at Wed Feb <span class="number">08</span> <span class="number">2017</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">16</span> GMT+<span class="number">0800</span> (CST) <span class="keyword">by</span> ConfigServer:Balancer</span><br><span class="line">    Failed balancer rounds <span class="keyword">in</span> last <span class="number">5</span> attempts:  <span class="number">0</span></span><br><span class="line">    Migration Results <span class="keyword">for</span> the last <span class="number">24</span> hours: </span><br><span class="line">        No recent migrations</span><br><span class="line">  databases:</span><br></pre></td></tr></table></figure>

<ul>
<li>添加shard副本集</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#首先要登陆到shard副本集中查看那个是主节点，本次实验室使用了两个shard副本集 sh.addShard(&quot;&lt;replSetName&gt;/主节点IP/port&quot;) </span></span><br><span class="line">mongos&gt; sh.addShard(<span class="string">&quot;shard/shard1:50000&quot;</span>)  </span><br><span class="line">&#123; <span class="string">&quot;shardAdded&quot;</span> : <span class="string">&quot;shard&quot;</span>, <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">mongos&gt; sh.addShard(<span class="string">&quot;sha/sha:60000&quot;</span>)</span><br><span class="line">&#123; <span class="string">&quot;shardAdded&quot;</span> : <span class="string">&quot;shard&quot;</span>, <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">mongos&gt; sh.status()  <span class="meta">#查看分片集群已经成功把shard加入分片中</span></span><br><span class="line">--- Sharding Status --- </span><br><span class="line">  sharding version: &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;minCompatibleVersion&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;currentVersion&quot;</span> : <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;clusterId&quot;</span> : ObjectId(<span class="string">&quot;589b0cff36b0915841e2a0a2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">    &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;sha&quot;</span>,  <span class="string">&quot;host&quot;</span> : <span class="string">&quot;sha/sha1:60000,sha2:60001,sha3:60002&quot;</span>,  <span class="string">&quot;state&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">    &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;shard&quot;</span>,  <span class="string">&quot;host&quot;</span> : <span class="string">&quot;shard/shard1:50000,shard2:50001,shard3:50002&quot;</span>,  <span class="string">&quot;state&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">    <span class="string">&quot;3.4.1&quot;</span> : <span class="number">1</span></span><br><span class="line"> autosplit:</span><br><span class="line">    Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">    Currently enabled:  yes</span><br><span class="line">    Currently running:  no</span><br><span class="line">        Balancer <span class="keyword">lock</span> taken at Wed Feb <span class="number">08</span> <span class="number">2017</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">16</span> GMT+<span class="number">0800</span> (CST) <span class="keyword">by</span> ConfigServer:Balancer</span><br><span class="line">    Failed balancer rounds <span class="keyword">in</span> last <span class="number">5</span> attempts:  <span class="number">5</span></span><br><span class="line">    Last reported error:  Cannot accept sharding commands <span class="keyword">if</span> <span class="keyword">not</span> started <span class="keyword">with</span> --shardsvr</span><br><span class="line">    Time of Reported error:  Thu Feb <span class="number">09</span> <span class="number">2017</span> <span class="number">17</span>:<span class="number">42</span>:<span class="number">21</span> GMT+<span class="number">0800</span> (CST)</span><br><span class="line">    Migration Results <span class="keyword">for</span> the last <span class="number">24</span> hours: </span><br><span class="line">        No recent migrations</span><br><span class="line">  databa</span><br></pre></td></tr></table></figure>

<ul>
<li>指定那个数据库使用分片，创建片键</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; sh.enableSharding(<span class="string">&quot;zhao&quot;</span>)  <span class="comment">#指定zhao数据库中使用分片</span></span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : 1 &#125;</span><br><span class="line"></span><br><span class="line">mongos&gt; sh.shardCollection(<span class="string">&quot;zhao.call&quot;</span>,&#123;name:1,age:1&#125;)   <span class="comment">#在zhao数据库和call集合中创建了name和age为升序的片键</span></span><br><span class="line">&#123; <span class="string">&quot;collectionsharded&quot;</span> : <span class="string">&quot;zhao.call&quot;</span>, <span class="string">&quot;ok&quot;</span> : 1 &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ul>
<li>查看<code>sh.status()</code>信息</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; sh.status()</span><br><span class="line">--- Sharding Status --- </span><br><span class="line">  sharding version: &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;minCompatibleVersion&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;currentVersion&quot;</span> : <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;clusterId&quot;</span> : ObjectId(<span class="string">&quot;589b0cff36b0915841e2a0a2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">    &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;sha&quot;</span>,  <span class="string">&quot;host&quot;</span> : <span class="string">&quot;sha/sha1:60000,sha2:60001,sha3:60002&quot;</span>,  <span class="string">&quot;state&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">    &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;shard&quot;</span>,  <span class="string">&quot;host&quot;</span> : <span class="string">&quot;shard/shard1:50000,shard2:50001,shard3:50002&quot;</span>,  <span class="string">&quot;state&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">    <span class="string">&quot;3.4.1&quot;</span> : <span class="number">1</span></span><br><span class="line"> autosplit:</span><br><span class="line">    Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">    Currently enabled:  yes</span><br><span class="line">    Currently running:  no</span><br><span class="line">        Balancer lock taken at Wed Feb <span class="number">08</span> <span class="number">2017</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">16</span> GMT+<span class="number">0800</span> (CST) by ConfigServer:Balancer</span><br><span class="line">    Failed balancer rounds <span class="keyword">in</span> last <span class="number">5</span> attempts:  <span class="number">5</span></span><br><span class="line">    Last reported error:  Cannot accept sharding commands <span class="keyword">if</span> not started <span class="keyword">with</span> --shardsvr</span><br><span class="line">    Time of Reported error:  Thu Feb <span class="number">09</span> <span class="number">2017</span> <span class="number">17</span>:<span class="number">56</span>:<span class="number">02</span> GMT+<span class="number">0800</span> (CST)</span><br><span class="line">    Migration Results <span class="keyword">for</span> the last <span class="number">24</span> hours: </span><br><span class="line">        No recent migrations</span><br><span class="line">  databases:</span><br><span class="line">    &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;zhao&quot;</span>,  <span class="string">&quot;primary&quot;</span> : <span class="string">&quot;shard&quot;</span>,  <span class="string">&quot;partitioned&quot;</span> : <span class="keyword">true</span> &#125;</span><br><span class="line">        zhao.call</span><br><span class="line">            shard key: &#123; <span class="string">&quot;name&quot;</span> : <span class="number">1</span>, <span class="string">&quot;age&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">            unique: <span class="keyword">false</span></span><br><span class="line">            balancing: <span class="keyword">true</span></span><br><span class="line">            chunks:</span><br><span class="line">                shard    <span class="number">1</span></span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : &#123; <span class="string">&quot;<span class="subst">$minKey</span>&quot;</span> : <span class="number">1</span> &#125;, <span class="string">&quot;age&quot;</span> : &#123; <span class="string">&quot;<span class="subst">$minKey</span>&quot;</span> : <span class="number">1</span> &#125; &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : &#123; <span class="string">&quot;<span class="subst">$maxKey</span>&quot;</span> : <span class="number">1</span> &#125;, <span class="string">&quot;age&quot;</span> : &#123; <span class="string">&quot;<span class="subst">$maxKey</span>&quot;</span> : <span class="number">1</span> &#125; &#125; <span class="keyword">on</span> : shard Timestamp(<span class="number">1</span>, <span class="number">0</span>) </span><br></pre></td></tr></table></figure>

<ul>
<li>测试批量插入数据验证</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; <span class="keyword">for</span> ( var i=<span class="number">1</span>;i&lt;<span class="number">10000000</span>;i++)&#123;db.call.insert(&#123;<span class="string">&quot;name&quot;</span><span class="symbol">:<span class="string">&quot;user&quot;</span>+i</span>,<span class="symbol">age:</span>i&#125;)&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前是否已经分片到两个shard中去了</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; sh.status()</span><br><span class="line">--- Sharding Status --- </span><br><span class="line">  sharding version: &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;minCompatibleVersion&quot;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;currentVersion&quot;</span> : <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;clusterId&quot;</span> : ObjectId(<span class="string">&quot;589b0cff36b0915841e2a0a2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">    &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;sha&quot;</span>,  <span class="string">&quot;host&quot;</span> : <span class="string">&quot;sha/sha1:60000,sha2:60001,sha3:60002&quot;</span>,  <span class="string">&quot;state&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">    &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;shard&quot;</span>,  <span class="string">&quot;host&quot;</span> : <span class="string">&quot;shard/shard1:50000,shard2:50001,shard3:50002&quot;</span>,  <span class="string">&quot;state&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">    <span class="string">&quot;3.4.1&quot;</span> : <span class="number">1</span></span><br><span class="line"> autosplit:</span><br><span class="line">    Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">    Currently enabled:  yes</span><br><span class="line">    Currently running:  no</span><br><span class="line">        Balancer <span class="keyword">lock</span> taken at Wed Feb <span class="number">08</span> <span class="number">2017</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">16</span> GMT+<span class="number">0800</span> (CST) <span class="keyword">by</span> ConfigServer:Balancer</span><br><span class="line">    Failed balancer rounds <span class="keyword">in</span> last <span class="number">5</span> attempts:  <span class="number">5</span></span><br><span class="line">    Last reported error:  Cannot accept sharding commands <span class="keyword">if</span> <span class="keyword">not</span> started <span class="keyword">with</span> --shardsvr</span><br><span class="line">    Time of Reported error:  Thu Feb <span class="number">09</span> <span class="number">2017</span> <span class="number">17</span>:<span class="number">56</span>:<span class="number">02</span> GMT+<span class="number">0800</span> (CST)</span><br><span class="line">    Migration Results <span class="keyword">for</span> the last <span class="number">24</span> hours: </span><br><span class="line">        <span class="number">4</span> : Success</span><br><span class="line">  databases:</span><br><span class="line">    &#123;  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;zhao&quot;</span>,  <span class="string">&quot;primary&quot;</span> : <span class="string">&quot;shard&quot;</span>,  <span class="string">&quot;partitioned&quot;</span> : <span class="literal">true</span> &#125;</span><br><span class="line">        zhao.call</span><br><span class="line">            shard key: &#123; <span class="string">&quot;name&quot;</span> : <span class="number">1</span>, <span class="string">&quot;age&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">            unique: <span class="literal">false</span></span><br><span class="line">            balancing: <span class="literal">true</span></span><br><span class="line">            chunks:   <span class="meta">#数据已经分片到两个chunks里面了</span></span><br><span class="line">                sha    <span class="number">4</span></span><br><span class="line">                shard    <span class="number">5</span></span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : &#123; <span class="string">&quot;$minKey&quot;</span> : <span class="number">1</span> &#125;, <span class="string">&quot;age&quot;</span> : &#123; <span class="string">&quot;$minKey&quot;</span> : <span class="number">1</span> &#125; &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">1</span> &#125; <span class="keyword">on</span> : <span class="function">sha <span class="title">Timestamp</span>(<span class="params"><span class="number">4</span>, <span class="number">1</span></span>)</span> </span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">1</span> &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">21</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">5</span>, <span class="number">1</span></span>)</span> </span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">21</span> &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">164503</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">2</span>, <span class="number">2</span></span>)</span> </span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">164503</span> &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">355309</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">2</span>, <span class="number">3</span></span>)</span> </span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">355309</span> &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">523081</span> &#125; <span class="keyword">on</span> : <span class="function">sha <span class="title">Timestamp</span>(<span class="params"><span class="number">3</span>, <span class="number">2</span></span>)</span> </span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">523081</span> &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">710594</span> &#125; <span class="keyword">on</span> : <span class="function">sha <span class="title">Timestamp</span>(<span class="params"><span class="number">3</span>, <span class="number">3</span></span>)</span> </span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">710594</span> &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">875076</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">4</span>, <span class="number">2</span></span>)</span> </span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">875076</span> &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">1056645</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">4</span>, <span class="number">3</span></span>)</span> </span><br><span class="line">            &#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : <span class="number">1056645</span> &#125; --&gt;&gt; &#123; <span class="string">&quot;name&quot;</span> : &#123; <span class="string">&quot;$maxKey&quot;</span> : <span class="number">1</span> &#125;, <span class="string">&quot;age&quot;</span> : &#123; <span class="string">&quot;$maxKey&quot;</span> : <span class="number">1</span> &#125; &#125; <span class="keyword">on</span> : <span class="function">sha <span class="title">Timestamp</span>(<span class="params"><span class="number">5</span>, <span class="number">0</span></span>) </span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前分片中是否均匀的分配到连个shard当中,<code>true</code>是均匀的<br> ，<code>false</code>不是均匀的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; sh.getBalancerState()</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="选择sharing-kes注意点"><a href="#选择sharing-kes注意点" class="headerlink" title="选择sharing kes注意点"></a>选择sharing kes注意点</h5><ul>
<li>考虑应该在哪里储存数据？</li>
<li>应该在哪里读取数据？</li>
<li>sharding key 应该是主键</li>
<li>sharding key 应该你能尽量保证避免分片查询</li>
</ul>
<h4 id="sharing-进级"><a href="#sharing-进级" class="headerlink" title="sharing 进级"></a>sharing 进级</h4><ul>
<li>如果sharing 分片不均匀没有分片均匀</li>
<li>sharding ： 新增<code>shard</code>和移除<code>shard</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; sh.addShard(<span class="string">&quot;sha4/192.168.2.10:21001&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h5><ul>
<li>开启Balncer<br> 开启Balancer之后，chunks之后会自动均分</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; sh<span class="selector-class">.startBalancer</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>设置Balancer进程运行时间窗口<br> 默认情况ixaBalancing进程在运行时为降低Balancing进程对系统的影响，可以设置Balancer进程的运行时间窗口，让Balancer进程在指定时间窗口操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置时间窗口</span></span><br><span class="line">db.settings.update(&#123; _id : <span class="string">&quot;balancer&quot;</span> &#125;, &#123; <span class="variable">$set</span> : &#123; activeWindow : &#123; start : <span class="string">&quot;23:00&quot;</span>, stop : <span class="string">&quot;6:00&quot;</span> &#125; &#125; &#125;, <span class="literal">true</span> )</span><br></pre></td></tr></table></figure>

<ul>
<li>查看Balancer运行时间窗口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看Balancer时间窗口</span></span><br><span class="line">mongos&gt; db.settings.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;balancer&quot;</span>, <span class="string">&quot;activeWindow&quot;</span> : &#123; <span class="string">&quot;start&quot;</span> : <span class="string">&quot;23:00&quot;</span>, <span class="string">&quot;stop&quot;</span> : <span class="string">&quot;6:00&quot;</span> &#125;, <span class="string">&quot;stopped&quot;</span> : <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">mongos&gt; sh.<span class="function"><span class="title">getBalancerWindow</span></span>()</span><br><span class="line">&#123; <span class="string">&quot;start&quot;</span> : <span class="string">&quot;23:00&quot;</span>, <span class="string">&quot;stop&quot;</span> : <span class="string">&quot;6:00&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除Balancer进程运行时间窗口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> mongos&gt; db.settings.update(&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;balancer&quot;</span> &#125;, &#123; <span class="variable">$unset</span> : &#123; activeWindow : 1 &#125;&#125;);</span><br><span class="line">mongos&gt; db.settings.find();</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;chunksize&quot;</span>, <span class="string">&quot;value&quot;</span> : 10 &#125;</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;balancer&quot;</span>, <span class="string">&quot;stopped&quot;</span> : <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="在shell脚本中执行mongodb"><a href="#在shell脚本中执行mongodb" class="headerlink" title="在shell脚本中执行mongodb"></a>在shell脚本中执行mongodb</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@My-Dev ~]<span class="meta"># echo  -e <span class="string">&quot;use zhao \n  db.call.find()&quot;</span> |mongo --port 60001 </span></span><br></pre></td></tr></table></figure>

<h5 id="Mongodb片键的添加"><a href="#Mongodb片键的添加" class="headerlink" title="Mongodb片键的添加"></a>Mongodb片键的添加</h5><ul>
<li>首先进入mongos的的admin数据库中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongos&gt; use admin</span><br><span class="line">switched to db admin  </span><br><span class="line">mongos&gt; db.runCommand(&#123;<span class="string">&quot;enablesharding&quot;</span>:<span class="string">&quot;zl&quot;</span>&#125;)   <span class="comment">#创建zl库中</span></span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : 1 &#125;</span><br><span class="line">mongos&gt; db.runCommand(db.runCommand(&#123;<span class="string">&quot;shardcollection&quot;</span>:<span class="string">&quot;<span class="variable">$ent</span>.t_srvappraise_back&quot;</span>,<span class="string">&quot;key&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>分片脚本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">url=10.241.96.155</span><br><span class="line">port=30000</span><br><span class="line">ent=test1</span><br><span class="line"></span><br><span class="line">./mongo <span class="variable">$url</span>:<span class="variable">$port</span>/admin &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">db.runCommand(&#123;&quot;enablesharding&quot;:&quot;$ent&quot;&#125;);</span></span><br><span class="line"><span class="string">db.runCommand(&#123;&quot;shardcollection&quot;:&quot;$ent.t_srvappraise_back&quot;,&quot;key&quot;:&#123;&quot;sa_seid&quot;:&quot;hashed&quot;&#125;&#125;)</span></span><br><span class="line"><span class="string">exit;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb55bb333e2d">https://www.jianshu.com/p/cb55bb333e2d</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/16/2020/03/Java%E6%96%B0%E7%94%9F%E4%BB%A3%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%88%92%E5%88%86%E5%8F%8A%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/16/2020/03/Java%E6%96%B0%E7%94%9F%E4%BB%A3%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%88%92%E5%88%86%E5%8F%8A%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Java新生代老年代的划分及回收算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-16 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-16T00:00:00+08:00">2020-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java堆(Java Heap)是JVM所管理的最大内存区域，也是所有线程共享的一块区域，在JVM启动时创建。</p>
<p>此内存区域存放的都是对象的实例和数组。JVM规范中说到:”所有的对象实例以及数组都要在堆上分配”。</p>
<p>Java堆是垃圾回收器管理的主要区域，百分之九十九的垃圾回收发生在Java堆，另外百分之一发生在方法区，因此又称之为”GC堆”。根据JVM规范规定的内容，Java堆可以处于物理上不连续的内存空间中。</p>
<p>当前JVM对于堆的垃圾回收，采用分代收集的策略。根据堆中对象的存活周期将堆内存分为新生代和老年代。在新生代中，每次垃圾回收都有大批对象死去，只有少量存活。而老年代中存放的对象存活率高。</p>
<p>这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记清除算法是最基础的回收算法，分为标记和清除两个部分：首先标记出所有需要回收的对象，这一过程在可达性分析过程中进行。在标记完之后统一回收所有被标记的对象。</p>
<p>标记清除算法有如下不足</p>
<ul>
<li>效率问题</li>
</ul>
<p>标记和清除这两个过程的效率不高</p>
<ul>
<li>空间问题</li>
</ul>
<p>清除之后会产生大量不连续的内存碎片，内存碎片太多会导致以后的程序运行中无法分配出较大的内存，从内不得不触发另外的垃圾回收。</p>
<p><img src="http://static.cyblogs.com/20180617105859782.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180617105859782.png"></p>
<p>如上图中，经过标记清除之后，假设有了100M空间，但是这100M是不连续的，最大的一块连续空间可能才10M，所以导致之后程序需要一块20M内存空间时就不得不再进行一次GC来继续清理空间，效率极低。</p>
<p>鉴于标记清除算法有如上的缺陷，所以现在一般是用的是其的变种算法。</p>
<h4 id="复制算法-新生代算法"><a href="#复制算法-新生代算法" class="headerlink" title="复制算法(新生代算法)"></a>复制算法(新生代算法)</h4><h5 id="复制算法概念"><a href="#复制算法概念" class="headerlink" title="复制算法概念"></a>复制算法概念</h5><p>复制算法是针对Java堆中的新生代内存垃圾回收所使用的回收策略，解决了”标记-清理”的效率问题。</p>
<p>复制算法将堆中可用的新生代内存按容量划分成大小相等的两块内存区域，每次只使用其中的一块区域。当其中一块内存区域需要进行垃圾回收时，会将此区域内还存活着的对象复制到另一块上面，然后再把此内存区域一次性清理掉。</p>
<p>这样做的好处是每次都是对整个新生代一半的内存区域进行内存回收，内存分配时也就不需要考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配即可。此算法实现简单，运行高效。算法的执行流程如下图 :</p>
<p><img src="http://static.cyblogs.com/2018061711175251.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;2018061711175251.png"></p>
<p>现在主流的虚拟机，包括HotSpot都是采用的这种回收策略进行新生代内存的回收。</p>
<h5 id="新生代内存划分"><a href="#新生代内存划分" class="headerlink" title="新生代内存划分"></a>新生代内存划分</h5><p>新生代中98%的对象都是”朝生夕死”的，所以并不需要按照1 : 1的比例来划分内存空间，而是将内存(新生代内存)分为一块较大的Eden(伊甸园)空间和两块较小的Survivor(幸存者)空间，每次使用Eden和其中一块Survivor（两个Survivor区域一个称为From区，另一个称为To区域）。</p>
<p>当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>当Survivor空间不够用时，则需要依赖其他内存(老年代)进行分配担保。</p>
<p>HotSpot默认Eden与Survivor的大小比例是8 : 1，也就是说Eden:Survivor From : Survivor To &#x3D; 8:1:1。所以每次新生代可用内存空间为整个新生代容量的90%,而剩下的10%用来存放回收后存活的对象。</p>
<p>HotSpot实现的复制算法流程如下:</p>
<p> 1. 当Eden区满的时候,会触发第一次Minor gc,把还活着的对象拷贝到Survivor From区；当Eden区再次触发Minor gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。</p>
<p> 2. 当后续Eden又发生Minor gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。</p>
<p> 3. 部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</p>
<p><img src="http://static.cyblogs.com/20180617112302206.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180617112302206.png"></p>
<p>发生在新生代的垃圾回收成为Minor GC，Minor GC又称为新生代GC，因为新生代对象大多都具备朝生夕灭的特性，因此Minor GC(采用复制算法)非常频繁，一般回收速度也比较快。</p>
<ol start="3">
<li>标记整理算法(老年代回收算法)<br> 复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以在栈的老年代不适用复制算法。</li>
</ol>
<p> 针对老年代对象存活率高的特点，提出了一种称之为”标记-整理算法”。标记过程仍与”标记-清除”过程一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。流程图如下:</p>
<p><img src="http://static.cyblogs.com/20180617112627331.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180617112627331.png"></p>
<p>发生在老年代的GC称为Full GC，又称为Major GC，其经常会伴随至少一次的Minor GC(并非绝对，在Parallel Scavenge收集器中就有直接进行Full GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40739833/article/details/80717638">https://blog.csdn.net/weixin_40739833/article/details/80717638</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/15/2020/03/Java%E7%BA%BF%E7%A8%8B%E4%B8%8ELinux%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/15/2020/03/Java%E7%BA%BF%E7%A8%8B%E4%B8%8ELinux%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">Java线程与Linux内核线程的映射关系</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-15T00:00:00+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Java</code>线程与<code>Linux</code>内核线程的映射关系<code>Linux</code>从内核2.6开始使用<code>NPTL （Native POSIX Thread Library）</code>支持，但这时线程本质上还轻量级进程。 </p>
<p><code>Java</code>里的线程是由<code>JVM</code>来管理的，它如何对应到操作系统的线程是由<code>JVM</code>的实现来确定的。<code>Linux 2.6</code>上的<code>HotSpot</code>使用了<code>NPTL</code>机制，<strong>JVM线程跟内核轻量级进程有一一对应的关系</strong>。线程的调度完全交给了操作系统内核，当然jvm还保留一些策略足以影响到其内部的线程调度，举个例子，在linux下，只要一个<code>Thread.run</code>就会调用一个<code>fork</code>产生一个线程。</p>
<p><code>Java</code>线程在<code>Windows</code>及<code>Linux</code>平台上的实现方式，现在看来，是内核线程的实现方式。**这种方式实现的线程，是直接由操作系统内核支持的——由内核完成线程切换，内核通过操纵调度器（Thread Scheduler）实现线程调度，并将线程任务反映到各个处理器上。**内核线程是内核的一个分身。程序一般不直接使用该内核线程，而是使用其高级接口，即轻量级进程（<code>LWP</code>），也即线程。这看起来可能很拗口。看图：</p>
<p><img src="http://static.cyblogs.com/1350871014_7132.jpg" alt="Java线程与Linux内核线程的映射关系"></p>
<p>（说明：KLT即内核线程<code>Kernel Thread</code>，是“内核分身”。每一个KLT对应到进程P中的某一个轻量级进程<code>LWP</code>（也即线程），期间要经过用户态、内核态的切换，并在<code>Thread Scheduler</code> 下反应到处理器<code>CPU</code>上。）</p>
<p>​    这种线程实现的方式也有它的缺陷：在程序面上使用内核线程，必然在操作系统上多次来回切换用户态及内核态；另外，因为是一对一的线程模型，<code>LWP</code>的支持数是有限的。</p>
<p>对于一个大型程序，我们可以<strong>开辟的线程数量至少等于运行机器的cpu内核数量</strong>。java程序里我们可以通过下面的一行代码得到这个数量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>

<p>所以最小线程数量即时<code>cpu</code>内核数量。如果所有的任务都是计算密集型的，这个最小线程数量就是我们需要的线程数。开辟更多的线程只会影响程序的性能，因为线程之间的切换工作，会消耗额外的资源。如果任务是IO密集型的任务，我们可以开辟更多的线程执行任务。当一个任务执行<code>IO</code>操作的时候，线程将会被阻塞，处理器立刻会切换到另外一个合适的线程去执行。如果我们只拥有与内核数量一样多的线程，即使我们有任务要执行，他们也不能执行，因为处理器没有可以用来调度的线程。</p>
<p>​    **如果线程有50%的时间被阻塞，线程的数量就应该是内核数量的2倍。**如果更少的比例被阻塞，那么它们就是计算密集型的，则需要开辟较少的线程。如果有更多的时间被阻塞，那么就是<code>IO</code>密集型的程序，则可以开辟更多的线程。于是我们可以得到下面的线程数量计算公式：线程数量&#x3D;内核数量 &#x2F; (1 – 阻塞率)</p>
<p>我们可以通过相应的分析工具或者<code>java</code>的<code>management</code>包来得到阻塞率的数值。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="http://www.hongyanliren.com/2015m07/35068.html">http://www.hongyanliren.com/2015m07/35068.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/14/2020/03/Java%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/14/2020/03/Java%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">Java线程的6种状态及切换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-14T00:00:00+08:00">2020-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java中线程的状态分为6种。</p>
<blockquote>
<ol>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>
<li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>
<li>阻塞(BLOCKED)：表示线程阻塞于锁。</li>
<li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>
</ol>
</blockquote>
<p>这6种状态定义在Thread类的State枚举中，可查看源码进行一一对应。</p>
<h4 id="线程的状态图"><a href="#线程的状态图" class="headerlink" title="线程的状态图"></a>线程的状态图</h4><p><img src="http://static.cyblogs.com/20181120173640764.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20181120173640764.jpg"></p>
<h5 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h5><p>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p>
<h5 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h5><p>就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。<br>调用线程的start()方法，此线程进入就绪状态。<br>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。<br>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。<br>锁池里的线程拿到对象锁后，进入就绪状态。</p>
<h5 id="运行中状态"><a href="#运行中状态" class="headerlink" title="运行中状态"></a>运行中状态</h5><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</p>
<h5 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h5><p>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p>
<h5 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h5><p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p>
<h5 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h5><p>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p>
<h5 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h5><p>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。<br>在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。<br>与等待队列相关的步骤和图</p>
<p><img src="http://static.cyblogs.com/20180701221233161.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180701221233161.jpg"></p>
<p>1、线程1获取对象A的锁，正在使用对象A。<br>2、线程1调用对象A的wait()方法。<br>3、线程1释放对象A的锁，并马上进入等待队列。<br>4、锁池里面的对象争抢对象A的锁。<br>5、线程5获得对象A的锁，进入synchronized块，使用对象A。<br>6、线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入同步队列。若线程5调用对象A的notify()方法，则唤醒一个线程，不知道会唤醒谁，被唤醒的那个线程进入同步队列。<br>7、notifyAll()方法所在synchronized结束，线程5释放对象A的锁。<br>8、同步队列的线程争抢对象锁，但线程1什么时候能抢到就不知道了。 </p>
<h4 id="同步队列状态"><a href="#同步队列状态" class="headerlink" title="同步队列状态"></a>同步队列状态</h4><ul>
<li>当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此时当前线程进入同步队列。简言之，同步队列里面放的都是想争夺对象锁的线程。</li>
<li>当一个线程1被另外一个线程2唤醒时，1线程进入同步队列，去争夺对象锁。</li>
<li>同步队列是在同步的环境下才有的概念，一个对象对应一个同步队列。</li>
<li>线程等待时间到了或被notify&#x2F;notifyAll唤醒后，会进入同步队列竞争锁，如果获得锁，进入RUNNABLE状态，否则进入BLOCKED状态等待获取锁。</li>
</ul>
<h4 id="几个方法的比较"><a href="#几个方法的比较" class="headerlink" title="几个方法的比较"></a>几个方法的比较</h4><p>1、Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。<br>2、Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。<br>3、thread.join()&#x2F;thread.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING&#x2F;TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程一般情况下进入RUNNABLE状态，也有可能进入BLOCKED状态（因为join是基于wait实现的）。<br>4、obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()&#x2F;notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。<br>5、obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。<br>6、LockSupport.park()&#x2F;LockSupport.parkNanos(long nanos),LockSupport.parkUntil(long deadlines), 当前线程进入WAITING&#x2F;TIMED_WAITING状态。对比wait方法,不需要获得锁就可以让线程进入WAITING&#x2F;TIMED_WAITING状态，需要通过LockSupport.unpark(Thread thread)唤醒。</p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><ul>
<li>等待队列里许许多多的线程都wait()在一个对象上，此时某一线程调用了对象的notify()方法，那唤醒的到底是哪个线程？随机？队列FIFO？or sth else？Java文档就简单的写了句：选择是任意性的（The choice is arbitrary and occurs at the discretion of the implementation）。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">https://blog.csdn.net/pange1991/article/details/53860651</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/13/2020/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%9AReentrantLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/13/2020/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%9AReentrantLock/" class="post-title-link" itemprop="url">Java并发编程系列：ReentrantLock</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-13 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-13T00:00:00+08:00">2020-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>ReentrantLock</code>和<code>synchronized</code>都是提供了同步的功能，<code>JDK1.6</code>之后对<code>synchronized</code>性能进行了优化，所以两者的性能上几乎没什么区别，但是<code>ReentrantLock</code>提供了了一些高级功能。</p>
<ul>
<li><p>等待可中断：在<code>synchronized</code>中，如果一个线程在等待锁，他只用两种结果，要么获得锁执行完，要么一直保持等待。可中断的等待是通知正在等待的线程，告诉他没必要再等待后。</p>
</li>
<li><p>实现公平锁：公平锁：会按照时间的先后顺序，保证先到先得。特点是它不会产生饥饿现象。而synchroized关键字进行所控制时，锁是非公平的。而重入锁可以设置为公平锁。 <code>public ReetranLock(boolean fair)</code> 当<code>fair</code>为<code>true</code>时，表示锁是公平的。实现公平锁必然要求系统维护一个有序队列，因此公平锁的成本比较高，性能也非常低向。默认情况下锁是非公平的。</p>
</li>
<li><p>绑定多个条件：类似于<code>Object</code>类的<code>wait</code>和<code>notify</code>方法，它是与<code>ReentrantLock</code>绑定的条件，可以绑定多个条件。</p>
</li>
</ul>
<h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p>注意：退出临界区要释放锁，否则其他线程就没有机回访问临界区了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">rlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            rlock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                rlock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TestReentrantLock</span> <span class="variable">tl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestReentrantLock</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tl); </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(tl); </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//表示当前线程等待t1执行完</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：退出临界区要释放锁，否则其他线程就没有机回访问临界区了。</p>
<h4 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h4><p><code>Lock</code>接口是<code>JDK1.5</code>新加的同步工具接口，它的实现类有<code>ReentrantLock</code>、<code>WriteLock</code>等，接口中定义了通用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 可中断获取锁，与lock()不同之处在于可响应中断操作，即在获取锁的过程中可中断</span></span><br><span class="line"><span class="comment">// synchronized在获取锁时是不可中断的</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//尝试非阻塞获取锁，调用该方法后立即返回结果，如果能够获取则返回true，否则返回false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//根据传入的时间段获取锁，在指定时间内没有获取锁则返回false，如果在指定时间内当前线程未被中并断获取到锁则返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//获取等待通知组件，该组件与当前锁绑定，当前线程只有获得了锁</span></span><br><span class="line"><span class="comment">//才能调用该组件的wait()方法，而调用后，当前线程将释放锁。</span></span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>lock</code>和<code>unlock</code>方法提供了<code>synchronized</code>的功能，其他方法使得同步过程更加的灵活。</p>
<h4 id="什么叫重入锁"><a href="#什么叫重入锁" class="headerlink" title="什么叫重入锁"></a>什么叫重入锁</h4><p>一个线程可以多次进入，当然必须多次释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rlock.lock();</span><br><span class="line">rlock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    rlock.unlock();</span><br><span class="line">    rlock.unlock();</span><br><span class="line">    <span class="comment">//如果释放次数多，则回抛出java.lang.IllegalMonitorStateException异常</span></span><br><span class="line">    <span class="comment">//rlock.unlock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面根据案例主要介绍<code>ReentrantLock</code>的用法，在后面的文章中介绍它的实现原理。</p>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>如果一个线程正在等待锁，那么它可以收到一个通知，被告知无序再等待，可以停止工作了。在<code>synchronized</code>中，<br>如果一个线程在等待锁，他只用两种结果，要么获得锁执行完，要么一直保持等待。</p>
<p>下面通过一个死锁的例子，介绍中断响应的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeathLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">int</span> lock;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeathLock</span><span class="params">(<span class="type">int</span> lock)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(lock==<span class="number">1</span>)&#123;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; get lock1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; get lock2&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; get lock2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; get lock1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//判断当前线程是否拥有该锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock1.isHeldByCurrentThread())</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            <span class="keyword">if</span>(lock2.isHeldByCurrentThread())</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 退出！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="comment">//这里new出两个实现Runnable的对象是因为为了传进去不同的lock值</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeathLock</span>(<span class="number">1</span>),<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeathLock</span>(<span class="number">1</span>),<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行过程是<code>thread1</code>占用<code>lock1</code>，休眠500毫秒，然后想占用<code>lock2</code>，与此同时，<code>thread2</code>占用<code>lock2</code>，休眠1000毫秒后在请求<code>lock1</code>。可是当<code>thread1</code>，想请求<code>lock2</code>时，已经被<code>thread2</code>占用，因此只能进入阻塞状态，<code>thread2</code>也同理进入阻塞状态。因此进入死锁。但是这里使用了<code>lockInterruptibly()</code>方法。这是一个可以对中断进行响应的锁申请动作，即在等待锁的过程中可以响应中断。在<code>thred2</code>调用<code>interrupt()</code>方法，<code>thread2</code>线程被中断，<code>thread2</code>放弃对<code>lock</code>的申请，同时释放已获得的<code>lock2</code>，所以<code>thread1</code>可以得到<code>lock2</code>继续执行下去。</p>
<p>结果为：</p>
<p><img src="http://static.cyblogs.com/20170809094510953.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20170809094510953.png"></p>
<p><code>thread2</code>先中断，抛出异常，跳入<code>finally</code>块，释放资源，最终退出。</p>
<h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><p>如果给定一个等待时间，超过时间，让线程自动放弃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; get　lock failed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">TimeLock</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimeLock</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t,<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryLock()</code>两个参数分别表示等待时长和计时单位，表示线程在请求锁的过程中，最多等待5秒，如果超过改时间则返回false，如果成果获得锁，则返回<code>true</code>。<br>该程序中首先任意一个线程先获得锁，然后休眠5秒，然而它一直占有锁，因此另一个线程无法再2秒内获得锁，因此失败。</p>
<p><code>tryLock()</code>方法也可以不带参数，这种情况下，当前线程会尝试获得锁，如果锁未被其他线程占用，则申请锁会成功，把那个返回<code>true</code>，如果锁被其他线程占用，则当前线程不会等待，而是立即返回<code>false</code>。这种模式下不会引起线程等待，因此也不会产生死锁。</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>大多数情况下，锁的申请都是非公平的，也就是说，线程1首先申请锁A，接着线程2也请求了锁A，当锁A可用时，线程1,2都有可能获得锁，系统只是在等待队列中随机挑选一个，因此不能保证公平性。<br>所以有了公平锁，公平锁：会按照时间的先后顺序，保证先到先得。特点是它不会产生饥饿现象。而<code>synchroized</code>关键字进行所控制时，锁是非公平的。而重入锁可以设置为公平锁。<br><code>public ReetranLock(boolean fair)</code><br>当<code>fair</code>为<code>true</code>时，表示锁是公平的。实现公平锁必然要求系统维护一个有序队列，因此公平锁的成本比较高，性能也非常低向。默认情况下锁是非公平的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairLock</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; get　lock !&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">FairLock</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FairLock</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f,<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分结果为：</p>
<p><img src="http://static.cyblogs.com/20170809094651573.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20170809094651573.png"></p>
<p>可以看出两个线程基本上是交替获得锁。</p>
<h4 id="Condition条件（搭配重入锁使用）"><a href="#Condition条件（搭配重入锁使用）" class="headerlink" title="Condition条件（搭配重入锁使用）"></a>Condition条件（搭配重入锁使用）</h4><p><code>Condition</code>类似于<code>wait()</code>和<code>notify()</code>的功能，它是与重入锁关联使用的。<code>Lock</code>接口中提供了<code>newCondition()</code>方法，该方法可以返回绑定到此<code>Lock</code>的<code>Condition</code>实例。</p>
<p>方法解释：<br><code>await</code>方法会使当前线程等待，同时释放当前锁，当其他线程中使用<code>signal()</code>或<code>signalAll()</code>方法时，线程会重新获得锁并继续执行，当线程被中断时，也能跳出等待。与<code>Object</code>的<code>wait()</code>方法相似。<br><code>singal()</code>方法用于唤醒一个在等待中的线程。<br>注意：以上连个方法调用之前必须当前线程拥有锁。否则抛出<code>IllegalMonitorStateException</code>异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//当前线程释放锁，进入等待状态</span></span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; get　lock !&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ConditionDemo</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConditionDemo</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//当thread1进入处于等待状态，main线程获得锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; get lock !&quot;</span>);</span><br><span class="line">        condition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果：</span></span><br><span class="line"><span class="comment">main get lock !</span></span><br><span class="line"><span class="comment">thread1 get　lock !</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<p><code>thread1</code>线程调用<code>await</code>时，要求线程持有相关的重入锁，调用后，线程释放这把锁，同理<code>signal</code>方法调用时，也要求线程先获得相关的锁，在<code>signal</code>方法调用后，系统会从当前的<code>Condition</code>对象的等待队列中唤醒一个线程，一旦线程唤醒，它会重新尝试获得之前绑定的锁，一旦成功获取<code>await</code>方法返回，继续执行。在调用<code>signal</code>后先睡眠2秒，并且保持了锁，释放了锁之后，<code>await</code>方法获取锁后才得以返回继续执行。因此打印出来的时间差为2000毫秒。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>上面结合例子介绍了<code>ReentrantLock</code>主要的用法，还有一些很有意思的用法，比如正在等待锁的线程，当前线程是否拥有锁等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询当前线程保持此锁的次数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getHoldCount</span><span class="params">()</span> </span><br><span class="line"><span class="comment">//返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。      </span></span><br><span class="line"><span class="keyword">protected</span>  Thread   <span class="title function_">getOwner</span><span class="params">()</span>; </span><br><span class="line"><span class="comment">//返回一个 collection，它包含可能正等待获取此锁的线程，其内部维持一个队列，这点稍后会分析。      </span></span><br><span class="line"><span class="keyword">protected</span>  Collection&lt;Thread&gt;   <span class="title function_">getQueuedThreads</span><span class="params">()</span>; </span><br><span class="line"><span class="comment">//返回正等待获取此锁的线程估计数。   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getQueueLength</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。</span></span><br><span class="line"><span class="keyword">protected</span>  Collection&lt;Thread&gt;   <span class="title function_">getWaitingThreads</span><span class="params">(Condition condition)</span>; </span><br><span class="line"><span class="comment">//返回等待与此锁相关的给定条件的线程估计数。       </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getWaitQueueLength</span><span class="params">(Condition condition)</span>;</span><br><span class="line"><span class="comment">// 查询给定线程是否正在等待获取此锁。     </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasQueuedThread</span><span class="params">(Thread thread)</span>; </span><br><span class="line"><span class="comment">//查询是否有些线程正在等待获取此锁。     </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//查询是否有些线程正在等待与此锁有关的给定条件。     </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasWaiters</span><span class="params">(Condition condition)</span>; </span><br><span class="line"><span class="comment">//如果此锁的公平设置为 true，则返回 true。     </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isFair</span><span class="params">()</span> </span><br><span class="line"><span class="comment">//查询当前线程是否保持此锁。      </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isHeldByCurrentThread</span><span class="params">()</span> </span><br><span class="line"><span class="comment">//查询此锁是否由任意线程保持。        </span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span>     </span><br></pre></td></tr></table></figure>

<p>进入<code>ReentrantLock</code>的源码发现，<code>ReentrantLock</code>类的绝大部分功能是通过它的内部类<code>Sync</code>来实现的，而<code>Sync</code>又继承了<code>AbstractQueuedSynchronizer</code>类。这就是大名鼎鼎的<code>AQS</code>，<code>Doug Lea</code>最著名的作品，后面的文章分析它的精华所在。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/TheLudlows/article/details/76962006">https://blog.csdn.net/TheLudlows/article/details/76962006</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/12/2020/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%85%B3%E9%97%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/12/2020/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%85%B3%E9%97%AD/" class="post-title-link" itemprop="url">Java并发编程：任务的取消和关闭</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-12 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-12T00:00:00+08:00">2020-03-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>任务和线程的启动很容易。在大多数时候，我们都会让它们运行直到结束，或者让它们自行停止。然而，有时候我们希望提前结束任务或线程，或许是因为用户取消了操作，或者应用程序需要被快速关闭。</p>
<p>要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java 没有提供任何机制来安全的终止线程。但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。</p>
<p>这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用一种协作的方式：当需要停止时，它们首先会清除当前正在执行的工作，然后再结束。这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代码更清除如何执行清除工作。</p>
<h4 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h4><p>在开始文章前，有几个问题需要思考一下：</p>
<ul>
<li>取消任务的方式由哪几种？</li>
<li>中断的策略是什么？</li>
<li>如何响应中断？</li>
</ul>
<h5 id="取消任务的方式有哪几种"><a href="#取消任务的方式有哪几种" class="headerlink" title="取消任务的方式有哪几种"></a>取消任务的方式有哪几种</h5><p>取消任务的方式大体上有一下两种：</p>
<ul>
<li>设置取消标志位</li>
<li>中断</li>
</ul>
<h6 id="设置取消标志位"><a href="#设置取消标志位" class="headerlink" title="设置取消标志位"></a>设置取消标志位</h6><p>设置某个“已请求取消”标志，而任务将定期地查看该标志。如果设置了这个标记，那么任务将提前结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BigInteger&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">p</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">            p = p.nextProbablePrime();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        cancelled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BigInteger&gt;(primes);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> List&lt;BigInteger&gt; <span class="title function_">aSecondOfPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">PrimeGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrimeGenerator</span>();</span><br><span class="line">        exec.execute(generator);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            generator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generator.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码使用了这项技术，其中的 <code>PrimeGenerator</code> 持续地枚举素数，知道它被取消。<code>cancel</code> 方法将设置 <code>cancelled</code> 标志，并且主循环在搜索下一个素数之前会首先检查这个标志（为了使这个过程能可靠的工作，标志 <code>cancelled</code> 必须为 <code>volatile</code> 类型）。</p>
<p><code>PrimeGenerator</code> 使用了一种简单的取消策略：客户代码通过调用 <code>cancel</code> 来请求取消，<code>PrimeGenerator</code> 在每次搜索素数前首先检查是否存在取消请求，如果存在则退出。</p>
<p>一个可取消的任务必须拥有取消策略，在这个策略中将详细地定义取消操作的<code>“How”</code>、<code>“When”</code>以及<code>“What”</code>，即其他代码如何（<code>How</code>）请求取消该任务，任务在何时（<code>When</code>）检查是否已经请求了取消，以及在响应取消请求时应该执行哪些（<code>What</code>）操作。</p>
<h6 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h6><p><code>PrimeGenerator</code> 中的取消机制最终会使得搜索素数的任务退出，但在退出过程中需要花费一定的时间。然而，如果使用这种方法的任务调用了一个阻塞方法，例如 <code>BlockingQueue.put</code>，那么可能会产生一个更严重的问题——任务可能永远不会检查取消标志位，因此永远不会结束。</p>
<p>接下来的代码说明了这个问题。生产者线程生成素数，并将它们放入一个阻塞队列。如果生产者的速度超过了消费者的处理速度，队列将被填满，<code>put</code> 方法也会阻塞。当生产者在 <code>put</code> 方法中阻塞时，如果消费者希望取消生产者任务，那么将发生什么情况？它可以调用 <code>cancel</code> 方法设置 <code>cancelled</code> 标志，但此时生产者却永远不能检查这个标志，因为它无法从阻塞的 <code>put</code> 方法中恢复过来（因为消费者此时已经停止从队列中取出素数，所以 <code>put</code> 方法将一直保持阻塞状态）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">cancelled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">needMoreStatus</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">	BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">    	<span class="built_in">this</span>.queue = queue;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="type">BigInteger</span> <span class="variable">p</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">        	<span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">            	queue.put(p = p.nextProbablePrime());</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        cancelled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> BlockingQueue&lt;BigInteger&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;BigInteger&gt; <span class="title function_">aSecondOfPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        BlockingQueue&lt;BigInteger&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;BigInteger&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="type">BrokenPrimeProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrokenPrimeProducer</span>(primes);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> producer.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BrokenPrimeProducer</code> 说明了一些自定义的取消机制无法与可阻塞的库函数实现良好交互的原因。如果任务代码能够响应中断，那么可以使用中断作为取消机制，并且利用许多库类中提供的中断支持。通常，中断是实现取消的最合理方式。</p>
<p>线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他的工作。</p>
<p>在 <code>Java</code> 的 <code>API</code> 或语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，那么都是不合适的，并且很难支撑起更大的应用。</p>
<p>每个线程都有一个 <code>boolean</code> 类型的中断状态。当中断线程时，这个线程的中断状态将被设置为 <code>true</code>。在 <code>Thread</code> 中包含了中断线程以及查询线程中断状态的方法。。<code>interrupt</code> 方法能中断目标线程，而 <code>isInterrupted</code> 方法能返回目标线程的中断状态。静态的 <code>interrupted</code> 方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 中断线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="comment">// 中断状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="comment">// 清除中断状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻塞库方法，例如 <code>Thread.sleep</code> 和 <code>Object.wait</code> 等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出 <code>InterruptedException</code>，表示阻塞操作由于中断而提前结束。<code>JVM</code> 并不能保证阻塞方法检测到中断的速度，但在实际情况中响应速度还是非常快的。</p>
<p>当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。通过这样的方法，中断操作将变得“有黏性”——如果不触发 <code>InterruptedException</code>，那么中断状态一直保持，直到明确地清除中断状态。</p>
<p>调用 <code>interrupt</code> 并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</p>
<p>对中断操作的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。有些方法，例如 <code>wait</code>、<code>sleep</code> 和 <code>join</code> 等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已经被设置好的中断状态时，将抛出一个异常。设计良好的方法可以完全忽略这种请求，只要它们能使调用代码对中断请求进行某种处理。设计槽糕的方法可能会屏蔽中断请求，从而导致调用栈中的其他代码无法对中断请求做出响应。</p>
<p>在使用静态的 <code>interrupted</code> 时应该小心，因为它会清除当前线程的中断状态。如果调用 <code>interrupted</code> 时返回了 <code>true</code>，那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出 <code>InterruptedException</code>，或者通过再次调用 <code>interrupt</code> 来恢复中断状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimeProducer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    </span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BigInteger</span> <span class="variable">p</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">            <span class="comment">/* Allow thread to exit */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> BlockingQueue&lt;BigInteger&gt; <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，在每次迭代循环中，有两个位置可以检测出中断：在阻塞的 <code>put</code> 方法调用中，以及在循环开始处查询中断状态时。由于调用了阻塞的 <code>put</code> 方法，因此这里并不一定需要进行显式的检测，但执行检测却会使 <code>PrimeProducer</code> 对中断具有更高的响应性，因为它是在启动寻找素数任务之前检查中断的，而不是在任务完成之后。如果可中断的阻塞方法的调用频率并不高，不足以获得足够的响应性，那么显式的检测中断状态能起到一定的帮助作用。</p>
<h5 id="中断策略是什么"><a href="#中断策略是什么" class="headerlink" title="中断策略是什么"></a>中断策略是什么</h5><p>正如任务中应该包含取消策略一样，线程同样应该包含中断策略中断策略规定线程如何解释某个中断请求——当发现中断请求时，应该做哪些工作（如果需要的话），哪些工作单元对于中断来说是原子操作，以及以多块的速度来响应中断。</p>
<p>最合理的中断策略是某种形式的线程级取消操作或服务级取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务，但对于那些包含非标准终端策略的线程或线程池，只能用于能知道这些策略的任务中。</p>
<p>区分任务和线程对中断的反应是很重要的。一个中断请求可以有一个或多个接收者——中断线程池中的某个工作者线程，同时意味着“取消当前任务”和“关闭工作者线程”。</p>
<p>任务不会在其自己拥有的线程中执行，而是在某个服务（例如线程池）拥有的线程中执行。对于非线程所有者的代码来说（例如，对于线程池而言，任何在线程池实现以外的代码），应该小心的保存中断状态，这样拥有线程的代码才能对中断做出响应，即使“非所有者”代码也可以做出响应。</p>
<p>这就是为什么大多数可阻塞的库函数都只是抛出 <code>InterruptedException</code> 作为中断响应。它们永远不会在某个由自己拥有的线程中运行，因为它们为任务或库代码实现了最合理的取消策略：尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以取消进一步的操作。</p>
<p>当检查到中断请求时，任务并不需要放弃所有的操作——它可以推迟处理中断请求，并直到某个更合适的时刻。因此需要记住中断请求，并在完成当前任务后抛出 <code>InterruptedException</code> 或者表示已经收到中断请求。这项技术能够确保在更新过程中发生中断时，数据结构不会被破坏。</p>
<p>任务不应该对执行该任务的线程的中断策略做出任何假设，除非该任务被专门设计为在服务中运行，并且在这些服务中心包含特定的中断策略。无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心地保存执行线程的中断状态。如果除了将 <code>InterruptedException</code> 传递给调用者外还需要执行其他操作，那么应该在捕获 <code>InterruptedException</code> 之后恢复中断状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().interrupt();</span><br></pre></td></tr></table></figure>


<p>正如任务代码不应该对其执行所在的线程的中断策略做出假设，执行取消操作的代码也不应该对线程的中断策略做出假设。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如关闭（<code>shutdown</code>）方法。</p>
<p>由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。</p>
<h5 id="如何响应中断"><a href="#如何响应中断" class="headerlink" title="如何响应中断"></a>如何响应中断</h5><p>当调用可中断的阻塞库函数时，例如 <code>Thread.sleep</code> 或 <code>BlockingQueue.put</code> 等，有两种使用策略可用来处理 <code>InterruptedException</code>：</p>
<p>传递异常（可能在执行某个特定于任务的清除操作之后），从而使你的方法也成为可中断的阻塞方法。<br>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。<br>传递 <code>InterruptedException</code> 与将 <code>InterruptedException</code> 添加到 <code>throws</code> 字句中一样容易，如下代码清单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">getNextInteger</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果不想或无法传递 <code>InterruptedException</code>（或许通过 <code>Runnable</code> 来定义任务），那么需要寻找另一种方式来保存中断请求。一种标准的方法就是再次调用 <code>interrupt</code> 来恢复中断状态。你不能屏蔽 <code>InterruptedException</code>，例如在 <code>catch</code> 块中捕获到异常却不做任何处理，除非在你的代码中实现了线程的中断策略。虽然 <code>PrimeProducer</code> 屏蔽了中断，但这是因为它已经知道线程将要结束，因此在调用栈中已经没有上层代码需要知道中断信息。由于大多数代码并不知道它们将在哪个线程中运行，因此应该保存中断状态。</p>
<p>只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。</p>
<p>对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获 <code>InterruptedException</code> 时恢复状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigInteger <span class="title function_">getNextInteger</span><span class="params">(BlockingQueue&lt;BigInteger&gt; queue)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 重新尝试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(interrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，如果过早的设置中断状态，就可能引起无限循环，因为大多数可中断的阻塞方法都会在入口处检查中断状态，并且当发现该状态已经被设置时会立即抛出 <code>InterruptedException</code>（通常，可中断的方法会在阻塞或进行重要的工作前首先检查中断，从而尽快地响应中断）。</p>
<p>如果代码不会调用可中断的阻塞方法，那么仍然可以通过在任务代码中轮询当前线程的中断状态来响应中断。要选择合适的轮询频率，就需要在效率和响应性之间进行权衡。如果响应性要求较高，那么不应该调用那些执行时间较长并且不响应中断的方法，从而对可调用的库代码进行一些限制。</p>
<p>在取消过程中可能涉及除了中断状态之外的其他状态。中断可以用来获得线程的注意，并且由中断线程保存的信息，可以为中断的线程提供进一步指示（当访问这些信息时，要确保使用同步）。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/dilixinxixitong2009/article/details/79752404">https://blog.csdn.net/dilixinxixitong2009/article/details/79752404</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/11/2020/03/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/11/2020/03/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">G1垃圾收集器详细介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-11T00:00:00+08:00">2020-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="1、G1垃圾收集器介绍"><a href="#1、G1垃圾收集器介绍" class="headerlink" title="1、G1垃圾收集器介绍"></a>1、G1垃圾收集器介绍</h4><p>G1垃圾收集器针对具有大量内存的多处理器机器。它试图以很高的概率满足GC停顿时间目标，同时实现高吞吐量且几乎不需要配置。G1旨在在延迟和吞吐量之间提供最佳平衡，应用场景包括如下环境特征：</p>
<ul>
<li>堆大小可达10 GB或更大，超过50％的Java堆占用实时数据。</li>
<li>随着时间的推移，对象分配速度和晋升（从新生代到老年代的晋升）速度会发生显著变化。</li>
<li>堆中大量的碎片。</li>
<li>可预测的时间停顿目标不超过几百毫秒，避免长时间垃圾收集停顿。</li>
</ul>
<p>G1取了CMS，G1也是默认的收集器（JVM9、JVM10）。</p>
<p>G1收集器有很高的性能，并尝试通过以下几节所述的几种方式来满足停顿时间的目标。</p>
<h4 id="2、启用G1收集器"><a href="#2、启用G1收集器" class="headerlink" title="2、启用G1收集器"></a>2、启用G1收集器</h4><p>G1是默认收集器，因此通常不需要执行任何其他操作。您可以通过在命令行上提供-XX：+ UseG1GC来显式启用它。</p>
<h4 id="3、基本概念"><a href="#3、基本概念" class="headerlink" title="3、基本概念"></a>3、基本概念</h4><p>G1是分代的、增量的、并行、大部分、并发的、stop-the-word、以及疏散（将活着的对象从一个区域（youngor young + old）拷贝到另一个区域）的垃圾收集器，用于监视每个stop-the-word停顿的停顿时间目标。与其他收集器类似，G1将堆分成（虚拟）新生代和老年代。空间回收的主要集中在年轻代，因为这样做最有效率，在老年代偶尔会有空间回收。</p>
<p>一些操作总是在stop-the-word停顿中执行以提高吞吐量。其他需要更多时间停止应用程序的操作（例如全局标记等全堆操作）将与应用程序同时并行并发执行。为了让空间回收stop-the-word停顿短，G1逐步地并行执行空间回收。G1通过跟踪以前的应用程序行为信息和垃圾收集停顿的信息来建立相关成本的模型，以此实现可预测性。它使用这些信息来调整在停顿中完成的工作。例如，G1首先在最有效率的区域回收空间（即大部分填充垃圾的区域，因此是名称）。</p>
<p>G1主要通过疏散回收空间：回收时，在选定的内存区域内发现的活动对象被复制到新的内存区域，在此过程中压缩它们。疏散完成后，由先前活动对象占据的空间被重新用于应用程序的分配。</p>
<p>垃圾收集器不是实时收集器。 它试图在较长的时间内，以很高的概率满足设定的停顿时间的目标，但对于给定的停顿，并不总是具有绝对的确定性。</p>
<h5 id="3-1、堆布局"><a href="#3-1、堆布局" class="headerlink" title="3.1、堆布局"></a>3.1、堆布局</h5><p>G1将堆分成一组相同大小的region，每个region占有一个连续的虚拟内存地址，如图1所示。 region是内存分配和内存回收的基本单位。 在任何给定的时间，这些region中的每一个都可以是空的（浅灰色），或者已经分配给特定的年轻代或老年代。 当内存请求出现时，内存管理器会拿出空闲区域。 内存管理器将它们分配给某一代，然后将它们作为空闲空间返回给应用程序，在该空间中，它可以分配自身。</p>
<p><img src="http://static.cyblogs.com/20180504154701245.png" alt="图1-G1堆内存布局"></p>
<p>[图1-G1堆内存布局]</p>
<p>年轻代包含eden区（红色）和幸存区（包含“S”的红色）。 这些region提供与其他收集器中相应的连续空间相同的功能，区别在于，在G1中，这些region通常在内存中以非连续模式布局。老region（浅蓝色）组成了老年代。对于跨越多个区域的物体，老年代region可能会变得很大（包含“H”的浅蓝色）。</p>
<p>应用程序总是将内存分配到新生代，即eden region，但是除了那些被直接分配到老年代的大对象。</p>
<p>G1 GC停顿可以回收整个新生代的空间，并且在任何收集停顿时，任何附加的老年代region都可以回收。停顿期间，G1将此收集集合中的对象复制到堆中的一个或多个不同region。对象的目的region域取决于该对象的源region：整个新生代被复制到幸存者或老年代region，老年代region的对象复制到其他不同老年代region。</p>
<h5 id="3-2、GC周期"><a href="#3-2、GC周期" class="headerlink" title="3.2、GC周期"></a>3.2、GC周期</h5><p>在较高的水平上，G1收集器在两个阶段之间交替。 young-only阶段包含垃圾收集，这些垃圾收集逐渐用老年代的对象来填充当前可用的内存。space-reclamation阶段是G1除了处理年轻一代之外，逐步回收老一代的空间。然后，循环以young-only阶段重新开始。</p>
<p>图2以一个可能发生的垃圾收集停顿序列为例说明了这个周期。</p>
<p><img src="http://static.cyblogs.com/20180504154735933.png" alt="img"></p>
<p>[图2垃圾收集周期概述]</p>
<p>以下列表详细介绍了G1垃圾回收周期的这两个阶段，以及它们的停顿和转换过程：</p>
<p>1、young-only阶段：这一阶段从对象晋升到老年代的收集开始。当老年代占用率达到某一阈值（Initiating Heap Occupancy threshold）时，young-only阶段和space-reclamation阶段之间的转换就开始了。在这个时候，G1安排了一个初始标记的young-only收集，而不是一个普通的young-only收集。</p>
<ul>
<li>初始标记：除了执行常规的young-only的收集之外，这种类型的收集开始标记过程。并发标记确定老年代region中的所有当前可到达（实时）对象将保留到以下space-reclamation阶段。标记尚未完全结束时，可能会发生常规新生代收集。标记结束了两个特殊的stop-the-word停顿：重新标注和清理。</li>
<li>重新标记：此停顿完成标记本身，并执行全局引用处理和类卸载。在重新标记和清理阶段之间G1并发计算对象活跃度概要信息，并将在清理停顿中用于更新内部数据结构。</li>
<li>清理：此停顿也回收完全空白的区域，并确定space-reclamation阶段是否会实际执行。如果有space-reclamation阶段，那么young-only阶段完成一次young-only收集。</li>
</ul>
<p>2、space-reclamation阶段：这一阶段由多个混合收集组成，除了新生代region之外，还会疏散老年代region存活对象。当G1确定疏散更多老一代的地区不会产生足够的可用空间时，space-reclamation阶段结束。</p>
<p>在space-reclamation之后，收集周期将以另一个young-only阶段重新开始。 作为备选，如果应用程序在收集对象存活信息时内存溢出，G1像其他收集器一样就地执行stop-the-word全局堆压缩（Full GC）。</p>
<h4 id="4、G1内部"><a href="#4、G1内部" class="headerlink" title="4、G1内部"></a>4、G1内部</h4><p>本节介绍G1 GC的一些重要细节。</p>
<h5 id="4-1、确定Initiating-HeapOccupancy"><a href="#4-1、确定Initiating-HeapOccupancy" class="headerlink" title="4.1、确定Initiating HeapOccupancy"></a>4.1、确定Initiating HeapOccupancy</h5><p>The Initiating Heap Occupancy Percent（IHOP）是触发初始标记收集的阈值，它被定义为老年代大小的百分比。</p>
<p>默认情况下，G1通过观察标记周期中标记需要多长时间以及老年代通常分配多少内存来自动确定最佳IHOP。这个功能称为Adaptive IHOP。如果此功能处于活动状态，在没有足够的观察值来很好地预测Initiating Heap Occupancy阈值的情况下，选项-XX：InitiatingHeapOccupancyPercent会以当前老年代的大小的百分比来确定初始值。 使用选项-XX：-G1UseAdaptiveIHOP关闭G1的这种行为。 在这种情况下，-XX：InitiatingHeapOccupancyPercent的值始终确定此阈值。</p>
<p>在内部，AdaptiveIHOP尝试设置Initiating Heap Occupancy，以便在老年代占有率处于当前最大老年代大小减去作为额外缓冲区的-XX：G1HeapReservePercent值时，开始空间回收阶段的第一个混合GC。</p>
<h5 id="4-2、标记"><a href="#4-2、标记" class="headerlink" title="4.2、标记"></a>4.2、标记</h5><p>G1标记使用称为 Snapshot-At-The-Beginning （SATB）的算法。 它在初始标记停顿时获取堆的虚拟快照，当标记开始时处于活动状态的所有对象，在标记剩余部分也被认为是活动的对象。这意味着标记期间变为死亡（无法访问）的对象，对space-reclamation阶段仍然被认为是存活的（有一些例外）。与其他收集器相比，这可能会导致一些额外的内存被错误保留。但是，在重新标记停顿期间，SATB可能会提供更好的延迟。在该标记过程中，过于保守考虑的存活对象，将在下一次标记过程中回收。</p>
<h5 id="4-3、在堆内存紧张下的行为"><a href="#4-3、在堆内存紧张下的行为" class="headerlink" title="4.3、在堆内存紧张下的行为"></a>4.3、在堆内存紧张下的行为</h5><p>当应用程序保持如此多的内存，疏散过程无法找到足够的空间进行复制时，会发生疏散失败。疏散失败意味着G1试图通过以下方式来完成当前GC，保留任何已经移动到新位置的对象，不复制任何尚未移动的对象，只调整对象之间的引用。疏散失败可能会带来一些额外开销，但通常应该像其他年轻代收集一样快。在疏散失败的GC之后，G1将照常恢复应用程序，无需任何其他措施。G1假定疏散失败发生在GC结束附近; 也就是说，大多数对象已经移动并且有足够的空间继续运行应用程序，直到标记完成并开始space-reclamation。</p>
<p>如果这个假设不成立，那么G1最终将安排一个fullGC。 这种类型的收集就地执行整个堆的压缩。 这可能非常缓慢。</p>
<h5 id="4-4、大对象"><a href="#4-4、大对象" class="headerlink" title="4.4、大对象"></a>4.4、大对象</h5><p>大对象是大于或等于半个region大小的对象。 除非使用-XX：G1HeapRegionSize选项进行设置，否则当前region的尺寸按照人体工程学设计确定，参考“G1 GC人体工程学默认值”章节所述。</p>
<p>这些大对象有时以特殊的方式进行处理：</p>
<ul>
<li>每一个大对象都被分配为老年代的一系列连续region。对象的开始位置始终位于该序列中第一个region的开始位置。该序列中最后一个region的剩余空间将丢失，直到整个对象被回收。</li>
<li>一般来说，只有在清理停顿期间的标记结束时，或者在Full GC期间，如果大对象变得无法到达，则可以被回收。但是，对于原始类型数组的大对象（例如bool，各种整数和浮点值）有一个特殊规定。如果G1在任何类型的GC停顿时都没有被任何对象引用，那么G1会尝试回收大对象。此行为默认启用，但可以使用选项-XX：G1EagerReclaimHumongousObjects将其禁用。</li>
<li>大对象的分配可能会导致GC停顿过早发生。 G1会在每个大对象分配中检查InitiatingHeap Occupancy阈值，如果当前占用率超过该阈值，可能会立即强制新生代收集初始标记。</li>
<li>大对象不会移动，即使在fullGC中也不会移动。 这可能会导致过早执行缓慢的fullGC或意外的内存溢出情况，尽管region空间碎片留下大量剩余空间。</li>
</ul>
<h5 id="4-5、young-only阶段代大小设置"><a href="#4-5、young-only阶段代大小设置" class="headerlink" title="4.5、young-only阶段代大小设置"></a>4.5、young-only阶段代大小设置</h5><p>在young-only阶段，要收集的region集合（收集集合）只包括新生代region。G1一直在young-only 收集结束时设置新生代大小。这样，G1根据实际暂停时间的长期观察值，就可以满足使用-XX：MaxGCPauseTimeMillis和-XX：PauseTimeIntervalMillis设置的停顿时间目标。它考虑了新生代同样规模的疏散需要多长时间。这包括诸如在收集期间需要复制多少个对象以及这些对象之间是如何相互关联的信息。</p>
<p>如果没有其他约束，则G1适应性地将年轻代大小设定为-XX：G1NewSizePercent和-XX：G1MaxNewSizePercent确定的值以满足停顿时间。</p>
<h5 id="4-6、Space-reclamation阶段代大小设置"><a href="#4-6、Space-reclamation阶段代大小设置" class="headerlink" title="4.6、Space-reclamation阶段代大小设置"></a>4.6、Space-reclamation阶段代大小设置</h5><p>在space-reclamation阶段，G1试图在单个垃圾收集停顿中最大回收化老年代空间。新生代的大小设置为允许的最小值，通常由-XX：G1NeSizeSizePercent确定，并且任何老年代region回收空间都会被添加，直到G1确定添加更多region将超过停顿时间的目标。在特定的GC停顿中，G1按其回收效率、剩余可用时间顺序添加老年代region，以获得最终收集集合。</p>
<p>要收集的潜在候选老年代region（收集集合候选region）的低端数量除以由-XX：G1MixedGCCountTarget确定的space-reclamation阶段的长度，得到商X，每次GC所采用的老年代region数量由商X确定下界。收集集合候选region：在本阶段开始时所占用的（小于-XX:G1MixedGCLiveThresholdPercent）老年代region</p>
<p>当收集组候选region中可回收的剩余空间量小于-XX：G1HeapWastePercent设置的百分比时，space-reclamation阶段结束。</p>
<h4 id="5、G1-GC的人机工程学默认值"><a href="#5、G1-GC的人机工程学默认值" class="headerlink" title="5、G1 GC的人机工程学默认值"></a>5、G1 GC的人机工程学默认值</h4><p>本主题概述了G1的最重要的参数及其默认值。他们给出了对预期行为和资源使用情况粗略概述，没有任何其他选项。</p>
<p><img src="http://static.cyblogs.com/20180504155312661.png" alt="img"><br>**</p>
<p>注意：<ergo>意味着实际的值是由人体工程学决定的，这取决于环境。</p>
<p><strong>6、与其他收集器对比</strong></p>
<p>这是对G1和其他收集器之间主要区别的总结：</p>
<ul>
<li>Parallel GC在老年代中全部压缩和回收空间。G1逐渐将这个工作分布在多个更短的收集中。这显著缩短了暂停时间，但可能会降低吞吐量。</li>
<li>与CMS相似，G1并发执行部分老年代space-reclamation。然而，CMS不能将老年代堆碎片整理出来，最终会运行长时间的full GC。</li>
<li>G1的开销可能比其他收集器高，因为它的并发特性影响了吞吐量。</li>
</ul>
<p>由于它的工作原理，G1有一些独特的机制来提高垃圾收集效率：</p>
<ul>
<li>在任何收集过程中，G1都可以回收老年代的一些完全空的、大的区域。这可以避免许多不必要的垃圾收集，在不费多大力气的情况下释放大量的空间。</li>
<li>G1可以选择性地尝试同时在Java堆上删除重复的字符串。</li>
</ul>
<p>从老年代中回收空的大型对象总是启用的。您可以使用选项-XX：-G1EagerReclaimHumongousObjects来禁用该特性。在默认情况下，字符串重复删除是禁用的。你可以使用选项-XX：+ G1EnableStringDeduplication来启用它。</p>
<p>由于水平有限，翻译的不好，欢迎批评指正。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/bill_hai/article/details/80196149">https://blog.csdn.net/bill_hai/article/details/80196149</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/03/10/2020/03/BlockingQueue%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%8A%E7%BA%BF%E7%A8%8B%E7%8E%A9%E7%9A%84%E5%A6%82%E6%AD%A4%E4%B9%8B%E7%89%9B%E7%9A%84%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/10/2020/03/BlockingQueue%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%8A%E7%BA%BF%E7%A8%8B%E7%8E%A9%E7%9A%84%E5%A6%82%E6%AD%A4%E4%B9%8B%E7%89%9B%E7%9A%84%EF%BC%9F/" class="post-title-link" itemprop="url">BlockingQueue是如何把线程玩的如此之牛的？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-10T00:00:00+08:00">2020-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>BlockingQueue</code>即阻塞队列，它算是一种将<code>ReentrantLock</code>用得非常精彩的一种表现，依据它的基本原理，我们可以实现Web中的长连接聊天功能，当然其最常用的还是用于实现生产者与消费者模式，大致如下图所示：</p>
<p><img src="http://static.cyblogs.com/20161108212521456.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161108212521456.png"></p>
<p>在Java中，<code>BlockingQueue</code>是一个接口，它的实现类有<code>ArrayBlockingQueue</code>、<code>DelayQueue</code>、 <code>LinkedBlockingDeque</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>、<code>SynchronousQueue</code>等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。下面的源码以<code>ArrayBlockingQueue</code>为例。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><code>BlockingQueue</code>内部有一个<code>ReentrantLock</code>，其生成了两个<code>Condition</code>，在<code>ArrayBlockingQueue</code>的属性声明中可以看见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果能把<code>notEmpty</code>、<code>notFull</code>、<code>put</code>线程、<code>take</code>线程拟人的话，那么我想<code>put</code>与<code>take</code>操作可能会是下面这种流程：</p>
<p><strong>put(e)</strong></p>
<p><img src="http://static.cyblogs.com/20161108212418173.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161108212418173.png"></p>
<p><strong>take()</strong></p>
<p><img src="http://static.cyblogs.com/20161108212452384.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20161108212452384.png"></p>
<p>其中<code>ArrayBlockingQueue.put(E e)</code>源码如下（其中中文注释为自定义注释，下同）：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue, waiting</span></span><br><span class="line"><span class="comment"> * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">   checkNotNull(e);</span><br><span class="line">   <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">   lock.lockInterruptibly();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == items.length)</span><br><span class="line">           notFull.await(); <span class="comment">// 如果队列已满，则等待</span></span><br><span class="line">       insert(e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element at current put position, advances, and signals.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E x)</span> &#123;</span><br><span class="line"> 		items[putIndex] = x;</span><br><span class="line">	 	putIndex = inc(putIndex);</span><br><span class="line">		++count;</span><br><span class="line"> 		notEmpty.signal(); <span class="comment">// 有新的元素被插入，通知等待中的取走元素线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArrayBlockingQueue.take()</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await(); <span class="comment">// 如果队列为空，则等待</span></span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extracts element at current take position, advances, and signals.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">extract</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">this</span>.&lt;E&gt;cast(items[takeIndex]);</span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    takeIndex = inc(takeIndex);</span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal(); <span class="comment">// 有新的元素被取走，通知等待中的插入元素线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，put(E)与take()是同步的，在put操作中，当队列满了，会阻塞put操作，直到队列中有空闲的位置。而在take操作中，当队列为空时，会阻塞take操作，直到队列中有新的元素。</p>
<p>而这里使用两个Condition，则可以避免调用signal()时，会唤醒相同的put或take操作。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/t894690230/article/details/53088660">https://blog.csdn.net/t894690230/article/details/53088660</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Vernon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <a target="_blank" href="https://beian.miit.gov.cn">粤ICP备2025433887号</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
