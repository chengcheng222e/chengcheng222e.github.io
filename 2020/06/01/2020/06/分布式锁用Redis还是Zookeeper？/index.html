<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Zookeeper,Redis,分布式锁," />


<meta name="description" content="为什么用分布式锁？在讨论这个问题之前，我们先来看一个业务场景。 为什么用分布式锁？系统 A 是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。 由于系统有一定的并发，所以会预先将商品的库存保存在 Redis 中，用户下单的时候会更新 Redis 的库存。 此时系统架构如下：  但是这样一来会产生一个问题：假如某个">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式锁用Redis还是Zookeeper？">
<meta property="og:url" content="http://www.cyblogs.com/2020/06/01/2020/06/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%94%A8Redis%E8%BF%98%E6%98%AFZookeeper%EF%BC%9F/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:description" content="为什么用分布式锁？在讨论这个问题之前，我们先来看一个业务场景。 为什么用分布式锁？系统 A 是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。 由于系统有一定的并发，所以会预先将商品的库存保存在 Redis 中，用户下单的时候会更新 Redis 的库存。 此时系统架构如下：  但是这样一来会产生一个问题：假如某个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s5.51cto.com/oss/201907/16/3e9e699864efd973960054445fbc67f4.jpg">
<meta property="og:image" content="http://static.cyblogs.com/ce0fee95ef6880c9ac5ba670fe5be268.jpg">
<meta property="og:image" content="http://static.cyblogs.com/99f3874bd484b4ea8000ca41023be3dc.jpg-wh_600x-s_592420448.jpg">
<meta property="og:image" content="http://static.cyblogs.com/3667d7cff8435d47f5a187ad596bdb09.jpg-wh_600x-s_1198484587.jpg">
<meta property="og:image" content="http://static.cyblogs.com/da6b5468501519f5688e47824b56ba21.jpg-wh_600x-s_4091681668.jpg">
<meta property="og:image" content="http://static.cyblogs.com/a7fbd80edbe1bc035e0a6e1c3c691ed7.jpg-wh_600x-s_1313345474.jpg">
<meta property="og:image" content="http://static.cyblogs.com/fb6c27bb22de93cbeb965718156f578f.jpg">
<meta property="og:image" content="https://s5.51cto.com/oss/201907/16/84636c96585ff2611ff55e284a57c6ab.jpg-wh_600x-s_3685227374.jpg">
<meta property="og:image" content="http://static.cyblogs.com/onegoleya.jpeg">
<meta property="article:published_time" content="2020-05-31T16:00:00.000Z">
<meta property="article:modified_time" content="2020-08-02T15:01:36.901Z">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="Zookeeper">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="分布式锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s5.51cto.com/oss/201907/16/3e9e699864efd973960054445fbc67f4.jpg">


  


  <link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml" />




  <link rel="canonical" href="http://www.cyblogs.com/2020/06/01/2020/06/分布式锁用Redis还是Zookeeper？/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>分布式锁用Redis还是Zookeeper？ | 简栈文化</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">简栈文化</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Java技术人的成长之路~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/06/01/2020/06/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%94%A8Redis%E8%BF%98%E6%98%AFZookeeper%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Vernon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/%E4%B8%AA%E4%BA%BA%E5%A4%B4%E5%83%8F.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">分布式锁用Redis还是Zookeeper？</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-01T00:00:00+08:00">2020-06-01</time>
            

            
            
              
                
              
            

            
              
              <span class="post-meta-divider">|</span>
              

              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-08-02T23:01:36+08:00">2020-08-02</time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>为什么用分布式锁？在讨论这个问题之前，我们先来看一个业务场景。</p>
<h4 id="为什么用分布式锁？"><a href="#为什么用分布式锁？" class="headerlink" title="为什么用分布式锁？"></a>为什么用分布式锁？</h4><p>系统 A 是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。</p>
<p>由于系统有一定的并发，所以会预先将商品的库存保存在 Redis 中，用户下单的时候会更新 Redis 的库存。</p>
<p>此时系统架构如下：</p>
<p><img src="https://s5.51cto.com/oss/201907/16/3e9e699864efd973960054445fbc67f4.jpg" alt="img"></p>
<p>但是这样一来会产生一个问题：假如某个时刻，Redis 里面的某个商品库存为 1。</p>
<p>此时两个请求同时到来，其中一个请求执行到上图的第 3 步，更新数据库的库存为 0，但是第 4 步还没有执行。</p>
<p>而另外一个请求执行到了第 2 步，发现库存还是 1，就继续执行第 3 步。这样的结果，是导致卖出了 2 个商品，然而其实库存只有 1 个。</p>
<p>很明显不对啊！这就是典型的库存超卖问题。此时，我们很容易想到解决方案：用锁把 2、3、4 步锁住，让他们执行完之后，另一个线程才能进来执行第 2 步。</p>
<p><img src="http://static.cyblogs.com/ce0fee95ef6880c9ac5ba670fe5be268.jpg" alt="http://static.cyblogs.com/ce0fee95ef6880c9ac5ba670fe5be268.jpg"></p>
<p>按照上面的图，在执行第 2 步时，使用 Java 提供的 Synchronized 或者 ReentrantLock 来锁住，然后在第 4 步执行完之后才释放锁。</p>
<p>这样一来，2、3、4 这 3 个步骤就被“锁”住了，多个线程之间只能串行化执行。</p>
<p>但是好景不长，整个系统的并发飙升，一台机器扛不住了。现在要增加一台机器，如下图：</p>
<p><img src="http://static.cyblogs.com/99f3874bd484b4ea8000ca41023be3dc.jpg-wh_600x-s_592420448.jpg" alt="http://static.cyblogs.com/99f3874bd484b4ea8000ca41023be3dc.jpg-wh_600x-s_592420448.jpg"></p>
<p>增加机器之后，系统变成上图所示，我的天！假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现库存超卖的问题。</p>
<p>为什么呢？因为上图中的两个 A 系统，运行在两个不同的 JVM 里面，他们加的锁只对属于自己 JVM 里面的线程有效，对于其他 JVM 的线程是无效的。</p>
<p>因此，这里的问题是：Java 提供的原生锁机制在多机部署场景下失效了，这是因为两台机器加的锁不是同一个锁（两个锁在不同的 JVM 里面）。</p>
<p>那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？此时，就该分布式锁隆重登场了。</p>
<p>分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。</p>
<p>至于这个“东西”，可以是 Redis、Zookeeper，也可以是数据库。文字描述不太直观，我们来看下图：</p>
<p><img src="http://static.cyblogs.com/3667d7cff8435d47f5a187ad596bdb09.jpg-wh_600x-s_1198484587.jpg" alt="http://static.cyblogs.com/3667d7cff8435d47f5a187ad596bdb09.jpg-wh_600x-s_1198484587.jpg"></p>
<p>通过上面的分析，我们知道了库存超卖场景在分布式部署系统的情况下使用 Java 原生的锁机制无法保证线程安全，所以我们需要用到分布式锁的方案。</p>
<p>那么，如何实现分布式锁呢？接着往下看！</p>
<h4 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h4><p>上面分析为啥要使用分布式锁了，这里我们来具体看看分布式锁落地的时候应该怎么样处理。</p>
<p><strong>①常见的一种方案就是使用 Redis 做分布式锁</strong></p>
<p>使用 Redis 做分布式锁的思路大概是这样的：在 Redis 中设置一个值表示加了锁，然后释放锁的时候就把这个 Key 删除。</p>
<p>具体代码是这样的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取锁 </span><br><span class="line">// NX是指如果key不存在就成功，key存在返回<span class="literal">false</span>，PX可以指定过期时间 </span><br><span class="line">SET anyLock unique_value NX PX <span class="number">30000</span> </span><br><span class="line"> </span><br><span class="line">// 释放锁：通过执行一段lua脚本 </span><br><span class="line">// 释放锁涉及到两条指令，这两条指令不是原子性的 </span><br><span class="line">// 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的 </span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这种方式有几大要点：</p>
<ul>
<li>一定要用 SET key value NX PX milliseconds 命令。如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(Key ***存在)</li>
<li>Value 要具有唯一性。这个是为了在解锁的时候，需要验证 Value 是和加锁的一致才删除 Key。</li>
</ul>
<p>这时避免了一种情况：假设 A 获取了锁，过期时间 30s，此时 35s 之后，锁已经自动释放了，A 去释放锁，但是此时可能 B 获取了锁。A 客户端就不能删除 B 的锁了。</p>
<p>除了要考虑客户端要怎么实现分布式锁之外，还需要考虑 Redis 的部署问题。</p>
<p>Redis 有 3 种部署方式：</p>
<ul>
<li>单机模式</li>
<li>Master-Slave+Sentinel 选举模式</li>
<li>Redis Cluster 模式</li>
</ul>
<p>使用 Redis 做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要 Redis 故障了。加锁就不行了。</p>
<p>采用 Master-Slave 模式，加锁的时候只对一个节点加锁，即便通过 Sentinel 做了高可用，但是如果 Master 节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。</p>
<p>基于以上的考虑，Redis 的作者也考虑到这个问题，他提出了一个 RedLock 的算法。</p>
<p>这个算法的意思大概是这样的：假设 Redis 的部署模式是 Redis Cluster，总共有 5 个 Master 节点。</p>
<p>通过以下步骤获取一把锁：</p>
<ul>
<li>获取当前时间戳，单位是毫秒。</li>
<li>轮流尝试在每个 Master 节点上创建锁，过期时间设置较短，一般就几十毫秒。</li>
<li>尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点（n / 2 +1）。</li>
<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了。</li>
<li>要是锁建立失败了，那么就依次删除这个锁。</li>
<li>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。</li>
</ul>
<p>但是这样的这种算法还是颇具争议的，可能还会存在不少的问题，无法保证加锁的过程一定正确。</p>
<p><img src="http://static.cyblogs.com/da6b5468501519f5688e47824b56ba21.jpg-wh_600x-s_4091681668.jpg" alt="http://static.cyblogs.com/da6b5468501519f5688e47824b56ba21.jpg-wh_600x-s_4091681668.jpg"></p>
<p><strong>②另一种方式：Redisson</strong></p>
<p>此外，实现 Redis 的分布式锁，除了自己基于 Redis Client 原生 API 来实现之外，还可以使用开源框架：Redission。</p>
<p>Redisson 是一个企业级的开源 Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？</p>
<p>回想一下上面说的，如果自己写代码来通过 Redis 设置一个值，是通过下面这个命令设置的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET anyLock unique_value NX PX <span class="number">30000</span></span><br></pre></td></tr></table></figure>

<p>这里设置的超时时间是 30s，假如我超过 30s 都还没有完成业务逻辑的情况下，Key 会过期，其他线程有可能会获取到锁。</p>
<p>这样一来的话，***个线程还没执行完业务逻辑，第二个线程进来了也会出现线程安全问题。</p>
<p>所以我们还需要额外的去维护这个过期时间，太麻烦了~我们来看看 Redisson 是怎么实现的？</p>
<p>先感受一下使用 Redission 的爽：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config(); </span><br><span class="line">config.useClusterServers() </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7001"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7002"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7003"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7001"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7002"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7003"</span>); </span><br><span class="line"> </span><br><span class="line">RedissonClient redisson = Redisson.create(config); </span><br><span class="line"></span><br><span class="line">RLock lock = redisson.getLock(<span class="string">"anyLock"</span>); </span><br><span class="line">lock.lock(); </span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>就是这么简单，我们只需要通过它的 API 中的 Lock 和 Unlock 即可完成分布式锁，他帮我们考虑了很多细节：</p>
<ul>
<li>Redisson 所有指令都通过 Lua 脚本执行，Redis 支持 Lua 脚本原子性执行。</li>
<li>Redisson 设置一个 Key 的默认过期时间为 30s，如果某个客户端持有一个锁超过了 30s 怎么办？</li>
<li>Redisson 中有一个 Watchdog 的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔 10s 帮你把 Key 的超时时间设为 30s。</li>
</ul>
<p>这样的话，就算一直持有锁也不会出现 Key 过期了，其他线程获取到锁的问题了。</p>
<ul>
<li>Redisson 的“看门狗”逻辑保证了没有死锁发生。(如果机器宕机了，看门狗也就没了。此时就不会延长 Key 的过期时间，到了 30s 之后就会自动过期了，其他线程可以获取到锁)</li>
</ul>
<p><img src="http://static.cyblogs.com/a7fbd80edbe1bc035e0a6e1c3c691ed7.jpg-wh_600x-s_1313345474.jpg" alt="http://static.cyblogs.com/a7fbd80edbe1bc035e0a6e1c3c691ed7.jpg-wh_600x-s_1313345474.jpg"></p>
<p>这里稍微贴出来其实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁逻辑 </span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 调用一段lua脚本，设置一些key、过期时间 </span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG); </span><br><span class="line">    ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) &#123; </span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            Long ttlRemaining = future.getNow(); </span><br><span class="line">            <span class="comment">// lock acquired </span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="comment">// 看门狗逻辑 </span></span><br><span class="line">                scheduleExpirationRenewal(threadId); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123; </span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command, </span><br><span class="line">              <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> + </span><br><span class="line">                  <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> + </span><br><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> + </span><br><span class="line">                  <span class="string">"return nil; "</span> + </span><br><span class="line">              <span class="string">"end; "</span> + </span><br><span class="line">              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> + </span><br><span class="line">                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> + </span><br><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> + </span><br><span class="line">                  <span class="string">"return nil; "</span> + </span><br><span class="line">              <span class="string">"end; "</span> + </span><br><span class="line">              <span class="string">"return redis.call('pttl', KEYS[1]);"</span>, </span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId)); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 看门狗最终会调用了这里 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.containsKey(getEntryName())) &#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 这个任务会延迟10s执行 </span></span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这个操作会将key的过期时间重新设置为30s </span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId); </span><br><span class="line"> </span><br><span class="line">            future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() &#123; </span><br><span class="line">                <span class="meta">@Override</span> </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">                    expirationRenewalMap.remove(getEntryName()); </span><br><span class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123; </span><br><span class="line">                        log.error(<span class="string">"Can't update lock "</span> + getName() + <span class="string">" expiration"</span>, future.cause()); </span><br><span class="line">                        <span class="keyword">return</span>; </span><br><span class="line">                    &#125; </span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (future.getNow()) &#123; </span><br><span class="line">                        <span class="comment">// reschedule itself </span></span><br><span class="line">                        <span class="comment">// 通过递归调用本方法，***循环延长过期时间 </span></span><br><span class="line">                        scheduleExpirationRenewal(threadId); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.putIfAbsent(getEntryName(), <span class="keyword">new</span> ExpirationEntry(threadId, task)) != <span class="keyword">null</span>) &#123; </span><br><span class="line">        task.cancel(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Redisson 还提供了对 Redlock 算法的支持，它的用法也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RedissonClient redisson = Redisson.create(config); </span><br><span class="line">RLock lock1 = redisson.getFairLock(<span class="string">"lock1"</span>); </span><br><span class="line">RLock lock2 = redisson.getFairLock(<span class="string">"lock2"</span>); </span><br><span class="line">RLock lock3 = redisson.getFairLock(<span class="string">"lock3"</span>); </span><br><span class="line">RedissonRedLock multiLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3); </span><br><span class="line">multiLock.lock(); </span><br><span class="line">multiLock.unlock();</span><br></pre></td></tr></table></figure>

<p>小结：本节分析了使用 Redis 作为分布式锁的具体落地方案以及其一些局限性，然后介绍了一个 Redis 的客户端框架 Redisson，这也是我推荐大家使用的，比自己写代码实现会少 Care 很多细节。</p>
<h4 id="基于-Zookeeper-实现分布式锁"><a href="#基于-Zookeeper-实现分布式锁" class="headerlink" title="基于 Zookeeper 实现分布式锁"></a>基于 Zookeeper 实现分布式锁</h4><p>常见的分布式锁实现方案里面，除了使用 Redis 来实现之外，使用 Zookeeper 也可以实现分布式锁。</p>
<p>在介绍 Zookeeper(下文用 ZK 代替)实现分布式锁的机制之前，先粗略介绍一下 ZK 是什么东西：ZK 是一种提供配置管理、分布式协同以及命名的中心化服务。</p>
<p>ZK 的模型是这样的：ZK 包含一系列的节点，叫做 Znode，就好像文件系统一样，每个 Znode 表示一个目录。</p>
<p>然后 Znode 有一些特性：</p>
<ul>
<li>有序节点：假如当前有一个父节点为 /lock，我们可以在这个父节点下面创建子节点，ZK 提供了一个可选的有序特性。</li>
</ul>
<p>例如我们可以创建子节点“/lock/node-”并且指明有序，那么 ZK 在生成子节点时会根据当前的子节点数量自动添加整数序号。</p>
<p>也就是说，如果是***个创建的子节点，那么生成的子节点为 /lock/node-0000000000，下一个节点则为 /lock/node-0000000001，依次类推。</p>
<ul>
<li>临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，ZK 会自动删除该节点。</li>
<li>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，ZK 会通知客户端。</li>
</ul>
<p>当前 ZK 有如下四种事件：</p>
<ul>
<li>节点创建</li>
<li>节点删除</li>
<li>节点数据修改</li>
<li>子节点变更</li>
</ul>
<p>基于以上的一些 ZK 的特性，我们很容易得出使用 ZK 实现分布式锁的落地方案：</p>
<ul>
<li>使用 ZK 的临时节点和有序节点，每个线程获取锁就是在 ZK 创建一个临时有序的节点，比如在 /lock/ 目录下。</li>
<li>创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点。</li>
<li>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。</li>
<li>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</li>
</ul>
<p>比如当前线程获取到的节点序号为 /lock/003，然后所有的节点列表为[/lock/001，/lock/002，/lock/003]，则对 /lock/002 这个节点添加一个事件监听器。</p>
<p>如果锁释放了，会唤醒下一个序号的节点，然后重新执行第 3 步，判断是否自己的节点序号是最小。</p>
<p>比如 /lock/001 释放了，/lock/002 监听到时间，此时节点集合为[/lock/002，/lock/003]，则 /lock/002 为最小序号节点，获取到锁。</p>
<p>整个过程如下：</p>
<p><img src="http://static.cyblogs.com/fb6c27bb22de93cbeb965718156f578f.jpg" alt="http://static.cyblogs.com/fb6c27bb22de93cbeb965718156f578f.jpg"></p>
<p>具体的实现思路就是这样，至于代码怎么写，这里比较复杂就不贴出来了。</p>
<p><strong>Curator 介绍</strong></p>
<p>Curator 是一个 ZK 的开源客户端，也提供了分布式锁的实现。它的使用方式也比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client,<span class="string">"/anyLock"</span>); </span><br><span class="line">interProcessMutex.acquire(); </span><br><span class="line">interProcessMutex.release();</span><br></pre></td></tr></table></figure>

<p>其实现分布式锁的核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">boolean</span>  haveTheLock = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">boolean</span>  doDelete = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> ( revocable.get() != <span class="keyword">null</span> ) &#123; </span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock ) &#123; </span><br><span class="line">            <span class="comment">// 获取当前所有节点排序后的集合 </span></span><br><span class="line">            List&lt;String&gt;        children = getSortedChildren(); </span><br><span class="line">            <span class="comment">// 获取当前节点的名称 </span></span><br><span class="line">            String              sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// +1 to include the slash </span></span><br><span class="line">            <span class="comment">// 判断当前节点是否是最小的节点 </span></span><br><span class="line">            PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases); </span><br><span class="line">            <span class="keyword">if</span> ( predicateResults.getsTheLock() ) &#123; </span><br><span class="line">                <span class="comment">// 获取到锁 </span></span><br><span class="line">                haveTheLock = <span class="keyword">true</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 没获取到锁，对当前节点的上一个节点注册一个监听器 </span></span><br><span class="line">                String  previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch(); </span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123; </span><br><span class="line">                    Stat stat = client.checkExists().usingWatcher(watcher).forPath(previousSequencePath); </span><br><span class="line">                    <span class="keyword">if</span> ( stat != <span class="keyword">null</span> )&#123; </span><br><span class="line">                        <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )&#123; </span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis); </span><br><span class="line">                            startMillis = System.currentTimeMillis(); </span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )&#123; </span><br><span class="line">                                doDelete = <span class="keyword">true</span>;    <span class="comment">// timed out - delete our node </span></span><br><span class="line">                                <span class="keyword">break</span>; </span><br><span class="line">                            &#125; </span><br><span class="line">                            wait(millisToWait); </span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                            wait(); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// else it may have been deleted (i.e. lock released). Try to acquire again </span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> ( Exception e ) &#123; </span><br><span class="line">        doDelete = <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">throw</span> e; </span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123; </span><br><span class="line">        <span class="keyword">if</span> ( doDelete )&#123; </span><br><span class="line">            deleteOurPath(ourPath); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> haveTheLock; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 Curator 实现分布式锁的底层原理和上面分析的是差不多的。这里我们用一张图详细描述其原理：</p>
<p><img src="https://s5.51cto.com/oss/201907/16/84636c96585ff2611ff55e284a57c6ab.jpg-wh_600x-s_3685227374.jpg" alt="https://s5.51cto.com/oss/201907/16/84636c96585ff2611ff55e284a57c6ab.jpg-wh_600x-s_3685227374.jpg"></p>
<p>小结：本节介绍了 ZK 实现分布式锁的方案以及 ZK 的开源客户端的基本使用，简要的介绍了其实现原理。</p>
<h4 id="两种方案的优缺点比较"><a href="#两种方案的优缺点比较" class="headerlink" title="两种方案的优缺点比较"></a>两种方案的优缺点比较</h4><p>学完了两种分布式锁的实现方案之后，本节需要讨论的是 Redis 和 ZK 的实现方案中各自的优缺点。</p>
<p>对于 Redis 的分布式锁而言，它有以下缺点：</p>
<ul>
<li>它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。</li>
<li>另外来说的话，Redis 的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮。</li>
<li>即便使用 Redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100% 没有问题，关于 Redlock 的讨论可以看 How to do distributed locking。</li>
<li>Redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。</li>
</ul>
<p>但是另一方面使用 Redis 实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”。</p>
<p>所以使用 Redis 作为分布式锁也不失为一种好的方案，最重要的一点是 Redis 的性能很高，可以支撑高并发的获取、释放锁操作。</p>
<p>对于 ZK 分布式锁而言:</p>
<ul>
<li>ZK 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</li>
<li>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</li>
</ul>
<p>但是 ZK 也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。</p>
<p>小结：综上所述，Redis 和 ZK 都有其优缺点。我们在做技术选型的时候可以根据这些问题作为参考因素。</p>
<h4 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h4><p>通过前面的分析，实现分布式锁的两种常见方案：Redis 和 ZK，他们各有千秋。应该如何选型呢？</p>
<p>就个人而言的话，我比较推崇 ZK 实现的锁：因为 Redis 是有可能存在隐患的，可能会导致数据不对的情况。但是，怎么选用要看具体在公司的场景了。</p>
<p>如果公司里面有 ZK 集群条件，优先选用 ZK 实现，但是如果说公司里面只有 Redis 集群，没有条件搭建 ZK 集群。</p>
<p>那么其实用 Redis 来实现也可以，另外还可能是系统设计者考虑到了系统已经有 Redis，但是又不希望再次引入一些外部依赖的情况下，可以选用 Redis。这个是要系统设计者基于架构来考虑了。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://developer.51cto.com/art/201907/599642.htm" target="_blank" rel="noopener">https://developer.51cto.com/art/201907/599642.htm</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Zookeeper/" rel="tag"># Zookeeper</a>
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="tag"># 分布式锁</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/15/2020/05/Linux%20Rsync%20%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4/" rel="next" title="Linux Rsync 增量同步与快速删除">
                <i class="fa fa-chevron-left"></i> Linux Rsync 增量同步与快速删除
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/02/2020/06/%E4%BD%A0%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E8%83%BD%E6%8A%8A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%99%E5%86%99%E5%A5%BD%EF%BC%9F/" rel="prev" title="你是否真的能把单例模式给写好？">
                你是否真的能把单例模式给写好？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/%E4%B8%AA%E4%BA%BA%E5%A4%B4%E5%83%8F.jpg"
                alt="Vernon" />
            
              <p class="site-author-name" itemprop="name">Vernon</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%7C%7C%20archive">
                
                    <span class="site-state-item-count">146</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">66</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">87</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/chengcheng222e" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:chengcheng222e@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么用分布式锁？"><span class="nav-number">1.</span> <span class="nav-text">为什么用分布式锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于-Redis-实现分布式锁"><span class="nav-number">2.</span> <span class="nav-text">基于 Redis 实现分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于-Zookeeper-实现分布式锁"><span class="nav-number">3.</span> <span class="nav-text">基于 Zookeeper 实现分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两种方案的优缺点比较"><span class="nav-number">4.</span> <span class="nav-text">两种方案的优缺点比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一些建议"><span class="nav-number">5.</span> <span class="nav-text">一些建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考地址"><span class="nav-number">6.</span> <span class="nav-text">参考地址</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vernon</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
