<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.cyblogs.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="我们用Spring就是因为它能帮我们很好的管理Bean，如果我们能充分的理解Bean的生命周期，就能在想要的环节去做想做的事情。 周期只有四个！是的，Spring Bean的生命周期只有这四个阶段。把这四个阶段和每个阶段对应的扩展点糅合在一起虽然没有问题，但是这样非常凌乱，难以记忆。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入">
<meta property="og:type" content="article">
<meta property="og:title" content="请别再问Spring Bean的生命周期了">
<meta property="og:url" content="http://www.cyblogs.com/2020/05/04/2020/05/%E8%AF%B7%E5%88%AB%E5%86%8D%E9%97%AESpring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:description" content="我们用Spring就是因为它能帮我们很好的管理Bean，如果我们能充分的理解Bean的生命周期，就能在想要的环节去做想做的事情。 周期只有四个！是的，Spring Bean的生命周期只有这四个阶段。把这四个阶段和每个阶段对应的扩展点糅合在一起虽然没有问题，但是这样非常凌乱，难以记忆。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://static.cyblogs.com/SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg">
<meta property="og:image" content="http://static.cyblogs.com/Spring%20Bean%E5%AE%9A%E4%B9%89.jpg">
<meta property="article:published_time" content="2020-05-03T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-25T01:56:28.717Z">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://static.cyblogs.com/SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg">


<link rel="canonical" href="http://www.cyblogs.com/2020/05/04/2020/05/%E8%AF%B7%E5%88%AB%E5%86%8D%E9%97%AESpring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.cyblogs.com/2020/05/04/2020/05/%E8%AF%B7%E5%88%AB%E5%86%8D%E9%97%AESpring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86/","path":"2020/05/04/2020/05/请别再问Spring Bean的生命周期了/","title":"请别再问Spring Bean的生命周期了"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>请别再问Spring Bean的生命周期了 | 简栈文化</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">简栈文化</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java技术人的成长之路~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%A8%E6%9C%9F%E5%8F%AA%E6%9C%89%E5%9B%9B%E4%B8%AA%EF%BC%81"><span class="nav-number">1.</span> <span class="nav-text">周期只有四个！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%89%A9%E5%B1%95%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">常用扩展点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E5%A4%A7%E7%B1%BB%EF%BC%9A%E5%BD%B1%E5%93%8D%E5%A4%9A%E4%B8%AABean%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.</span> <span class="nav-text">第一大类：影响多个Bean的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#InstantiationAwareBeanPostProcessor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">2.1.1.</span> <span class="nav-text">InstantiationAwareBeanPostProcessor源码分析：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E5%A4%A7%E7%B1%BB%EF%BC%9A%E5%8F%AA%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.</span> <span class="nav-text">第二大类：只调用一次的接口</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E7%9A%84Aware"><span class="nav-number">2.2.1.</span> <span class="nav-text">无所不知的Aware</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Aware%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.2.2.</span> <span class="nav-text">Aware调用时机源码分析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.3.</span> <span class="nav-text">简单的两个生命周期接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-BeanPostProcessor-%E6%B3%A8%E5%86%8C%E6%97%B6%E6%9C%BA%E4%B8%8E%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">扩展阅读: BeanPostProcessor 注册时机与执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%97%B6%E6%9C%BA"><span class="nav-number">3.1.</span> <span class="nav-text">注册时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.2.</span> <span class="nav-text">执行顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E5%9C%B0%E5%9D%80"><span class="nav-number">5.</span> <span class="nav-text">参考地址</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vernon"
      src="/images/vernonchen.jpg">
  <p class="site-author-name" itemprop="name">Vernon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengcheng222e" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengcheng222e" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengcheng222e@gmail.com" title="E-Mail → mailto:chengcheng222e@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/05/04/2020/05/%E8%AF%B7%E5%88%AB%E5%86%8D%E9%97%AESpring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="请别再问Spring Bean的生命周期了 | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          请别再问Spring Bean的生命周期了
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-04T00:00:00+08:00">2020-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>我们用<code>Spring</code>就是因为它能帮我们很好的管理<code>Bean</code>，如果我们能充分的理解<code>Bean</code>的生命周期，就能在想要的环节去做想做的事情。</p>
<h4 id="周期只有四个！"><a href="#周期只有四个！" class="headerlink" title="周期只有四个！"></a>周期只有四个！</h4><p>是的，<code>Spring Bean</code>的生命周期只有这四个阶段。把这四个阶段和每个阶段对应的扩展点糅合在一起虽然没有问题，但是这样非常凌乱，难以记忆。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段。在这四步之间穿插的各种扩展点，稍后会讲。</p>
<ul>
<li><ol>
<li>实例化 <code>Instantiation</code></li>
</ol>
</li>
<li><ol start="2">
<li>属性赋值 <code>Populate</code></li>
</ol>
</li>
<li><ol start="3">
<li>初始化 <code>Initialization</code></li>
</ol>
</li>
<li><ol start="4">
<li>销毁 <code>Destruction</code></li>
</ol>
</li>
</ul>
<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<p>主要逻辑都在<code>doCreate()</code>方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。</p>
<ul>
<li><ol>
<li><code>createBeanInstance()</code> -&gt; 实例化</li>
</ol>
</li>
<li><ol start="2">
<li><code>populateBean()</code> -&gt; 属性赋值</li>
</ol>
</li>
<li><ol start="3">
<li><code>initializeBean()</code> -&gt; 初始化</li>
</ol>
</li>
</ul>
<p>源码如下，能证明实例化，属性赋值和初始化这三个生命周期的存在。关于本文的<code>Spring</code>源码都将忽略无关部分，便于理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略了无关代码</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 实例化阶段！</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 属性赋值阶段！</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">       <span class="comment">// 初始化阶段！</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于销毁，是在容器关闭时调用的，详见<code>ConfigurableApplicationContext#close()</code></p>
<h4 id="常用扩展点"><a href="#常用扩展点" class="headerlink" title="常用扩展点"></a>常用扩展点</h4><p><code>Spring</code>生命周期相关的常用扩展点非常多，所以问题不是不知道，而是记不住或者记不牢。其实记不住的根本原因还是不够了解，这里通过源码+分类的方式帮大家记忆。</p>
<h5 id="第一大类：影响多个Bean的接口"><a href="#第一大类：影响多个Bean的接口" class="headerlink" title="第一大类：影响多个Bean的接口"></a>第一大类：影响多个Bean的接口</h5><p>实现了这些接口的<code>Bean</code>会切入到多个<code>Bean</code>的生命周期中。正因为如此，这些接口的功能非常强大，<code>Spring</code>内部扩展也经常使用这些接口，例如自动注入以及<code>AOP</code>的实现都和他们有关。</p>
<ul>
<li><code>BeanPostProcessor</code></li>
<li><code>InstantiationAwareBeanPostProcessor</code></li>
</ul>
<p>这两兄弟可能是<code>Spring</code>扩展中<strong>最重要</strong>的两个接口！<code>InstantiationAwareBeanPostProcessor</code>作用于<strong>实例化</strong>阶段的前后，<code>BeanPostProcessor</code>作用于<strong>初始化</strong>阶段的前后。正好和第一、第三个生命周期阶段对应。通过图能更好理解：</p>
<p><img src="http://static.cyblogs.com/SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;SpringBean的生命周期.jpg"></p>
<p><code>InstantiationAwareBeanPostProcessor</code>实际上继承了<code>BeanPostProcessor</code>接口，严格意义上来看他们不是两兄弟，而是两父子。但是从生命周期角度我们重点关注其特有的对实例化阶段的影响，图中省略了从<code>BeanPostProcessor</code>继承的方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InstantiationAwareBeanPostProcessor <span class="keyword">extends</span> BeanPostProcessor</span><br></pre></td></tr></table></figure>

<h6 id="InstantiationAwareBeanPostProcessor源码分析："><a href="#InstantiationAwareBeanPostProcessor源码分析：" class="headerlink" title="InstantiationAwareBeanPostProcessor源码分析："></a>InstantiationAwareBeanPostProcessor源码分析：</h6><ul>
<li><code>postProcessBeforeInstantiation</code>调用点，忽略无关代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        <span class="comment">// postProcessBeforeInstantiation方法调用点，这里就不跟进了，</span></span><br><span class="line">        <span class="comment">// 有兴趣的同学可以自己看下，就是for循环调用所有的InstantiationAwareBeanPostProcessor</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;   </span><br><span class="line">        <span class="comment">// 上文提到的doCreateBean方法，可以看到</span></span><br><span class="line">        <span class="comment">// postProcessBeforeInstantiation方法在创建Bean之前调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>postProcessBeforeInstantiation</code>在<code>doCreateBean</code>之前调用，也就是在<code>bean</code>实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的<code>Bean</code>作为代理，这也是<code>Aop</code>等功能实现的关键点。</p>
<ul>
<li><code>postProcessAfterInstantiation</code>调用点，忽略无关代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">   <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">   <span class="comment">// to support styles of field injection.</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">continueWithPropertyPopulation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation()</span></span><br><span class="line">    <span class="comment">// 方法作为属性赋值的前置检查条件，在属性赋值之前执行，能够影响是否进行属性赋值！</span></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 忽略后续的属性赋值操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法在属性赋值方法内，但是在真正执行赋值操作之前。其返回值为<code>boolean</code>，返回<code>false</code>时可以阻断属性赋值阶段（<code>continueWithPropertyPopulation = false;</code>）。</p>
<p>关于<code>BeanPostProcessor</code>执行阶段的源码穿插在下文<code>Aware</code>接口的调用时机分析中，因为部分Aware功能的就是通过他实现的!只需要先记住<code>BeanPostProcessor</code>在初始化前后调用就可以了。</p>
<h5 id="第二大类：只调用一次的接口"><a href="#第二大类：只调用一次的接口" class="headerlink" title="第二大类：只调用一次的接口"></a>第二大类：只调用一次的接口</h5><p>这一大类接口的特点是功能丰富，常用于用户自定义扩展。<br> 第二大类中又可以分为两类：</p>
<ol>
<li><code>Aware</code>类型的接口</li>
<li>生命周期接口</li>
</ol>
<h6 id="无所不知的Aware"><a href="#无所不知的Aware" class="headerlink" title="无所不知的Aware"></a>无所不知的Aware</h6><p><code>Aware</code>类型的接口的作用就是让我们能够拿到<code>Spring</code>容器中的一些资源。基本都能够见名知意，<code>Aware</code>之前的名字就是可以拿到什么资源，例如<code>BeanNameAware</code>可以拿到<code>BeanName</code>，以此类推。调用时机需要注意：所有的<code>Aware</code>方法都是在初始化阶段之前调用的！<br> <code>Aware</code>接口众多，这里同样通过分类的方式帮助大家记忆。<br> <code>Aware</code>接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是<code>Aware</code>接口的执行顺序，能够见名知意的接口不再解释。</p>
<p><strong>Aware Group1</strong></p>
<ol>
<li><code>BeanNameAware</code></li>
<li><code>BeanClassLoaderAware</code></li>
<li><code>BeanFactoryAware</code></li>
</ol>
<p><strong>Aware Group2</strong></p>
<ol>
<li><code>EnvironmentAware</code></li>
<li><code>EmbeddedValueResolverAware</code> 这个知道的人可能不多，实现该接口能够获取<code>Spring EL</code>解析器，用户的自定义注解需要支持<code>spel</code>表达式的时候可以使用，非常方便。</li>
<li><code>ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)</code> 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的<code>ApplicationContext</code>对象，因为<code>ApplicationContext</code>是一个复合接口，如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory,</span><br><span class="line">        MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到另一道面试题，<code>ApplicationContext</code>和<code>BeanFactory</code>的区别，可以从<code>ApplicationContext</code>继承的这几个接口入手，除去<code>BeanFactory</code>相关的两个接口就是<code>ApplicationContext</code>独有的功能，这里不详细说明。</p>
<h6 id="Aware调用时机源码分析"><a href="#Aware调用时机源码分析" class="headerlink" title="Aware调用时机源码分析"></a>Aware调用时机源码分析</h6><p>详情如下，忽略了部分无关代码。代码位置就是我们上文提到的initializeBean方法详情，这也说明了Aware都是在初始化阶段之前调用的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 见名知意，初始化阶段调用的方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里调用的是Group1中的三个Bean开头的Aware</span></span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里调用的是Group2中的几个Aware，</span></span><br><span class="line">    <span class="comment">// 而实质上这里就是前面所说的BeanPostProcessor的调用点！</span></span><br><span class="line">    <span class="comment">// 也就是说与Group1中的Aware不同，这里是通过BeanPostProcessor（ApplicationContextAwareProcessor）实现的。</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">// 下文即将介绍的InitializingBean调用点</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    <span class="comment">// BeanPostProcessor的另一个调用点</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到并不是所有的<code>Aware</code>接口都使用同样的方式调用。<code>Bean××Aware</code>都是在代码中直接调用的，而<code>ApplicationContext</code>相关的<code>Aware</code>都是通过<code>BeanPostProcessor#postProcessBeforeInitialization()</code>实现的。感兴趣的可以自己看一下<code>ApplicationContextAwareProcessor</code>这个类的源码，就是判断当前创建的<code>Bean</code>是否实现了相关的<code>Aware</code>方法，如果实现了会调用回调方法将资源传递给<code>Bean</code>。<br> 至于<code>Spring</code>为什么这么实现，应该没什么特殊的考量。也许和<code>Spring</code>的版本升级有关。基于对修改关闭，对扩展开放的原则，<code>Spring</code>对一些新的<code>Aware</code>采用了扩展的方式添加。</p>
<p><code>BeanPostProcessor</code>的调用时机也能在这里体现，包围住<code>invokeInitMethods</code>方法，也就说明了在初始化阶段的前后执行。</p>
<p>关于<code>Aware</code>接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了。每组中各个<code>Aware</code>方法的调用顺序其实没有必要记，有需要的时候点进源码一看便知。</p>
<h6 id="简单的两个生命周期接口"><a href="#简单的两个生命周期接口" class="headerlink" title="简单的两个生命周期接口"></a>简单的两个生命周期接口</h6><p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是<code>Spring</code>帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p>
<ol>
<li><code>InitializingBean</code> 对应生命周期的初始化阶段，在上面源码的<code>invokeInitMethods(beanName, wrappedBean, mbd);</code>方法中调用。<br> 有一点需要注意，因为<code>Aware</code>方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用<code>Aware</code>接口获取的资源，这也是我们自定义扩展<code>Spring</code>的常用方式。<br> 除了实现<code>InitializingBean</code>接口之外还能通过注解或者xml配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</li>
<li><code>DisposableBean</code> 类似于<code>InitializingBean</code>，对应生命周期的销毁阶段，以<code>ConfigurableApplicationContext#close()</code>方法作为入口，实现是通过循环取所有实现了<code>DisposableBean</code>接口的<code>Bean</code>然后调用其<code>destroy()</code>方法 。感兴趣的可以自行跟一下源码。</li>
</ol>
<h4 id="扩展阅读-BeanPostProcessor-注册时机与执行顺序"><a href="#扩展阅读-BeanPostProcessor-注册时机与执行顺序" class="headerlink" title="扩展阅读: BeanPostProcessor 注册时机与执行顺序"></a>扩展阅读: BeanPostProcessor 注册时机与执行顺序</h4><p><code>Spring</code>所做的事情就是把各种方式定义的<code>Java</code>类变成它的<code>BeanDefinition</code>，然后通过<code>Bean工厂</code>变成<code>Bean</code>放入到它的各种容器中，这样子就被<code>Spring</code>所管理了。</p>
<p><img src="http://static.cyblogs.com/Spring%20Bean%E5%AE%9A%E4%B9%89.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;Spring%20Bean定义.jpg"></p>
<h5 id="注册时机"><a href="#注册时机" class="headerlink" title="注册时机"></a>注册时机</h5><p>我们知道<code>BeanPostProcessor</code>也会注册为<code>Bean</code>，那么<code>Spring</code>是如何保证<code>BeanPostProcessor</code>在我们的业务Bean之前初始化完成呢？<br> 请看我们熟悉的refresh()方法的源码，省略部分无关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 所有BeanPostProcesser初始化的调用点</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 所有单例非懒加载Bean的调用点</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>Spring</code>是先执行<code>registerBeanPostProcessors()</code>进行<code>BeanPostProcessors</code>的注册，然后再执行<code>finishBeanFactoryInitialization</code>初始化我们的单例非懒加载的<code>Bean</code>。</p>
<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p><code>BeanPostProcessor</code>有很多个，而且每个<code>BeanPostProcessor</code>都影响多个<code>Bean</code>，其执行顺序至关重要，必须能够控制其执行顺序才行。关于执行顺序这里需要引入两个排序相关的接口：<code>PriorityOrdered、Ordered</code></p>
<ul>
<li><code>PriorityOrdered</code>是一等公民，首先被执行，<code>PriorityOrdered</code>公民之间通过接口返回值排序</li>
<li><code>Ordered</code>是二等公民，然后执行，<code>Ordered</code>公民之间通过接口返回值排序</li>
<li>都没有实现是三等公民，最后执行</li>
</ul>
<p>在以下源码中，可以很清晰的看到<code>Spring</code>注册各种类型<code>BeanPostProcessor</code>的逻辑，根据实现不同排序接口进行分组。优先级高的先加入，优先级低的后加入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 首先，加入实现了PriorityOrdered接口的BeanPostProcessors，顺便根据PriorityOrdered排了序</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 然后，加入实现了Ordered接口的BeanPostProcessors，顺便根据Ordered排了序</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line"><span class="comment">// 最后加入其他常规的BeanPostProcessors</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">    reiterate = <span class="literal">false</span>;</span><br><span class="line">    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">            reiterate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据排序接口返回值排序，默认升序排序，返回值越低优先级越高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Useful constant for the highest precedence value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer#MIN_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">HIGHEST_PRECEDENCE</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Useful constant for the lowest precedence value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer#MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">LOWEST_PRECEDENCE</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure>

<p><code>PriorityOrdered</code>、<code>Ordered</code>接口作为<code>Spring</code>整个框架通用的排序接口，在<code>Spring</code>中应用广泛，也是非常重要的接口。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Spring Bean</code>的生命周期分为<code>四个阶段</code>和<code>多个扩展点</code>。扩展点又可以分为<code>影响多个Bean</code>和<code>影响单个Bean</code>。整理如下：<br> 四个阶段</p>
<ul>
<li>实例化 <code>Instantiation</code></li>
<li>属性赋值 <code>Populate</code></li>
<li>初始化 <code>Initialization</code></li>
<li>销毁 <code>Destruction</code></li>
</ul>
<p>多个扩展点</p>
<ul>
<li>影响多个<code>Bean</code><ul>
<li><code>BeanPostProcessor</code></li>
<li><code>InstantiationAwareBeanPostProcessor</code></li>
</ul>
</li>
<li>影响单个<code>Bean</code><ul>
<li>Aware<ul>
<li>Aware Group1<ul>
<li>BeanNameAware</li>
<li>BeanClassLoaderAware</li>
<li>BeanFactoryAware</li>
</ul>
</li>
<li>Aware Group2<ul>
<li>EnvironmentAware</li>
<li>EmbeddedValueResolverAware</li>
<li>ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)</li>
</ul>
</li>
</ul>
</li>
<li>生命周期<ul>
<li>InitializingBean</li>
<li>DisposableBean</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>至此，<code>Spring Bean</code>的生命周期介绍完毕，由于作者水平有限难免有疏漏，欢迎留言纠错。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1dec08d290c1">https://www.jianshu.com/p/1dec08d290c1</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SpringBoot/" rel="tag"># SpringBoot</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/05/03/2020/05/%E6%B5%85%E8%B0%88Next-Key%20Lock%E4%B8%8E%E5%AE%9E%E6%B5%8B/" rel="prev" title="浅谈Next-Key Lock与实测">
                  <i class="fa fa-angle-left"></i> 浅谈Next-Key Lock与实测
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/05/10/2020/05/%E6%B7%B1%E5%A4%9C%E9%87%8C%E5%AE%89%E9%9D%99%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AAOpenJDK8%EF%BC%8C%E5%9D%91%E5%A4%AA%E5%A4%9A/" rel="next" title="深夜里安静的编译一个OpenJDK8，坑太多">
                  深夜里安静的编译一个OpenJDK8，坑太多 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Vernon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <a target="_blank" href="https://beian.miit.gov.cn">粤ICP备2025433887号</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
