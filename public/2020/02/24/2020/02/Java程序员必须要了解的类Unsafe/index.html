<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.cyblogs.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="前言Java是一个安全的编程语言，它能最大程度的防止程序员犯一些低级的错误（大部分是和内存管理有关的）。但凡是不是绝对的，使用Unsafe程序员就可以操作内存，因此可能带来一个安全隐患。 这篇文章是就快速学习下sun.misc.Unsafe的公共API和一些有趣的使用例子。 Unsafe 实例化在使用Unsafe之前我们需要先实例化它。但我们不能通过像Unsafe unsafe &#x3D; new Uns">
<meta property="og:type" content="article">
<meta property="og:title" content="Java程序员必须要了解的类Unsafe">
<meta property="og:url" content="http://www.cyblogs.com/2020/02/24/2020/02/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BBUnsafe/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:description" content="前言Java是一个安全的编程语言，它能最大程度的防止程序员犯一些低级的错误（大部分是和内存管理有关的）。但凡是不是绝对的，使用Unsafe程序员就可以操作内存，因此可能带来一个安全隐患。 这篇文章是就快速学习下sun.misc.Unsafe的公共API和一些有趣的使用例子。 Unsafe 实例化在使用Unsafe之前我们需要先实例化它。但我们不能通过像Unsafe unsafe &#x3D; new Uns">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-23T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-25T01:56:28.706Z">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.cyblogs.com/2020/02/24/2020/02/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BBUnsafe/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.cyblogs.com/2020/02/24/2020/02/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BBUnsafe/","path":"2020/02/24/2020/02/Java程序员必须要了解的类Unsafe/","title":"Java程序员必须要了解的类Unsafe"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java程序员必须要了解的类Unsafe | 简栈文化</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">简栈文化</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java技术人的成长之路~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unsafe-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">Unsafe 实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unsafe-API"><span class="nav-number">3.</span> <span class="nav-text">Unsafe API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%BF%E7%94%A8case"><span class="nav-number">4.</span> <span class="nav-text">有趣的使用case</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B7%B3%E8%BF%87%E6%9E%84%E9%80%A0%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.1.</span> <span class="nav-text">跳过构造初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">4.2.</span> <span class="nav-text">内存泄露</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sizeOf"><span class="nav-number">4.3.</span> <span class="nav-text">sizeOf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">4.4.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%AF%86%E7%A0%81"><span class="nav-number">4.5.</span> <span class="nav-text">隐藏密码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">5.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">动态类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8"><span class="nav-number">7.</span> <span class="nav-text">抛出一个异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">快速序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E7%BB%84"><span class="nav-number">9.</span> <span class="nav-text">大数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">10.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bonus"><span class="nav-number">11.</span> <span class="nav-text">Bonus</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">12.</span> <span class="nav-text">结论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E5%9C%B0%E5%9D%80"><span class="nav-number">13.</span> <span class="nav-text">参考地址</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vernon"
      src="/images/vernonchen.jpg">
  <p class="site-author-name" itemprop="name">Vernon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengcheng222e" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengcheng222e" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengcheng222e@gmail.com" title="E-Mail → mailto:chengcheng222e@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/24/2020/02/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BBUnsafe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java程序员必须要了解的类Unsafe | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java程序员必须要了解的类Unsafe
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-24T00:00:00+08:00">2020-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Java是一个安全的编程语言，它能最大程度的防止程序员犯一些低级的错误（大部分是和内存管理有关的）。但凡是不是绝对的，使用Unsafe程序员就可以操作内存，因此可能带来一个安全隐患。</p>
<p>这篇文章是就快速学习下<code>sun.misc.Unsafe</code>的公共API和一些有趣的使用例子。</p>
<h4 id="Unsafe-实例化"><a href="#Unsafe-实例化" class="headerlink" title="Unsafe 实例化"></a>Unsafe 实例化</h4><p>在使用Unsafe之前我们需要先实例化它。但我们不能通过像<code>Unsafe unsafe = new Unsafe()</code>这种简单的方式来实现Unsafe的实例化，这是由于Unsafe的构造方法是私有的。Unsafe有一个静态的getUnsafe()方法，但是如果天真的以为调用该方法就可以的话，那你将遇到一个<code>SecurityException</code>异常，这是由于该方法只能在被信任的代码中调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">cc</span> <span class="operator">=</span> sun.reflect.Reflection.getCallerClass(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (cc.getClassLoader() != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那Java是如何判断我们的代码是否是受信的呢？它就是通过判断加载我们代码的类加载器是否是根类加载器。</p>
<p>我们可是通过这种方法将我们自己的代码变为受信的，使用jvm参数<code>bootclasspath</code>。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath:/usr/jdk1<span class="number">.7</span><span class="number">.0</span>/jre/lib/rt.jar:. com.mishadoff.magic.UnsafeClient</span><br></pre></td></tr></table></figure>

<p><strong>但这种方式太难了</strong></p>
<p>Unsafe类内部有一个名为<code>theUnsafe</code>的私有实例变量，我们可以通过反射来获取该实例变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 忽略你的IDE提示. 例如, eclipse可能会报这样的错误”Access restriction…” 单如果你运行你的代码，会发现一切正常。如果还是还是提示错误，你可以通过如下的方式关闭该错误提示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Preferences -&gt; Java -&gt; Compiler -&gt; Errors/Warnings -&gt;</span><br><span class="line">Deprecated and restricted API -&gt; Forbidden reference -&gt; Warning           </span><br></pre></td></tr></table></figure>

<h4 id="Unsafe-API"><a href="#Unsafe-API" class="headerlink" title="Unsafe API"></a>Unsafe API</h4><p>类 <a target="_blank" rel="noopener" href="http://www.docjar.com/docs/api/sun/misc/Unsafe.html">sun.misc.Unsafe</a> 由150个方法组成。事实上这些方法只有几组是非常重要的用来操作不同的对象。下面我们就来看下这些方法中的一部分。</p>
<ol>
<li><strong>Info</strong> 仅仅是返回一个低级别的内存相关的信息<ul>
<li>addressSize</li>
<li>pageSize</li>
</ul>
</li>
<li><strong>Objects</strong>. 提供操作对象和对象字段的方法<ul>
<li>allocateInstance</li>
<li>objectFieldOffset</li>
</ul>
</li>
<li><strong>Classes</strong>. 提供针对类和类的静态字段操作的方法<ul>
<li>staticFieldOffset</li>
<li>defineClass</li>
<li>defineAnonymousClass</li>
<li>ensureClassInitialized</li>
</ul>
</li>
<li><strong>Arrays</strong>. 数组操作<ul>
<li>arrayBaseOffset</li>
<li>arrayIndexScale</li>
</ul>
</li>
<li>Synchronization. 低级别的同步原语<ul>
<li>monitorEnter</li>
<li>tryMonitorEnter</li>
<li>monitorExit</li>
<li>compareAndSwapInt</li>
<li>putOrderedInt</li>
</ul>
</li>
<li>Memory. 直接访问内存的方法<ul>
<li>allocateMemory</li>
<li>copyMemory</li>
<li>freeMemory</li>
<li>getAddress</li>
<li>getInt</li>
<li>putInt</li>
</ul>
</li>
</ol>
<h4 id="有趣的使用case"><a href="#有趣的使用case" class="headerlink" title="有趣的使用case"></a>有趣的使用case</h4><h5 id="跳过构造初始化"><a href="#跳过构造初始化" class="headerlink" title="跳过构造初始化"></a>跳过构造初始化</h5><p>allocateInstance方法可能是有用的,当你需要在构造函数中跳过对象初始化阶段或绕过安全检查又或者你想要实例化哪些没有提供公共构造函数的类时就可以使用该方法。考虑下面的类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> a; <span class="comment">// not initialized value</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">1</span>; <span class="comment">// initialization</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">a</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.a; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过构造函数，反射，Unsafe分别来实例化该类结果是不同的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">// constructor</span></span><br><span class="line">o1.a(); <span class="comment">// prints 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">A</span> <span class="variable">o2</span> <span class="operator">=</span> A.class.newInstance(); <span class="comment">// reflection</span></span><br><span class="line">o2.a(); <span class="comment">// prints 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">A</span> <span class="variable">o3</span> <span class="operator">=</span> (A) unsafe.allocateInstance(A.class); <span class="comment">// unsafe</span></span><br><span class="line">o3.a(); <span class="comment">// prints 0</span></span><br></pre></td></tr></table></figure>

<p>思考一下这些确保对<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Singleton_pattern">Singletons</a>模式的影响。</p>
<h5 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h5><p>对C程序员来说这中情况是很常见的。</p>
<p>思考一下一些简单的类是如何坚持访问规则的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Guard</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ACCESS_ALLOWED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">giveAccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span> == ACCESS_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码是非常安全的,调用giveAccess()检查访问规则。不幸的是对所有的客户端代码,它总是返回false。只有特权用户在某种程度上可以改变ACCESS_ALLOWED常量并且获得访问权限。</p>
<p>事实上,这不是真的。这是证明它的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Guard</span> <span class="variable">guard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Guard</span>();</span><br><span class="line">guard.giveAccess();   <span class="comment">// false, no access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bypass</span></span><br><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> guard.getClass().getDeclaredField(<span class="string">&quot;ACCESS_ALLOWED&quot;</span>);</span><br><span class="line">unsafe.putInt(guard, unsafe.objectFieldOffset(f), <span class="number">42</span>); <span class="comment">// memory corruption</span></span><br><span class="line"></span><br><span class="line">guard.giveAccess(); <span class="comment">// true, access granted</span></span><br></pre></td></tr></table></figure>

<p>现在所有的客户端都没有访问限制了。</p>
<p>事实上同样的功能也可以通过反射来实现。但有趣的是, 通过上面的方式我们修改任何对象，即使我们没有持有对象的引用。</p>
<p>举个例子, 在内存中有另外的一个Guard对象，并且地址紧挨着当前对象的地址，我们就可以通过下面的代码来修改该对象的<code>ACCESS_ALLOWED</code>字段的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe.putInt(guard, <span class="number">16</span> + unsafe.objectFieldOffset(f), <span class="number">42</span>); <span class="comment">// memory corruption</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，我们没有使用任何指向该对象的引用，16是Guard对象在32位架构上的大小。我们也可以通过<code>sizeOf</code>方法来计算Guard对象的大小。</p>
<h5 id="sizeOf"><a href="#sizeOf" class="headerlink" title="sizeOf"></a>sizeOf</h5><p>使用<code>objectFieldOffset</code>方法我们可以实现C风格的sizeof方法。下面的方法实现返回对象的表面上的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sizeOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">u</span> <span class="operator">=</span> getUnsafe();</span><br><span class="line">    HashSet&lt;Field&gt; fields = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Field&gt;();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> o.getClass();</span><br><span class="line">    <span class="keyword">while</span> (c != Object.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Field f : c.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((f.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                fields.add(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c = c.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get offset</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> u.objectFieldOffset(f);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; maxSize) &#123;</span><br><span class="line">            maxSize = offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((maxSize/<span class="number">8</span>) + <span class="number">1</span>) * <span class="number">8</span>;   <span class="comment">// padding</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法逻辑如下：收集所有包括父类在内的非静态字段，获得每个字段的偏移量，发现最大并添加填充。也许,我错过了一些东西，但是概念是明确的。</p>
<p>更简单的sizeof方法实现逻辑是：我们只读取该对象对应的class对象中关于大小的字段值。在<code>JVM 1.7 32 位</code>版本上该表示大小的字段偏移量是12。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sizeOf</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUnsafe().getAddress(</span><br><span class="line">        normalize(getUnsafe().getInt(object, <span class="number">4L</span>)) + <span class="number">12L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>normalize</code>是一个将有符号的int类型转为无符号的long类型的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">normalize</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value &gt;= <span class="number">0</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">return</span> (~<span class="number">0L</span> &gt;&gt;&gt; <span class="number">32</span>) &amp; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太棒了,这个方法返回的结果和我们之前的sizeof函数是相同的。</p>
<p>but it requires specifyng agent option in your JVM.</p>
<p>事实上，对于合适的，安全的，准确的sizeof函数最好使用<code>java.lang.instrument</code>包，但它需要特殊的JVM参数。</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>在实现了计算对象浅层大小的基础上，我们可以非常容易的添加对象的拷贝方法。标准的办法需要修改我们的代码和Cloneable。或者你可以实现自定义的对象拷贝函数，但它不会变为通用的函数。</p>
<p>浅拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object <span class="title function_">shallowCopy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> sizeOf(obj);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> toAddress(obj);</span><br><span class="line">    <span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> getUnsafe().allocateMemory(size);</span><br><span class="line">    getUnsafe().copyMemory(start, address, size);</span><br><span class="line">    <span class="keyword">return</span> fromAddress(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toAddress</code> 和 <code>fromAddress</code> 将对象转为它在内存中的地址或者从指定的地址内容转为对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">toAddress</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;obj&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">baseOffset</span> <span class="operator">=</span> getUnsafe().arrayBaseOffset(Object[].class);</span><br><span class="line">    <span class="keyword">return</span> normalize(getUnsafe().getInt(array, baseOffset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Object <span class="title function_">fromAddress</span><span class="params">(<span class="type">long</span> address)</span> &#123;</span><br><span class="line">    Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="variable">baseOffset</span> <span class="operator">=</span> getUnsafe().arrayBaseOffset(Object[].class);</span><br><span class="line">    getUnsafe().putLong(array, baseOffset, address);</span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该拷贝函数可以用来拷贝任何类型的对象，因为对象的大小是动态计算的。</p>
<p><strong>注意</strong> 在完成拷贝动作后你需要将拷贝对象的类型强转为目标类型。</p>
<h5 id="隐藏密码"><a href="#隐藏密码" class="headerlink" title="隐藏密码"></a>隐藏密码</h5><p>在Unsafe的直接内存访问方法使用case中有一个非常有趣的用法就是删除内存中不想要的对象。</p>
<p>大多数获取用户密码的API方法的返回值不是byte[]就是char[]，这是为什么呢？</p>
<p>这完全是出于安全原因, 因为我们可以在不需要它们的时候将数组元素置为失效。如果我们获取的密码是字符串类型，则密码字符串是作为一个对象保存在内存中的。要将该密码字符串置为无效，我们只能讲字符串引用职位null，但是该字符串的内容任然存在内存直到GC回收该对象后。</p>
<p>这个技巧在内存创建一个假的大小相同字符串对象来替换原来的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;l00k@myHor$e&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(password.replaceAll(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;?&quot;</span>));</span><br><span class="line">System.out.println(password); <span class="comment">// l00k@myHor$e</span></span><br><span class="line">System.out.println(fake); <span class="comment">// ????????????</span></span><br><span class="line"></span><br><span class="line">getUnsafe().copyMemory(</span><br><span class="line">          fake, <span class="number">0L</span>, <span class="literal">null</span>, toAddress(password), sizeOf(password));</span><br><span class="line"></span><br><span class="line">System.out.println(password); <span class="comment">// ????????????</span></span><br><span class="line">System.out.println(fake); <span class="comment">// ????????????</span></span><br></pre></td></tr></table></figure>

<p>感觉安全了吗？</p>
<p>其实该方法不是真的安全。想要真的安全我们可以通过反射API将字符串对象中的字符数组<code>value</code>字段的值修改为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">stringValue</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">stringValue.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">char</span>[] mem = (<span class="type">char</span>[]) stringValue.get(password);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; mem.length; i++) &#123;</span><br><span class="line">  mem[i] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>在Java中本来是没有多重集成的。除非我们可以将任意的类型转为我们想要的任意类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">intClassAddress</span> <span class="operator">=</span> normalize(getUnsafe().getInt(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>), <span class="number">4L</span>));</span><br><span class="line"><span class="type">long</span> <span class="variable">strClassAddress</span> <span class="operator">=</span> normalize(getUnsafe().getInt(<span class="string">&quot;&quot;</span>, <span class="number">4L</span>));</span><br><span class="line">getUnsafe().putAddress(intClassAddress + <span class="number">36</span>, strClassAddress);</span><br></pre></td></tr></table></figure>

<p>这段代码将String类添加到Integer的超类集合中,所以我们的强转代码是没有运行时异常的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String) (Object) (<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">666</span>))</span><br></pre></td></tr></table></figure>

<p>有个问题是我们需要先将要转的对象转为Object，然后再转为我们想要的类型。这是为了欺骗编译器。</p>
<h4 id="动态类"><a href="#动态类" class="headerlink" title="动态类"></a>动态类</h4><p>We can create classes in runtime, for example from compiled .class file. To perform that read class contents to byte array and pass it properly to defineClass method.</p>
<p>我们可以在运行时创建类, 例如通过一个编译好的class文件。将class文件的内容读入到字节数组中然后将该数组传递到合适的<code>defineClass</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] classContents = getClassContent();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> getUnsafe().defineClass(</span><br><span class="line">              <span class="literal">null</span>, classContents, <span class="number">0</span>, classContents.length);</span><br><span class="line">    c.getMethod(<span class="string">&quot;a&quot;</span>).invoke(c.newInstance(), <span class="literal">null</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>读取class文件内如的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] getClassContent() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/mishadoff/tmp/A.class&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">    <span class="type">byte</span>[] content = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">    input.read(content);</span><br><span class="line">    input.close();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方式是非常有用的，如果你确实需要在运行时动态的创建类。比如生产代理类或切面类。</p>
<h4 id="抛出一个异常"><a href="#抛出一个异常" class="headerlink" title="抛出一个异常"></a>抛出一个异常</h4><p>不喜欢受检异常？这不是问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getUnsafe().throwException(<span class="keyword">new</span> <span class="title class_">IOException</span>());</span><br></pre></td></tr></table></figure>

<p>该方法抛出一个受检异常，但是你的代码不需要强制捕获该异常就像运行时异常一样。</p>
<h4 id="快速序列化"><a href="#快速序列化" class="headerlink" title="快速序列化"></a>快速序列化</h4><p>这种使用方式更实用。</p>
<p>每个人都知道java标准的序列化的功能速度很慢而且它还需要类拥有公有的构造函数。</p>
<p>外部序列化是更好的方式，但是需要定义针对待序列化类的schema。</p>
<p>非常流行的高性能序列化库，像<a target="_blank" rel="noopener" href="http://code.google.com/p/kryo/">kryo</a>是有使用限制的，比如在内存缺乏的环境就不合适。</p>
<p>但通过使用Unsafe类我们可以非常简单的实现完整的序列化功能。</p>
<p><strong>序列化</strong>：</p>
<ul>
<li>通过反射定义类的序列化。 这个可以只做一次。</li>
<li>通过Unsafe的<code>getLong</code>, <code>getInt</code>, <code>getObject</code>等方法获取字段真实的值。</li>
<li>添加可以恢复该对象的标识符。</li>
<li>将这些数据写入到输出</li>
</ul>
<p>当然也可以使用压缩来节省空间。</p>
<p><strong>反序列化</strong>:</p>
<ul>
<li>创建一个序列化类的实例，可以通过方法<code>allocateInstance</code>。因为该方法不需要任何构造方法。</li>
<li>创建schama, 和序列化类似</li>
<li>从文件或输入读取或有的字段</li>
<li>使用 <code>Unsafe</code> 的 <code>putLong</code>, <code>putInt</code>, <code>putObject</code>等方法来填充对象。</li>
</ul>
<p>Actually, there are much more details in correct inplementation, but intuition is clear.</p>
<p>事实上要正确实现序列化和反序列化需要注意很多细节，但是思路是清晰的。</p>
<p>这种序列化方式是非常快的。</p>
<p>顺便说一句，在 <code>kryo</code> 有许多使用<code>Unsafe</code>的尝试 <a target="_blank" rel="noopener" href="http://code.google.com/p/kryo/issues/detail?id=75">http://code.google.com/p/kryo/issues/detail?id=75</a></p>
<h4 id="大数组"><a href="#大数组" class="headerlink" title="大数组"></a>大数组</h4><p>如你所知Java数组长度的最大值是<code>Integer.MAX_VALUE</code>。使用直接内存分配我们可以创建非常大的数组，该数组的大小只受限于堆的大小。</p>
<p>这里有一个<code>SuperArray</code>的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BYTE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SuperArray</span><span class="params">(<span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        address = getUnsafe().allocateMemory(size * BYTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> i, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">        getUnsafe().putByte(address + i * BYTE, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">long</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getUnsafe().getByte(address + idx * BYTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">SUPER_SIZE</span> <span class="operator">=</span> (<span class="type">long</span>)Integer.MAX_VALUE * <span class="number">2</span>;</span><br><span class="line"><span class="type">SuperArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperArray</span>(SUPER_SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;Array size:&quot;</span> + array.size()); <span class="comment">// 4294967294</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    array.set((<span class="type">long</span>)Integer.MAX_VALUE + i, (<span class="type">byte</span>)<span class="number">3</span>);</span><br><span class="line">    sum += array.get((<span class="type">long</span>)Integer.MAX_VALUE + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Sum of 100 elements:&quot;</span> + sum);  <span class="comment">// 300</span></span><br></pre></td></tr></table></figure>

<p>事实上该技术使用了非堆内存<code>off-heap memory</code>，在 <code>java.nio</code> 包中也有使用。</p>
<p>通过这种方式分配的内存不在堆上，并且不受GC管理。因此需要小心使用<code>Unsafe.freeMemory()</code>。该方法不会做任何边界检查，因此任何不合法的访问可能就会导致JVM奔溃。</p>
<p>这种使用方式对于数学计算是非常有用的，因为代码可以操作非常大的数据数组。 同样的编写实时程序的程序员对此也非常感兴趣，因为不受GC限制，就不会因为GC导致非常大的停顿。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>关于并发编程使用Unsafe的只言片语。<code>compareAndSwap</code> 方法是原子的，可以用来实现高性能的无锁化数据结构。</p>
<p>举个例子，多个线程并发的更新共享的对象这种场景：</p>
<p>首先我们定义一个简单的接口 <code>Counter</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义工作线程 <code>CounterClient</code>, 它会使用 <code>Counter</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterClient</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Counter c;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterClient</span><span class="params">(Counter c, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            c.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">NUM_OF_THREADS</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">NUM_OF_INCREMENTS</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(NUM_OF_THREADS);</span><br><span class="line"><span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> ... <span class="comment">// creating instance of specific counter</span></span><br><span class="line"><span class="type">long</span> <span class="variable">before</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NUM_OF_THREADS; i++) &#123;</span><br><span class="line">    service.submit(<span class="keyword">new</span> <span class="title class_">CounterClient</span>(counter, NUM_OF_INCREMENTS));</span><br><span class="line">&#125;</span><br><span class="line">service.shutdown();</span><br><span class="line">service.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"><span class="type">long</span> <span class="variable">after</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;Counter result: &quot;</span> + c.getCounter());</span><br><span class="line">System.out.println(<span class="string">&quot;Time passed in ms:&quot;</span> + (after - before));</span><br></pre></td></tr></table></figure>

<p>第一个实现-没有同步的计数器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StupidCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">99542945</span></span><br><span class="line">Time passed in ms: <span class="number">679</span></span><br></pre></td></tr></table></figure>

<p>速度很多，但是没有对所有的线程进行协调所以结果是错误的。第二个版本，使用Java常见的同步方式来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SyncCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">10136</span></span><br></pre></td></tr></table></figure>

<p>彻底的同步当然会导致正确的结果。但是花费的时间令人沮丧。让我们试试 <code>ReentrantReadWriteLock</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">WriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>().writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        counter++;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">8065</span></span><br></pre></td></tr></table></figure>

<p>结果依然是正确的，时间也短。那使用原子的类呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">6552</span></span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicCounter</code>的效果更好一点。最后我们试试<code>Unsafe</code>的原子方法<code>compareAndSwapLong</code>看看是不是更进一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CASCounter</span> <span class="keyword">implements</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CASCounter</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        unsafe = getUnsafe();</span><br><span class="line">        offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(<span class="string">&quot;counter&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">before</span> <span class="operator">=</span> counter;</span><br><span class="line">        <span class="keyword">while</span> (!unsafe.compareAndSwapLong(<span class="built_in">this</span>, offset, before, before + <span class="number">1</span>)) &#123;</span><br><span class="line">            before = counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">6454</span></span><br></pre></td></tr></table></figure>

<p>开起来和使用原子类是一样的效果，难道原子类使用了<code>Unsafe</code>？答案是YES。</p>
<p>事实上该例子非常简单但表现出了<code>Unsafe</code>的强大功能。</p>
<p>就像前面提到的 <code>CAS</code>原语可以用来实现高效的无锁数据结构。实现的原理很简单：</p>
<ul>
<li>拥有一个状态</li>
<li>创建一个它的副本</li>
<li>修改该副本</li>
<li>执行 CAS 操作</li>
<li>如果失败就重复执行</li>
</ul>
<p>事实上，在真实的环境它的实现难度超过你的想象，这其中有需要类似ABA，指令重排序这样的问题。</p>
<p>如果你确实对此感兴趣，你可以参考关于无锁HashMap的精彩演示。</p>
<h4 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h4><p>Documentation for park method from Unsafe class contains longest English sentence I’ve ever seen:</p>
<blockquote>
<p>Block current thread, returning when a balancing unpark occurs, or a balancing unpark has already occurred, or the thread is interrupted, or, if not absolute and time is not zero, the given time nanoseconds have elapsed, or if absolute, the given deadline in milliseconds since Epoch has passed, or spuriously (i.e., returning for no “reason”). Note: This operation is in the Unsafe class only because unpark is, so it would be strange to place it elsewhere.</p>
</blockquote>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>尽管Unsafe有这么多有用的应用，但是尽力不要使用。当然了使用JDK中利用了Unsafe实现的类是可以的。或者你对你代码功力非常自信。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://leokongwq.github.io/2016/12/31/java-magic-unsafe.html">https://leokongwq.github.io/2016/12/31/java-magic-unsafe.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://dzone.com/articles/understanding-sunmiscunsafe">https://dzone.com/articles/understanding-sunmiscunsafe</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html</a></p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/02/23/2020/02/Java%20volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/" rel="prev" title="我们如何看SpringBoot的源代码">
                  <i class="fa fa-angle-left"></i> 我们如何看SpringBoot的源代码
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/02/25/2020/02/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" rel="next" title="Java深拷贝和浅拷贝">
                  Java深拷贝和浅拷贝 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Vernon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <a target="_blank" href="https://beian.miit.gov.cn">粤ICP备2025433887号</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
