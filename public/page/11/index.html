<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.cyblogs.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="简栈文化">
<meta property="og:url" content="http://www.cyblogs.com/page/11/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.cyblogs.com/page/11/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>简栈文化</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">简栈文化</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java技术人的成长之路~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vernon"
      src="/images/vernonchen.jpg">
  <p class="site-author-name" itemprop="name">Vernon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengcheng222e" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengcheng222e" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengcheng222e@gmail.com" title="E-Mail → mailto:chengcheng222e@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/15/2020/02/CAS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8AABA%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/15/2020/02/CAS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8AABA%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">CAS原理分析及ABA问题详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-15T00:00:00+08:00">2020-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p><code>CAS</code>即<code>Compare And Swap</code>的缩写，翻译成中文就是<strong>比较并交换</strong>，其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是CAS是<strong>原子性</strong>的操作(读和写两者同时具有原子性)，其实现方式是通过借助<code>C/C++</code>调用CPU指令完成的，所以效率很高。<br><code>CAS</code>的原理很简单，这里使用一段<code>Java</code>代码来描述</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSwap</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line"><span class="comment">//        如果内存中的值value和期望值expect一样 则将值更新为新值update</span></span><br><span class="line">    <span class="keyword">if</span> (value == expect) &#123;</span><br><span class="line">        value = update;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致过程是将内存中的值、我们的期望值、新值交给CPU进行运算，如果内存中的值和我们的期望值相同则将值更新为新值，否则不做任何操作。这个过程是在CPU中完成的，这里不好描述CPU的工作过程，就拿Java代码来描述了。 </p>
<h4 id="Unsafe源码分析"><a href="#Unsafe源码分析" class="headerlink" title="Unsafe源码分析"></a>Unsafe源码分析</h4><p>Java是在<code>Unsafe(sun.misc.Unsafe)</code>类实现<code>CAS</code>的操作，而我们知道Java是无法直接访问操作系统底层的API的(原因是Java的跨平台性限制了Java不能和操作系统耦合)，所以Java并没有在<code>Unsafe</code>类直接实现<code>CAS</code>的操作，而是通过**JDI(Java Native Interface)**本地调用<code>C/C++</code>语言来实现<code>CAS</code>操作的。<br><code>Unsafe</code>有很多个<code>CAS</code>操作的相关方法，这里举例几个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</span><br></pre></td></tr></table></figure>

<p>我们拿<code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code>进行分析，这个方法是比较内存中的一个值(整型)和我们的期望值(var4)是否一样，如果一样则将内存中的这个值更新为<code>var5</code>，参数中的<code>var1</code>是值所在的对象，<code>var2</code>是值在对象(var1)中的内存偏移量，<strong>参数var1和参数var2是为了定位出值所在内存的地址</strong>。<br><img src="http://static.cyblogs.com/e0e01e43ly1g11dbvrjwoj21ay0bujtl.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;e0e01e43ly1g11dbvrjwoj21ay0bujtl.jpg"><br><strong>Unsafe.java在这里发挥的作用有：</strong></p>
<ol>
<li>将对象引用、值在对象中的偏移量、期望的值和欲更新的新值传递给<code>Unsafe.cpp</code></li>
<li>如果值更新成功则返回<code>true</code>给开发者，没有更新则返回<code>false</code></li>
</ol>
<p><strong>Unsafe.cpp在这里发挥的作用有：</strong></p>
<ol>
<li>接受从<code>Unsafe</code>传递过来的对象引用、偏移量、期望的值和欲更新的新值，根据对象引用和偏移量<strong>计算出值的地址</strong>，然后将值的地址、期望的值、欲更新的新值传递给CPU</li>
<li>如果值更新成功则返回<code>true</code>给<code>Unsafe.java</code>，没有更新则返回<code>false</code></li>
</ol>
<p><strong>CPU在这里发挥的作用：</strong></p>
<ol>
<li>接受从<code>Unsafe.cpp</code>传递过来的地址、期望的值和欲更新的新值，执行指令<code>cmpxchg</code>，比较地址中的值是否和期望的值一样，一样则将值更新为新的值，不一样则不做任何操作</li>
<li>将操作结果返回给<code>Unsafe.cpp</code></li>
</ol>
<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><p><code>CAS</code>虽然高效的实现了原子性操作，但是也存在一些缺点，主要表现在以下三个方面。</p>
<h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>在多线程场景下<code>CAS</code>会出现<code>ABA</code>问题，关于ABA问题这里简单科普下，例如有2个线程同时对同一个值(初始值为A)进行CAS操作，这三个线程如下 </p>
<ol>
<li>线程1，期望值为A，欲更新的值为B</li>
<li>线程2，期望值为A，欲更新的值为B</li>
</ol>
<p>线程<code>1</code>抢先获得CPU时间片，而线程<code>2</code>因为其他原因阻塞了，线程<code>1</code>取值与期望的A值比较，发现相等然后将值更新为B，然后这个时候<strong>出现了线程<code>3</code>，期望值为B，欲更新的值为A</strong>，线程3取值与期望的值B比较，发现相等则将值更新为A，此时线程<code>2</code>从阻塞中恢复，并且获得了CPU时间片，这时候线程<code>2</code>取值与期望的值A比较，发现相等则将值更新为B，虽然线程<code>2</code>也完成了操作，但是线程<code>2</code>并不知道值已经经过了<code>A-&gt;B-&gt;A</code>的变化过程。 </p>
<p><strong><code>ABA</code>问题带来的危害</strong>：<br>小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50<br>线程1（提款机）：获取当前值100，期望更新为50，<br>线程2（提款机）：获取当前值100，期望更新为50，<br>线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50<br>线程3（默认）：获取当前值50，期望更新为100，<br>这时候线程3成功执行，余额变为100，<br>线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！<br>此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的成功提交。</p>
<p><strong>解决方法</strong>：<br>在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code>。</p>
<h5 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h5><p>如果<code>CAS</code>操作失败，就需要循环进行<code>CAS</code>操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。</p>
<blockquote>
<p>这种循环也称为自旋</p>
</blockquote>
<p><strong>解决方法</strong>：<br>限制自旋次数，防止进入死循环。</p>
<h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p><code>CAS</code>的原子操作只能针对一个共享变量。</p>
<p><strong>解决方法</strong>：<br>如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p>
<h4 id="CAS的应用"><a href="#CAS的应用" class="headerlink" title="CAS的应用"></a>CAS的应用</h4><p>我们知道<code>CAS</code>操作并不会锁住共享变量，也就是一种<strong>非阻塞</strong>的同步机制，<code>CAS</code>就是乐观锁的实现。</p>
<ol>
<li>乐观锁<br><strong>乐观锁</strong>总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</li>
<li>悲观锁<br><strong>悲观锁</strong>总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，<strong>所以在每次操作数据的时候都会给数据加锁</strong>，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久。</li>
</ol>
<p><code>Java</code>利用<code>CAS</code>的乐观锁、原子性的特性高效解决了多线程的安全性问题，例如JDK1.8中的集合类<code>ConcurrentHashMap</code>、关键字<code>volatile</code>、<code>ReentrantLock</code>等。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li>原文地址：<a target="_blank" rel="noopener" href="https://ddnd.cn/2019/03/13/java-cas/">https://ddnd.cn/2019/03/13/java-cas/</a></li>
<li><a target="_blank" rel="noopener" href="https://zl198751.iteye.com/blog/1848575">https://zl198751.iteye.com/blog/1848575</a></li>
<li><a target="_blank" rel="noopener" href="http://objcoding.com/2018/11/29/cas">http://objcoding.com/2018/11/29/cas</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014858404#articleHeader3">https://segmentfault.com/a/1190000014858404#articleHeader3</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23281499">https://www.zhihu.com/question/23281499</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/14/2020/02/ArrayList%E4%B8%8ECopyOnWriteArrayList%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/14/2020/02/ArrayList%E4%B8%8ECopyOnWriteArrayList%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">ArrayList与CopyOnWriteArrayList常见操作与问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-14T00:00:00+08:00">2020-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="ArrayList循环遍历并删除元素的常见陷阱"><a href="#ArrayList循环遍历并删除元素的常见陷阱" class="headerlink" title="ArrayList循环遍历并删除元素的常见陷阱"></a>ArrayList循环遍历并删除元素的常见陷阱</h4><p>在工作和学习中，经常碰到删除ArrayList里面的某个元素，看似一个很简单的问题，却很容易出bug。不妨把这个问题当做一道面试题目，我想一定能难道不少的人。今天就给大家说一下在ArrayList循环遍历并删除元素的问题。首先请看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayListRemove</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　ArrayList&lt;String&gt;list=newArrayList&lt;String&gt;();</span><br><span class="line">　　　　list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">　　　　list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">　　　　list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">　　　　list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">　　　　list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">　　　　list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">　　　　remove(list);</span><br><span class="line">　　　　<span class="keyword">for</span>(Strings:list)</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　System.out.println(<span class="string">&quot;element : &quot;</span>+s);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　<span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要想删除list的b字符，有下面两种常见的错误例子：</p>
<p>错误写法实例一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(inti=<span class="number">0</span>;i&lt;list.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Strings=list.get(i);</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误的原因：这种最普通的循环写法执行后会发现第二个“b”的字符串没有删掉。</p>
<p>错误写法实例二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(Strings:list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误的原因：这种for-each写法会报出著名的并发修改异常：java.util.ConcurrentModificationException。</p>
<p>先解释一下实例一的错误原因。翻开JDK的ArrayList源码，先看下ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是入参不同，这里看的是入参为Object的remove方法）是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Objecto)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(intindex=<span class="number">0</span>;index&lt;size;index++)</span><br><span class="line">            <span class="keyword">if</span>(elementData[index]==<span class="literal">null</span>)&#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(intindex=<span class="number">0</span>;index&lt;size;index++)</span><br><span class="line">                <span class="keyword">if</span>(o.equals(elementData[index]))&#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下程序的执行路径会走到else路径下最终调用faseRemove方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        intnumMoved=size-index-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numMoved&gt;<span class="number">0</span>)             </span><br><span class="line">        　　System.arraycopy(elementData,index+<span class="number">1</span>,elementData,index,numMoved);</span><br><span class="line">        elementData[--size]=<span class="literal">null</span>;<span class="comment">// Let gc do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到会执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。针对错误写法一，在遍历第一个字符串b时因为符合删除条件，所以将该元素从数组中删除，并且将后一个元素移动（也就是第二个字符串b）至当前位置，导致下一次循环遍历时后一个字符串b并没有遍历到，所以无法删除。针对这种情况可以倒序删除的方式来避免：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(inti=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Strings=list.get(i);</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组倒序遍历时即使发生元素删除也不影响后序元素遍历。</p>
<p>接着解释一下实例二的错误原因。错误二产生的原因却是foreach写法是对实际的Iterable、hasNext、next方法的简写，问题同样处在上文的fastRemove方法中，可以看到第一行把modCount变量的值加一，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> get(cursor);</span><br><span class="line">            lastRet = cursor++;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行checkForComodification方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会做迭代器内部修改次数检查，因为上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。要避免这种情况的出现则在使用迭代器迭代时（显示或for-each的隐式）不要使用ArrayList的remove，改为用Iterator的remove即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;b&quot;</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>Doug Lea 大师就为我们提供 CopyOnWriteArrayList 容器可以保证线程安全，保证读读之间在任何时候都不会被阻塞，CopyOnWriteArrayList 也被广泛应用于很多业务场景之中，CopyOnWriteArrayList 值得被我们好好认识一番。</p>
<h5 id="CopyOnWrite的设计思想"><a href="#CopyOnWrite的设计思想" class="headerlink" title="CopyOnWrite的设计思想"></a>CopyOnWrite的设计思想</h5><p>如果简单的使用读写锁的话，在写锁被获取之后，读写线程被阻塞，只有当写锁被释放后读线程才有机会获取到锁从而读到最新的数据，站在<strong>读线程的角度来看，即读线程任何时候都是获取到最新的数据，满足数据实时性</strong>。既然我们说到要进行优化，必然有 trade-off,我们就可以<strong>牺牲数据实时性满足数据的最终一致性即可</strong>。而 CopyOnWriteArrayList 就是通过 Copy-On-Write(COW)，即写时复制的思想来通过延时更新的策略来实现数据的最终一致性，并且能够保证读线程间不阻塞。</p>
<p>COW 通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对 CopyOnWrite 容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，放弃数据实时性达到数据的最终一致性。</p>
<h5 id="CopyOnWriteArrayList-的实现原理"><a href="#CopyOnWriteArrayList-的实现原理" class="headerlink" title="CopyOnWriteArrayList 的实现原理"></a>CopyOnWriteArrayList 的实现原理</h5><p>现在我们来通过看源码的方式来理解 CopyOnWriteArrayList，实际上 CopyOnWriteArrayList 内部维护的就是一个数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<p>并且该数组引用是被 volatile 修饰，注意这里<strong>仅仅是修饰的是数组引用</strong>，其中另有玄机，稍后揭晓。关于 volatile 很重要的一条性质是它能够够保证可见性，关于 volatile 的详细讲解可以看<a target="_blank" rel="noopener" href="https://juejin.im/post/5ae9b41b518825670b33e6c4">这篇文章</a>。对 list 来说，我们自然而然最关心的就是读写的时候，分别为 get 和 add 方法的实现。</p>
<h5 id="get-方法实现原理"><a href="#get-方法实现原理" class="headerlink" title="get 方法实现原理"></a>get 方法实现原理</h5><p>get 方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来 get 方法实现非常简单，几乎就是一个“单线程”程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有 CAS 操作等等，原因是，所有的读线程只是会读取数据容器中的数据，并不会进行修改。</p>
<h5 id="add-方法实现原理"><a href="#add-方法实现原理" class="headerlink" title="add 方法实现原理"></a>add 方法实现原理</h5><p>再来看下如何进行添加数据的？add 方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">	<span class="comment">//1. 使用Lock,保证写线程在同一时刻只有一个</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//2. 获取旧数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">		<span class="comment">//3. 创建新的数组，并将旧数组的数据复制到新数组中</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//4. 往新数组中添加新的数据</span></span><br><span class="line">		newElements[len] = e;</span><br><span class="line">		<span class="comment">//5. 将旧数组引用指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add 方法的逻辑也比较容易理解，请看上面的注释。需要注意这么几点：</p>
<ol>
<li>采用 ReentrantLock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份被复制的数据；</li>
<li>前面说过数组引用是 volatile 修饰的，因此将旧的数组引用指向新的数组，根据 volatile 的 happens-before 规则，写线程对数组引用的修改对读线程是可见的。</li>
<li>由于在写数据的时候，是在新的数组中插入数据的，从而保证读写实在两个不同的数据容器中进行操作。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们知道 COW 和读写锁都是通过读写分离的思想实现的，但两者还是有些不同，可以进行比较：</p>
<blockquote>
<p><strong>COW vs 读写锁</strong></p>
</blockquote>
<p>相同点：1. 两者都是通过读写分离的思想实现；2.读线程间是互不阻塞的</p>
<p>不同点：<strong>对读线程而言，为了实现数据实时性，在写锁被获取后，读线程会等待或者当读锁被获取后，写线程会等待，从而解决“脏读”等问题。也就是说如果使用读写锁依然会出现读线程阻塞等待的情况。而 COW 则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延时感知的，因此读线程不会存在等待的情况</strong>。</p>
<p>对这一点从文字上还是很难理解，我们来通过 debug 看一下，add 方法核心代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Object[] elements = getArray();</span><br><span class="line"><span class="number">2.</span><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line"><span class="number">3.</span>Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"><span class="number">4.</span>newElements[len] = e;</span><br><span class="line"><span class="number">5.</span>setArray(newElements);</span><br></pre></td></tr></table></figure>

<p>假设 COW 的变化如下图所示：</p>
<p><img src="http://static.cyblogs.com/QQ20200216-233236@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200216-233236@2x.jpg"></p>
<p>数组中已有数据 1,2,3，现在写线程想往数组中添加数据 4，我们在第 5 行处打上断点，让写线程暂停。读线程依然会“不受影响”的能从数组中读取数据，可是还是只能读到 1,2,3。<strong>如果读线程能够立即读到新添加的数据的话就叫做能保证数据实时性</strong>。当对第 5 行的断点放开后，读线程才能感知到数据变化，读到完整的数据 1,2,3,4，而保证<strong>数据最终一致性</strong>，尽管有可能中间间隔了好几秒才感知到。</p>
<p>这里还有这样一个问题： <strong>为什么需要复制呢？ 如果将 array 数组设定为 volitile 的， 对 volatile 变量写 happens-before 读，读线程不是能够感知到 volatile 变量的变化</strong>。</p>
<p>原因是，这里 volatile 的修饰的<strong>仅仅</strong>只是<strong>数组引用</strong>，<strong>数组中的元素的修改是不能保证可见性的</strong>。因此 COW 采用的是新旧两个数据容器，通过第 5 行代码将数组引用指向新的数组。</p>
<p>这也是为什么 concurrentHashMap 只具有弱一致性的原因，关于 concurrentHashMap 的弱一致性可以<a target="_blank" rel="noopener" href="http://ifeve.com/volatile-array-visiblity/294529737/">看这篇文章</a>。</p>
<blockquote>
<p><strong>COW 的缺点</strong></p>
</blockquote>
<p>CopyOnWrite 容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<ol>
<li><strong>内存占用问题</strong>：因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对 象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对 象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比 如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 minor GC 和 major GC。</li>
<li><strong>数据一致性问题</strong>：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5aeeb55f5188256715478c21">https://juejin.im/post/5aeeb55f5188256715478c21</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangjinyong/p/9455163.html">https://www.cnblogs.com/huangjinyong/p/9455163.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/13/2020/02/%E4%B8%80%E7%9B%B4%E6%83%B3%E6%90%9E%E6%87%82%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/13/2020/02/%E4%B8%80%E7%9B%B4%E6%83%B3%E6%90%9E%E6%87%82%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">一直想搞懂的字符编码问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-13 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-13T00:00:00+08:00">2020-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">编码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>​		从你刚刚毕业开始最怕的问题就是乱码问题对不对？起码我是。后面渐渐的知道是编码问题，而后面为了出现这种问题就都选择<code>UTF-8</code>，然后后面渐渐的就开始淡忘了这个问题。然后当小弟弟小妹妹问我们这相关的问题的时候，也都是跟他们说，全部改成<code>UTF-8</code>就好了。</p>
<p>​		但这是一种逃避，其实编码问题困扰我好多年，其实说句实话，真的没有搞懂。之前还有同事在一起相互考问 <strong>一个中文到底占用几个字节？</strong> 对不对，你遇到过吗？你回答的上来吗？哈哈</p>
<p>推荐几个常用的地址：</p>
<ul>
<li><p>ASCII：<a target="_blank" rel="noopener" href="http://tool.oschina.net/commons?type=4">http://tool.oschina.net/commons?type=4</a></p>
</li>
<li><p>GB2312简体中文编码表：<a target="_blank" rel="noopener" href="http://tools.jb51.net/table/gb2312">http://tools.jb51.net/table/gb2312</a></p>
</li>
<li><p>Unicode编码：<a target="_blank" rel="noopener" href="http://tool.chinaz.com/Tools/Unicode.aspx">http://tool.chinaz.com/Tools/Unicode.aspx</a></p>
</li>
</ul>
<h4 id="常见的编码"><a href="#常见的编码" class="headerlink" title="常见的编码"></a>常见的编码</h4><h5 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h5><p>​		它是现今最早最通用的单字节编码系统,并等同于国际标准<code>ISO/IEC 646</code>，其中一个英文字母（不分大小写）占一个字节的空间。</p>
<p>引申：字节是指一小组相邻的二进制数码。通常是8位作为一个字节，如00001111，换算为十进制。</p>
<p>最小值：-128</p>
<p>最大值：127</p>
<p>标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。其中：</p>
<ul>
<li><p>1、0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响。</p>
</li>
<li><p>2、32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。</p>
</li>
<li><p>3、65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
</li>
</ul>
<p>同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1。</p>
<h5 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h5><p>​		UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</p>
<ul>
<li><p>1、对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。</p>
</li>
<li><p>2、对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">Unicode</th>
<th align="right">UTF-8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0000 0000 - 0000 007F</td>
<td align="right">0xxxxxxx</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0000 0080 - 0000 07FF</td>
<td align="right">110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0000 0800 - 0000 FFFF</td>
<td align="right">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0001 0000 - 0010 FFFF</td>
<td align="right">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码，大家就很容易理解了。</p>
<p>“汉”的 <code>Unicode</code> 码点是 <code>0x6c49（110 1100 0100 1001）</code>，通过上面的对照表可以发现，<code>0x0000 6c49</code> 位于第三行的范围，那么得出其格式为 <code>1110xxxx 10xxxxxx 10xxxxxx</code>。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 <code>11100110 10110001 10001001</code>，转换成十六进制就是 <code>0xE6 0xB7 0x89</code>。</p>
<h5 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h5><p>​		在了解 <code>UTF-16</code> 编码方式之前，先了解一下另外一个概念——“平面”。</p>
<p>​		在上面的介绍中，提到了 <code>Unicode</code> 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（216216）字符，称为一个平面（plane）。目前，一共有 17 个（2525）平面，也就是说，整个 <code>Unicode</code> 字符集的大小现在是 221221。</p>
<p>​		最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 216−1216−1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。</p>
<p>​		基本了解了平面的概念后，再说回到 <code>UTF-16</code>。<code>UTF-16</code> 编码介于 <code>UTF-32</code> 与 <code>UTF-8</code> 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，<code>UTF-16</code> 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？</p>
<p>​		这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。</p>
<p>​		辅助平面的字符位共有 220220 个，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。</p>
<p>​		因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。</p>
<h5 id="Unicode之Emoji表情"><a href="#Unicode之Emoji表情" class="headerlink" title="Unicode之Emoji表情"></a>Unicode之Emoji表情</h5><blockquote>
<p>1999年前后，日本一个名叫栗田穰崇的年轻人，和许多直男一样， 给女友发的短信经常会被误解。比如，“知道了”被解读成“生气了”、“不耐烦了”，随后引发冷战。 于是少年栗田想：“如果能在文字里插入一些表情符号来表达感情，大家应该会需要吧！”<br>原始的Emoji就这么诞生了。</p>
</blockquote>
<p><code>Emoji</code>字符是<code>Unicode</code>字符集中一部分. 特定形象的<code>Emoji</code>表情符号对应到特定的<code>Unicode</code>字节。<br>常见的Emoji表情符号在Unicode字符集中的范围和具体的字节映射关系, 可通过<strong>Emoji Unicode Tables</strong> (<a target="_blank" rel="noopener" href="http://apps.timwhitlock.info/emoji/tables/unicode#block-6c-other-additional-symbols)%E6%9F%A5%E7%9C%8B%E5%88%B0%E3%80%82">http://apps.timwhitlock.info/emoji/tables/unicode#block-6c-other-additional-symbols)查看到。</a></p>
<p>对于做<code>UGC</code>的网站来说，现在不仅仅是苹果手机，越来越多的软件都在用<code>emoji</code>表情，因为它能很形象的来表达我们的感情。对于这里我们能做的可以是把emoji表情转码后用文本的方式存在数据库中，还有一个方式就是升级数据库，改变它的编码。</p>
<p>推荐一个对这个错误描述的地址： <a target="_blank" rel="noopener" href="https://blog.csdn.net/asahinokawa/article/details/85255732">https://blog.csdn.net/asahinokawa/article/details/85255732</a></p>
<h4 id="一个汉字占几个字符？"><a href="#一个汉字占几个字符？" class="headerlink" title="一个汉字占几个字符？"></a>一个汉字占几个字符？</h4><p>如果你说的“字符”就是指 <code>Java</code> 中的 <code>char</code>，那好，那它就是 16 位，2 字节。</p>
<p>如果你说的“字符”是指我们用眼睛看到的那些“抽象的字符”，那么，谈论它占几个字节是没有意义的。具体地讲，脱离具体的编码谈某个字符占几个字节是没有意义的。就好比有一个抽象的整数“42”，你说它占几个字节？这得具体看你是用 <code>byte</code>，<code>short</code>，<code>int</code>，还是 <code>long</code> 来存它。用 byte 存就占一字节，用 <code>short</code> 存就占两字节，<code>int</code> 通常是四字节，<code>long</code> 通常八字节。当然，如果你用 <code>byte</code>，受限于它有限的位数，有些数它是存不了的，比如 256 就无法放在一个 <code>byte</code> 里了。</p>
<p>字符是同样的道理，如果你想谈“占几个字节”，就要先把编码说清楚。同一个字符在不同的编码下可能占不同的字节。就以你举的“字”字为例，“字”在 <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=GBK&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">GBK</a> 编码下占 2 字节，在 <code>UTF-16</code> 编码下也占 2 字节，在 <code>UTF-8</code> 编码下占 3 字节，在 <code>UTF-32</code> 编码下占 4 字节。不同的字符在同一个编码下也可能占不同的字节。“字”在 <code>UTF-8</code> 编码下占3字节，而“A”在 <code>UTF-8</code> 编码下占 1 字节。（因为 <code>UTF-8</code> 是变长编码），而 <code>Java</code> 中的 <code>char</code> 本质上是 <code>UTF-16</code> 编码。而 <code>UTF-16</code> 实际上也是一个变长编码（2 字节或 4字节）。</p>
<p>如果一个抽象的字符在 <code>UTF-16</code> 编码下占 4 字节，显然它是不能放到 <code>char</code> 中的。换言之， <code>char</code> 中只能放 <code>UTF-16</code> 编码下只占 2 字节的那些字符。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/113144610.html">https://zhidao.baidu.com/question/113144610.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/be286767563c">https://www.jianshu.com/p/be286767563c</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/12/2020/02/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/12/2020/02/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1AQS/" class="post-title-link" itemprop="url">一文带你快速掌握AQS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-12 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-12T00:00:00+08:00">2020-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>作者：薛8</p>
<p>来源：<a target="_blank" rel="noopener" href="https://juejin.im/post/5c890b4a51882501351d5929">https://juejin.im/post/5c890b4a51882501351d5929</a></p>
<h4 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h4><p><strong><code>AbstractQueuedSynchronizer</code>抽象队列同步器</strong>，简称为<code>AQS</code>，可用于构建<strong>阻塞锁</strong>或者其他相关<strong>同步器</strong>的基础框，是Java并发包的基础工具类。通过<code>AQS</code>这个框架可以对<strong>同步状态原子性管理、线程的阻塞和解除阻塞、队列的管理</strong>进行统一管理。<br> <code>AQS</code>是抽象类，并不能直接实例化，当需要使用<code>AQS</code>的时候需要继承<code>AQS</code>抽象类并且重写指定的方法，这些重写方法包括<strong>线程获取资源和释放资源的方式</strong>(如ReentractLock通过分别重写线程获取和释放资源的方式实现了公平锁和非公平锁)，<strong>同时子类还需要负责共享变量state的维护，如当state为0时表示该锁没有被占，大于0时候代表该锁被一个或多个线程占领(重入锁)</strong>，而队列的维护(获取资源失败入队、线程唤醒、线程的状态等)不需要我们考虑，<code>AQS</code>已经帮我们实现好了。<code>AQS</code>的这种设计模式采用的正是<strong>模板方法模式</strong>。<br> <strong>总结起来子类的任务有：</strong></p>
<ol>
<li>通过<code>CAS</code>操作维护共享变量<code>state</code>。</li>
<li>重写资源的获取方式。</li>
<li>重写资源释放的方式。</li>
</ol>
<blockquote>
<p>如果对CAS和Java内存模型还不清楚的，建议先了解这两者之后再食用本文，效果更佳！<a target="_blank" rel="noopener" href="https://ddnd.cn/2019/03/13/java-cas/">CAS原理分析及ABA问题详解</a>         <a target="_blank" rel="noopener" href="https://ddnd.cn/2019/03/11/java-memory-model/">什么是Java内存模型？</a></p>
</blockquote>
<p>完成以上三个任务即可实现自己的锁。<br> <code>AQS</code>作为<code>J.U.C</code>的工具类，面向的是需要实现<strong>锁的实现者</strong>，而锁面向的是<strong>锁的使用者</strong>，这两者的区别还是需要搞清楚的。</p>
<h4 id="AQS数据结构"><a href="#AQS数据结构" class="headerlink" title="AQS数据结构"></a>AQS数据结构</h4><p>先看<code>AQS</code>有哪些重要的成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，不过也是最简单的，代表当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 之所以说大于0，而不是等于1，是因为锁可以重入嘛，每次重入都加上1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure>

<p>然后再看看<code>AQS</code>的内部结构，<code>AQS</code>内部数据结构为一个<strong>双向链表</strong>和一个<strong>单向链表</strong>，双链表为同步队列，队列中的每个节点对应一个<code>Node</code>内部类，<code>AQS</code>通过控制链表的节点而达到阻塞、同步的目的，单链表为条件队列，<strong>可以把同步队列和条件队列理解成储存等待状态的线程的队列</strong>，但是条件队列中的线程并不能直接去获取资源，而要先从条件队列转到同步队列中排队获取，同步队列的唤醒结果是线程去尝试获取锁，而条件队列的唤醒结果是把线程从条件队列移到同步队列中，一个线程要么是在同步队列中，要么是在条件队列中，不可能同时存在这两个队列里面。</p>
<p><img src="http://static.cyblogs.com/169ae1c4f86ba568.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c4f86ba568.png"></p>
<blockquote>
<p>Java<strong>阻塞状态</strong>和<strong>等待状态</strong>的线程从Linux内核来看，都是阻塞(等待)状态，它们都会让出CPU时间片。Java为了方便管理线程将“阻塞(等待)”状态细分成了阻塞状态和等待状态，这两个状态的区别<strong>在于由谁去唤醒</strong>，是操作系统还是其他线程。Java线程请求某一个资源失败的时候就会进入<strong>阻塞状态</strong>，处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。而当线程调用<code>wait</code>、<code>join</code>、<code>pack</code>函数时候会进入<strong>等待状态</strong>，需要其它线程显性的唤醒否则会无限期的处于等待状态。</p>
</blockquote>
<p>Java线程6状态图：</p>
<p><img src="http://static.cyblogs.com/169ae1c4f87a969e.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c4f87a969e.png"></p>
<p>内部类<code>Node</code>详解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">//代表当前节(线程)点是共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">//代表当前节点(线程)是独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//代表当前节点(线程)已被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//代表当前节点(线程)的后继节点需要被提醒唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//代表节点(线程)在 Condition queue中，等待某一条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//代表当前节点的后继节点(线程)会传传播唤醒的操作，仅在共享模式下才有作用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//代表当前节点的状态，它的取值除了以上说的CANCELLED、SIGNAL、CONDITION、PROPAGATE，同时</span></span><br><span class="line">    <span class="comment">//还可能为0，为0的时候代表当前节点在sync队列中，阻塞着排队获取锁。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">//当前节点的前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">//当前节点的后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//当前节点关联的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//在condition队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前节点是否为共享模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回当前节点的前驱节点 没有前驱节点则抛出异常</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程都关联一个节点，节点的状态也代表着线程的状态，<code>AQS</code>通过对同步队列的管理而达到对线程的管理。</p>
<h4 id="AQS的功能"><a href="#AQS的功能" class="headerlink" title="AQS的功能"></a>AQS的功能</h4><p><code>AQS</code>提供了<code>2</code>大功能，基于双链表的同步队列和基于单链表的条件队列，同步队列维护的是<strong>阻塞状态的线程对应的节点</strong>，这些线程都是阻塞着排队获取锁的，条件队列维护的是<strong>等待状态的线程对应的节点</strong>。</p>
<h5 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h5><p><code>AQS</code>提供了两种方式去获取资源，分别是<strong>共享模式</strong>和<strong>独占模式</strong>，但是一般锁只会去继承其中一种模式，不会在一个锁里同时存在<strong>共享模式</strong>和<strong>独占模式</strong>两种模式。</p>
<blockquote>
<p>资源指锁、IO、Socket等</p>
</blockquote>
<p>当一个线程以共享模式或独占模式去获取资源的时候，如果获取失败则将该线程封装成<code>Node</code>节点(同时将该节点标识为共享模式或独占模式)<strong>加入到同步队列的尾部</strong>，<code>AQS</code>实时维护着这个同步队列，这个队列以<strong>FIFO(先进先出)来管理节点的排队</strong>，即资源的转移(获取再释放)的顺序是从头结点开始到尾节点。</p>
<p><img src="http://static.cyblogs.com/169ae1c4f8d7e8d6.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c4f8d7e8d6.png"></p>
<p>共享模式和独占模式去获取、释放资源都分别对应着一套<code>API</code>，以下分别分析这两套<code>API</code></p>
<blockquote>
<p>独占模式即获取资源的<strong>排他锁</strong>，共享模式及获取资源的<strong>共享锁</strong>。</p>
</blockquote>
<h6 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h6><p>独占模式即一个线程获取到资源后，其他线程不能再对资源进行任何操作，只能阻塞获得资源。</p>
<h6 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h6><ol>
<li>线程调用子类重写的<code>tryAcquire</code>方法获取资源，如果获取成功，则流程结束，否则继续往下执行。</li>
<li>调用<code>addWaiter</code>方法(详细过程看下面的源码解析)，将该线<strong>程封装成Node节点</strong>，并添加到队列<strong>队尾</strong>。</li>
<li>调用<code>acquireQueued</code>方法让节点以”死循环”方式进行获取资源，为什么死循环加了双引号呢？因为循环并不是一直让节点无间断的去获取资源，节点会经历 获取资源-&gt;失败-&gt;线程进入等待状态-&gt;唤醒-&gt;获取资源……，<strong>线程在死循环的过程会不断等待和唤醒</strong>，节点进入到自旋状态(详细过程看下面的源码解析)，<strong>再循环过程中还会将标识为取消的前驱节点移除队列，同时标识前驱节点状态为SIGNAL</strong>。</li>
<li>线程的等待状态是通过调用<code>LockSupport.lock()</code>方法实现的，这个方法会响应<code>Thread.interrupt</code>，但是不会抛出InterruptedException异常，这点与<code>Thread.sleep</code>、<code>Thread.wait</code>不一样。</li>
</ol>
<p><img src="http://static.cyblogs.com/169ae1c4f8c40a95.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c4f8c40a95.png"></p>
<p><img src="http://static.cyblogs.com/169ae1c4f8e8cde5.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c4f8e8cde5.png"></p>
<p><strong>可以看到节点和节点之间在自旋过程中除了前驱节点会唤醒该节点之外基本不会互相通讯</strong></p>
<p><strong>源码分析</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//该线程调用tryAcquire方法尝试以独占模式获取资源，如果获取失败，则调</span></span><br><span class="line">    <span class="comment">//用addWaiter函数，将线程封装到Node节点中，然后再将Node节点加入到同</span></span><br><span class="line">    <span class="comment">//步队列的尾部，然后再调用acquireQueued让线程进入到阻塞状态，如果获</span></span><br><span class="line">    <span class="comment">//取成功则返回true，然后调用selfInterrupt</span></span><br><span class="line">    <span class="comment">//函数。</span></span><br><span class="line">    <span class="comment">//注意的是，tryAcquire函数就是继承AQS的子类所需要去重写的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS的tryAcquire函数并没有获取资源的相关实现，需要继承`AQS`的子类去</span></span><br><span class="line"><span class="comment">//重写这个方法。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">//创建新的节点，并将线程和节点关联。</span></span><br><span class="line">    <span class="comment">//将同步队列的尾节点后继节点指向新节点，</span></span><br><span class="line">    <span class="comment">//将新节点的前驱节点指向尾节点，</span></span><br><span class="line">    <span class="comment">//新节点称为同步队列的尾节点。</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS操作将新节点插入到，成功则返回，不成功则继续下面的enq方法，</span></span><br><span class="line">        <span class="comment">//进行死循环CAS插入，直到成功。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果上面的CAS操作插入不成功，则调用enq方法 死循环插入 直到成功。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//死循环 直到插入成功。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">//如果尾节点为null，说明同步队列还未初始化，则CAS操作新建头节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过CAS操作将节点插入到同步队列尾部</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点以“死循环”的方式去获取资源，为什么死循环加了双引号呢？因为循环并不</span></span><br><span class="line"><span class="comment">//是一直让节点无间断的去获取资源，节点会经历 获取资源-&gt;失败-&gt;线程进入等待</span></span><br><span class="line"><span class="comment">//状态-&gt;唤醒-&gt;获取资源......，线程在死循环的过程会不断等待和唤醒，即节点的自旋。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱节点为头结点，表示资源正在前驱节点的手上，那该节点</span></span><br><span class="line">            <span class="comment">//去尝试获取资源，如果获取成功则将该节点设置为头结点，并且</span></span><br><span class="line">            <span class="comment">//返回。</span></span><br><span class="line">            <span class="comment">//如果该节点的前驱节点并不是头节点或者是前驱节点是头结点但是</span></span><br><span class="line">            <span class="comment">//该节点获取资源失败，继续往下执行。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用shouldParkAfterFailedAcquire函数，将该节点的前驱节点</span></span><br><span class="line">            <span class="comment">//的状态设置为SIGNAL，告诉前驱节点我要去“睡觉”了，当资源排</span></span><br><span class="line">            <span class="comment">//到你的时候，你就通知我一下让我醒来，即节点做进入等待状态</span></span><br><span class="line">            <span class="comment">//的准备。</span></span><br><span class="line">            <span class="comment">//当节点做好了进入等待状态的准备，则调用parkAndCheckInterrupt</span></span><br><span class="line">            <span class="comment">//函数，让该节点进入到等待状态。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//获取前驱节点的状态。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">//如果前驱节点的状态已经为SIGNAL了，即已经做好准备了，那直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果前驱节点的状态为取消状态，则将前驱节点移除队列，循环这个过程</span></span><br><span class="line">    <span class="comment">//直到前驱节点不为取消状态为止。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    <span class="comment">//如果前驱节点没有做好准备(标志状态为SIGNAL)、前驱节点也没有被取消，</span></span><br><span class="line">    <span class="comment">//则使用CAS操作将前驱节点的状态更新为SIGNAL，然后返回false，为什么</span></span><br><span class="line">    <span class="comment">//是返回false呢？因为CAS操作并不保证一定能更新成功，返回false的目的</span></span><br><span class="line">    <span class="comment">//是让acquireQueued函数再执行一次for循环，这个循环第一可以让该节点</span></span><br><span class="line">    <span class="comment">//再尝试获取资源(万一成功了呢 是吧)，第二是让acquireQueued函数再调用</span></span><br><span class="line">    <span class="comment">//一次shouldParkAfterFailedAcquire函数(即本函数)判断节点的前驱节点是</span></span><br><span class="line">    <span class="comment">//否已经设置为SIGNAL状态了。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用LockSupport.park函数将该线程设置为等待状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//注意LockSupport遇到Thread.interrupt是会立刻返回的，但是不会抛出异常InterruptedExcept</span></span><br><span class="line">    <span class="comment">//ion，这个需要注意和Thread.wait，Thread.sleep的区别，</span></span><br><span class="line">    <span class="comment">//唤醒的时候 会返回该线程是否为中断唤醒的。</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h6><ol>
<li>线程调用子类重写的<code>tryRelease</code>方法进行释放资源，如果释放成功则继续检查线程(节点)的是否有后继节点，有后继几点则去<strong>唤醒</strong>。</li>
<li>调用<code>unparkSuccessor</code>方法进行后继节点的唤醒，<strong>如果后继节点为取消状态，则从队列的队尾往前遍历，找到一个离节点最近且不为取消状态的节点进行唤醒，如果后继节点不为取消状态则直接唤醒</strong>。</li>
</ol>
<p><img src="http://static.cyblogs.com/169ae1c515d4bfe8.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c515d4bfe8.png"></p>
<p><strong>源码解析</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//线程调用tryRelease方法尝试释放资源，如果释放成功则检查该节点是否有后继节点，有的话则</span></span><br><span class="line">    <span class="comment">//调用unpacrkSuccessor()方法去唤醒后继节点。</span></span><br><span class="line">    <span class="comment">//注意的是，tryRelease函数就是继承AQS的子类所需要去重写的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//头结点(即释放资源的节点)不为空，头结点的状态不为0，代表有后继节点，需要唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取头结点状态。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">//如果状态小于0，即代表有后继节点需要唤醒。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//将头结点的状态置为0 因为只需要唤醒一次</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">//如果头结点的后继节点为空 或者 头结点的后继节点处于取消状态，则从尾部开始往前寻找，</span></span><br><span class="line">    <span class="comment">//找到一个离头结点最近 且状态不是取消状态的节点。</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果头结点的后继节点不为取消状态，则直接将后继节点唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h5><p>共享模式下，线程无论是<strong>获取资源还是释放资源，都可能会唤醒后继节点</strong>。</p>
<h6 id="获取资源-1"><a href="#获取资源-1" class="headerlink" title="获取资源"></a>获取资源</h6><ol>
<li>调用子类重写的<code>tryAcquireShared</code>方法进行资源获取，获取失败则调用<code>doAcquireShared</code>将<strong>线程封装Node节点加入到同步队列队尾</strong>。</li>
<li>调用<code>doAcquireShared</code>方法让节点以”死循环”方式进行获取资源，为什么死循环加了双引号呢？因为循环并不是一直让节点无间断的去获取资源，节点会经历获取资源-&gt;失败-&gt;线程进入等待状态-&gt;唤醒-&gt;获取资源……，线程在死循环的过程会不断等待和唤醒，节点进入到自旋状态(详细过程看下面的源码解析)。<strong>如果线程节点被唤醒后，且获取资源成功，且后继节点为共享模式，那么会唤醒后继节点……唤醒会一直传递下去，直到后继节点不是共享模式，唤醒的节点同样会去获取资源</strong>，这点和独占模式不一样。</li>
</ol>
<p><img src="http://static.cyblogs.com/169ae1c51e6294d8.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c51e6294d8.png"></p>
<p><img src="http://static.cyblogs.com/169ae1c520e21e80.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c520e21e80.png"></p>
<p><strong>共享模式资源的获取和独占模式资源的获取流程差不多，就是在获取资源成功后，会唤醒为共享模式的后继节点，然后被唤醒的后继节点也去获取资源</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//和独占模式的一样，同样是调用子类重写的tryAcquireShared方法以共享模式进行资源获取。</span></span><br><span class="line">    <span class="comment">//如果获取失败，则调用doAcquireShared方法将线程封装成Node节点加入到同步队列的队尾，</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//将线程封装到节点中，且将节点加入到队尾中。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取线程(节点)的前驱节点。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱节点为头结点，则该线程尝试获取资源。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//获取资源。</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//获取资源成功则将节点设为头结点。</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取成功 对后继SHARED节点持续唤醒</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//和独占模式的一样。</span></span><br><span class="line">            <span class="comment">//调用shouldParkAfterFailedAcquire函数，将该节点的前驱节点</span></span><br><span class="line">            <span class="comment">//的状态设置为SIGNAL，告诉前驱节点我要去“睡觉”了，当资源排</span></span><br><span class="line">            <span class="comment">//到你的时候，你就通知我一下让我醒来，即节点做进入等待状态的准备。</span></span><br><span class="line">            <span class="comment">//当节点做好了进入等待状态的准备，则调用parkAndCheckInterrupt</span></span><br><span class="line">            <span class="comment">//函数，让该节点进入到等待状态。            </span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//如果节点为共享节点，则调用doReleaseShared函数唤醒后继节点。</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="释放资源-1"><a href="#释放资源-1" class="headerlink" title="释放资源"></a>释放资源</h6><ol>
<li>调用子类重写的<code>tryReleaseShared</code>方法释放资源，释放成功则调用<code>doReleaseShared</code>方法进行后继节点的唤醒。</li>
<li>如果后继节点为共享模式，则持续唤醒。</li>
</ol>
<p><img src="http://static.cyblogs.com/169ae1c5271b53d9.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c5271b53d9.png"></p>
<p><strong>共享模式下资源释放流程和独占模式下资源释放的流程差不多，就是在释放后唤醒后继为共享模式的节点，且唤醒的动作是传播下去的，直到后继节点出现不是共享模式的，这个唤醒的过程和共享模式的获取资源的唤醒过程一样。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用子类重写的tryReleaseShared方法进行以共享模式释放资源，释放失败则调用doReleaseShared。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果节点标识后继节点需要唤醒，则调用unparkSuccessor方法进行唤醒。</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h4><p>条件队列又称等待队列、条件队列等，条件队列的实现是通过<code>ConditionObject</code>的内之类来完成的，，一开始就介绍了同步队列条件队列的去，不过这里再啰嗦一下，<strong>可以把同步队和条件队列理解成储存等待状态的线程的队列</strong>，条件队列中的线程并不能直接去获取资源，而要先从条件队列转到同步队列中排队获取，一个线程要么是在同步队列中，要么是在条件队列中，不可能同时存在这两个队列里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 使当前线程进入等待状态，直到以下4种情况任意一个发生：</span></span><br><span class="line"><span class="comment"> * 1.另一个线程调用该对象的signal()，当前线程恰好是被选中的唤醒线程</span></span><br><span class="line"><span class="comment"> * 2.另一个线程调用该对象的signalAll()</span></span><br><span class="line"><span class="comment"> * 3.另一个线程interrupt当前线程（此时会抛出InterruptedException）</span></span><br><span class="line"><span class="comment"> * 4.虚假唤醒（源自操作系统，发生概率低）</span></span><br><span class="line"><span class="comment"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 与await()相同，但是不会被interrupt唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 与await()相同，增加了超时时间，超过超时时间也会停止等待</span></span><br><span class="line"><span class="comment"> * 三个方法功能相似，其返回值代表剩余的超时时间，或是否超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 唤醒一个正在等待该条件变量对象的线程</span></span><br><span class="line"><span class="comment"> * ConditionObject会选择等待时间最长的线程来唤醒</span></span><br><span class="line"><span class="comment"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 唤醒所有正在等待该条件变量对象的线程</span></span><br><span class="line"><span class="comment"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，其作用与Object原生的wait()&#x2F;notify()&#x2F;notifyAll()很相似，但是增加了更多的功能。下面以awaitUninterruptibly()、signal()为例，阐述一下其内部实现。</p>
<p><img src="http://static.cyblogs.com/169ae1c528ceaba6.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169ae1c528ceaba6.png"></p>
<h4 id="同步队列和条件队列的关系"><a href="#同步队列和条件队列的关系" class="headerlink" title="同步队列和条件队列的关系"></a>同步队列和条件队列的关系</h4><p>线程执行<code>condition.await()</code>方法，将节点1从同步队列转移到条件队列中。</p>
<p><img src="http://static.cyblogs.com/169b3432b128105d.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169b3432b128105d.png"></p>
<p>线程执行<code>condition.signal()</code>方法，将节点1从条件队列中转移到同步队列。</p>
<p><img src="http://static.cyblogs.com/169b3411b74cfff1.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;169b3411b74cfff1.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/11/2020/02/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/11/2020/02/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" class="post-title-link" itemprop="url">序列化和反序列化的底层实现原理是什么？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-11T00:00:00+08:00">2020-02-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="1、什么是序列化和反序列化"><a href="#1、什么是序列化和反序列化" class="headerlink" title="1、什么是序列化和反序列化"></a>1、什么是序列化和反序列化</h5><p>（1）Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程；</p>
<p>（2）序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。</p>
<p>（3）反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
<p>（4）本质上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。</p>
<h5 id="2、为什么需要序列化与反序列化"><a href="#2、为什么需要序列化与反序列化" class="headerlink" title="2、为什么需要序列化与反序列化"></a>2、为什么需要序列化与反序列化</h5><p>我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。</p>
<p>那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的！如何做到呢？这就需要Java序列化与反序列化了！</p>
<p>换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。</p>
<p>当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p>
<p>总的来说可以归结为以下几点：</p>
<p>（1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中；<br>（2）通过序列化以字节流的形式使对象在网络中进行传递和接收；<br>（3）通过序列化在进程间传递对象；</p>
<h5 id="3、序列化算法一般会按步骤做如下事情："><a href="#3、序列化算法一般会按步骤做如下事情：" class="headerlink" title="3、序列化算法一般会按步骤做如下事情："></a>3、序列化算法一般会按步骤做如下事情：</h5><p>（1）将对象实例相关的类元数据输出。<br>（2）递归地输出类的超类描述直到不再有超类。<br>（3）类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。<br>（4）从上至下递归输出实例的数据</p>
<h4 id="Java如何实现序列化和反序列化"><a href="#Java如何实现序列化和反序列化" class="headerlink" title="Java如何实现序列化和反序列化"></a>Java如何实现序列化和反序列化</h4><h5 id="1、JDK类库中序列化和反序列化API"><a href="#1、JDK类库中序列化和反序列化API" class="headerlink" title="1、JDK类库中序列化和反序列化API"></a>1、JDK类库中序列化和反序列化API</h5><p>（1）java.io.ObjectOutputStream：表示对象输出流；</p>
<p>它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；</p>
<p>（2）java.io.ObjectInputStream：表示对象输入流；</p>
<p>它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回；</p>
<h5 id="2、实现序列化的要求"><a href="#2、实现序列化的要求" class="headerlink" title="2、实现序列化的要求"></a>2、实现序列化的要求</h5><p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！</p>
<h5 id="3、实现Java对象序列化与反序列化的方法"><a href="#3、实现Java对象序列化与反序列化的方法" class="headerlink" title="3、实现Java对象序列化与反序列化的方法"></a>3、实现Java对象序列化与反序列化的方法</h5><p>假定一个User类，它的对象需要序列化，可以有如下三种方法：</p>
<p>（1）若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化</p>
<p>ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。<br>ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。</p>
<p>（2）若User类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。</p>
<p>ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化。<br>ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化。</p>
<p>（3）若User类实现了Externalnalizable接口，且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。</p>
<p>ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化。<br>ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化。</p>
<h5 id="4、JDK类库中序列化的步骤"><a href="#4、JDK类库中序列化的步骤" class="headerlink" title="4、JDK类库中序列化的步骤"></a>4、JDK类库中序列化的步骤</h5><p>步骤一：创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\object.out&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>步骤二：通过对象输出流的writeObject()方法写对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xuliugen&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;male&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="5、JDK类库中反序列化的步骤"><a href="#5、JDK类库中反序列化的步骤" class="headerlink" title="5、JDK类库中反序列化的步骤"></a>5、JDK类库中反序列化的步骤</h5><p>步骤一：创建一个对象输入流，它可以包装一个其它类型输入流，如文件输入流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream ois= <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.out&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>步骤二：通过对象输出流的readObject()方法读取对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = (User) ois.readObject();</span><br></pre></td></tr></table></figure>

<p>说明：为了正确读取数据，完成反序列化，必须保证向对象输出流写对象的顺序与从对象输入流中读对象的顺序一致。</p>
<h5 id="6、序列化和反序列化的示例"><a href="#6、序列化和反序列化的示例" class="headerlink" title="6、序列化和反序列化的示例"></a>6、序列化和反序列化的示例</h5><p>为了更好地理解Java序列化与反序列化，举一个简单的示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerialDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xuliugen&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName() + <span class="string">&quot; &quot;</span> + user2.getPassword() + <span class="string">&quot; &quot;</span> + user2.getSex());</span><br><span class="line">        <span class="comment">//反序列化的输出结果为：xuliugen 123456 male</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">//全参构造方法、get和set方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>object.out文件如下（使用UltraEdit打开）：</p>
<p><img src="http://static.cyblogs.com/20180407130515728.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180407130515728.png"></p>
<p>注：上图中0000000h-000000c0h表示行号；0-f表示列；行后面的文字表示对这行16进制的解释；对上述字节码所表述的内容感兴趣的可以对照相关的资料，查阅一下每一个字符代表的含义，这里不在探讨！</p>
<p>类似于我们Java代码编译之后的.class文件，每一个字符都代表一定的含义。序列化和反序列化的过程就是生成和解析上述字符的过程！</p>
<p>序列化图示：</p>
<p><img src="http://static.cyblogs.com/20180408163613978.jpeg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180408163613978.jpeg"></p>
<p>反序列化图示：</p>
<p><img src="http://static.cyblogs.com/20180408163634701.jpeg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20180408163634701.jpeg"></p>
<h4 id="相关注意事项"><a href="#相关注意事项" class="headerlink" title="相关注意事项"></a>相关注意事项</h4><p>1、序列化时，只对对象的状态进行保存，而不管对象的方法；</p>
<p>2、当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p>
<p>3、当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</p>
<p>4、并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p>
<ul>
<li>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</li>
<li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</li>
</ul>
<p>5、声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p>
<p>6、序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：</p>
<ul>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</li>
<li>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</li>
</ul>
<p>7、Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p>
<p>8、如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；</p>
<p>​    序列化时，类的所有数据成员应可序列化除了声明为transient或static的成员。将变量声明为transient告诉JVM我们会负责将变元序列化。将数据成员声明为transient后，序列化过程就无法将其加进对象字节流中，没有从transient数据成员发送的数据。后面数据反序列化时，要重建数据成员（因为它是类定义的一部分），但不包含任何数据，因为这个数据成员不向流中写入任何数据。记住，对象流不序列化static或transient。我们的类要用writeObject()与readObject()方法以处理这些数据成员。使用writeObject()与readObject()方法时，还要注意按写入的顺序读取这些数据成员</p>
<p>那对于这些问题，我们该如何进行序列化和反序列化呢？</p>
<p>简单，也就是说我们要对这俩个类型的变量单独处理，怎么办？就是在出现这类变量的所属类中增加俩个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span><span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span><span class="keyword">throws</span> IOException,ClassNotFoundException;</span><br><span class="line">        而对应于我们的类中添加的方法就是</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerialTest</span> <span class="keyword">extends</span> <span class="title class_">parent</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        out.defaultWriteObject();</span><br><span class="line">        out.writeInt(<span class="built_in">this</span>.testStatic);</span><br><span class="line">        out.writeInt(<span class="built_in">this</span>.testTransient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        <span class="built_in">this</span>.testStatic = in.readInt();</span><br><span class="line">        <span class="built_in">this</span>.testTransient = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当ObjectOutputStream对一个SerialTest对象进行序列化时，如果该对象具有writeObject()方法，那么就会执行这一方法，否则就按默认方式序列化。在该对象的writeObjectt()方法中，可以先调用ObjectOutputStream的defaultWriteObject()方法，使得对象输出流先执行默认的序列化操作。同理可得出反序列化的情况，不过这次是defaultReadObject()方法。</p>
<p>  <em>ObjectOutputStream.defaultWriteObject()</em> ：将当前类的非静态(static)和非瞬态字段(transient)写入此流。</p>
<p>  <em>ObjectInputStream.defaultReadObject()</em> ：  从此流读取当前类的非静态和非瞬态字段。</p>
<p>Externalizable的作用</p>
<p>对于实现Serializable的类来说，在序列化的时候，所有的非静态(static)和非瞬态字段(transient)会被自动序列化，如果有一些特殊要求，我们可以完全手动控制哪些字段要被序列化，哪些不要序列化。将他们的生死大权完全掌握在咱手中。怎么办？这个时候就应该谈谈Externalizable类了。</p>
<p>只要实现Externalizable这个类，并且复写 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readExternal(ObjectInput in) <span class="keyword">throws</span> IOException,CalssNotFoundException</span><br><span class="line"> </span><br><span class="line"><span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException,CalssNotFoundException</span><br></pre></td></tr></table></figure>

<p>就可以了，在readExternal(ObjectInput in) throws IOException,CalssNotFoundException方法中，可以自行决定从in读取哪些对象数据。</p>
<p>writeExternal(ObjectOutput out) throws IOException,CalssNotFoundException方法中，可以自行决定将什么数据write到out去。</p>
<p>这俩个方法分别会在在ObjectOutputStream.writeObject(object);ObjectInputStream.readObject()自动执行。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><p>1、<a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/688891250408618484.html">https://zhidao.baidu.com/question/688891250408618484.html</a><br>2、<a target="_blank" rel="noopener" href="https://blog.csdn.net/morethinkmoretry/article/details/5929345">https://blog.csdn.net/morethinkmoretry/article/details/5929345</a><br>3、<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/edcf7bd2c085">https://www.jianshu.com/p/edcf7bd2c085</a><br>4、<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaocaidexuexibiji/article/details/22692097">https://blog.csdn.net/xiaocaidexuexibiji/article/details/22692097</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/10/2020/02/%E4%BD%BF%E7%94%A8SimpleDateFormat%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%8F%E5%BF%83%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/10/2020/02/%E4%BD%BF%E7%94%A8SimpleDateFormat%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%8F%E5%BF%83%E7%82%B9/" class="post-title-link" itemprop="url">使用SimpleDateFormat的时候小心点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-10T00:00:00+08:00">2020-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>SimpleDateFormat是Java提供的一个格式化和解析日期的工具类，日常开发中应该经常会用到，但是由于它是线程不安全的，多线程公用一个SimpleDateFormat实例对日期进行解析或者格式化会导致程序出错。</p>
<h4 id="代码示例演示"><a href="#代码示例演示" class="headerlink" title="代码示例演示"></a>代码示例演示</h4><p>写一段小Demo来模拟多线程下<code>SimpleDateFormat</code>做时间格式化的时候报错,代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan</span></span><br><span class="line"><span class="comment"> * Date：2019/3/20 Time：2:03 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatCase</span> &#123;</span><br><span class="line">    <span class="comment">//1、创建单例实例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//2、创建多个线程，并启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">//3、使用单例日期实例解析文本</span></span><br><span class="line">                        System.out.println(sdf.parse(<span class="string">&quot;2017-12-13 15:17:27&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">	          <span class="comment">//4、启动线程</span></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="控制台正常的情况：-运气好"><a href="#控制台正常的情况：-运气好" class="headerlink" title="控制台正常的情况： 运气好~"></a><strong>控制台正常的情况：</strong> 运气好~</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#x27;127.0.0.1:57434&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:57434&#x27;, transport: &#x27;socket&#x27;</span><br></pre></td></tr></table></figure>

<h6 id="控制台非正常的情况-运气不好"><a href="#控制台非正常的情况-运气不好" class="headerlink" title="控制台非正常的情况 运气不好~"></a><strong>控制台非正常的情况</strong> 运气不好~</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#x27;127.0.0.1:57756&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">Exception in thread &quot;Thread-2&quot; Exception in thread &quot;Thread-0&quot; java.lang.NumberFormatException: multiple points</span><br><span class="line">	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line">	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line">	at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line">	at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line">	at java.text.DecimalFormat.parse(DecimalFormat.java:2056)</span><br><span class="line">	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line">	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line">	at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line">	at com.vernon.test.demo.jdk.text.SimpleDateFormatCase$1.run(SimpleDateFormatCase.java:23)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line">	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line">	at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line">	at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line">	at java.text.DecimalFormat.parse(DecimalFormat.java:2056)</span><br><span class="line">	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line">	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line">	at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line">	at com.vernon.test.demo.jdk.text.SimpleDateFormatCase$1.run(SimpleDateFormatCase.java:23)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Fri Dec 12 15:17:27 CST 2217</span><br><span class="line">Thu Dec 13 15:17:27 CST 2012</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Fri Jun 09 15:17:27 CST 5881628</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:57756&#x27;, transport: &#x27;socket&#x27;</span><br></pre></td></tr></table></figure>

<p>通过IntelliJ IDEA的功能查看一下SimpleDateFormat的一个类关系图：</p>
<p><img src="http://static.cyblogs.com/WX20200116-175032.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200116-175032.png"></p>
<p>可知每个<code>SimpleDateFormat</code>实例里面有一个<code>Calendar</code>对象，从后面会知道其实<code>SimpleDateFormat</code>之所以是线程不安全的就是因为<code>Calendar</code>是线程不安全的，后者之所以是线程不安全的是因为其中存放日期数据的变量都是线程不安全的，比如里面的<code>fields</code>、<code>time</code>等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String text, ParsePosition pos)</span> &#123;</span><br><span class="line">    <span class="comment">//1、解析日期字符串放入CalendarBuilder的实例calb中</span></span><br><span class="line">    .....</span><br><span class="line">    Date parsedDate;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//2、使用calb中解析好的日期数据设置calendar</span></span><br><span class="line">        parsedDate = calb.establish(calendar).getTime();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parsedDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Calendar <span class="title function_">establish</span><span class="params">(Calendar cal)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//3、重置日期对象cal的属性值</span></span><br><span class="line">   cal.clear();</span><br><span class="line">   <span class="comment">//4、使用calb中中属性设置cal</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//5、返回设置好的cal对象</span></span><br><span class="line">   <span class="keyword">return</span> cal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; ) &#123;</span><br><span class="line">        stamp[i] = fields[i] = <span class="number">0</span>; <span class="comment">// UNSET == 0</span></span><br><span class="line">        isSet[i++] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    areAllFieldsSet = areFieldsSet = <span class="literal">false</span>;</span><br><span class="line">    isTimeSet = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>1、解析日期字符串放入<code>CalendarBuilder</code>的实例<code>calb</code>中；</p>
</li>
<li><p>2、使用calb中解析好的日期数据设置<code>calendar</code>；</p>
</li>
<li><p>3、重置日期对象<code>cal</code>的属性值；</p>
</li>
<li><p>4、使用<code>calb</code>中中属性设置<code>cal</code>；</p>
</li>
<li><p>5、返回设置好的<code>cal</code>对象；</p>
</li>
</ul>
<p>从上面步骤可知步骤<code>3、4、5</code>操作不是原子性操作，当多个线程调用parse方法时候比如线程A执行了步骤<code>3、4</code>也就是设置好了cal对象，在执行步骤<code>5</code>前线程B执行了步骤<code>3</code>清空了cal对象，由于多个线程使用的是一个cal对象，所以线程A执行步骤<code>5</code>返回的就可能是被线程B清空后的对象，当然也有可能线程B执行了步骤<code>4</code>被线程B修改后的cal对象，从而导致程序错误。</p>
<h4 id="那么怎么解决呢？"><a href="#那么怎么解决呢？" class="headerlink" title="那么怎么解决呢？"></a>那么怎么解决呢？</h4><h6 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h6><p>每次使用时候new一个SimpleDateFormat的实例，这样可以保证每个实例使用自己的Calendar实例,但是每次使用都需要new一个对象，并且使用后由于没有其它引用，就会需要被回收，开销会很大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan</span></span><br><span class="line"><span class="comment"> * Date：2019/3/20</span></span><br><span class="line"><span class="comment"> * Time：2:07 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatCase2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line">                            System.out.println(sdf.parse(<span class="string">&quot;2020-01-16 15:17:27&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h6><p>究其原因是因为多线程下步骤3、4、5三个步骤不是一个原子性操作，那么容易想到的是对其进行同步，让3、4、5成为原子操作，可以使用synchronized进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan Date：2019/3/21 Time：10:32 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatCase3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line">                            System.out.println(sdf.parse(<span class="string">&quot;2020-01-16 15:17:27&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="第三种方式："><a href="#第三种方式：" class="headerlink" title="第三种方式："></a>第三种方式：</h6><p>使用ThreadLocal，这样每个线程只需要使用一个SimpleDateFormat实例相比第一种方式大大节省了对象的创建销毁开销，并且不需要对多个线程直接进行同步，使用ThreadLocal方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan</span></span><br><span class="line"><span class="comment"> * Date：2019/3/21 Time：10:32 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatCase4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; safeSdf = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> SimpleDateFormat <span class="title function_">initialValue</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(safeSdf.get().parse(<span class="string">&quot;2020-01-16 15:17:27&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="第四种方式："><a href="#第四种方式：" class="headerlink" title="第四种方式："></a>第四种方式：</h6><p>在JDK8中新增了<code>DateTimeFormatter</code>，由<code>DateTimeFormatter</code>的静态方法<code>ofPattern()</code>构建日期格式，<code>LocalDateTime</code>和<code>LocalDate</code>等一些表示日期或时间的类使用<code>parse</code>和<code>format</code>方法把日期和字符串做转换。使用新的API，整个转换过程都不需要考虑线程安全的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan</span></span><br><span class="line"><span class="comment"> * Date：2019/3/21 Time：10:32 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleDateFormatCase5</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(LocalDate.parse(<span class="string">&quot;2020-01-16 15:17:27&quot;</span>, formatter));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Java8</code>发布，已有数年之久，但是发现很多人都还是坚持着用<code>SimpleDateFormat</code>和<code>Date</code>进行时间操作。<code>SimpleDateFormat</code>这个类不是线程安全的，在使用的时候稍不注意，就会产生致命的问题。<code>Date</code>这个类，是可以重新设置时间的，这对于一些类内部的属性来说，是非常不安全的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/09/2020/02/%E4%BD%BF%E7%94%A8HashMap%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%8F%E5%BF%83%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/09/2020/02/%E4%BD%BF%E7%94%A8HashMap%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%8F%E5%BF%83%E7%82%B9/" class="post-title-link" itemprop="url">使用HashMap的时候小心点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-09 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-09T00:00:00+08:00">2020-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HashMap/" itemprop="url" rel="index"><span itemprop="name">HashMap</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/HashMap/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="Map家族介绍"><a href="#Map家族介绍" class="headerlink" title="Map家族介绍"></a>Map家族介绍</h5><p>我们都知道<code>HashMap</code>是线程不安全的，但是<code>HashMap</code>的使用频率在所有<code>Map</code>中确实属于比较高的。因为它可以满足我们大多数的场景了。</p>
<p>看一眼Map家族的关系图：</p>
<p><img src="http://static.cyblogs.com/WX20200117-161643@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200117-161643@2x.png"></p>
<p><code>Map</code>是一个接口，我们常用的实现类有<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>，<code>HashTable</code>。</p>
<h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><p><code>HashMap</code>根据<code>key</code>的·值来保存value，需要注意的是，<code>HashMap</code>不保证遍历的顺序和插入的顺序是一致的。<code>HashMap</code>允许有一条记录的<code>key</code>为<code>null</code>，但是对值是否为<code>null</code>不做要求。</p>
<h6 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h6><p><code>HashTable</code>类是线程安全的，它使用<code>synchronize</code>来做线程安全，全局只有一把锁，在线程竞争比较激烈的情况下<code>hashtable</code>的效率是比较低下的。因为当一个线程访问<code>hashtable</code>的同步方法时，其他线程再次尝试访问的时候，会进入阻塞或者轮询状态，比如当线程1使用put进行元素添加的时候，线程2不但不能使用put来添加元素，而且不能使用get获取元素。所以，竞争会越来越激烈。相比之下，<code>ConcurrentHashMap</code>使用了分段锁技术来提高了并发度，不在同一段的数据互相不影响，多个线程对多个不同的段的操作是不会相互影响的。每个段使用一把锁。所以在需要线程安全的业务场景下，推荐使用<code>ConcurrentHashMap</code>，而<code>HashTable</code>不建议在新的代码中使用，如果需要线程安全，则使用<code>ConcurrentHashMap</code>，否则使用<code>HashMap</code>就足够了。</p>
<h6 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h6><p><code>LinkedHashMap</code>属于<code>HashMap</code>的子类，与<code>HashMap</code>的区别在于<code>LinkedHashMap</code>保存了记录插入的顺序。</p>
<h6 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h6><p><code>TreeMap</code>实现了<code>SortedMap</code>接口，<code>TreeMap</code>有能力对插入的记录根据<code>key</code>排序，默认按照升序排序，也可以自定义比较强，在使用<code>TreeMap</code>的时候，<code>key</code>应当实现<code>Comparable</code>。</p>
<h5 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a>HashMap的实现</h5><p><code>Java7</code>和<code>Java7</code>在实现<code>HashMap</code>上有所区别，当然<code>Java7</code>的效率要更好一些，主要是<code>Java7</code>的<code>HashMap</code>在<code>Java7</code>的基础上增加了红黑树这种数据结构，使得在桶里面查找数据的复杂度从<code>O(n)</code>降到<code>O(logn)</code>，当然还有一些其他的优化，比如<code>resize</code>的优化等。<br> 介于<code>Java7</code>的<code>HashMap</code>较为复杂，本文将基于<code>Java7</code>的<code>HashMap</code>实现来说明，主要的实现部分还是一致的，<code>Java7</code>的实现上主要是做了一些优化，内容还是没有变化的，依然是线程不安全的。<br> <code>HashMap</code>的实现使用了一个数组，每个数组项里面有一个链表的方式来实现，因为<code>HashMap</code>使用<code>key</code>的<code>hashCode</code>来寻找存储位置，不同的<code>key</code>可能具有相同的<code>hashCode</code>，这时候就出现哈希冲突了，也叫做哈希碰撞，为了解决哈希冲突，有开放地址方法，以及链地址方法。<code>HashMap</code>的实现上选取了链地址方法，也就是将哈希值一样的<code>entry</code>保存在同一个数组项里面，可以把一个数组项当做一个桶，桶里面装的<code>entry</code>的<code>key</code>的<code>hashCode</code>是一样的。</p>
<p><img src="http://static.cyblogs.com/WX20200117-160020@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200117-160020@2x.png"></p>
<p>上面的图片展示了我们的描述，其中有一个非常重要的数据结构<code>Node&lt;K,V&gt;</code>，这就是实际保存我们的<code>key-value</code>对的数据结构，下面是这个数据结构的主要内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> hash;    </span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K,V&gt; next;   </span><br></pre></td></tr></table></figure>

<p>一个<code>Node</code>就是一个链表节点，也就是我们插入的一条记录，明白了<code>HashMap</code>使用链地址方法来解决哈希冲突之后，我们就不难理解上面的数据结构，<code>hash</code>字段用来定位桶的索引位置，<code>key</code>和<code>value</code>就是我们的数据内容，需要注意的是，我们的<code>key</code>是<code>final</code>的，也就是不允许更改，这也好理解，因为<code>HashMap</code>使用<code>key</code>的<code>hashCode</code>来寻找桶的索引位置，一旦key被改变了，那么<code>key</code>的<code>hashCode</code>很可能就会改变了，所以随意改变key会使得我们丢失记录（无法找到记录）。<code>next</code>字段指向链表的下一个节点。</p>
<p><code>HashMap</code>的初始桶的数量为<code>16</code>，<code>loadFact</code>为<code>0.75</code>,当桶里面的数据记录超过阈值的时候，<code>HashMap</code>将会进行扩容则操作，每次都会变为原来大小的<code>2倍</code>，直到设定的最大值之后就无法再<code>resize</code>了。</p>
<p>下面对<code>HashMap</code>的实现做简单的介绍，具体实现还得看代码，对于<code>Java7</code>中的<code>HashMap</code>实现，还需要能理解红黑树这种数据结构。</p>
<p>1、根据<code>key</code>的<code>hashCode</code>来决定应该将该记录放在哪个桶里面，无论是插入、查找还是删除，这都是第一步，计算桶的位置。因为<code>HashMap</code>的<code>length</code>总是<code>2的n</code>次幂，所以可以使用下面的方法来做模运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h &amp; (length-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code>h</code>是<code>key</code>的<code>hashCode</code>值，计算好<code>hashCode</code>之后，使用上面的方法来对桶的数量取模，将这个数据记录落到某一个桶里面。当然取模是<code>Java7</code>中的做法，<code>Java7</code>进行了优化，做得更加巧妙，因为我们的<code>length</code>总是<code>2的n</code>次幂，所以在一次<code>resize</code>之后，当前位置的记录要么保持当前位置不变，要么就向前移动<code>length</code>就可以了。所以<code>Java7</code>中的<code>HashMap</code>的<code>resize</code>不需要重新计算<code>hashCode</code>。我们可以通过观察java7中的计算方法来抽象出算法，然后进行优化，具体的细节看代码就可以了。</p>
<p>2、<code>HashMap</code>的<code>put</code>方法</p>
<p><img src="http://static.cyblogs.com/WX20200117-160735@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200117-160735@2x.png"></p>
<p>上图展示了<code>Java7</code>中<code>put</code>方法的处理逻辑，比<code>Java7</code>多了红黑树部分，以及在一些细节上的优化，<code>put</code>逻辑和<code>Java7</code>中是一致的。</p>
<p>3、<code>resize</code>机制</p>
<p>HashMap的扩容机制就是重新申请一个容量是当前的2倍的桶数组，然后将原先的记录逐个重新映射到新的桶里面，然后将原先的桶逐个置为null使得引用失效。后面会讲到，HashMap之所以线程不安全，就是resize这里出的问题。</p>
<h5 id="为什么HashMap线程不安全？"><a href="#为什么HashMap线程不安全？" class="headerlink" title="为什么HashMap线程不安全？"></a>为什么HashMap线程不安全？</h5><p>上面说到，<code>HashMap</code>会进行<code>resize</code>操作，在<code>resize</code>操作的时候会造成线程不安全。下面将举两个可能出现线程不安全的地方。</p>
<p><strong>1、put的时候导致的多线程数据不一致。</strong><br> 这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个<code>key-value</code>对到<code>HashMap</code>中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p>
<p><strong>2、另外一个比较明显的线程不安全的问题是HashMap的get操作可能因为resize而引起死循环（cpu100%），具体分析如下：</strong></p>
<p>下面的代码是resize的核心内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;  </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;  </span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;           </span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;  </span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);   </span><br><span class="line">            e.next = newTable[i];  </span><br><span class="line">            newTable[i] = e;  </span><br><span class="line">            e = next;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这个方法的功能是将原来的记录重新计算在新桶的位置，然后迁移过去。</p>
<p><img src="http://static.cyblogs.com/WX20200117-160831@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200117-160831@2x.png"></p>
<p><strong>多线程HashMap的resize</strong>：我们假设有两个线程同时需要执行resize操作，我们原来的桶数量为2，记录数为3，需要resize桶到4，原来的记录分别为：<code>[3,A]</code>，<code>[7,B]</code>，<code>[5,C]</code>，在原来的map里面，我们发现这三个entry都落到了第二个桶里面。<br> 假设线程thread1执行到了<code>transfer</code>方法的<code>Entry next = e.next</code>这一句，然后时间片用完了，此时的<code>e = [3,A]</code>, <code>next = [7,B]</code>。线程<code>thread2</code>被调度执行并且顺利完成了<code>resize</code>操作，需要注意的是，此时的<code>[7,B]</code>的<code>next</code>为<code>[3,A]</code>。此时线程<code>thread1</code>重新被调度运行，此时的<code>thread1</code>持有的引用是已经被<code>thread2 resize</code>之后的结果。线程thread1首先将[3,A]迁移到新的数组上，然后再处理<code>[7,B]</code>，而<code>[7,B]</code>被链接到了<code>[3,A]</code>的后面，处理完<code>[7,B]</code>之后，就需要处理<code>[7,B]</code>的<code>next</code>了啊，而通过<code>thread2</code>的<code>resize</code>之后，<code>[7,B]</code>的<code>next</code>变为了<code>[3,A]</code>，此时，<code>[3,A]</code>和<code>[7,B]</code>形成了环形链表，在<code>get</code>的时候，如果<code>get</code>的<code>key</code>的桶索引和<code>[3,A]</code>和<code>[7,B]</code>一样，那么就会陷入死循环。</p>
<p>如果在取链表的时候从头开始取（现在是从尾部开始取）的话，则可以保证节点之间的顺序，那样就不存在这样的问题了。</p>
<p>综合上面两点，可以说明<code>HashMap</code>是线程不安全的。</p>
<h5 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h5><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1e9cf0ac07f4">https://www.jianshu.com/p/1e9cf0ac07f4</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e2f75c8cce01">https://www.jianshu.com/p/e2f75c8cce01</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/08/2020/02/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/08/2020/02/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F/" class="post-title-link" itemprop="url">什么是Java内存模型？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-08 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-08T00:00:00+08:00">2020-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>要想深入了解Java并发编程，就要先理解好<strong>Java内存模型</strong>，而要理解Java内存模型又不得不从硬件、计算机内存模型说起，本文从计算机内存模型产生的原因、解决的问题谈起，然后再对Java模型进行介绍，最后对计算机内存模型和Java内存模型进行总结，希望大家看完本文之后有所收获！</p>
<h4 id="CPU工作过程及出现的问题"><a href="#CPU工作过程及出现的问题" class="headerlink" title="CPU工作过程及出现的问题"></a>CPU工作过程及出现的问题</h4><h5 id="CPU执行过程"><a href="#CPU执行过程" class="headerlink" title="CPU执行过程"></a>CPU执行过程</h5><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道，而计算机上面的临时数据，是储存在<strong>主存</strong>中的。</p>
<blockquote>
<p>计算机内存包括<strong>高速缓存</strong>和<strong>主存</strong>。</p>
</blockquote>
<p>我们知道CPU执行指令的速度比从主存读取数据和向主存写入数据快很多，所以为了高效利用CPU，CPU增加了**高速缓存(cache)**来匹配CPU的执行速度，最终程序的执行过程如下</p>
<ol>
<li>首先会将数据从主存中复制一份到CPU的高速缓存中</li>
<li>当CPU执行计算的时候就可以直接从高速缓存中读取数据和写入数据</li>
<li>当运算结束后，再将高速缓存的数据更新到主存中</li>
</ol>
<h5 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h5><p>上面的执行过程在单线程情况下并没有问题，但是在多线程情况下就会出现问题，<strong>因为CPU如果含有多个核心，则每个核心都有自己独占高速缓存</strong>，如果出现多个线程同时执行同一个操作，那么结果是无法预知。例如<code>2</code>个线程同时执行<code>i++</code>，假设i的初始值是<code>0</code>，那么我们希望<code>2</code>个线程执行完成之后<code>i</code>的值变为<code>2</code>，但是事实会是这样吗？<br><img src="http://static.cyblogs.com/WX20200212-224624@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200212-224624@2x.png"></p>
<p>可能出现的情况有：</p>
<ol>
<li>线程1先将<code>i=0</code>从主存中读取到线程1的高速缓存中，然后CPU完成运算，再将<code>i=1</code>写入到主存中，然后线程2开始从主存中读取<code>i=1</code>到线程2的高速缓存中，然后CPU完成运算，再将<code>i=2</code>写入到主存中，那么<code>i=2</code>即为我们想要的结果。</li>
<li>线程1将<code>i=0</code>从主存中读取到线程1的高速缓存中的同时线程2也从主存中读取<code>i=0</code>到线程2的高速缓存中，然后线程1和线程2完成运算后，也都将<code>i=1</code>写入到主存中，那么结果<code>i=1</code>，结果就不是我们想要的了。出现这个情况，我们称为<strong>缓存不一致问题</strong>。</li>
</ol>
<p>那么如何解决CPU出现的<strong>缓存不一致问题</strong>呢？通常使用的解决方法有2种：</p>
<ol>
<li>通过给总线加锁</li>
<li>使用<strong>缓存一致性协议</strong></li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200212-224440@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200212-224440@2x.png"></p>
<p>第<code>1</code>种方法虽然也达到了目的，但是在总线被锁住的期间，其他的CPU也无法访问主存，<strong>效率很低</strong>，所以就出现了缓存一致性协议即第<code>2</code>种方法，其中最出名的就是<code>Intel</code>的MESI协议，MESI协议保证每个CPU高速缓存中的变量都是一致的。它的核心思想是，当CPU写数据时候，如果发现操作的变量是共享变量(即其他CPU上也存在该变量)，就会发出信号通知<strong>其他CPU</strong>将它高速缓存中缓存这个变量的缓存行置为<strong>无效状态</strong>，因此当其他CPU需要读取这个变量时，发现自己高速缓存中缓存该变量的缓存行为无效状态，那么它就会从主存中<strong>重新读取</strong>。<br><img src="http://static.cyblogs.com/WX20200212-224337@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200212-224337@2x.png"></p>
<h5 id="处理器重排序问题"><a href="#处理器重排序问题" class="headerlink" title="处理器重排序问题"></a>处理器重排序问题</h5><p>在多线程场景下，CPU除了会出现缓存一致性问题，还会出现因为<strong>处理器重排序</strong>即<strong>处理器(CPU)为了提高效率可能会对输入的代码进行乱序执行</strong>，而造成多线程的情况下出现问题。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="literal">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>线程1由于处理器重排序，先执行性了语句2，那么此时线程2会认为<code>context</code>已经初始化完成，那么跳出循环，去执行<code>doSomethingwithconfig(context)</code>方法，实际上此时context并未初始化(即线程1的语句1还未执行)，而导致程序出错。</p>
<h4 id="什么是计算机内存模型"><a href="#什么是计算机内存模型" class="headerlink" title="什么是计算机内存模型"></a>什么是计算机内存模型</h4><p>上面提到的<strong>缓存一致性问题</strong>、<strong>处理器重排序问题</strong>都是在多线程情况下CPU可能出现的问题，那我们应该怎么处理这些问题？实际上这些问题并不需要我们考虑，这些问题CPU都会处理好，而CPU处理这些问题的时候是按照特定的<strong>操作规范</strong>，对特定的主存进行访问或告诉CPU高速缓存怎么访问主存，保证了多线程场景下的<strong>原子性、可见性、有序性</strong>，这个操作规范就称为<strong>计算机内存模型</strong>。</p>
<blockquote>
<p>可见性即当一个变量修改后，这个变量会马上更新到主存中，其他线程会收到通知这个变量修改过了，使用这个变量的时候重新去主存获取</p>
</blockquote>
<h4 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h4><p>从前面的介绍了解到计算机内存模型是一种解决多线程场景下的一个主存操作规范，既然是规范，那么不同的编程语言都可以遵循这种操作规范，在多线程场景下访问主存保证原子性、可见性、有序性。<br><strong>Java内存模型(Java Memory Model，JMM)<strong>即是Java语言对这个操作规范的遵循，<code>JMM</code>规定了所有的变量都存储在</strong>主存</strong>中，每个线程都有自己的<strong>工作区</strong>，线程将使用到的变量从主存中<strong>复制</strong>一份到自己的工作区，线程对变量的<strong>所有操作</strong>(读取、赋值等)都必须在工作区，不同的线程也无法直接访问对方工作区，线程之间的消息传递都需要通过主存来完成。<strong>可以把这里主存类比成计算机内存模型中的主存，工作区类比成计算机内存模型中的高速缓存</strong>。</p>
<p><img src="http://static.cyblogs.com/WX20200212-224252@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200212-224252@2x.png"></p>
<p>而我们知道<code>JMM</code>其实是工作主存中的，Java内存模型中的工作区也是主存中的一部分，所以可以这样说Java内存模型解决的是<strong>内存一致性问题(主存和主存)<strong>而计算机内存模型解决的是</strong>缓存一致性问题(CPU高速缓存和主存)</strong>，这两个模型类似，但是作用域不一样，Java内存模型保证的是主存和主存之间的原子性、可见性、有序性，而计算机内存模型保证的是CPU高速缓存和主存之间的原子性、可见性、有序性。</p>
<p><img src="http://static.cyblogs.com/WX20200212-224147@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200212-224147@2x.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文很多观点都是按照笔者自己的理解然后总结出来的，若有偏颇，欢迎指正！</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a target="_blank" rel="noopener" href="https://ddnd.cn/2019/03/11/java-memory-model/">https://ddnd.cn/2019/03/11/java-memory-model/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/07/2020/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%9A%84CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/07/2020/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%9A%84CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">深入理解Linux的CPU上下文切换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-07T00:00:00+08:00">2020-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="如何理解Linux的上下文切换"><a href="#如何理解Linux的上下文切换" class="headerlink" title="如何理解Linux的上下文切换"></a>如何理解Linux的上下文切换</h4><ul>
<li><code>Linux</code> 是一个多任务操作系统，它支持同时运行的任务数量远大于 <code>CPU</code> 个数。其实这些任务没有真正的同时运行，是因为系统在很短的时间内，将 <code>CPU</code> 轮流分配给它们，造成多任务同时运行的错觉。</li>
<li>而在每个任务运行前，<code>CPU</code> 都需要知道任务从哪里加载、从哪里开始运行，需要系统事先设置好 <code>CPU 寄存器</code>和<code>程序计数器</code>。<code>CPU</code> 寄存器是 <code>CPU</code> 内置的容量小、速度极快的内存。而程序计数器则是用来存储 <code>CPU</code> 正在执行的指令位置、或即将执行的下一条指令位置。它们都是 <code>CPU</code> 在运行任务前必须依赖的环境，也被叫做 <code>CPU 上下文</code>。</li>
<li><code>上下文切换</code>，就是先把前一个任务的 <code>CPU</code> 上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳到程序计数器所指的新位置，运行新任务。而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</li>
</ul>
<p>根据任务的不同，<code>CPU</code> 的上下文切换可以分为几个不同的场景，也就是：进程上下文切换、线程上下文切换、中断上下文切换。</p>
<h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p><strong>1、用户空间与内核空间</strong></p>
<p><code>Linux</code> 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着 CPU 特权等级的 <code>Ring 0</code> 和 <code>Ring 3</code>。</p>
<ul>
<li>内核空间(<code>Ring 0</code>)具有最高权限，可以直接访问所有资源。</li>
<li>用户空间(<code>Ring 3</code>)只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入内核中才能访问这些特权资源。</li>
<li>进程既可以在用户空间运行，又可以在内核空间运行。在用户空间运行时被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</li>
</ul>
<p><strong>2、系统调用</strong></p>
<p>从用户态到内核态的转变，需要通过<code>系统调用</code>来完成。比如查看文件时，需要执行多次系统调用：open、read、write、close等。系统调用的过程如下：</p>
<ul>
<li>首先，把 CPU 寄存器里原来用户态的指令位置保存起来</li>
<li>为了执行内核代码，CPU 寄存器需要更新为内核态指令的新位置，最后跳转到内核态运行内核任务。</li>
<li>系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</li>
<li>所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。</li>
</ul>
<p>但系统调用的过程中并不会涉及虚拟内存等进程用户态的资源，也不会切换进程，这和平时说的进程上下文切换是不一样的：</p>
<ul>
<li>进程上下文切换，是指从一个进程切换到另一个进程运行</li>
<li>系统调用过程中一直是同一个进程在运行</li>
</ul>
<p>因此，系统调用的过程通常称为特权模式切换，而不是上下文切换。</p>
<p><strong>3、进程上下文切换</strong></p>
<p>进程是由内核来管理和调度的，进程的切换只能发生在内核态，因此进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p>
<p>因此进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需先把该进程的<code>虚拟内存、栈等保存</code>下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p>
<p>保存上下文和恢复上下文的过程并不是<code>免费</code>的，需要内核在 CPU 上运行才能完成。据测试，每次上下文切换都需要几十纳秒到数微妙的 <code>CPU</code> 时间。特别是在进程上下文切换次数较多的情况下，很容易导致 <code>CPU</code> 将大量时间消耗在寄存器、内核栈、虚拟内存等资源的保存和恢复上，从而大大缩短了真正运行进程的时间。</p>
<p><code>Linux</code> 通过 <code>TLB</code> 来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，<code>TLB</code> 也需要刷新，内存的访问也会随之变慢。特别是多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其它处理器的进程。</p>
<p><strong>4、进程上下文何时切换</strong></p>
<p><code>Linux</code> 为每个 <code>CPU</code> 维护了一个就绪队列，将活跃进程按照优先级和等待 <code>CPU</code> 的时间排序，然后选择最需要 <code>CPU</code> 的进程，也就是优先级最高和等待 <code>CPU</code> 时间最长的进程来运行。那么，进程在什么时候才会被调度到 <code>CPU</code> 上运行呢？</p>
<ul>
<li>进程执行完终止了，它之前使用的 <code>CPU</code> 会释放出来，这时再从就绪队列中拿一个新的进程来运行</li>
<li>为了保证所有进程可以得到公平调度，<code>CPU</code> 时间被划分为一段段的时间片，这些时间片被轮流分配给各个进程。当某个进程时间片耗尽了就会被系统挂起，切换到其它等待 <code>CPU</code> 的进程运行。</li>
<li>进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行。</li>
<li>当进程通过睡眠函数 <code>sleep</code> 主动挂起时，也会重新调度。</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li>
<li>发生硬件中断时，<code>CPU</code> 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li>
</ul>
<h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><p>线程与进程最大的区别在于，线程是操作系统调度的最小单位，而进程是操作系统分配资源的最小单位。所谓内核调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。对于线程和进程我们可以这么理解：</p>
<ul>
<li>当进程只有一个线程时，可以认为进程就等于线程</li>
<li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li>
<li>另外线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也时需要保存的。</li>
</ul>
<p>其实线程的上下文切换可以分为两种情况：</p>
<ul>
<li>前后两个线程属于不同进程。此时因为资源不共享，所以切换过程就跟进程上下文切换是一样的。</li>
<li>前后两个线程属于同一个进程。此时虚拟内存是共享的，上下文切换时，虚拟内存这些资源保持不动，只需要切换线程的私有数、寄存器等不共享的数据。</li>
</ul>
<p>可以发现同进程内的线程切换，要比多进程间的切换消耗更少的资源，这也正是多线程代替多进程的一个优势。</p>
<h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其它进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p>
<ul>
<li>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以即便中断过程打断了一个正在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文其实只包括内核态中断服务程序执行所必需的状态，包括 <code>CPU</code> 寄存器、内核堆栈、硬件中断参数等。</li>
<li>对同一个 <code>CPU</code> 来说，中断处理比进程拥有更高的优先级，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</li>
<li>跟进程上下文切换一样，中断上下文切换也需要消耗 <code>CPU</code>，当发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</li>
</ul>
<h4 id="概念小结"><a href="#概念小结" class="headerlink" title="概念小结"></a>概念小结</h4><p>总结一下，不管是哪种场景导致的上下文切换，你都应该知道：</p>
<ul>
<li><code>CPU</code> 上下文切换是保证 <code>Linux</code> 系统正常工作的核心功能之一，一般情况下我们无需特别关注。</li>
<li>过多的上下文切换，会把 <code>CPU</code> 时间消耗在寄存器、内核栈、虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。</li>
</ul>
<h4 id="如何查看系统的上下文切换"><a href="#如何查看系统的上下文切换" class="headerlink" title="如何查看系统的上下文切换"></a>如何查看系统的上下文切换</h4><p>我们可以通过 <code>vmstat</code> 工具来查看系统的上下文切换情况。<code>vmstat</code> 主要用来分析系统内存使用情况，也常用来分析 <code>CPU</code> 上下文切换和中断的次数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔 5 秒输出 1 组数据</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vmstat 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b  swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0    0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0</span><br></pre></td></tr></table></figure>

<p>我们需要重点关注下列四项内容：</p>
<ul>
<li>cs(context switch) 是每秒上下文切换的次数。</li>
<li>in(interrupt) 是每秒中断的次数。</li>
<li>r(Running or Runnable) 是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</li>
<li>b(Blocked) 是处于不可中断睡眠状态的进程数。</li>
</ul>
<p>想要查看每个进程的详细情况，需要使用 pidstat，给它加上 <code>-w</code> 选项，就可以查看每个进程上下文切换的情况。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔 5 秒输出 1 组数据</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pidstat -w 5</span></span><br><span class="line">Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)</span><br><span class="line">08:18:26      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:18:31        0         1      0.20      0.00  systemd</span><br><span class="line">08:18:31        0         8      5.40      0.00  rcu_sched</span><br></pre></td></tr></table></figure>

<p>上述结果有两列是我们重点关注的对象，一个是 cswch，表示每秒自愿上下文切换的次数；另一个是 nvcswch，表示每秒非自愿上下文切换的次数。</p>
<ul>
<li>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如，IO、内存等系统资源不足时，就会发生自愿上下文切换。</li>
<li>非资源上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在抢占 CPU 时，就容易发生非自愿上下文切换。</li>
</ul>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p><strong>准备环境</strong></p>
<p><code>sysbench</code> 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况，本次案例把它当作一个异常进程来看，作用是模拟上下文切换过多的问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预先安装 sysbench</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install sysbench -y</span></span><br></pre></td></tr></table></figure>

<p><strong>操作和分析</strong></p>
<p>首先在第一个终端里运行 <code>sysbench</code>，模拟系统多线程调度的瓶颈：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysbench --threads=10 --max-time=300 threads run</span></span><br></pre></td></tr></table></figure>

<p>接着在第二个终端运行 <code>vmstat</code>，观察上下文切换情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vmstat 1</span></span><br><span class="line">procs --------memory-------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b swpd   free   buff  cache  si so bi bo   in   cs us sy id wa st</span><br><span class="line"> 6  0  0 6487428 118240 1292772    0   0  0  0 9019 1398830 16 84  0  0  0</span><br><span class="line"> 8  0  0 6487428 118240 1292772    0   0  0  0 10191 1392312 16 84  0  0  0</span><br></pre></td></tr></table></figure>

<p>可以发现，cs 列的上下文切换次数从之前的 35 上升到了 139 万，观察其他几个指标：</p>
<ul>
<li>r 列：就绪队列长度为 8，远大于 CPU 个数，所以会有大量的 CPU 竞争</li>
<li>us 和 sys 列：这两列加一起上升到 100%，sys 列高达 84%，说明 CPU 主要是被内核占用了。</li>
<li>in 列：中断次数为 1 万左右，说明中断也是个潜在的问题。</li>
</ul>
<p>综合分析，由于系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。</p>
<p>我们可以使用 pidstat 继续分析到底是哪个进程导致了这些问题？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pidstat -w -u 1</span></span><br><span class="line">08:06:33      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">08:06:34        0     10488   30.00  100.00    0.00    0.00  100.00     0  sysbench</span><br><span class="line">08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2</span><br><span class="line"></span><br><span class="line">08:06:33      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:06:34        0         8     11.00      0.00  rcu_sched</span><br><span class="line">08:06:34        0        16      1.00      0.00  ksoftirqd/1</span><br><span class="line">08:06:34        0       471      1.00      0.00  hv_balloon</span><br><span class="line">08:06:34        0      1230      1.00      0.00  iscsid</span><br><span class="line">08:06:34        0      4089      1.00      0.00  kworker/1:5</span><br><span class="line">08:06:34        0      4333      1.00      0.00  kworker/0:3</span><br><span class="line">08:06:34        0     10499      1.00    224.00  pidstat</span><br><span class="line">08:06:34        0     26326    236.00      0.00  kworker/u4:2</span><br><span class="line">08:06:34     1000     26784    223.00      0.00  sshd</span><br></pre></td></tr></table></figure>

<p>可以发现，<code>CPU</code> 使用率的升高是 <code>sysbench</code> 导致的，但上下文切换则来自其他进程，包括非自愿上下文切换频率最高的 <code>pidstat</code>，以及自愿上下文切换频率最高的内核线程 <code>kworker</code> 和 <code>sshd</code>。</p>
<p>默认 <code>pidstat</code> 显示进程的指标数据，加上 <code>-t</code> 参数后，才会输出线程的指标</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pidstat -wt 1</span></span><br><span class="line">08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">...</span><br><span class="line">08:14:05        0     10551         -      6.00      0.00  sysbench</span><br><span class="line">08:14:05        0         -     10551      6.00      0.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10552  18911.00 103740.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10553  18915.00 100955.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10554  18827.00 103954.00  |__sysbench</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>虽然 <code>sysbench</code> 进程的上下文切换次数不多，但它的子线程的上下文切换次数非常多，可以判定上下文切换罪魁祸首的是 <code>sysbench</code> 进程。还没完，记得我们通过 <code>vmstat</code> 看到的中断次数到了 1 万，到底是什么类型的中断上升了呢？</p>
<p>我们可以通过 <code>/proc/interrupts</code> 来读取中断的使用情况，通过运行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 参数表示高亮显示变化的区域</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">watch -d <span class="built_in">cat</span> /proc/interrupts</span></span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line">RES:    2450431    5279697   Rescheduling interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以发现，变化速度最快的是<code>重调度中断(RES)</code>，表示唤醒空闲状态的 <code>CPU</code> 来调度新的任务运行。这是多处理器系统(SMP)中，调度器用来分散任务队列到不同 <code>CPU</code> 的机制，通常也被称为<code>处理器间中断</code>。根本原因还是因为过多任务的调度问题，跟前边分析结果是一致的。</p>
<h4 id="每秒上下文切换多少次算正常"><a href="#每秒上下文切换多少次算正常" class="headerlink" title="每秒上下文切换多少次算正常"></a>每秒上下文切换多少次算正常</h4><p>这个数值其实取决于系统本身的 <code>CPU</code> 性能。如果系统的上下文切换次数比较稳定，从数百到一万以内，都应该算是正常的。如果当上下文切换次数超过一万次，或者切换次数出现数量级增长时，很可能已经出现了性能问题。</p>
<p>这时，你还需要根据上下文切换的类型，再做具体分析，比方说：</p>
<ul>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 <code>IO</code> 等其他问题</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 <code>CPU</code>，说明 <code>CPU</code> 的确成了瓶颈。</li>
<li>中断次数变多了，说明 <code>CPU</code> 被中断处理程序占用，还需要通过查看 <code>/proc/interrupts</code> 文件来分析具体的中断类型。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.linuxblogs.cn/articles/18120200.html">https://www.linuxblogs.cn/articles/18120200.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/79772089">https://zhuanlan.zhihu.com/p/79772089</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/02/06/2020/02/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90synchronized%E5%8E%9F%E7%90%86%E5%92%8C%E9%94%81%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/06/2020/02/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90synchronized%E5%8E%9F%E7%90%86%E5%92%8C%E9%94%81%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">深入分析synchronized原理和锁膨胀过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-06 00:00:00" itemprop="dateCreated datePublished" datetime="2020-02-06T00:00:00+08:00">2020-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>上一篇文章介绍了多线程的概念及<code>synchronized</code>的使用方法<a target="_blank" rel="noopener" href="https://ddnd.cn/2019/03/21/java-synchronized/">《synchronized的使用（一）》</a>，但是仅仅会用还是不够的，只有了解其底层实现才能在开发过程中运筹帷幄，所以本篇探讨<code>synchronized</code>的实现原理及锁升级(膨胀)的过程。</p>
<h4 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h4><p><code>synchronized</code>是依赖于<code>JVM</code>来实现同步的，在同步方法和代码块的原理有点区别。</p>
<h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><p>我们在代码块加上<code>synchronized</code>关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synSay</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synSay----&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synSay</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field object:Ljava/lang/String;</span></span><br><span class="line">       <span class="number">4</span>: dup</span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: monitorenter</span><br><span class="line">       <span class="number">7</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">10</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">      <span class="number">13</span>: dup</span><br><span class="line">      <span class="number">14</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">17</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String synSay----</span></span><br><span class="line">      <span class="number">19</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">22</span>: invokestatic  #<span class="number">8</span>                  <span class="comment">// Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span></span><br><span class="line">      <span class="number">25</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/Thread.getName:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">28</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">31</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">34</span>: invokevirtual #<span class="number">11</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">37</span>: aload_1</span><br><span class="line">      <span class="number">38</span>: monitorexit</span><br><span class="line">      <span class="number">39</span>: <span class="keyword">goto</span>          <span class="number">47</span></span><br><span class="line">      <span class="number">42</span>: astore_2</span><br><span class="line">      <span class="number">43</span>: aload_1</span><br><span class="line">      <span class="number">44</span>: monitorexit</span><br><span class="line">      <span class="number">45</span>: aload_2</span><br><span class="line">      <span class="number">46</span>: athrow</span><br><span class="line">      <span class="number">47</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">7</span>    <span class="number">39</span>    <span class="number">42</span>   any</span><br><span class="line">          <span class="number">42</span>    <span class="number">45</span>    <span class="number">42</span>   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">22</span>: <span class="number">7</span></span><br><span class="line">      line <span class="number">23</span>: <span class="number">37</span></span><br><span class="line">      line <span class="number">24</span>: <span class="number">47</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">48</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcn/T1;</span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">      frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">        offset_delta = <span class="number">42</span></span><br><span class="line">        locals = [ <span class="keyword">class</span> <span class="title class_">cn</span>/T1, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object ]</span><br><span class="line">        stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Throwable ]</span><br><span class="line">      frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">        offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>可以发现<code>synchronized</code>同步代码块是通过加<code>monitorenter</code>和<code>monitorexit</code>指令实现的。<br> 每个对象都有个**监视器锁(monitor) **，当<code>monitor</code>被占用的时候就代表对象处于锁定状态，而<code>monitorenter</code>指令的作用就是获取<code>monitor</code>的所有权，<code>monitorexit</code>的作用是释放<code>monitor</code>的所有权，这两者的工作流程如下：<br> <strong>monitorenter</strong>：</p>
<ol>
<li>如果<code>monitor</code>的进入数为0，则线程进入到<code>monitor</code>，然后将进入数设置为<code>1</code>，该线程称为<code>monitor</code>的所有者。</li>
<li>如果是线程已经拥有此<code>monitor</code>(即<code>monitor</code>进入数不为0)，然后该线程又重新进入<code>monitor</code>，则将<code>monitor</code>的进入数<code>+1</code>，这个即为<strong>锁的重入</strong>。</li>
<li>如果其他线程已经占用了<code>monitor</code>，则该线程进入到<strong>阻塞状态，知道<code>monitor</code>的进入数为0，该线程再去重新尝试获取<code>monitor</code>的所有权</strong>。</li>
</ol>
<p><strong>monitorexit</strong>：执行该指令的线程必须是<code>monitor</code>的所有者，指令执行时，<code>monitor</code>进入数<code>-1</code>，如果<code>-1</code>后进入数为<code>0</code>，那么线程退出<code>monitor</code>，不再是这个<code>monitor</code>的所有者。这个时候其它阻塞的线程可以尝试获取<code>monitor</code>的所有权。</p>
<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>在方法上加上<code>synchronized</code>关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synSay</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;synSay----&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">synSay</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">       <span class="number">6</span>: dup</span><br><span class="line">       <span class="number">7</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      <span class="number">10</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String synSay----</span></span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">15</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span></span><br><span class="line">      <span class="number">18</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/Thread.getName:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">21</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      <span class="number">24</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      <span class="number">27</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">21</span>: <span class="number">30</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcn/T1;</span><br></pre></td></tr></table></figure>

<p>从字节码上看，加有<code>synchronized</code>关键字的方法，常量池中比普通的方法多了个<code>ACC_SYNCHRONIZED</code>标识，<code>JVM</code>就是根据这个标识来实现方法的同步。<br> 当调用方法的时候，调用指令会检查方法是否有<code>ACC_SYNCHRONIZED</code>标识，有的话<strong>线程需要先获取<code>monitor</code>，获取成功才能继续执行方法，方法执行完毕之后，线程再释放<code>monitor</code>，同一个<code>monitor</code>同一时刻只能被一个线程拥有。</strong></p>
<h5 id="两种同步方式区别"><a href="#两种同步方式区别" class="headerlink" title="两种同步方式区别"></a>两种同步方式区别</h5><p><code>synchronized</code>同步代码块的时候通过加入字节码<code>monitorenter</code>和<code>monitorexit</code>指令来实现<code>monitor</code>的获取和释放，也就是需要<strong>JVM通过字节码显式的去获取和释放monitor实现同步</strong>，而synchronized同步方法的时候，没有使用这两个指令，而是检查方法的<code>ACC_SYNCHRONIZED</code>标志是否被设置，如果设置了则线程需要先去获取monitor，执行完毕了线程再释放monitor，也就是不需要JVM去显式的实现。<br> <strong>这两个同步方式实际都是通过获取monitor和释放monitor来实现同步的，而monitor的实现依赖于底层操作系统的<code>mutex</code>互斥原语，而操作系统实现线程之间的切换的时候需要从用户态转到内核态，这个转成过程开销比较大。</strong><br> 线程获取、释放<code>monitor</code>的过程如下：</p>
<p><img src="http://static.cyblogs.com/WX20200201-131434@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-131434@2x.png"></p>
<p>线程尝试获取<code>monitor</code>的所有权，如果获取失败说明<code>monitor</code>被其他线程占用，则将线程加入到的<strong>同步队列</strong>中，等待其他线程释放<code>monitor</code>，<strong>当其他线程释放<code>monitor</code>后，有可能刚好有线程来获取<code>monitor</code>的所有权，那么系统会将<code>monitor</code>的所有权给这个线程，而不会去唤醒同步队列的第一个节点去获取，所以<code>synchronized</code>是非公平锁</strong>。如果线程获取<code>monitor</code>成功则进入到<code>monitor</code>中，并且将其进入数<code>+1</code>。</p>
<blockquote>
<p>关于什么是公平锁、非公平锁可以参考一下美团技术团队写的<a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">《不可不说的Java“锁”事》</a></p>
</blockquote>
<p>到这里我们也清楚了<code>synchronized</code>的语义底层是通过一个<code>monitor</code>的对象完成，其实<code>wait</code>、<code>notiyf</code>和<code>notifyAll</code>等方法也是依赖于<code>monitor</code>对象来完成的，<strong>这也就是为什么需要在同步方法或者同步代码块中调用的原因(需要先获取对象的锁，才能执行)，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常</strong></p>
<h4 id="Java对象的组成"><a href="#Java对象的组成" class="headerlink" title="Java对象的组成"></a>Java对象的组成</h4><p>我们知道了线程要访问同步方法、代码块的时候，首先需要取得锁，在退出或者抛出异常的时候又必须释放锁，那么锁到底是什么？又储存在哪里？<br> 为了解开这个疑问，我们需要进入<strong>Java虚拟机(JVM)</strong> 的世界。在<code>HotSpot</code>虚拟机中，<code>Java</code>对象在内存中储存的布局可以分为<code>3</code>块区域：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。<strong>synchronized使用的锁对象储存在对象头中</strong></p>
<p><img src="http://static.cyblogs.com/WX20200201-131531@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-131531@2x.png"></p>
<p><img src="http://static.cyblogs.com/WX20200201-131609@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-131609@2x.png"></p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>对象头的数据长度在<code>32</code>位和<code>64</code>位(未开启压缩指针)的虚拟机中分别为<code>32bit</code>和<code>64bit</code>。对象头由以下三个部分组成：</p>
<ul>
<li>Mark Word：记录了对象和锁的有关信息，储存对象自身的运行时数据，如哈希码(HashCode)、<code>GC</code>分代年龄、锁标志位、线程持有的锁、偏向线程<code>ID</code>、偏向时间戳、对象分代年龄等。<strong>注意这个Mark Word结构并不是固定的，它会随着锁状态标志的变化而变化，而且里面的数据也会随着锁状态标志的变化而变化，这样做的目的是为了节省空间</strong>。</li>
<li>类型指针：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>数组长度：这个属性只有数组对象才有，储存着数组对象的长度。</li>
</ul>
<p>在<code>32</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>5</code>种中的一种。</p>
<p><img src="http://static.cyblogs.com/WX20200201-131652@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-131652@2x.png"></p>
<p>在<code>64</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>2</code>种中的一种。</p>
<p><img src="http://static.cyblogs.com/WX20200201-131726@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-131726@2x.png"></p>
<p>这里重点注意<strong>是否偏向锁</strong>和<strong>锁标志位</strong>，这两个标识和<code>synchronized</code>的锁膨胀息息相关。</p>
<h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><p>储存着对象的实际数据，也就是我们在程序中定义的各种类型的字段内容。</p>
<h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><p><code>HotSpot</code>虚拟机的对齐方式为<code>8</code>字节对齐，即一个对象必须为<code>8</code>字节的整数倍，如果不是，则通过这个对齐填充来占位填充。</p>
<h4 id="synchronized锁膨胀过程"><a href="#synchronized锁膨胀过程" class="headerlink" title="synchronized锁膨胀过程"></a>synchronized锁膨胀过程</h4><p>上文介绍的 “<code>synchronized</code>实现原理” 实际是synchronized实现<strong>重量级锁的原理</strong>，那么上文频繁提到<code>monitor</code>对象和对象又存在什么关系呢，或者说<code>monitor</code>对象储存在对象的哪个地方呢？<br> <strong>在对象的对象头中，当锁的状态为重量级锁的时候，它的指针即指向<code>monitor</code>对象</strong>，如图：</p>
<p><img src="http://static.cyblogs.com/WX20200201-131856@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-131856@2x.png"></p>
<p><img src="http://static.cyblogs.com/WX20200201-131932@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-131932@2x.png"></p>
<p>那锁的状态为其它状态的时候是不是就没用上<code>monitor</code>对象？答案:是的。<br> 这也是<code>JVM</code>对<code>synchronized</code>的优化，我们知道重量级锁的实现是基于底层操作系统的<code>mutex</code>互斥原语的，这个开销是很大的。所以<code>JVM</code>对<code>synchronized</code>做了优化，<code>JVM</code>先利用对象头实现锁的功能，如果线程的竞争过大则会将锁升级(膨胀)为重量级锁，也就是使用<code>monitor</code>对象。当然<code>JVM</code>对锁的优化不仅仅只有这个，还有引入适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等。</p>
<p>那么锁的是怎么进行膨胀的或者依据什么来膨胀，这也就是本篇需要介绍的重点，首先我们需要了解几个概念。</p>
<h5 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h5><h5 id="自旋锁和自适应性自旋锁"><a href="#自旋锁和自适应性自旋锁" class="headerlink" title="自旋锁和自适应性自旋锁"></a>自旋锁和自适应性自旋锁</h5><p><strong>自旋</strong>：当有个线程<code>A</code>去请求某个锁的时候，这个锁正在被其它线程占用，但是线程<code>A</code>并不会马上进入阻塞状态，而是循环请求锁(自旋)。这样做的目的是因为很多时候持有锁的线程会很快释放锁的，线程<code>A</code>可以尝试一直请求锁，没必要被挂起放弃<code>CPU</code>时间片，因为线程被挂起然后到唤醒这个过程开销很大,当然如果线程<code>A</code>自旋指定的时间还没有获得锁，仍然会被挂起。</p>
<p><strong>自适应性自旋</strong>：自适应性自旋是自旋的升级、优化，自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。例如<strong>线程如果自旋成功了，那么下次自旋的次数会增多</strong>，因为<code>JVM</code>认为既然上次成功了，那么这次自旋也很有可能成功，那么它会允许自旋的次数更多。反之，如果<strong>对于某个锁，自旋很少成功</strong>，那么在以后获取这个锁的时候，自旋的次数会变少甚至忽略，避免浪费处理器资源。有了自适应性自旋，随着程序运行和性能监控信息的不断完善，<code>JVM</code>对程序锁的状况预测就会变得越来越准确，<code>JVM</code>也就变得越来越聪明。</p>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指虚拟机即时编译器在运行时，<strong>对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</strong>。</p>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>在使用锁的时候，需要让同步块的作用范围尽可能小，这样做的目的是<strong>为了使需要同步的操作数量尽可能小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁</strong>。</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>所谓<strong>轻量级锁</strong>是相对于使用底层操作系统<code>mutex</code>互斥原语实现同步的<strong>重量级锁</strong>而言的，因为轻量级锁同步的<strong>实现是基于对象头的Mark Word</strong>。那么轻量级锁是怎么使用对象头来实现同步的呢，我们看看具体实现过程。</p>
<p><strong>获取锁过程</strong>：</p>
<ol>
<li>在线程进入同步方法、同步块的时候，如果<strong>同步对象锁状态为无锁状态(锁标志位为”01”状态，是否为偏向锁为”0”)</strong>，虚拟机首先将在当前线程的栈帧中<strong>建立一个名为锁记录(Lock Recored)的空间</strong>，用于储存锁对象目前的Mark Word的拷贝(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)。</li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200201-132045@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-132045@2x.png"></p>
<ol>
<li>将对象头的<code>Mark Word</code>拷贝到线程的锁记录(Lock Recored)中。</li>
<li>拷贝成功后，虚拟机将使用<code>CAS</code>操作<strong>尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针</strong>。如果这个更新成功了，则执行步骤<code>4</code>，否则执行步骤<code>5</code>。</li>
<li>更新成功，这个<strong>线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为”00”，即表示此对象处于轻量级锁的状态。</strong>。</li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200201-132119@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-132119@2x.png"></p>
<ol>
<li>更新失败，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其其它线程抢占了。<strong>进行自旋执行步骤<code>3</code>，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为”10”，Mark Word中储存就是指向<code>monitor</code>对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</strong></li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200201-132152@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-132152@2x.png"></p>
<p><strong>释放锁的过程</strong>：</p>
<ol>
<li>使用<code>CAS</code>操作将对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来(依据<code>Mark Word</code>中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤<code>2</code>，否则执行步骤<code>3</code>。</li>
<li>如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。</li>
<li>如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。</li>
</ol>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的目的是消除数据在无竞争情况下的同步原语，<strong>进一步提高程序的运行性能</strong>。如果说轻量级锁是在无竞争的情况下使用<code>CAS</code>操作区消除同步使用的互斥量，那么偏向锁就是在无竞争的情况下把整个同步都消除掉，连<code>CAS</code>操作都不用做了。<strong>偏向锁默认是开启的，也可以关闭</strong>。<br> 偏向锁”偏”，就是”偏心”的”偏”，它的意思是这个锁会偏向于第一个获得它的程序，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p><strong>获取锁的过程</strong>：</p>
<ol>
<li>检查<code>Mark Word</code>是否为<strong>可偏向锁的状态</strong>，即是否偏向锁即为1即表示支持可偏向锁，否则为0表示不支持可偏向锁。</li>
<li>如果是可偏向锁，则<strong>检查<code>Mark Word</code>储存的线程<code>ID</code>是否为当前线程<code>ID</code></strong>，如果是则执行同步块，否则执行步骤<code>3</code>。</li>
<li>如果检查到<code>Mark Word</code>的<code>ID</code>不是本线程的<code>ID</code>，则通过<code>CAS</code>操作去修改线程<code>ID</code>修改成本线程的<code>ID</code>，如果修改成功则执行同步代码块，否则执行步骤<code>4</code>。</li>
<li>当拥有该锁的线程到达安全点之后，挂起这个线程，升级为轻量级锁。</li>
</ol>
<p><strong>锁释放的过程</strong>：</p>
<ol>
<li>有其他线程来获取这个锁，偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。</li>
<li>等待全局安全点(在这个是时间点上没有字节码正在执行)。</li>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为无锁状态，否则设置为被锁定状态。如果锁对象处于<strong>无锁状态，则恢复到无锁状态(01)</strong>，以允许其他线程竞争，如果<strong>锁对象处于锁定状态</strong>，则挂起持有偏向锁的线程，并将对象头<code>Mark Word</code>的锁记录指针改成当前线程的锁记录，锁<strong>升级为轻量级锁状态(00)</strong>。</li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200201-132302@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-132302@2x.png"></p>
<h5 id="锁的转换过程"><a href="#锁的转换过程" class="headerlink" title="锁的转换过程"></a>锁的转换过程</h5><p>锁主要存在<code>4</code>种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争的情况逐渐升级，这几个锁只有重量级锁是需要使用操作系统底层<code>mutex</code>互斥原语来实现，其他的锁都是使用对象头来实现的。<strong>需要注意锁可以升级，但是不可以降级。</strong></p>
<p><img src="http://static.cyblogs.com/WX20200201-132345@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-132345@2x.png"></p>
<p>这里盗个图，这个图总结的挺好的！(图被压缩过了 看不清，可以打开这个地址查看高清图<a target="_blank" rel="noopener" href="http://wx2.sinaimg.cn/large/e0e01e43gy1g1cozajzz3j22zf1e7u0x.jpg">&gt;&gt;高清图&lt;&lt;</a>)</p>
<p><img src="http://static.cyblogs.com/WX20200201-132428@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-132428@2x.png"></p>
<h5 id="三种锁的优缺点比较"><a href="#三种锁的优缺点比较" class="headerlink" title="三种锁的优缺点比较"></a>三种锁的优缺点比较</h5><p><img src="http://static.cyblogs.com/WX20200201-132500@2x.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;WX20200201-132500@2x.png"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liupeifeng3514/article/details/79111565">JVM（三）JVM中对象的内存布局详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhengbin/p/6490953.html">JVM——深入分析对象的内存布局</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b4eec7df265da0fa00a118f#heading-16">啃碎并发（七）：深入分析Synchronized原理</a></li>
<li><a target="_blank" rel="noopener" href="http://bigdatadecode.club/JavaSynchronizedTheory.html">Java Synchronized实现原理</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Vernon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <a target="_blank" href="https://beian.miit.gov.cn">粤ICP备2025433887号</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
