<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.cyblogs.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="简栈文化">
<meta property="og:url" content="http://www.cyblogs.com/page/3/index.html">
<meta property="og:site_name" content="简栈文化">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Vernon">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.cyblogs.com/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>简栈文化</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="简栈文化" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">简栈文化</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java技术人的成长之路~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vernon"
      src="/images/vernonchen.jpg">
  <p class="site-author-name" itemprop="name">Vernon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">149</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chengcheng222e" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chengcheng222e" rel="noopener me" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chengcheng222e@gmail.com" title="E-Mail → mailto:chengcheng222e@gmail.com" rel="noopener me" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/11/12/2020/11/%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%8E%A9Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%91%A2%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/12/2020/11/%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%8E%A9Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%91%A2%EF%BC%9F/" class="post-title-link" itemprop="url">你是如何玩Git分支模型的呢？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-12 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-12T00:00:00+08:00">2020-11-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:58:47" itemprop="dateModified" datetime="2025-06-25T09:58:47+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>总览(一张流程图给大家先镇镇惊)</p>
<p><img src="http://static.cyblogs.com/git%E5%88%86%E6%94%AF%E6%80%BB%E5%9B%BE%E6%A6%82%E8%A7%88.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;git分支总图概览.jpg"></p>
<p>它主要体现了<code>Git</code>对我们源代码版本的管理。</p>
<p>（转载者加）一般情况：</p>
<ul>
<li><code>master</code>和<code>develop</code>并行。 </li>
<li><code>master</code>上始终是最稳定的代码，<code>develop</code>是正在开发的代码。 </li>
<li><code>feature</code>则是某个开发为了自己的功能拉的分支。<br>不一般情况： </li>
<li><code>develop</code>正在开发，如果你上线突然被拒绝了，这时候就要从master上开一个热分支，或者<code>release</code>分支也行，改好之后在分别合并到其他分支。但，本人感觉release通常意味着终止。别在从<code>release</code>上拉分支了。</li>
</ul>
<h4 id="为何是Git？"><a href="#为何是Git？" class="headerlink" title="为何是Git？"></a>为何是Git？</h4><p>​		对于<code>Git</code>与其他集中式代码管理工具相比的优缺点的全面讨论，请参见这里。这样的争论总是喋喋不休。作为一个开发者，与现今的其他开发工具相比较，我更喜欢<code>Git</code>。<code>Git</code>真得改变了开发者对于合并和分支的思考。我曾经使用经典的<code>CVS/Subversion</code>，然而每次的合并&#x2F;分支和其他行为总让人担惊受怕（“小心合并里的冲突，简直要命！”）。<br>但是对于<code>Git</code>来说，这些行为非常简单和搞笑，它们被认为是日常工作中的核心部分。例如，在很多<code>CVS/Subversion</code>书里，分支与合并总是在后面的章节中被讨论（对于高级用户使用），然而在每个<code>Git</code>书中，在第3章就已经完全涵盖了（作为基础）。<br>简单和重复的特性带来的结果是：分支与合并不再是什么可以害怕的东西。分支&#x2F;合并被认为对于版本管理工具比其他功能更重要。<br>关于工具，不再多说，让我们直接看开发模型吧。这个模型并不是如下模型：在管理软件开发进度方面，面对每个开发过程，每个队员必须按一定次序开发。</p>
<h4 id="分布式而非集中式"><a href="#分布式而非集中式" class="headerlink" title="分布式而非集中式"></a>分布式而非集中式</h4><p>​    	对于这种分支模型，我们设置了一个版本库，它运转良好，这是一个”事实上” 版本库。不过请注意，这个版本库只是被认为是中心版本库（因为<code>Git</code>是一个分布式版本管理系统，从技术上来讲，并没有一个中心版本库）。我们将把这个版本库称为原始库，这个名字对所有的Git用户来说都很容易理解。</p>
<p><img src="http://static.cyblogs.com/git%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E4%B8%AD%E5%BC%8F.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;git分布式集中式.jpg"></p>
<p>每个开发者都对<code>origin</code>库拉代码和提交代码。但是除了集中式的存取代码关系，每个开发者也可以从子团队的其他队友那里获得代码版本变更。例如，对于2个或多个开发者一起完成的大版本变更，为了防止过早地向<code>origin</code>库提交工作内容，这种机制就变得非常有用。在上述途中，有如下子团队：<code>Alice</code>和Bob，<code>Alice</code>和<code>David</code>，<code>Clair</code>和<code>David</code>。<br>从技术上将，这意味着，<code>Alice</code>创建了一个<code>Git</code>的远程节点，而对于<code>Bob</code>，该节点指向了<code>Bob</code>的版本库，反之亦然。</p>
<h4 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h4><p><img src="http://static.cyblogs.com/develop%E4%B8%8Emaster%E5%88%86%E6%94%AF%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;develop与master分支的关系.jpg"></p>
<p>在核心部分，研发模型很大程度上靠其他现有模型支撑的。中心库有2个可一直延续的分支： </p>
<ul>
<li>master分支 </li>
<li>develop分支</li>
</ul>
<p>每个<code>Git</code>用户都要熟悉原始的<code>master</code>分支。与master分支并行的另一个分支，我们称之为<code>develop</code>分支。<br>我们把原始库&#x2F;<code>master</code>库认作为主分支，HEAD的源代码存在于此版本中，并且随时都是一个预备生产状态。 </p>
<p>我们把<code>origin/develop</code>库认为是主分支，该分支<code>HEAD</code>源码始终体现下个发布版的最新软件变更。有人称这个为“集成分支”，而这是每晚自动构建得来的。<br>当<code>develop</code>分支的源码到达了一个稳定状态待发布，所有的代码变更需要以某种方式合并到master分支，然后标记一个版本号。如何操作将在稍后详细介绍。<br>所以，每次变更都合并到了<code>master</code>，这就是新产品的定义。在这一点，我们倾向于严格执行这一点，从而，理论上，每当对<code>master</code>有一个提交操作，我们就可以使用<code>Git</code>钩子脚本来自动构建并且发布软件到生产服务器。</p>
<h4 id="辅助性分支"><a href="#辅助性分支" class="headerlink" title="辅助性分支"></a>辅助性分支</h4><p>我们的开发模型使用了各种辅助性分支，这些分支与关键分支（master和develop）一起，用来支持团队成员们并行开发，使得易于追踪功能，协助生产发布环境准备，以及快速修复实时在线问题。与关键分支不同，这些分支总是有一个有限的生命期，因为他们最终会被移除。<br>我们用到的分支类型包括： </p>
<ul>
<li>功能分支 </li>
<li>发布分支 </li>
<li>热修复分支</li>
</ul>
<p>每一种分支有一个特定目的，并且受限于严格到规则，比如：可以用哪些分支作为源分支，哪些分支能作为合并目标。我们马上将进行演练。<br>从技术角度来看，这些分支绝不是特殊分支。分支的类型基于我们使用的方法来进行分类。它们理所当然是普通的Git分支。</p>
<h4 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h4><p><img src="http://static.cyblogs.com/20181126103335995_580-0.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20181126103335995_580-0.jpg"></p>
<p>可能是<code>develop</code>分支的分支版本，最终必须合并到<code>develop</code>分支中。<br>分支命名规则：除了<code>master</code>、<code>develop</code>、<code>release-</code>、<code>hotfix-</code>之外，其他命名均可。<br>功能分支（有时被称为<code>topic</code>分支）通常为即将发布或者未来发布版开发新的功能。当新功能开始研发，包含该功能的发布版本在这个还是无法确定发布时间的。功能版本的实质是只要这个功能处于开发状态它就会存在，但是最终会或合并到<code>develop</code>分支（确定将新功能添加到不久的发布版中）或取消（譬如一次令人失望的测试）。<br>功能分支通常存在于开发者的软件库，而不是在源代码库中。<br><strong>创建一个功能分支</strong><br>开始一项功能的开发工作时，基于<code>develop</code>创建分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b myfeature develop</span></span><br><span class="line">Switched to a new branch &quot;myfeature&quot;</span><br></pre></td></tr></table></figure>

<p><strong>合并一个功能到develop分支</strong><br>完成的功能可以合并进develop分支，以明确加入到未来的发布：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line">Switched to branch &#x27;develop&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff myfeature</span></span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d myfeature</span></span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin develop</span></span><br></pre></td></tr></table></figure>

<p><code>--no-ff</code>标志导致合并操作创建一个新<code>commit</code>对象，即使该合并操作可以<code>fast-forward</code>。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。 比较:</p>
<p><img src="http://static.cyblogs.com/t_70_580-0.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;t_70_580-0.jpg"></p>
<p>后一种情况，不可能从<code>Git</code>历史中看到哪些提交一起实现了一个功能——你必须手工阅读全部的日志信息。如果对整个功能进行回退 (比如一组提交)，后一种方式会是一种真正头痛的问题，而使用<code>--no-ff flag</code>的情况则很容易.<br>是的，它会创建一个新的（空）提交对象，但是收益远大于开销。<br>不幸的是，我还没找到一种方法，让–no-ff时作为合并操作的默认选项，但它应该是可行的。</p>
<h4 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a>Release 分支</h4><p><code>Release</code>分支可能从<code>develop</code>分支分离而来，但是一定要合并到<code>develop</code>和master分支上，它的习惯命名方式为：<code>release-*</code>。<br><code>Release</code>分支是为新产品的发布做准备的。它允许我们在最后时刻做一些细小的修改。他们允许小bugs的修改和准备发布元数据（版本号，开发时间等等）。当在<code>Release</code>分支完成这些所有工作以后，对于下一次打的发布，develop分支接收<code>features</code>会更加明确。<br>从<code>develop</code>分支创建新的<code>Release</code>分支的关键时刻是<code>develop</code>分支达到了发布的理想状态。至少所有这次要发布的<code>features</code>必须在这个点及时合并到develop分支。对于所有未来准备发布的<code>features</code>必须等到Release分支创建以后再合并。<br>在<code>Release</code>分支创建的时候要为即将发行版本分配一个版本号，一点都不早。直到那时，<code>develop</code>分支反映的变化都是为了下一个发行版，但是在<code>Release</code>分支创建之前，下一个发行版到底叫<code>0.3</code>还是<code>1.0</code>是不明确的。这个决定是在<code>Release</code>分支创建时根据项目在版本号上的规则制定的。</p>
<p><strong>创建一个release分支</strong><br><code>Release</code>分支是从<code>develop</code>分支创建的。例如，当前产品的发行版本号为<code>1.1.5</code>，同事我们有一个大的版本即将发行。<code>develop</code> 分支已经为下次发行做好了准备，我们得决定下一个版本是<code>1.2</code>（而不是<code>1.1.6</code>或者<code>2.0</code>）。所以我们将<code>Release</code>分支分离出来，给一个能够反映新版本号的分支名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b release-1.2 develop</span></span><br><span class="line">Switched to a new branch &quot;release-1.2&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2</span></span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2&quot;</span></span></span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>创建新分支以后，切换到该分支，添加版本号。这里，<code>bump-version.sh</code> 是一个虚构的<code>shell</code>脚本，它可以复制一些文件来反映新的版本（这当然可以手动改变–目的就是修改一些文件）。然后版本号被提交。<br>这个新分支可能会存在一段时间，直到该发行版到达它的预定目标。在此期间，bug的修复可能被提交到该分支上（而不是提交到<code>develop</code>分支上）。在这里严格禁止增加大的新<code>features</code>。他们必须合并到<code>develop</code>分支上，然后等待下一次大的发行版。</p>
<p><strong>完成一个release分支</strong><br>当一个<code>release</code>分支准备好成为一个真正的发行版的时候，有一些工作必须完成。首先，release分支要合并到<code>master</code>上（因为每一次提交到<code>master</code>上的都是一个新定义的发行版，记住）。然后，提交到<code>master</code>上必须打一个标签，以便以后更加方便的引用这个历史版本。最后，在<code>release</code>分支上的修改必须合并到develop分支上，以便未来发行版也包含这些<code>bugs</code>的修复。<br>在<code>Git</code>中的前两步是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff release-1.2</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.2</span></span><br></pre></td></tr></table></figure>

<p>发行版现在已经完成，为以后引用打上标签。<br>**编辑：**你可能也想使用<code>the-sor-u &lt;key&gt;flags</code>来标记你的标签。<br>为了是修改保持在<code>release</code>分支上，我们需要合并这些到<code>develop</code>分支上去，在<code>Git</code>上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span></span><br><span class="line">Switched to branch &#x27;develop&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff release-1.2</span></span><br><span class="line">Merge made by recursive.</span><br></pre></td></tr></table></figure>

<p>(Summary of changes)<br>这个步骤可能会导致合并冲突（可能由于改变版本号更是如此）。如果是这样，修复它然后提交。<br>现在我们真正的完成了，这个<code>release</code>分支将被删除，因为我们不再需要它了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d release-1.2</span></span><br><span class="line">Deleted branch release-1.2 (was ff452fe).</span><br></pre></td></tr></table></figure>

<h4 id="热修复分支"><a href="#热修复分支" class="headerlink" title="热修复分支"></a>热修复分支</h4><p><img src="http://static.cyblogs.com/t_70_580-1.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;t_70_580-1.jpg"></p>
<p>可以基于<code>master</code>分支，必须合并回<code>develop</code>和<code>master</code>分支。<br>分支名约定：<code>hotfix-*</code><br>热修复分支与发布分支很相似，他们都为新的生成环境发布做准备，尽管这是未经计划的。他们来自生产环境的处于异常状态压力。当生成环境验证缺陷必须马上修复是，热修复分支可以基于<code>master</code>分支上对应与线上版本的<code>tag</code>创建。<br>其本质是团队成员（在<code>develop</code>分支上）的工作可以继续，而另一个人准备生产环境的快速修复。<br><strong>创建修补bug分支</strong><br><code>hotfix branch</code>(修补bug分支)是从<code>Master</code>分支上面分出来的。例如，1.2版本是当前生产环境的版本并且有<code>bug</code>。但是开发分支（<code>develop</code>）变化还不稳定。我们需要分出来一个修补<code>bug</code>分支（<code>hotfix branch</code>）来解决这种情况。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b hotfix-1.2.1 master</span></span><br><span class="line">Switched to a new branch &quot;hotfix-1.2.1&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bump-version.sh 1.2.1</span></span><br><span class="line">Files modified successfully, version bumped to 1.2.1.</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -a -m <span class="string">&quot;Bumped version number to 1.2.1&quot;</span></span></span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>分支关闭的时侯不要忘了更新版本号(<code>bump the version</code>)<br>然后，修复<code>bug</code>，一次提交或者多次分开提交。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;Fixed severe production problem&quot;</span></span></span><br><span class="line">[hotfix-1.2.1 abbe5d6] Fixed severe production problem</span><br><span class="line">5 files changed, 32 insertions(+), 17 deletions(-)</span><br></pre></td></tr></table></figure>

<p><strong>完成一个hotfix分支</strong><br>完成一个<code>bugfix</code>之后，需要把<code>butfix</code>合并到<code>master</code>和develop分支去，这样就可以保证修复的这个<code>bug</code>也包含到下一个发行版中。这一点和完成<code>release</code>分支很相似。<br>首先，更新<code>master</code>并对<code>release</code>打上<code>tag</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a 1.2.1</span></span><br></pre></td></tr></table></figure>

<p>编辑：你可能也会想使用 <code>-sor-u &lt;key&gt;</code>参数来对你的tag进行加密<br>下一步，把<code>bugfix</code>添加到<code>develop</code>分支中： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout develop</span> </span><br><span class="line">Switched to branch &#x27;develop&#x27; </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff hotfix-1.2.1</span> </span><br><span class="line">Merge made by recursive. </span><br></pre></td></tr></table></figure>

<p>(Summary of changes)<br>规则的一个例外是： <strong>如果一个<code>release</code>分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支</strong>。当<code>release</code>分支完成后， 将<code>bugfix</code>分支合并回<code>release</code>分支也会使得<code>bugfix</code>被合并到<code>develop</code>分支。（如果在<code>develop</code>分支的工作急需这个<code>bugfix</code>，等不到<code>release</code>分支的完成，那你也可以把<code>bugfix</code>合并到develop分支）<br>最后，删除临时分支：</p>
<p>(Summary of changes)<br>规则的一个例外是： <strong>如果一个release分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支</strong>。当release分支完成后， 将bugfix分支合并回release分支也会使得bugfix被合并到develop分支。（如果在develop分支的工作急需这个bugfix，等不到release分支的完成，那你也可以把bugfix合并到develop分支）<br>最后，删除临时分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d hotfix-1.2.1</span></span><br><span class="line">Deleted branch hotfix-1.2.1 (was abbe5d6).</span><br></pre></td></tr></table></figure>

<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>尽管这个分支模型没有任何震撼的新东西, 文章开头的图表在我们的项目中表现出惊人的实用性。它形成了一个优雅的思维模型，易于领悟并使团队成员发展出对分支和发布过程的共同理解。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hj7jay/article/details/84527062">https://blog.csdn.net/hj7jay/article/details/84527062</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/11/10/2020/11/RedisTemplate%E5%92%8CStringRedisTemplate%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/10/2020/11/RedisTemplate%E5%92%8CStringRedisTemplate%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">RedisTemplate和StringRedisTemplate的区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-10T00:00:00+08:00">2020-11-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 10:05:09" itemprop="dateModified" datetime="2025-06-25T10:05:09+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h4><p>简单的说，<code>RedisTemplate</code>和<code>StringRedisTemplate</code>的关系如下：</p>
<blockquote>
<p>1.<code>StringRedisTemplate</code>是<code>RedisTemplate</code>的子类。</p>
<p>2.<code>StringRedisTemplate</code>的各个序列化策略都是<code>StringRedisSerializer</code>，而<code>RedisTemplate</code>用的是<code>JdkSerializationRedisSerializer</code>。</p>
</blockquote>
<h4 id="二-RedisTemplate和StringRedisTemplate的代码结构"><a href="#二-RedisTemplate和StringRedisTemplate的代码结构" class="headerlink" title="二.RedisTemplate和StringRedisTemplate的代码结构"></a>二.RedisTemplate和StringRedisTemplate的代码结构</h4><p>从<code>RedisTemplate</code>类说起。</p>
<p>在<code>RedisTemplate</code>类中，定义了这样四个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RedisSerializer</span> <span class="variable">keySerializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RedisSerializer</span> <span class="variable">valueSerializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RedisSerializer</span> <span class="variable">hashKeySerializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RedisSerializer</span> <span class="variable">hashValueSerializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>分别代表了普通<code>key</code>，<code>value</code>，和<code>Hash</code>类型的<code>key</code>，value的序列化策略，可以分别设置。</p>
<p>另外定义变量，用来指定默认的序列化策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer&lt;?&gt; defaultSerializer;</span><br></pre></td></tr></table></figure>

<p>在<code>RedisTemplate</code>类中，定义了<code>afterPropertiesSet()</code>方法，当<code>Spring</code>创建<code>RedisTemplate</code>类的对象时，会调用这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.afterPropertiesSet();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">defaultUsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.defaultSerializer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultSerializer = <span class="keyword">new</span> <span class="title class_">JdkSerializationRedisSerializer</span>(<span class="built_in">this</span>.classLoader != <span class="literal">null</span> ? <span class="built_in">this</span>.classLoader : <span class="built_in">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.enableDefaultSerializer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.keySerializer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.keySerializer = <span class="built_in">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.valueSerializer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.valueSerializer = <span class="built_in">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hashKeySerializer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hashKeySerializer = <span class="built_in">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hashValueSerializer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hashValueSerializer = <span class="built_in">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.enableDefaultSerializer &amp;&amp; defaultUsed) &#123;</span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.defaultSerializer, <span class="string">&quot;default serializer null and not all serializers initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.scriptExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.scriptExecutor = <span class="keyword">new</span> <span class="title class_">DefaultScriptExecutor</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在默认情况下，<code>RedisTemplate</code>使用的默认序列化策略是<code>JdkSerializationRedisSerializer</code>。包括<code>RedisTemplate</code>下的<code>key</code>，<code>value</code>，<code>hash-key</code>，hash-value的序列化，都用这种策略。</p>
<p>再来看看<code>StringRedisTemplate</code>，他作为RedisTemplate的子类，只是修改了序列化策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title class_">RedisTemplate</span>&lt;String, String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringRedisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; stringSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="built_in">this</span>.setKeySerializer(stringSerializer);</span><br><span class="line">        <span class="built_in">this</span>.setValueSerializer(stringSerializer);</span><br><span class="line">        <span class="built_in">this</span>.setHashKeySerializer(stringSerializer);</span><br><span class="line">        <span class="built_in">this</span>.setHashValueSerializer(stringSerializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringRedisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="built_in">this</span>.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="built_in">this</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> RedisConnection <span class="title function_">preProcessConnection</span><span class="params">(RedisConnection connection, <span class="type">boolean</span> existingConnection)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultStringRedisConnection</span>(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是<code>StringRedisTemplate</code>整个类的内容，可以看到，在他的默认构造中，<code>key</code>，<code>value</code>，<code>hash-key</code>，<code>hash-value</code>都使用的是StringRedisSerializer类作为序列化策略。这也就是<code>StringRedisTemplate</code>和他的父类RedisTemplate的主要区别。</p>
<h4 id="三-序列化策略"><a href="#三-序列化策略" class="headerlink" title="三.序列化策略"></a>三.序列化策略</h4><p>更进一步，看一下这个序列化策略是什么。</p>
<p>上面提到的<code>StringRedisSerializer</code>和<code>JdkSerializationRedisSerializer</code>都是序列化策略类，他们都实现了一个<code>RedisSerializer&lt;T&gt;</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RedisSerializer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="type">byte</span>[] serialize(<span class="meta">@Nullable</span> T var1) <span class="keyword">throws</span> SerializationException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">deserialize</span><span class="params">(<span class="meta">@Nullable</span> <span class="type">byte</span>[] var1)</span> <span class="keyword">throws</span> SerializationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口表达的意思很简单，两个方法，serialize用于序列化，把对象变为<code>byte</code>数组，<code>deserialize</code>用于反序列化，把byte数组转为对象。</p>
<h5 id="StringRedisSerializer"><a href="#StringRedisSerializer" class="headerlink" title="StringRedisSerializer"></a>StringRedisSerializer</h5><p>看看<code>StringRedisSerializer</code>是怎么做的：</p>
<p><strong>1.StringRedisSerializer的构造：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringRedisSerializer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringRedisSerializer</span><span class="params">(Charset charset)</span> &#123;</span><br><span class="line">    Assert.notNull(charset, <span class="string">&quot;Charset must not be null!&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.charset = charset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了编码格式，默认<code>UTF_8</code>。</p>
<p><strong>2.StringRedisSerializer的serialize和deserialize方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">deserialize</span><span class="params">(<span class="meta">@Nullable</span> <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bytes == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="built_in">this</span>.charset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] serialize(<span class="meta">@Nullable</span> String string) &#123;</span><br><span class="line">    <span class="keyword">return</span> string == <span class="literal">null</span> ? <span class="literal">null</span> : string.getBytes(<span class="built_in">this</span>.charset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>StringRedisSerializer</code>采用的是字符串和对应编码下二进制数组之间的转换。</p>
<p>在这种编码格式下，如果我们向redis保存信息，然后用客户端访问<code>Redis</code>时，只要编码格式一致，就能看到保存信息的原文。保存字符串<code>ABC</code>，客户端看到的也是字符串<code>ABC</code>。</p>
<h5 id="JdkSerializationRedisSerializer"><a href="#JdkSerializationRedisSerializer" class="headerlink" title="JdkSerializationRedisSerializer"></a>JdkSerializationRedisSerializer</h5><p>然后对比看看<code>JdkSerializationRedisSerializer</code>是怎么做的。</p>
<p><strong>1.JdkSerializationRedisSerializer的构造：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;Object, <span class="type">byte</span>[]&gt; serializer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;<span class="type">byte</span>[], Object&gt; deserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JdkSerializationRedisSerializer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">SerializingConverter</span>(), <span class="keyword">new</span> <span class="title class_">DeserializingConverter</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JdkSerializationRedisSerializer</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">SerializingConverter</span>(), <span class="keyword">new</span> <span class="title class_">DeserializingConverter</span>(classLoader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>JdkSerializationRedisSerializer</code>定义了两个变量，serializer和<code>deserializer</code>，显然是用来序列化和反序列化的，他们两个的类型是一样的，都是Converter接口，只是泛型不同。</p>
<p>Converter接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;S, T&gt; &#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        T <span class="title function_">convert</span><span class="params">(S source)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就一个方法。</p>
<p>另外在<code>JdkSerializationRedisSerializer</code>的构造中，对serializer和<code>deserializer</code>进行了初始化，使用<code>SerializingConverter</code>和DeserializingConverter作为实现类。</p>
<p><strong>2.JdkSerializationRedisSerializer的serialize和deserialize方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(<span class="meta">@Nullable</span> <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (SerializationUtils.isEmpty(bytes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.deserializer.convert(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(<span class="string">&quot;Cannot deserialize&quot;</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] serialize(<span class="meta">@Nullable</span> Object object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializationUtils.EMPTY_ARRAY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">byte</span>[])<span class="built_in">this</span>.serializer.convert(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(<span class="string">&quot;Cannot serialize&quot;</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是调用了对应<code>Converter</code>的<code>convert</code>方法。</p>
<p><strong>3.关于Converter</strong></p>
<p>既然到这了，就再深入一步，看看<code>SerializingConverter</code>和DeserializingConverter的<code>convert</code>方法。</p>
<p><strong>首先，序列化：</strong></p>
<p><code>SerializingConverter</code>的相关方法，贴一部分关键的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SerializingConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serializer = <span class="keyword">new</span> <span class="title class_">DefaultSerializer</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] convert(Object source) &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span>  &#123;</span><br><span class="line">                <span class="built_in">this</span>.serializer.serialize(source, byteStream);</span><br><span class="line">                <span class="keyword">return</span> byteStream.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationFailedException</span>(<span class="string">&quot;Failed to serialize object using &quot;</span> +</span><br><span class="line">                                <span class="built_in">this</span>.serializer.getClass().getSimpleName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>SerializingConverter</code>类定义了<code>serializer</code>变量，用<strong>DefaultSerializer</strong>类实现，序列化的方式是调用<code>DefaultSerializer</code>的<code>serialize</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object, OutputStream outputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Serializable)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(getClass().getSimpleName() + <span class="string">&quot; requires a Serializable payload &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;but received an object of type [&quot;</span> + object.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream);</span><br><span class="line">        objectOutputStream.writeObject(object);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultSerializer</code>的<code>serialize</code>方法使用了<code>ObjectOutputStream</code>，调用writeObject方法序列化对象。</p>
<p><strong>对应的，反序列化：</strong></p>
<p><code>DeserializingConverter</code>的convert方法，贴一下相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DeserializingConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.deserializer = <span class="keyword">new</span> <span class="title class_">DefaultDeserializer</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">convert</span><span class="params">(<span class="type">byte</span>[] source)</span> &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(source);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.deserializer.deserialize(byteStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationFailedException</span>(<span class="string">&quot;Failed to deserialize payload. &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;Is the byte array a result of corresponding serialization for &quot;</span> +</span><br><span class="line">                                <span class="built_in">this</span>.deserializer.getClass().getSimpleName() + <span class="string">&quot;?&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见<code>DeserializingConverter</code>使用了<strong>DefaultDeserializer</strong>作为反序列化工具，调用了他的deserialize方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">deserialize</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurableObjectInputStream</span>(inputStream, <span class="built_in">this</span>.classLoader);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to deserialize object type&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比<code>SerializingConverter</code>，<code>DeserializingConverter</code>使用的是<code>ConfigurableObjectInputStream</code>，并调用他的<code>readObject</code>方法进行反序列化。</p>
<p>这种序列化方式，如果保存信息至<code>redis</code>，用客户端查看时，保存的信息看起来像是在原来的字符前面加了几个字符。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JdkSerializationRedisSerializer</span> <span class="variable">jdkSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkSerializationRedisSerializer</span>();</span><br><span class="line"><span class="type">StringRedisSerializer</span> <span class="variable">stringSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"><span class="type">byte</span>[] jdkByteArr = jdkSerializer.serialize(<span class="string">&quot;CSDN博客&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] stringByteArr = stringSerializer.serialize(<span class="string">&quot;CSDN博客&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种情况下，得到的<code>byte</code>数组是：</p>
<p><code>jdkByteArr</code>：</p>
<blockquote>
<p>{-84,-19,0,5,116,0,10,67,83,68,78,-27,-115,-102,-27,-82,-94}</p>
</blockquote>
<p>stringByteArr：</p>
<blockquote>
<p>{67,83,68,78,-27,-115,-102,-27,-82,-94}</p>
</blockquote>
<p><code>StringRedisSerializer</code>把字符串本身转化成<code>byte</code>数组，而<code>JdkSerializationRedisSerializer</code>在数组前面加了几个字符，这些字符也会被保存到redis中。</p>
<p>所以，从数据上来说，这两种序列化策略处理的数据是不会共通的，各人管各人的。</p>
<h4 id="四-关于redisTemplate的Operations"><a href="#四-关于redisTemplate的Operations" class="headerlink" title="四.关于redisTemplate的Operations"></a>四.关于redisTemplate的Operations</h4><p>使用<code>redisTemplate</code>时，除了调用<code>execute</code>方法并自定义RedisCallback之外，还可以使用<code>redisTemplate</code>提供的几个Operations接口。</p>
<p><code>redisTemplate</code>中定义了以下几个<code>Operations</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ValueOperations&lt;K, V&gt; valueOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ListOperations&lt;K, V&gt; listOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> SetOperations&lt;K, V&gt; setOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ZSetOperations&lt;K, V&gt; zSetOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> GeoOperations&lt;K, V&gt; geoOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HyperLogLogOperations&lt;K, V&gt; hllOps;</span><br></pre></td></tr></table></figure>

<p>这几个<code>Operations</code>接口，分别提供了对不同种类数据的操作方法。</p>
<p>以<code>ValueOperations</code>为例，他提供的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K var1, V var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K var1, V var2, <span class="type">long</span> var3, TimeUnit var5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Boolean <span class="title function_">setIfAbsent</span><span class="params">(K var1, V var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">multiSet</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Boolean <span class="title function_">multiSetIfAbsent</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">V <span class="title function_">getAndSet</span><span class="params">(K var1, V var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">List&lt;V&gt; <span class="title function_">multiGet</span><span class="params">(Collection&lt;K&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Long <span class="title function_">increment</span><span class="params">(K var1, <span class="type">long</span> var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Double <span class="title function_">increment</span><span class="params">(K var1, <span class="type">double</span> var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Integer <span class="title function_">append</span><span class="params">(K var1, String var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">String <span class="title function_">get</span><span class="params">(K var1, <span class="type">long</span> var2, <span class="type">long</span> var4)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K var1, V var2, <span class="type">long</span> var3)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Long <span class="title function_">size</span><span class="params">(K var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Boolean <span class="title function_">setBit</span><span class="params">(K var1, <span class="type">long</span> var2, <span class="type">boolean</span> var4)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Boolean <span class="title function_">getBit</span><span class="params">(K var1, <span class="type">long</span> var2)</span>;</span><br></pre></td></tr></table></figure>

<p>其他的<code>Operations</code>提供的方法各有不同，但是这些<code>Operations</code>的使用方式都是相同的。</p>
<p>不同的Operations分别通过<code>RedisTemplate</code>的以下方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ValueOperations&lt;K, V&gt; <span class="title function_">opsForValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.valueOps == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.valueOps = <span class="keyword">new</span> <span class="title class_">DefaultValueOperations</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListOperations&lt;K, V&gt; <span class="title function_">opsForList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.listOps == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.listOps = <span class="keyword">new</span> <span class="title class_">DefaultListOperations</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.listOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> SetOperations&lt;K, V&gt; <span class="title function_">opsForSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.setOps == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.setOps = <span class="keyword">new</span> <span class="title class_">DefaultSetOperations</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.setOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ZSetOperations&lt;K, V&gt; <span class="title function_">opsForZSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.zSetOps == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.zSetOps = <span class="keyword">new</span> <span class="title class_">DefaultZSetOperations</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.zSetOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> GeoOperations&lt;K, V&gt; <span class="title function_">opsForGeo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.geoOps == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.geoOps = <span class="keyword">new</span> <span class="title class_">DefaultGeoOperations</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.geoOps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，在这些获得<code>Operations</code>的方法中，都提供了一个默认实现类，并且把<code>RedisTemplate</code>对象本身当做参数传给了这个实现类。</p>
<p>还是以<code>ValueOperations</code>为例，<code>RedisTemplate</code>提供的默认实现类是DefaultValueOperations，看看这个类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.redis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.AbstractOperations.ValueDeserializingRedisCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultValueOperations</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractOperations</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">ValueOperations</span>&lt;K, V&gt; &#123;</span><br><span class="line">    DefaultValueOperations(RedisTemplate&lt;K, V&gt; template) &#123;</span><br><span class="line">        <span class="built_in">super</span>(template);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.execute(<span class="keyword">new</span> <span class="title class_">AbstractOperations</span>&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="type">byte</span>[] inRedis(<span class="type">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.get(rawKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getAndSet</span><span class="params">(K key, V newValue)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">byte</span>[] rawValue = <span class="built_in">this</span>.rawValue(newValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.execute(<span class="keyword">new</span> <span class="title class_">AbstractOperations</span>&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="type">byte</span>[] inRedis(<span class="type">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.getSet(rawKey, rawValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">increment</span><span class="params">(K key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Long)<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.incrBy(rawKey, delta);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">increment</span><span class="params">(K key, <span class="type">double</span> delta)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Double)<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.incrBy(rawKey, delta);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">append</span><span class="params">(K key, String value)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="type">byte</span>[] rawString = <span class="built_in">this</span>.rawString(value);</span><br><span class="line">        <span class="keyword">return</span> (Integer)<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> connection.append(rawKey, rawString);</span><br><span class="line">            <span class="keyword">return</span> result != <span class="literal">null</span> ? result.intValue() : <span class="literal">null</span>;</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(K key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="type">byte</span>[] rawReturn = (<span class="type">byte</span>[])<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.getRange(rawKey, start, end);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.deserializeString(rawReturn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;V&gt; <span class="title function_">multiGet</span><span class="params">(Collection&lt;K&gt; keys)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[][] rawKeys = <span class="keyword">new</span> <span class="title class_">byte</span>[keys.size()][];</span><br><span class="line">            <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Object hashKey;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> keys.iterator(); var4.hasNext(); rawKeys[counter++] = <span class="built_in">this</span>.rawKey(hashKey)) &#123;</span><br><span class="line">                hashKey = var4.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;<span class="type">byte</span>[]&gt; rawValues = (List)<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.mGet(rawKeys);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.deserializeValues(rawValues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiSet</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.isEmpty()) &#123;</span><br><span class="line">            Map&lt;<span class="type">byte</span>[], <span class="type">byte</span>[]&gt; rawKeys = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(m.size());</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> m.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; entry = (Entry)var3.next();</span><br><span class="line">                rawKeys.put(<span class="built_in">this</span>.rawKey(entry.getKey()), <span class="built_in">this</span>.rawValue(entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                connection.mSet(rawKeys);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">multiSetIfAbsent</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Map&lt;<span class="type">byte</span>[], <span class="type">byte</span>[]&gt; rawKeys = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(m.size());</span><br><span class="line">            <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> m.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; entry = (Entry)var3.next();</span><br><span class="line">                rawKeys.put(<span class="built_in">this</span>.rawKey(entry.getKey()), <span class="built_in">this</span>.rawValue(entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.mSetNX(rawKeys);</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">byte</span>[] rawValue = <span class="built_in">this</span>.rawValue(value);</span><br><span class="line">        <span class="built_in">this</span>.execute(<span class="keyword">new</span> <span class="title class_">AbstractOperations</span>&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="type">byte</span>[] inRedis(<span class="type">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                connection.set(rawKey, rawValue);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K key, V value, <span class="keyword">final</span> <span class="type">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">byte</span>[] rawValue = <span class="built_in">this</span>.rawValue(value);</span><br><span class="line">        <span class="built_in">this</span>.execute(<span class="keyword">new</span> <span class="title class_">RedisCallback</span>&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">                <span class="built_in">this</span>.potentiallyUsePsetEx(connection);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">potentiallyUsePsetEx</span><span class="params">(RedisConnection connection)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!TimeUnit.MILLISECONDS.equals(unit) || !<span class="built_in">this</span>.failsafeInvokePsetEx(connection)) &#123;</span><br><span class="line">                    connection.setEx(rawKey, TimeoutUtils.toSeconds(timeout, unit), rawValue);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">failsafeInvokePsetEx</span><span class="params">(RedisConnection connection)</span> &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.pSetEx(rawKey, timeout, rawValue);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedOperationException var4) &#123;</span><br><span class="line">                    failed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> !failed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">setIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="type">byte</span>[] rawValue = <span class="built_in">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.setNX(rawKey, rawValue);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K key, V value, <span class="type">long</span> offset)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="type">byte</span>[] rawValue = <span class="built_in">this</span>.rawValue(value);</span><br><span class="line">        <span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            connection.setRange(rawKey, rawValue, offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">size</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Long)<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.strLen(rawKey);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">setBit</span><span class="params">(K key, <span class="type">long</span> offset, <span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.setBit(rawKey, offset, value);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getBit</span><span class="params">(K key, <span class="type">long</span> offset)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] rawKey = <span class="built_in">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.getBit(rawKey, offset);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有<code>Operations</code>实现类都是<code>AbstractOperations</code>的子类，另外各自实现各自的接口。</p>
<p>实现类的方法中多数都是调用了<code>this.execute()</code>方法，这个方法在父类AbstractOperations中，最终调用的其实也是<code>RedisTemplate</code>的<code>execute()</code>方法。</p>
<p>以上面<code>DefaultValueOperations</code>的<code>set()</code>方法为例，看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] rawValue = <span class="built_in">this</span>.rawValue(value);</span><br><span class="line">    <span class="built_in">this</span>.execute(<span class="keyword">new</span> <span class="title class_">AbstractOperations</span>&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">byte</span>[] inRedis(<span class="type">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">            connection.set(rawKey, rawValue);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是对<code>value</code>的处理，调用<code>this.rawValue()</code>方法，把value序列化成<code>byte</code>数组，这个方法在父类<code>AbstractOperations</code>中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] rawValue(Object value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueSerializer() == <span class="literal">null</span> &amp;&amp; value <span class="keyword">instanceof</span> <span class="type">byte</span>[] ? (<span class="type">byte</span>[])((<span class="type">byte</span>[])value) : <span class="built_in">this</span>.valueSerializer().serialize(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，代码用的是自己的<code>valueSerializer</code>来序列化<code>value</code>，这个valueSerializer来自<code>RedisTemplate</code>。</p>
<p>回到<code>set()</code>方法，<code>value</code>序列化完成后，调用<code>this.execute()</code>方法，给此方法传递的第一个参数是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">AbstractOperations</span>&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">byte</span>[] inRedis(<span class="type">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">        connection.set(rawKey, rawValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个参数实际上是一个<code>ValueDeserializingRedisCallback</code>对象，在其中定义了<code>inRedis()</code>方法的实现。</p>
<p><code>this.execute()</code>方法在父类AbstractOperations中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">execute</span><span class="params">(RedisCallback&lt;T&gt; callback, <span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.template.execute(callback, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>this.template</code>指的就是初始化时传入的<code>RedisTemplate</code>，其execute()方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="type">boolean</span> exposeConnection)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.execute(action, exposeConnection, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="type">boolean</span> exposeConnection, <span class="type">boolean</span> pipeline)</span> &#123;</span><br><span class="line">    Assert.isTrue(<span class="built_in">this</span>.initialized, <span class="string">&quot;template not initialized; call afterPropertiesSet() before using it&quot;</span>);</span><br><span class="line">    Assert.notNull(action, <span class="string">&quot;Callback object must not be null&quot;</span>);</span><br><span class="line">    <span class="type">RedisConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="built_in">this</span>.getRequiredConnectionFactory();</span><br><span class="line">    <span class="type">RedisConnection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Object var11;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.enableTransactionSupport) &#123;</span><br><span class="line">            conn = RedisConnectionUtils.bindConnection(factory, <span class="built_in">this</span>.enableTransactionSupport);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn = RedisConnectionUtils.getConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">existingConnection</span> <span class="operator">=</span> TransactionSynchronizationManager.hasResource(factory);</span><br><span class="line">        <span class="type">RedisConnection</span> <span class="variable">connToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.preProcessConnection(conn, existingConnection);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">pipelineStatus</span> <span class="operator">=</span> connToUse.isPipelined();</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.openPipeline();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">RedisConnection</span> <span class="variable">connToExpose</span> <span class="operator">=</span> exposeConnection ? connToUse : <span class="built_in">this</span>.createRedisConnectionProxy(connToUse);</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> action.doInRedis(connToExpose);</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.closePipeline();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var11 = <span class="built_in">this</span>.postProcessResult(result, connToUse, existingConnection);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RedisConnectionUtils.releaseConnection(conn, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法初始化了<code>RedisConnection</code>，最后面调用了<code>RedisCallback</code>的<code>doInRedis()</code>方法，也就是这一行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> action.doInRedis(connToExpose);</span><br></pre></td></tr></table></figure>

<p>这里的变量<code>action</code>就是在<code>set()</code>方法中自定义的<code>new AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key)</code>。</p>
<p><code>ValueDeserializingRedisCallback</code>类是<code>AbstractOperations</code>的内部抽象类，他的<code>doInRedis()</code>方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">doInRedis</span><span class="params">(RedisConnection connection)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] result = <span class="built_in">this</span>.inRedis(AbstractOperations.<span class="built_in">this</span>.rawKey(<span class="built_in">this</span>.key), connection);</span><br><span class="line">    <span class="keyword">return</span> AbstractOperations.<span class="built_in">this</span>.deserializeValue(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见调用了<code>inRedis()</code>方法，其第一个参数是序列化后的<code>key</code>，调用的是<code>AbstractOperations</code>的<code>rawKey()</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] rawKey(Object key) &#123;</span><br><span class="line">    Assert.notNull(key, <span class="string">&quot;non null key required&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keySerializer() == <span class="literal">null</span> &amp;&amp; key <span class="keyword">instanceof</span> <span class="type">byte</span>[] ? (<span class="type">byte</span>[])((<span class="type">byte</span>[])key) : <span class="built_in">this</span>.keySerializer().serialize(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把<code>key</code>进行序列化，<code>keySerializer()</code>方法从<code>RedisTemplate</code>中获取<code>keySerializer</code>，并由<code>keySerializer</code>对<code>key</code>进行序列化。</p>
<p>在<code>ValueDeserializingRedisCallback</code>类中的<code>inRedis()</code>方法是抽象方法，具体的实现在<code>DefaultValueOperations</code>的<code>set()</code>方法中，也就是这一部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">byte</span>[] inRedis(<span class="type">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">    connection.set(rawKey, rawValue);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用的是<code>RedisConnection</code>的<code>set()</code>方法，完成<code>Redis</code>的<code>set</code>操作。</p>
<p>以上就是在RedisTemplate中使用<code>ValueOperations</code>进行<code>set</code>操作的全部代码流程。</p>
<p>对<code>Redis</code>的不同操作分散在<code>RedisTemplate</code>的不同Operations中，只是调用的方法不同，调用流程都差不多。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lkforce/article/details/103685707">https://blog.csdn.net/lkforce/article/details/103685707</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/11/07/2020/10/%E6%96%B0%E7%89%88IDEA%202020.1%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/07/2020/10/%E6%96%B0%E7%89%88IDEA%202020.1%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/" class="post-title-link" itemprop="url">新版IDEA 2020.1碰到的一个小坑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-07T00:00:00+08:00">2020-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:58:47" itemprop="dateModified" datetime="2025-06-25T09:58:47+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用新版idea创建了一个springboot项目，运行build时发生如下报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error:(<span class="number">3</span>, <span class="number">32</span>) java: 程序包org.springframework.boot不存在</span><br><span class="line">Error:(<span class="number">4</span>, <span class="number">46</span>) java: 程序包org.springframework.boot.autoconfigure不存在</span><br><span class="line">Error:(<span class="number">5</span>, <span class="number">40</span>) java: 程序包org.springframework.boot.builder不存在</span><br><span class="line">Error:(<span class="number">6</span>, <span class="number">52</span>) java: 程序包org.springframework.boot.web.servlet.support不存在</span><br><span class="line">Error:(<span class="number">9</span>, <span class="number">34</span>) java: 找不到符号</span><br><span class="line">符号: 类 SpringBootServletInitializer</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/QQ20201107-080822@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20201107-080822@2x.jpg"></p>
<p>诡异的是，使用<code>mvn</code>打包却是正常的，能生成正确的jar并且能通过命令行启动 后来通过查阅资料得知新版<code>IDEA</code>需要在<code>Setting</code>里将 <code>delegate IDE build/run actions to Maven</code>勾选上即可。</p>
<p><img src="http://static.cyblogs.com/QQ20201107-081022@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20201107-081022@2x.jpg"></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>在解决这个问题的过程中，还了解到使用<code>spring-boot-maven-plugin</code>这个插件打的jar的结构会和普通插件<code>maven-jar-plugin</code>的有些不一样。<code>spring-boot-maven-plugin</code>将所有应用启动运行所需的jar全部包含进来了，具备独立运行的条件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>spring-boot-maven-plugin</code>打包的<code>jar</code>目录：</p>
<p><img src="http://static.cyblogs.com/QQ20201107-081147@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20201107-081147@2x.jpg"></p>
<p>而使用普通插件打包的结构如图：</p>
<p><img src="http://static.cyblogs.com/QQ20201107-081242@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20201107-081242@2x.jpg"></p>
<p>最后，这里补充一点。如果是你想在<code>IDEA</code>里面，不是通过<code>Maven</code>来依赖，这里就不用打钩，否则你每次都必须要<code>install</code>你的<code>jar</code>包到本地来。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904177114562573">https://juejin.im/post/6844904177114562573</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/11/07/2020/11/%E6%B3%A8%E8%A7%A3@Autowired%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/07/2020/11/%E6%B3%A8%E8%A7%A3@Autowired%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/" class="post-title-link" itemprop="url">注解@Autowired是如何实现的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-11-07T00:00:00+08:00">2020-11-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:58:47" itemprop="dateModified" datetime="2025-06-25T09:58:47+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用<code>spring</code>开发时，进行配置主要有两种方式，一是<code>xml</code>的方式，二是<code>java config</code>的方式。<code>spring</code>技术自身也在不断的发展和改变，从当前<code>springboot</code>的火热程度来看，<code>java config</code>的应用是越来越广泛了，在使用<code>java config</code>的过程当中，我们不可避免的会有各种各样的注解打交道，其中，我们使用最多的注解应该就是<code>@Autowired</code>注解了。这个注解的功能就是为我们注入一个定义好的<code>bean</code>。那么，这个注解除了我们常用的属性注入方式之外还有哪些使用方式呢？它在代码层面又是怎么实现的呢？这是本篇文章着重想讨论的问题。</p>
<h4 id="Autowired注解用法"><a href="#Autowired注解用法" class="headerlink" title="@Autowired注解用法"></a>@Autowired注解用法</h4><p>在分析这个注解的实现原理之前，我们不妨先来回顾一下<code>@Autowired</code>注解的用法。</p>
<p>将<code>@Autowired</code>注解应用于构造函数，如以下示例所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>@Autowired</code>注释应用于<code>setter</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>@Autowired</code>注释应用于具有任意名称和多个参数的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您也可以将<code>@Autowired</code>应用于字段，或者将其与构造函数混合，如以下示例所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接应用于字段是我们使用的最多的一种方式，但是使用构造方法注入从代码层面却是更加好的，原因可以参考这篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/topdeveloperr/article/details/81414039">spring重点知识</a>。除此之外，还有以下不太常见的几种方式</p>
<p>将<code>@Autowired</code>注释添加到需要该类型数组的字段或方法，则<code>spring</code>会从<code>ApplicationContext</code>中搜寻符合指定类型的所有<code>bean</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组可以，我们可以马上举一反三，那容器也可以吗，答案是肯定的，下面是<code>set</code>以及<code>map</code>的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是<code>@Autowired</code>注解的主要使用方式，经常使用<code>spring</code>的话应该对其中常用的几种不会感到陌生。</p>
<h4 id="Autowired注解的作用到底是什么"><a href="#Autowired注解的作用到底是什么" class="headerlink" title="@Autowired注解的作用到底是什么?"></a>@Autowired注解的作用到底是什么?</h4><p><code>@Autowired</code>这个注解我们经常在使用，现在，我想问的是，它的作用到底是什么呢?</p>
<p>首先，我们从所属范围来看，事实上这个注解是属于<code>spring</code>的容器配置的一个注解，与它同属容器配置的注解还有：<code>@Required</code>,<code>@Primary</code>, <code>@Qualifier</code>等等。因此<code>@Autowired</code>注解是一个用于容器(<code>container</code>)配置的注解。</p>
<p>其次，我们可以直接从字面意思来看，<code>@autowired</code>注解来源于英文单词<code>autowire</code>,这个单词的意思是自动装配的意思。</p>
<p>自动装配又是什么意思？这个词语本来的意思是指的一些工业上的用机器代替人口，自动将一些需要完成的组装任务，或者别的一些任务完成。而在<code>spring</code>的世界当中，自动装配指的就是使用将<code>Spring</code>容器中的<code>bean</code>自动的和我们需要这个<code>bean</code>的类组装在一起。</p>
<p>因此，笔者个人对这个注解的作用下的定义就是:将<code>Spring</code>容器中的<code>bean</code>自动的和我们需要这个<code>bean</code>的类组装在一起协同使用。</p>
<p>接下来，我们就来看一下这个注解背后到底做了些什么工作。</p>
<h4 id="Autowired注解是如何实现的"><a href="#Autowired注解是如何实现的" class="headerlink" title="@Autowired注解是如何实现的"></a>@Autowired注解是如何实现的</h4><p>事实上，要回答这个问题必须先弄明白的是<code>java</code>是如何支持注解这样一个功能的。</p>
<p><code>java</code>的注解实现的核心技术是反射，让我们通过一些例子以及自己实现一个注解来理解它工作的原理。</p>
<h5 id="例子注解-Override"><a href="#例子注解-Override" class="headerlink" title="例子注解@Override"></a>例子注解@Override</h5><p><code>@Override</code>注解的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Override</code>注解使用<code>java</code>官方提供的注解，它的定义里面并没有任何的实现逻辑。注意，所有的注解几乎都是这样的，<strong>注解只能是被看作元数据，它不包含任何业务逻辑</strong>。<strong>注解更像是一个标签，一个声明，表面被注释的这个地方，将具有某种特定的逻辑</strong>。</p>
<p>那么，问题接踵而至，注解本身不包含任何逻辑，那么注解的功能是如何实现的呢？答案必然是别的某个地方对这个注解做了实现。以<code>@Override</code>注解为例，他的功能是重写一个方法，而他的实现者就是<code>JVM</code>，<code>java</code>虚拟机，<code>java</code>虚拟机在字节码层面实现了这个功能。</p>
<p>但是对于开发人员，虚拟机的实现是无法控制的东西，也不能用于自定义注解。 所以，如果是我们自己想定义一个独一无二的注解的话，则我们需要自己为注解写一个实现逻辑，<strong>换言之，我们需要实现自己注解特定逻辑的功能</strong>。</p>
<h5 id="自己实现一个注解"><a href="#自己实现一个注解" class="headerlink" title="自己实现一个注解"></a>自己实现一个注解</h5><p>在自己写注解之前我们有一些基础知识需要掌握，那就是我们写注解这个功能首先是需要<code>java</code>支持的，<code>java</code>在<code>jdk5</code>当中支持了这一功能，<strong>并且在java.lang.annotation包中提供了四个注解，仅用于编写注解时使用</strong>，他们是：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><em><strong>@Documented</strong></em></td>
<td>表明是否在java doc中添加Annotation</td>
</tr>
<tr>
<td><em><strong>@Retention</strong></em></td>
<td>定义注释应保留多长时间，即有效周期。有以下几种策略： <strong>RetentionPolicy.SOURCE</strong> - 在编译期间丢弃。 编译完成后，这些注释没有任何意义，因此它们不会写入字节码。 示例@Override，@ SuppressWarnings <strong>RetentionPolicy.CLASS</strong> - 在类加载期间丢弃。 在进行字节码级后处理时很有用。 有点令人惊讶的是，这是默认值。 <strong>RetentionPolicy.RUNTIME</strong> - 不要丢弃。 注释应该可以在运行时进行反射。 这是我们通常用于自定义注释的内容。</td>
</tr>
<tr>
<td><em><strong>@Target</strong></em></td>
<td>指定可以放置注解的位置。 如果不指定，则可以将注解放在任何位置。若我们只想要其中几个，则需要定义对应的几个。下面是这8个属性:ElementType.TYPE（类，接口，枚举）ElementType.FIELD（实例变量）ElementType.METHODElementType.PARAMETERElementType.CONSTRUCTORElementType.LOCAL_VARIABLEElementType.ANNOTATION_TYPE（在另一个注释上）ElementType.PACKAGE（记住package-info.java）</td>
</tr>
<tr>
<td><em><strong>@Inherited</strong></em></td>
<td>控制注解是否对子类产生影响。</td>
</tr>
</tbody></table>
<p>下面我们开始自己实现一个注解，注解仅支持 <code>primitives</code>, <code>string</code>和 <code>enumerations</code>这三种类型。 注解的所有属性都定义为方法，也可以提供默认值。我们先实现一个最简单的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SimpleAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个注释里面只定义了一个字符传，它的目标注释对象是方法，保留策略是在运行期间。下面我们定义一个方法来使用这个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseAnnotation</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SimpleAnnotation(&quot;testStringValue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//do something here</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在这里使用了这个注解，并把字符串赋值为:<code>testStringValue</code>,到这里,定义一个注解并使用它，我们就已经全部完成。</p>
<p>简单的不敢相信。但是，细心一想的话，我们虽然写了一个注解也用了它，可是它并没有产生任何作用啊。也没有对我们这里方法产生任何效果啊。是的现在确实是这样的，原因在于我们前面提到的一点，我们还没有为这个注解实现它的逻辑，现在我们就来为这个注解实现逻辑。</p>
<p>应该怎么做呢？我们不妨自己来想一想。首先，我想给标注了这个注解的方法或字段实现功能，我们必须得知道，到底有哪些方法，哪些字段使用了这个注解吧，因此，这里我们很容易想到，这里应该会用到反射。其次，利用反射，我们利用反射拿到这样目标之后，得为他实现一个逻辑，这个逻辑是这些方法本身逻辑之外的逻辑，这又让我们想起了代理，aop等知识，我们相当于就是在为这些方法做一个增强。事实上的实现主借的逻辑也大概就是这个思路。梳理一下大致步骤如下:</p>
<ol>
<li>利用反射机制获取一个类的<code>Class</code>对象</li>
<li>通过这个<code>class</code>对象可以去获取他的每一个方法<code>method</code>，或字段<code>Field</code>等等</li>
<li><code>Method</code>，<code>Field</code>等类提供了类似于<code>getAnnotation</code>的方法来获取这个一个字段的所有注解</li>
<li>拿到注解之后，我们可以判断这个注解是否是我们要实现的注解，如果是则实现注解逻辑</li>
</ol>
<p>现在我们来实现一下这个逻辑，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">annotationLogic</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="type">Class</span> <span class="variable">useAnnotationClass</span> <span class="operator">=</span> UseAnnotation.class;</span><br><span class="line">     <span class="keyword">for</span>(Method method : useAnnotationClass.getMethods()) &#123;</span><br><span class="line">         <span class="type">SimpleAnnotation</span> <span class="variable">simpleAnnotation</span> <span class="operator">=</span> (SimpleAnnotation)method.getAnnotation(SimpleAnnotation.class);</span><br><span class="line">         <span class="keyword">if</span>(simpleAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot; Method Name : &quot;</span> + method.getName());</span><br><span class="line">             System.out.println(<span class="string">&quot; value : &quot;</span> + simpleAnnotation.value());</span><br><span class="line">             System.out.println(<span class="string">&quot; --------------------------- &quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们实现的逻辑就是打印几句话。从上面的实现逻辑我们不能发现，借助于java的反射我们可以直接拿到一个类里所有的方法，然后再拿到方法上的注解，当然，我们也可以拿到字段上的注解。借助于反射我们可以拿到几乎任何属于一个类的东西。</p>
<p>关于反射更多的知识请参见这篇博客:<a target="_blank" rel="noopener" href="https://blog.csdn.net/topdeveloperr/article/details/81395710#%E5%8F%8D%E5%B0%84">java中的反射和多态实现原理详解以及对比</a></p>
<p>一个简单的注解我们就实现完了。现在我们再回过头来，看一下@Autowired注解是如何实现的。</p>
<h5 id="Autowired注解实现逻辑分析"><a href="#Autowired注解实现逻辑分析" class="headerlink" title="@Autowired注解实现逻辑分析"></a>@Autowired注解实现逻辑分析</h5><p>知道了上面的知识，我们不难想到，上面的注解虽然简单，但是<code>@Autowired</code>和他最大的区别应该仅仅在于注解的实现逻辑，其他利用反射获取注解等等步骤应该都是一致的。先来看一下<code>@Autowired</code>这个注解在<code>spring</code>的源代码里的定义是怎样的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.annotation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读代码我们可以看到，<code>Autowired</code>注解可以应用在构造方法，普通方法，参数，字段，以及注解这五种类型的地方，它的保留策略是在运行时。下面，我们不多说直接来看spring对这个注解进行的逻辑实现.</p>
<p>在<code>Spring</code>源代码当中，<code>Autowired</code>注解位于包<code>org.springframework.beans.factory.annotation</code>之中，该包的内容如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20191031121038318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvcGRldmVsb3BlcnI=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>经过分析，不难发现<code>Spring</code>对<code>autowire</code>注解的实现逻辑位于类:<code>AutowiredAnnotationBeanPostProcessor</code>之中,已在上图标红。其中的核心处理代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">		LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">		Class&lt;?&gt; targetClass = clazz;<span class="comment">//需要处理的目标类</span></span><br><span class="line">       </span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">/*通过反射获取该类所有的字段，并遍历每一个字段，并通过方法findAutowiredAnnotation遍历每一个字段的所用注解，并如果用autowired修饰了，则返回auotowired相关属性*/</span>  </span><br><span class="line">			ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">				<span class="type">AnnotationAttributes</span> <span class="variable">ann</span> <span class="operator">=</span> findAutowiredAnnotation(field);</span><br><span class="line">				<span class="keyword">if</span> (ann != <span class="literal">null</span>) &#123;<span class="comment">//校验autowired注解是否用在了static方法上</span></span><br><span class="line">					<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">						<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">							logger.warn(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;<span class="comment">//判断是否指定了required</span></span><br><span class="line">					<span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line">					currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredFieldElement</span>(field, required));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">      <span class="comment">//和上面一样的逻辑，但是是通过反射处理类的method</span></span><br><span class="line">			ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">				<span class="type">Method</span> <span class="variable">bridgedMethod</span> <span class="operator">=</span> BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">				<span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">AnnotationAttributes</span> <span class="variable">ann</span> <span class="operator">=</span> findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">				<span class="keyword">if</span> (ann != <span class="literal">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">					<span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">						<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">							logger.warn(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">							logger.warn(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">									method);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line">					<span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">              	    currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredMethodElement</span>(method, required, pd));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">      <span class="comment">//用@Autowired修饰的注解可能不止一个，因此都加在currElements这个容器里面，一起处理		</span></span><br><span class="line">			elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">			targetClass = targetClass.getSuperclass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (targetClass != <span class="literal">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InjectionMetadata</span>(clazz, elements);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>博主在源代码里加了注释，结合注释就能看懂它做的事情了，最后这个方法返回的就是包含所有带有<code>autowire</code>注解修饰的一个<code>InjectionMetadata</code>集合。这个类由两部分组成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InjectionMetadata</span><span class="params">(Class&lt;?&gt; targetClass, Collection&lt;InjectedElement&gt; elements)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.targetClass = targetClass;</span><br><span class="line">		<span class="built_in">this</span>.injectedElements = elements;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>一是我们处理的目标类，二就是上述方法获取到的所以<code>elements</code>集合。</p>
<p>有了目标类，与所有需要注入的元素集合之后，我们就可以实现<code>autowired</code>的依赖注入逻辑了，实现的方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> PropertyValues <span class="title function_">postProcessPropertyValues</span><span class="params">(</span></span><br><span class="line"><span class="params">			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			metadata.inject(bean, beanName, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pvs;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>它调用的方法是<code>InjectionMetadata</code>中定义的<code>inject</code>方法，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		Collection&lt;InjectedElement&gt; checkedElements = <span class="built_in">this</span>.checkedElements;</span><br><span class="line">		Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">				(checkedElements != <span class="literal">null</span> ? checkedElements : <span class="built_in">this</span>.injectedElements);</span><br><span class="line">		<span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Processing injected element of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + element);</span><br><span class="line">				&#125;</span><br><span class="line">				element.inject(target, beanName, pvs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其逻辑就是遍历，然后调用<code>inject</code>方法，<code>inject</code>方法其实现逻辑如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Either this or &#123;<span class="doctag">@link</span> #getResourceToInject&#125; needs to be overridden.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String requestingBeanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span></span><br><span class="line">		<span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.isField) &#123;</span><br><span class="line">		<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> (Field) <span class="built_in">this</span>.member;</span><br><span class="line">		ReflectionUtils.makeAccessible(field);</span><br><span class="line">		field.set(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (checkPropertySkipping(pvs)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> (Method) <span class="built_in">this</span>.member;</span><br><span class="line">			ReflectionUtils.makeAccessible(method);</span><br><span class="line">			method.invoke(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里的代码当中我们也可以看到，是<code>inject</code>也使用了反射技术并且依然是分成字段和方法去处理的。在代码里面也调用了<code>makeAccessible</code>这样的可以称之为暴力破解的方法，但是反射技术本就是为框架等用途设计的，这也无可厚非。</p>
<p>对于字段的话，本质上就是去set这个字段的值，即对对象进行实例化和赋值，例如下面代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectTest objectTest;</span><br></pre></td></tr></table></figure>

<p>那么在这里实现的就相当于给这个<code>objecTest</code>引用赋值了。</p>
<p>对于方法的话，本质就是去调用这个方法，因此这里调用的是<code>method.invoke</code>。<code>getResourceToInject</code>方法的参数就是要注入的<code>bean</code>的名字，这个方法的功能就是根据这个<code>bean</code>的名字去拿到它。</p>
<p>以上，就是<code>@Autowire</code>注解实现逻辑的全部分析。结合源代码再看一遍的话，会更加清楚一点。下面是<code>spring</code>容器如何实现<code>@AutoWired</code>自动注入的过程的图:</p>
<p> <img src="https://img-blog.csdnimg.cn/20190319171936407.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvcGRldmVsb3BlcnI=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>总结起来一句话：使用<code>@Autowired</code>注入的<code>bean</code>对于目标类来说，从代码结构上来讲也就是一个普通的成员变量，<code>@Autowired</code>和<code>spring</code>一起工作，通过反射为这个成员变量赋值，也就是将其赋为期望的类实例。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="注解的有效周期是什么？"><a href="#注解的有效周期是什么？" class="headerlink" title="注解的有效周期是什么？"></a>注解的有效周期是什么？</h5><p>各种注释之间的第一个主要区别是，它们是在编译时使用，然后被丢弃（如<code>@Override</code>），还是被放在编译的类文件中，并在运行时可用（如<code>Spring</code>的<code>@Component</code>）。这是由注释的“<code>@Retention</code>”策略决定的。如果您正在编写自己的注释，则需要决定该注释在运行时（可能用于自动配置）还是仅在编译时（用于检查或代码生成）有用。</p>
<p>当用注释编译代码时，编译器看到注释就像看到源元素上的其他修饰符一样，比如访问修饰符（<code>public/private</code>）或.。当遇到注释时，它运行一个注释处理器，就像一个插件类，表示对特定的注释感兴趣。注释处理器通常使用反射<code>API</code>来检查正在编译的元素，并且可以简单地对它们执行检查、修改它们或生成要编译的新代码。<code>@Override</code>是一个示例；它使用反射<code>API</code>来确保能够在其中一个超类中找到方法签名的匹配，如果不能，则使用<code>@Override</code>会导致编译错误。</p>
<h5 id="注入的bean和用它的bean的关系是如何维护的？"><a href="#注入的bean和用它的bean的关系是如何维护的？" class="headerlink" title="注入的bean和用它的bean的关系是如何维护的？"></a>注入的bean和用它的bean的关系是如何维护的？</h5><p>无论以何种方式注入，注入的<code>bean</code>就相当于类中的一个普通对象应用，这是它的实例化是<code>spring</code>去容器中找符合的<code>bean</code>进行实例化，并注入到类当中的。他们之间的关系就是普通的一个对象持有另一个对象引用的关系。只是这些对象都是<code>spring</code>当中的<code>bean</code>而已。</p>
<h5 id="为什么注入的bean不能被定义为static的？"><a href="#为什么注入的bean不能被定义为static的？" class="headerlink" title="为什么注入的bean不能被定义为static的？"></a>为什么注入的bean不能被定义为static的？</h5><p>从设计的角度来说 ，使用静态字段会鼓励使用静态方法。 静态方法是<code>evil</code>的。 依赖注入的主要目的是让容器为您创建对象并进行连接。 而且，它使测试更加容易。</p>
<p>一旦开始使用静态方法，您就不再需要创建对象的实例，并且测试变得更加困难。 同样，您不能创建给定类的多个实例，每个实例都注入不同的依赖项（因为该字段是隐式共享的，并且会创建全局状态）。</p>
<p>静态变量不是<code>Object</code>的属性，而是<code>Class</code>的属性。 <code>spring</code>的<code>autowire</code>是在对象上完成的，这样使得设计很干净。 在<code>spring</code>当中我们也可以将<code>bean</code>对象定义为单例，这样就能从功能上实现与静态定义相同的目的。</p>
<p>但是从纯粹技术的层面，我们可以这样做：</p>
<p>将<code>@Autowired</code>可以与<code>setter</code>方法一起使用，然后可以让<code>setter</code>修改静态字段的值。但是这种做法非常不推荐。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/topdeveloperr/article/details/87971446">https://blog.csdn.net/topdeveloperr/article/details/87971446</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/08/14/2020/08/Redis%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%98%AF%E7%94%A8String%E8%BF%98%E6%98%AFHash%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/14/2020/08/Redis%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%98%AF%E7%94%A8String%E8%BF%98%E6%98%AFHash%EF%BC%9F/" class="post-title-link" itemprop="url">Redis保存一个用户信息是用String还是Hash？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-14 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-14T00:00:00+08:00">2020-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:58:47" itemprop="dateModified" datetime="2025-06-25T09:58:47+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>如果用普通的<code>key/value</code>结构来存储，主要有以下2种存储方式：</p>
<p>第一种方式将用户<code>ID</code>作为查找<code>key</code>,把其他信息封装成一个对象以序列化的方式存储，</p>
<p> 如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set u001 &quot;李三,18,20010101&quot; </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get u001</span><br><span class="line">&quot;\xe6\x9d\x8e\xe4\xb8\x89,18,20010101&quot;</span><br></pre></td></tr></table></figure>

<p> 这种方式的缺点是，增加了序列化&#x2F;反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入<code>CAS</code>等复杂问题。</p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>第二种方法是这个用户信息对象有多少成员就存成多少个<code>key-value</code>对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，</p>
<p> 如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mset user:001:name &quot;李三&quot; user:001:age 18 user:001:birthday &quot;20010101&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get user:001:name</span><br><span class="line">&quot;\xe6\x9d\x8e\xe4\xb8\x89&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user:001:age</span><br><span class="line">&quot;18&quot;</span><br><span class="line">127.0.0.1:6379&gt; get user:001:birthday</span><br><span class="line">&quot;20010101&quot;</span><br></pre></td></tr></table></figure>

<p> 虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。</p>
<h4 id="最好的办法"><a href="#最好的办法" class="headerlink" title="最好的办法"></a>最好的办法</h4><p>那么<code>Redis</code>提供的<code>Hash</code>很好的解决了这个问题，<code>Redis</code>的<code>Hash</code>实际是内部存储的<code>Value</code>为一个<code>HashMap</code>，</p>
<p> 并提供了直接存取这个<code>Map</code>成员的接口，</p>
<p> 如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:001 name &quot;李三&quot; age 18 birthday &quot;20010101&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;\xe6\x9d\x8e\xe4\xb8\x89&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;18&quot;</span><br><span class="line">5) &quot;birthday&quot;</span><br><span class="line">6) &quot;20010101&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget user:001 age</span><br><span class="line">&quot;18&quot;</span><br></pre></td></tr></table></figure>

<p>也就是说，<code>Key</code>仍然是用户<code>ID</code>,<code>value</code>是一个<code>Map</code>，这个<code>Map</code>的<code>key</code>是成员的属性名，<code>value</code>是属性值， 这样对数据的修改和存取都可以直接通过其内部<code>Map</code>的<code>Key</code>(<code>Redis</code>里称内部<code>Map</code>的<code>key</code>为<code>field</code>), 也就是通过</p>
<p> <code>key</code>(用户ID) + <code>field</code>(属性标签) 操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dustin_CDS/article/details/79701975">https://blog.csdn.net/Dustin_CDS/article/details/79701975</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-hashes.html">https://www.runoob.com/redis/redis-hashes.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/08/03/2020/08/%E4%BA%86%E8%A7%A3Eureka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/03/2020/08/%E4%BA%86%E8%A7%A3Eureka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">了解Eureka工作原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-03 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-03T00:00:00+08:00">2020-08-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:58:47" itemprop="dateModified" datetime="2025-06-25T09:58:47+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/" itemprop="url" rel="index"><span itemprop="name">注册中心</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Eureka-工作原理"><a href="#Eureka-工作原理" class="headerlink" title="Eureka 工作原理"></a>Eureka 工作原理</h4><p><code>Eureka</code> 作为 <code>Spring Cloud</code> 体系中最核心、默认的注册中心组件，研究它的运行机制，有助于我们在工作中更好地使用它。</p>
<h4 id="Eureka-核心概念"><a href="#Eureka-核心概念" class="headerlink" title="Eureka 核心概念"></a>Eureka 核心概念</h4><p>回到上节的服务注册调用示意图，服务提供者和服务的消费者，本质上也是 <code>Eureka Client</code> 角色。整体上可以分为两个主体：<code>Eureka Server</code> 和 <code>Eureka Client</code>。<br><img src="http://static.cyblogs.com/20190703102014756.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20190703102014756.png"></p>
<p><strong>Eureka Server：注册中心服务端</strong></p>
<p>注册中心服务端主要对外提供了三个功能：</p>
<p><strong>服务注册</strong><br>服务提供者启动时，会通过 <code>Eureka Client</code> 向 <code>Eureka Server</code> 注册信息，<code>Eureka Server</code> 会存储该服务的信息，<code>Eureka Server</code> 内部有二层缓存机制来维护整个注册表</p>
<p><strong>提供注册表</strong><br>服务消费者在调用服务时，如果 <code>Eureka Client</code> 没有缓存注册表的话，会从 <code>Eureka Server</code> 获取最新的注册表</p>
<p><strong>同步状态</strong><br><code>Eureka Client</code> 通过注册、心跳机制和 <code>Eureka Server</code> 同步当前客户端的状态。</p>
<p><strong>Eureka Client：注册中心客户端</strong><br><code>Eureka Client</code> 是一个 <code>Java</code> 客户端，用于简化与 <code>Eureka Server</code> 的交互。<code>Eureka Client</code> 会拉取、更新和缓存 <code>Eureka Server</code> 中的信息。因此当所有的 <code>Eureka Server</code> 节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者，但是当服务有更改的时候会出现信息不一致。</p>
<p><strong>Register: 服务注册</strong><br>服务的提供者，将自身注册到注册中心，服务提供者也是一个 <code>Eureka Client</code>。当 <code>Eureka Client</code> 向 <code>Eureka Server</code> 注册时，它提供自身的元数据，比如 IP 地址、端口，运行状况指示符 URL，主页等。</p>
<p><strong>Renew: 服务续约</strong><br><code>Eureka Client</code> 会每隔 30 秒发送一次心跳来续约。 通过续约来告知 <code>Eureka Server</code> 该 <code>Eureka Client</code> 运行正常，没有出现问题。 默认情况下，如果 <code>Eureka Server</code> 在 90 秒内没有收到 <code>Eureka Client</code> 的续约，<code>Server</code> 端会将实例从其注册表中删除，此时间可配置，一般情况不建议更改。</p>
<p><strong>服务续约的两个重要属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务续约任务的调用间隔时间，默认为<span class="number">30</span>秒</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=<span class="number">30</span></span><br><span class="line"></span><br><span class="line">服务失效的时间，默认为<span class="number">90</span>秒。</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=<span class="number">90</span></span><br></pre></td></tr></table></figure>

<p><strong>Eviction 服务剔除</strong><br>当 <code>Eureka Client</code> 和 <code>Eureka Server</code> 不再有心跳时，<code>Eureka Server</code> 会将该服务实例从服务注册列表中删除，即服务剔除。</p>
<p><strong>Cancel: 服务下线</strong><br><code>Eureka Client</code> 在程序关闭时向 <code>Eureka Server</code> 发送取消请求。 发送请求后，该客户端实例信息将从 <code>Eureka Server</code> 的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryManager.getInstance().shutdownComponent()；</span><br></pre></td></tr></table></figure>

<p><strong>GetRegisty: 获取注册列表信息</strong><br><code>Eureka Client</code> 从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 <code>Eureka Client</code> 的缓存信息不同，<code>Eureka Client</code> 自动处理。</p>
<p>如果由于某种原因导致注册列表信息不能及时匹配，<code>Eureka Client</code> 则会重新获取整个注册表信息。 <code>Eureka Server</code> 缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。<code>Eureka Client</code> 和 <code>Eureka Server</code> 可以使用 <code>JSON/XML</code> 格式进行通讯。在默认情况下 <code>Eureka Client</code> 使用压缩 <code>JSON</code> 格式来获取注册列表的信息。</p>
<p><strong>获取服务是服务消费者的基础，所以必有两个重要参数需要注意：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 启用服务消费者从注册中心拉取服务列表的功能</span><br><span class="line">eureka.client.fetch-registry=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"># 设置服务消费者从注册中心拉取服务列表的间隔</span><br><span class="line">eureka.client.registry-fetch-interval-seconds=<span class="number">30</span></span><br></pre></td></tr></table></figure>

<p><strong>Remote Call: 远程调用</strong><br>当 <code>Eureka Client</code> 从注册中心获取到服务提供者信息后，就可以通过 <code>Http</code> 请求调用对应的服务；服务提供者有多个时，<code>Eureka Client</code> 客户端会通过 <code>Ribbon</code> 自动进行负载均衡。</p>
<h4 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h4><p>默认情况下，如果 <code>Eureka Server</code> 在一定的 90s 内没有接收到某个微服务实例的心跳，会注销该实例。但是在微服务架构下服务之间通常都是跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，网络分区故障，导致此实例被注销。</p>
<p>固定时间内大量实例被注销，可能会严重威胁整个微服务架构的可用性。为了解决这个问题，<code>Eureka</code> 开发了自我保护机制，那么什么是自我保护机制呢？</p>
<p><code>Eureka Server</code> 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，<code>Eureka Server</code> 即会进入自我保护机制。</p>
<p><strong>Eureka Server 触发自我保护机制后，页面会出现提示：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190703103514416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F3ZTg2MzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>Eureka Server 进入自我保护机制，会出现以下几种情况：</strong></p>
<ul>
<li>(1) <code>Eureka</code> 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li>
<li>(2)<code>Eureka</code> 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</li>
<li>(3)当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li>
</ul>
<p><code>Eureka</code> 自我保护机制是为了防止误杀服务而提供的一个机制。当个别客户端出现心跳失联时，则认为是客户端的问题，剔除掉客户端；当 <code>Eureka</code> 捕获到大量的心跳失败时，则认为可能是网络问题，进入自我保护机制；当客户端心跳恢复时，<code>Eureka</code> 会自动退出自我保护机制。</p>
<p>如果在保护期内刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，即会调用失败。对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。</p>
<p><strong>通过在 Eureka Server 配置如下参数，开启或者关闭保护机制，生产环境建议打开：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.server.enable-self-preservation=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="Eureka-集群原理"><a href="#Eureka-集群原理" class="headerlink" title="Eureka 集群原理"></a>Eureka 集群原理</h4><p>再来看看 Eureka 集群的工作原理。我们假设有三台 <code>Eureka Server</code> 组成的集群，第一台 <code>Eureka Server</code> 在北京机房，另外两台 <code>Eureka Server</code> 在深圳和西安机房。这样三台 <code>Eureka Server</code> 就组建成了一个跨区域的高可用集群，只要三个地方的任意一个机房不出现问题，都不会影响整个架构的稳定性。</p>
<p><img src="http://static.cyblogs.com/20190703103823398.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;20190703103823398.png"></p>
<p>从图中可以看出 <code>Eureka Server</code> 集群相互之间通过 <code>Replicate</code> 来同步数据，相互之间不区分主节点和从节点，所有的节点都是平等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的 <code>serviceUrl</code> 指向其他节点。</p>
<p>如果某台 <code>Eureka Server</code> 宕机，<code>Eureka Client</code> 的请求会自动切换到新的 <code>Eureka Server</code> 节点。当宕机的服务器重新恢复后，<code>Eureka</code> 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它 <code>Eureka Server</code> 当前所知的所有节点中。</p>
<p>另外 <code>Eureka Server</code> 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个 <code>Eureka Server</code> 同时也是 <code>Eureka Client</code>，多个 <code>Eureka Server</code> 之间通过 <code>P2P</code> 的方式完成服务注册表的同步。</p>
<p><code>Eureka Server</code> 集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。</p>
<p><strong>Eureka 分区</strong><br><code>Eureka</code> 提供了 <code>Region</code> 和 <code>Zone</code> 两个概念来进行分区，这两个概念均来自于亚马逊的 <code>AWS</code>:</p>
<ul>
<li>region：可以理解为地理上的不同区域，比如亚洲地区，中国区或者深圳等等。没有具体大小的限制。根据项目具体的情况，可以自行合理划分 region。</li>
<li>zone：可以简单理解为 region 内的具体机房，比如说 region 划分为深圳，然后深圳有两个机房，就可以在此 region 之下划分出 zone1、zone2 两个 zone。</li>
</ul>
<p>上图中的 <code>us-east-1c</code>、<code>us-east-1d</code>、<code>us-east-1e</code> 就代表了不同的 <code>Zone</code>。<code>Zone</code> 内的 <code>Eureka Client</code> 优先和 <code>Zone</code> 内的 <code>Eureka Server</code> 进行心跳同步，同样调用端优先在 <code>Zone</code> 内的 <code>Eureka Server</code> 获取服务列表，当 <code>Zone</code> 内的 <code>Eureka Server</code> 挂掉之后，才会从别的 <code>Zone</code> 中获取信息。</p>
<p><strong>Eurka 保证 AP</strong></p>
<p><code>Eureka Server</code> 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 <code>Eureka Client</code> 在向某个 <code>Eureka</code> 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台 <code>Eureka Server</code> 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p>
<h4 id="Eurka-工作流程"><a href="#Eurka-工作流程" class="headerlink" title="Eurka 工作流程"></a>Eurka 工作流程</h4><p>了解完 <code>Eureka</code> 核心概念，自我保护机制，以及集群内的工作原理后，我们来整体梳理一下 <code>Eureka</code> 的工作流程：</p>
<p>1、<code>Eureka Server</code> 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 <code>Replicate</code> 同步注册表，每个 <code>Eureka Server</code> 都存在独立完整的服务注册表信息</p>
<p>2、<code>Eureka Client</code> 启动时根据配置的 <code>Eureka Server</code> 地址去注册中心注册服务</p>
<p>3、<code>Eureka Client</code> 会每 30s 向 <code>Eureka Server</code> 发送一次心跳请求，证明客户端服务正常</p>
<p>4、当 <code>Eureka Server</code> 90s 内没有收到 <code>Eureka Client</code> 的心跳，注册中心则认为该节点失效，会注销该实例</p>
<p>5、单位时间内 <code>Eureka Server</code> 统计到有大量的 <code>Eureka Client</code> 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端</p>
<p>6、当 <code>Eureka Client</code> 心跳请求恢复正常之后，<code>Eureka Server</code> 自动退出自我保护模式</p>
<p>7、<code>Eureka Client</code> 定时全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地</p>
<p>8、服务调用时，<code>Eureka Client</code> 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存</p>
<p>9、<code>Eureka Client</code> 获取到目标服务器信息，发起服务调用</p>
<p>10、<code>Eureka Client</code> 程序关闭时向 <code>Eureka Server</code> 发送取消请求，<code>Eureka Server</code> 将实例从注册表中删除</p>
<p>讲了 <code>Eureka</code> 核心概念、<code>Eureka</code> 自我保护机制和 <code>Eureka</code> 集群原理。通过分析 <code>Eureka</code> 工作原理，我可以明显地感觉到 <code>Eureka</code> 的设计之巧妙，通过一些列的机制，完美地解决了注册中心的稳定性和高可用性。</p>
<p><code>Eureka</code> 为了保障注册中心的高可用性，容忍了数据的非强一致性，服务节点间的数据可能不一致， <code>Client-Server</code> 间的数据可能不一致。比较适合跨越多机房、对注册中心服务可用性要求较高的使用场景。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qwe86314/article/details/94552801">https://blog.csdn.net/qwe86314/article/details/94552801</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/07/30/2020/07/%E4%BB%80%E4%B9%88%E8%83%BD%E5%8A%9B%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%BD%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E5%8D%B4%E6%B2%A1%E6%9C%89%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/30/2020/07/%E4%BB%80%E4%B9%88%E8%83%BD%E5%8A%9B%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%BD%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E5%8D%B4%E6%B2%A1%E6%9C%89%EF%BC%9F/" class="post-title-link" itemprop="url">什么能力很重要，但大多数人却没有？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-30 00:00:00" itemprop="dateCreated datePublished" datetime="2020-07-30T00:00:00+08:00">2020-07-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:58:47" itemprop="dateModified" datetime="2025-06-25T09:58:47+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9A%8F%E6%84%9F/" itemprop="url" rel="index"><span itemprop="name">随感</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="深度阅读的能力"><a href="#深度阅读的能力" class="headerlink" title="深度阅读的能力"></a>深度阅读的能力</h4><p>我敢保证，看完这个回答之前，就有很多人会划走。</p>
<p>这绝逼不是因为我这个回答写的太无趣，或者他们不同意我的某些观点，而是因为——<strong>他们看什么东西都是这样。</strong></p>
<p>他们根本不能沉浸式的阅读什么东西，一般超过几百字的内容就很少看了，除非是小黄文和超能力爽文。他们做的最多的是浮皮潦草的刷刷抖音、看看段子，稍微有点复杂的电影都看不下去，更何况那些晦涩枯燥的工具书了。</p>
<p>我不能说知乎用户就比抖音用户牛逼，但是经过我这些年的学习和生活，我发现能够全神贯注的阅读长篇文字，本身就是很强的一种能力，它能够轻而易举的影响到我们的学习效果和工作效果，它关乎到我们的注意力、记忆力、逻辑思维能力和理解能力。</p>
<p>你信也好，你不信也罢，越看书就会越聪明，一直看爽文、肥皂剧、抖音就会变得不善思考。</p>
<h4 id="自我认知能力"><a href="#自我认知能力" class="headerlink" title="自我认知能力"></a>自我认知能力</h4><p>不要觉得这个能力很菜，真没几个人有。</p>
<p>不服你可以冷静下来想想，你真的了解你自己么？你真的知道你自己在这个社会中处于怎样的一个阶层和水平么？如果你觉得你都了解，那我再问你一句，<strong>你的这些认知，都来源于哪里？</strong></p>
<p>其实你对自己的评价往往都来源于他人对你的反馈，所以人其实是很容易被环境和他人的评价所左右的，不要觉得你不可能进入传销，当你周围的环境和人全都变了，你得到的反馈就完全乱了，你自己就会失去对自己的认知。</p>
<p>而更值得注意的是，很多人并没有进入什么传销组织，但是却在他人的吹捧之中失去了对自己的判断，很多商家就是利用这一点，忽悠了不知多少人前赴后继的去送钱。</p>
<h4 id="持久且专注的坚持做一件事的能力"><a href="#持久且专注的坚持做一件事的能力" class="headerlink" title="持久且专注的坚持做一件事的能力"></a>持久且专注的坚持做一件事的能力</h4><p>其实这世界上绝大多数对未来很有意义的事情，短期内往往不会看到成效。比如健身、读书、早睡早起。你健身一天不会有八块腹肌，读一本书不能洞悉人性，早睡早起一天也不能容光焕发。</p>
<p>这些从长期看来对一个人有利的行为，不会像你刷抖音、看段子一样，短短一两分钟内就能够带给你刺激的感觉。</p>
<p>而且我相信所有的人都知道读书有好处，但问题就是读一本往往看不到效果，所以我一直觉得牛逼的人和普通人之间最大的差距就是——<strong>牛逼的人能在看不到回馈的情况下继续坚持下去，持续且专注的坚持下去。</strong></p>
<p>对于99%的普通人来说，长期执着于一件事，持续深耕，五年十年后，你就会得到巨大的回报，并且成为这个领域的专家。</p>
<h4 id="控制情绪的能力"><a href="#控制情绪的能力" class="headerlink" title="控制情绪的能力"></a>控制情绪的能力</h4><p>每个人的生活中，都有一大半决策是在情绪的影响下做出的，而且往往这样做出的决策都不是最佳决策。只要你能在情绪失控的时候，提醒自己不要做出决策，让自己平复一下，就能解决很多麻烦事儿。</p>
<p>生而为人，必然有很多事情让你很愤怒、很悲伤、很焦躁，但是我想说的是，你要学会别跟自己过不去，让自己活的轻松点！</p>
<p>这本身就是很强悍的一种能力，会影响自己的生活，并影响身边人对你的看法。</p>
<h4 id="掌控自己欲望的能力"><a href="#掌控自己欲望的能力" class="headerlink" title="掌控自己欲望的能力"></a>掌控自己欲望的能力</h4><p>很多人都以为自律是限制自己的欲望，据我所知，恰恰相反，自律应该是更好的分配自己的欲望。</p>
<p>你觉得健身的人是没有食欲的人么？错了，他们只是为了满足自己“拥有好身材”的长期欲望而放弃了满足眼前美食的欲望而已。</p>
<p>所以一个真正长期自律的人实际上就是对自己欲望进行更好的规划的分配的人。</p>
<h4 id="用语言表达自己思想的能力"><a href="#用语言表达自己思想的能力" class="headerlink" title="用语言表达自己思想的能力"></a>用语言表达自己思想的能力</h4><p>知乎有一个很重要的特点就是会把质量好的回答都排在前面，你看多了就会觉得所有的人都很牛逼，但是你可以做这么一个实验：</p>
<p>先给我这个回答点个赞（别走丢了），然后随便翻几个情感、生活类的大问题，几千个回答的那种，按时间排序，再找找那些0赞的回答看一下，长长一段文字，要么在写自己家里的琐事，要么是生活中遇到的不良情绪，要么试图用自己蹩脚的生活经验来总结人生的大道理，读完以后再回来看看我这个回答我自己都觉得我是个大文豪。</p>
<p>不光如此，就连一个简单的提问，很多人也能问的乱七八糟，完全没有逻辑顺序，描述抓不住重点，最后连自己想要问什么都说不明白。</p>
<p>连话都说不明白，你说还谈什么能力？</p>
<h4 id="共情能力"><a href="#共情能力" class="headerlink" title="共情能力"></a>共情能力</h4><p>为什么经常有人会被说情商低？据我所知不是因为他们脑子笨或者不会说话，本质上是因为<strong>他不能体会到对方的情绪和感觉</strong>，不能通过对方的描述、表情、动作而产生共情。</p>
<p>你说人家在那儿跟你诉着苦，说的就差哭出来了，你突然get到了笑点，对着别人哈哈大笑，你说这是不是缺？</p>
<p>你女朋友含情脉脉的看着你，说她冷，结果你说，“活该，谁让你穿那么点，瞅你冻得那逼出”，我就问你抗不抗揍吧。</p>
<h4 id="不要脸的能力"><a href="#不要脸的能力" class="headerlink" title="不要脸的能力"></a>不要脸的能力</h4><p>别觉得这不算什么能力，我很严肃的告诉你，这能力特别牛逼，而且非常重要。</p>
<p>不要脸这个词，表面上是骂人，其实你仔细想想，这里面还包含了一个人对外界评判的不在意，对别人眼光的不care，甚至还能够体现出一个人的大局观。</p>
<p>你有多少次想跟领导去提要求最后却打了退堂鼓？你有多少次内心一万只草泥马奔腾而过但是嘴上却答应了别人的请求？你有多少次因为对方说咱们这么好的交情而抹不开面子？</p>
<p>多少因为面子天天加班的，因为面子【顺路】帮别人送东西的，因为面子给别人办事儿丢了饭碗的，还有因为面子借给别人钱要不回来的。</p>
<h4 id="接纳不同观点的能力"><a href="#接纳不同观点的能力" class="headerlink" title="接纳不同观点的能力"></a>接纳不同观点的能力</h4><p>你有没有想过，为什么现在满大街都是教别人说话的和提高情商的书籍？但是却没有多少书是教人说大实话的？</p>
<p><strong>因为很多人根本就听不下那些难听的大实话！</strong></p>
<p>哪怕你是真的为他好，他也不爱听。</p>
<p>比如一个女生要买一件衣服，你觉得很难看，她穿上以后像块被马蹄子踩了的奶油蛋糕，但是她自己还觉得自己美美哒。</p>
<p>如果她能心平气和的接纳你的不同观点，显然对她有好处，她就不至于买那么难看的衣服，不至于乱花钱。</p>
<p>但事实是大部分人总是先入为主，根本听不进去不同观点，别人的好言相劝大多都被当做情商低和柠檬精。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/305507128/answer/1073167931">https://www.zhihu.com/question/305507128/answer/1073167931</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/06/07/2020/06/3%E7%A7%8Dweb%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/07/2020/06/3%E7%A7%8Dweb%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">3种web会话管理的方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-07T00:00:00+08:00">2020-06-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:58:47" itemprop="dateModified" datetime="2025-06-25T09:58:47+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>http</code> 是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道 <code>http</code> 请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。本文总结了 3 种常见的实现 <code>web</code> 应用会话管理的方式：</p>
<p>1）基于 <code>server</code> 端 <code>session</code> 的管理方式</p>
<p>2）<code>cookie-base</code> 的管理方式</p>
<p>3）<code>token-base</code> 的管理方式</p>
<p>这些内容可以帮助加深对 <code>web</code> 中用户登录机制的理解，对实际项目开发也有参考价值，欢迎阅读与指正。</p>
<h4 id="1-基于-server-端-session-的管理"><a href="#1-基于-server-端-session-的管理" class="headerlink" title="1. 基于 server 端 session 的管理"></a>1. 基于 server 端 session 的管理</h4><p>在早期 <code>web</code> 应用中，通常使用服务端 <code>session</code> 来管理用户的会话。快速了解服务端 <code>session</code>:</p>
<ol>
<li>服务端 <code>session</code> 是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个 <code>session</code> 都分配一个唯一的 <code>sessionid</code>，以保证每个用户都有一个不同的 <code>session</code> 对象。</li>
</ol>
<p>2）服务器在创建完 <code>session</code> 后，会把 <code>sessionid</code> 通过 <code>cookie</code> 返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过 <code>cookie</code> 把 <code>sessionid</code> 传回给服务器，以便服务器能够根据 <code>sessionid</code> 找到与该用户对应的 <code>session</code> 对象。</p>
<p>3）<code>session</code> 通常有失效时间的设定，比如 2 个小时。当失效时间到，服务器会销毁之前的 <code>session</code>，并创建新的 <code>session</code> 返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的 <code>session</code> 的失效时间根据当前的请求时间再延长 2 个小时。</p>
<p>4）<code>session</code> 在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往 <code>sesssion</code> 对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的 <code>session</code> 对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的 <code>session</code> 对象里的登录凭证清掉。所以在用户登录前或退出后或者 <code>session</code> 对象失效时，肯定都是拿不到需要的登录凭证的。</p>
<p>以上过程可简单使用流程图描述如下：</p>
<p><img src="http://static.cyblogs.com/459873-20161115231400951-1095594983.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;459873-20161115231400951-1095594983.png"></p>
<p>主流的 <code>web</code> 开发平台（<code>java</code>,<code>.net</code>,<code>php</code>）都原生支持这种会话管理的方式，而且开发起来很简单，相信大部分后端开发人员在入门的时候都了解并使用过它。它还有一个比较大的优点就是安全性好，因为在浏览器端与服务器端保持会话状态的媒介始终只是一个 <code>sessionid</code> 串，只要这个串够随机，攻击者就不能轻易冒充他人的 <code>sessionid</code> 进行操作；除非通过 <code>CSRF</code> 或 <code>http</code> 劫持的方式，才有可能冒充别人进行操作；即使冒充成功，也必须被冒充的用户 <code>session</code> 里面包含有效的登录凭证才行。但是在真正决定用它管理会话之前，也得根据自己的应用情况考虑以下几个问题：</p>
<p>1）这种方式将会话信息存储在 <code>web</code> 服务器里面，所以在用户同时在线量比较多时，这些会话信息会占据比较多的内存；</p>
<p>2）当应用采用集群部署的时候，会遇到多台 <code>web</code> 服务器之间如何做 <code>session</code> 共享的问题。因为 <code>session</code> 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 <code>session</code> 的服务器，这样他就拿不到之前已经放入到 <code>session</code> 中的登录凭证之类的信息了；</p>
<p>3）多个应用要共享 <code>session</code> 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 <code>cookie</code> 跨域的处理。</p>
<p>针对问题 1 和问题 2，我见过的解决方案是采用 <code>redis</code> 这种中间服务器来管理 <code>session</code> 的增删改查，一来减轻 <code>web</code> 服务器的负担，二来解决不同 web 服务器共享 <code>session</code> 的问题。针对问题 3，由于服务端的 <code>session</code> 依赖 <code>cookie</code> 来传递 <code>sessionid</code>，所以在实际项目中，只要解决各个项目里面如何实现 <code>sessionid</code> 的 <code>cookie</code> 跨域访问即可，这个是可以实现的，就是比较麻烦，前后端有可能都要做处理。</p>
<p>如果不考虑以上三个问题，这种管理方式比较值得使用，尤其是一些小型的 <code>web</code> 应用。但是一旦应用将来有扩展的必要，那就得谨慎对待前面的三个问题。如果真要在项目中使用这种方式，推荐结合单点登录框架如 <code>CAS</code> 一起用，这样会使应用的扩展性更强。</p>
<h4 id="2-cookie-based-的管理方式"><a href="#2-cookie-based-的管理方式" class="headerlink" title="2. cookie-based 的管理方式"></a>2. cookie-based 的管理方式</h4><p>由于前一种方式会增加服务器的负担和架构的复杂性，所以后来就有人想出直接把用户的登录凭证直接存到客户端的方案，当用户登录成功之后，把登录凭证写到 <code>cookie</code> 里面，并给 <code>cookie</code> 设置有效期，后续请求直接验证存有登录凭证的 <code>cookie</code> 是否存在以及凭证是否有效，即可判断用户的登录状态。使用它来实现会话管理的整体流程如下：</p>
<p>1）用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户 id，凭证创建时间和过期时间三个值。</p>
<p>2）服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入 <code>cookie</code>。<code>cookie</code> 的名字必须固定（如 <code>ticket</code>），因为后面再获取的时候，还得根据这个名字来获取 cookie 值。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止 <code>cookie</code> 被别人截取的时候，无法轻易读到其中的用户信息。</p>
<p>3）用户登录后发起后续请求，服务端根据上一步存登录凭证的 <code>cookie</code> 名字，获取到相关的 <code>cookie</code> 值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。</p>
<p><img src="http://static.cyblogs.com/459873-20161120210043123-760641758.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;459873-20161120210043123-760641758.png"></p>
<p>这种方式最大的优点就是实现了服务端的无状态化，彻底移除了服务端对会话的管理的逻辑，服务端只需要负责创建和验证登录 <code>cookie</code> 即可，无需保持用户的状态信息。对于第一种方式的第二个问题，用户会话信息共享的问题，它也能很好解决：因为如果只是同一个应用做集群部署，由于验证登录凭证的代码都是一样的，所以不管是哪个服务器处理用户请求，总能拿到 <code>cookie</code> 中的登录凭证来进行验证；如果是不同的应用，只要每个应用都包含相同的登录逻辑，那么他们也是能轻易实现会话共享的，不过这种情况下，登录逻辑里面数字签名以及加密解密要用到的密钥文件或者密钥串，需要在不同的应用里面共享，总而言之，就是需要算法完全保持一致。</p>
<p>这种方式由于把登录凭证直接存放客户端，并且需要 <code>cookie</code> 传来传去，所以它的缺点也比较明显：</p>
<p>1）<code>cookie</code> 有大小限制，存储不了太多数据，所以要是登录凭证存的消息过多，导致加密签名后的串太长，就会引发别的问题，比如其它业务场景需要 <code>cookie</code> 的时候，就有可能没那么多空间可用了；所以用的时候得谨慎，得观察实际的登录 <code>cookie</code> 的大小；比如太长，就要考虑是非是数字签名的算法太严格，导致签名后的串太长，那就适当调整签名逻辑；比如如果一开始用 <code>4096</code> 位的 <code>RSA</code> 算法做数字签名，可以考虑换成 <code>1024</code>、<code>2048</code> 位；</p>
<p>2）每次传送 <code>cookie</code>，增加了请求的数量，对访问性能也有影响；</p>
<p>3）也有跨域问题，毕竟还是要用 <code>cookie</code>。</p>
<p>相比起第一种方式，<code>cookie-based</code> 方案明显还是要好一些，目前好多 <code>web</code> 开发平台或框架都默认使用这种方式来做会话管理，比如 <code>php</code> 里面 <code>yii</code> 框架，这是我们团队后端目前用的，它用的就是这个方案，以上提到的那些登录逻辑，框架也都已经封装好了，实际用起来也很简单；<code>asp.net</code> 里面 <code>forms</code> 身份认证，也是这个思路，这里有一篇好文章把它的实现细节都说的很清楚：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html">http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html</a></p>
<p>前面两种会话管理方式因为都用到 <code>cookie</code>，不适合用在 <code>native app</code> 里面：<code>native app</code> 不好管理 <code>cookie</code>，毕竟它不是浏览器。这两种方案都不适合用来做纯 <code>api</code> 服务的登录认证。要实现 api 服务的登录认证，就要考虑下面要介绍的第三种会话管理方式。</p>
<h4 id="3-token-based-的管理方式"><a href="#3-token-based-的管理方式" class="headerlink" title="3. token-based 的管理方式"></a>3. token-based 的管理方式</h4><p>这种方式从流程和实现上来说，跟 <code>cookie-based</code> 的方式没有太多区别，只不过 <code>cookie-based</code> 里面写到 <code>cookie</code> 里面的 <code>ticket</code> 在这种方式下称为 <code>token</code>，这个 <code>token</code> 在返回给客户端之后，后续请求都必须通过 <code>url</code> 参数或者是 <code>http header</code> 的形式，主动带上 <code>token</code>，这样服务端接收到请求之后就能直接从 <code>http header</code> 或者 <code>url</code> 里面取到 <code>token</code> 进行验证：</p>
<p><img src="http://static.cyblogs.com/459873-20161120210044154-648255641.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;459873-20161120210044154-648255641.png"></p>
<p>这种方式不通过 <code>cookie</code> 进行 <code>token</code> 的传递，而是每次请求的时候，主动把 <code>token</code> 加到 <code>http header</code> 里面或者 <code>url</code> 后面，所以即使在 <code>native app</code> 里面也能使用它来调用我们通过 <code>web</code> 发布的 <code>api</code> 接口。<code>app</code> 里面还要做两件事情：</p>
<p>1）有效存储 <code>token</code>，得保证每次调接口的时候都能从同一个位置拿到同一个 <code>token</code>；</p>
<p>2）每次调接口的的代码里都得把 <code>token</code> 加到 <code>header</code> 或者接口地址里面。</p>
<p>看起来麻烦，其实也不麻烦，这两件事情，对于 <code>app</code> 来说，很容易做到，只要对接口调用的模块稍加封装即可。</p>
<p>这种方式同样适用于网页应用，<code>token</code> 可以存于 <code>localStorage</code> 或者 <code>sessionStorage</code> 里面，然后每发 <code>ajax</code> 请求的时候，都把 <code>token</code> 拿出来放到 <code>ajax</code> 请求的 <code>header</code> 里即可。不过如果是非接口的请求，比如直接通过点击链接请求一个页面这种，是无法自动带上 <code>token</code> 的。所以这种方式也仅限于走纯接口的 <code>web</code> 应用。</p>
<p>这种方式用在 <code>web</code> 应用里也有跨域的问题，比如应用如果部署在 <code>a.com</code>，<code>api</code> 服务部署在 <code>b.com</code>，从 <code>a.com</code> 里面发出 <code>ajax</code> 请求到 <code>b.com</code>，默认情况下是会报跨域错误的，这种问题可以用 <code>CORS</code>（<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享</a>）的方式来快速解决，相关细节可去阅读前面给出的 <code>CORS</code> 文章详细了解。</p>
<p>这种方式跟 <code>cookie-based</code> 的方式同样都还有的一个问题就是 <code>ticket</code> 或者 <code>token</code> 刷新的问题。有的产品里面，你肯定不希望用户登录后，操作了半个小时，结果 <code>ticket</code> 或者 <code>token</code> 到了过期时间，然后用户又得去重新登录的情况出现。这个时候就得考虑 <code>ticket</code> 或 <code>token</code> 的自动刷新的问题，简单来说，可以在验证 <code>ticket</code> 或 <code>token</code> 有效之后，自动把 <code>ticket</code> 或 <code>token</code> 的失效时间延长，然后把它再返回给客户端；客户端如果检测到服务器有返回新的 <code>ticket</code> 或 <code>token</code>，就替换原来的 <code>ticket</code> 或 <code>token</code>。</p>
<h4 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4. 安全问题"></a>4. 安全问题</h4><p>在 <code>web</code> 应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。</p>
<p>首先从会话管理凭证来说，第一种方式的会话凭证仅仅是一个 <code>session id</code>，所以只要这个 <code>session id</code> 足够随机，而不是一个自增的数字 <code>id</code> 值，那么其它人就不可能轻易地冒充别人的 <code>session id</code> 进行操作；第二种方式的凭证（ticket）以及第三种方式的凭证（<code>token</code>）都是一个在服务端做了数字签名，和加密处理的串，所以只要密钥不泄露，别人也无法轻易地拿到这个串中的有效信息并对它进行篡改。总之，这三种会话管理方式的凭证本身是比较安全的。</p>
<p>然后从客户端和服务端的 <code>http</code> 过程来说，当别人截获到客户端请求中的会话凭证，就能拿这个凭证冒充原用户，做一些非法操作，而服务器也认不出来。这种安全问题，可以简单采用 <code>https</code> 来解决，虽然可能还有 <code>http</code> 劫持这种更高程度的威胁存在，但是我们从代码能做的防范，确实也就是这个层次了。</p>
<p>最后的安全问题就是 <code>CSRF</code>（跨站请求伪造）。这个跟代码有很大关系，本质上它就是代码的漏洞，只不过一般情况下这些漏洞，作为开发人员都不容易发现，只有那些一门心思想搞些事情的人才会专门去找这些漏洞，所以这种问题的防范更多地还是依赖于开发人员对这种攻击方式的了解，包括常见的攻击形式和应对方法。不管凭证信息本身多么安全，别人利用 <code>CSRF</code>，就能拿到别人的凭证，然后用它冒充别人进行非法操作，所以有时间还真得多去了解下它的相关资料才行。举例来说，假如我们把凭证直接放到 url 后面进行传递，就有可能成为一个 <code>CSRF</code> 的漏洞：当恶意用户在我们的应用内上传了 1 张引用了他自己网站的图片，当正常的用户登录之后访问的页面里面包含这个图片的时候，由于这个图片加载的时候会向恶意网站发送 <code>get</code> 请求；当恶意网站收到请求的时候，就会从这个请求的 <code>Reffer header</code> 里面看到包含这个图片的页面地址，而这个地址正好包含了正常用户的会话凭证；于是恶意用户就拿到了正常用户的凭证；只要这个凭证还没失效，他就能用它冒充用户进行非法操作。</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p>前面这三种方式，各自有各自的优点及使用场景，我觉得没有哪个是最好的，做项目的时候，根据项目将来的扩展情况和架构情况，才能决定用哪个是最合适的。本文的目的也就是想介绍这几种方式的原理，以便掌握 web 应用中登录验证的关键因素。</p>
<p>作为一个前端开发人员，本文虽然介绍了 3 种会话管理的方式，但是与前端关系最紧密的还是第三种方式，毕竟现在前端开发 <code>SPA</code> 应用以及 <code>hybrid</code> 应用已经非常流行了，所以掌握好这个方式的认证过程和使用方式，对前端来说，显然是很有帮助的。好在这个方式的技术其实早就有很多实现了，而且还有现成的标准可用，这个标准就是 <code>JWT(json-web-token)</code>。</p>
<p><code>JWT</code> 本身并没有做任何技术实现，它只是定义了 <code>token-based</code> 的管理方式该如何实现，它规定了 <code>token</code> 的应该包含的标准内容以及 <code>token</code> 的生成过程和方法。目前实现了这个标准的技术已经有非常多：</p>
<p><img src="http://static.cyblogs.com/459873-20161120210045904-1163191341.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;459873-20161120210045904-1163191341.png"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lyzg/p/6067766.html">https://www.cnblogs.com/lyzg/p/6067766.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/06/06/2020/06/Spring%20Bean%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/06/2020/06/Spring%20Bean%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F/" class="post-title-link" itemprop="url">Spring Bean解决循环依赖为什么是三级缓存？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-06 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-06T00:00:00+08:00">2020-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>循环依赖：就是N个类循环(嵌套)引用</strong>。 通俗的讲就是N个Bean互相引用对方，最终形成<code>闭环</code>。用一副经典的图示可以表示成这样（A、B、C都代表对象，虚线代表引用关系）： </p>
<p><img src="http://static.cyblogs.com/mxuio3xfqc.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;mxuio3xfqc.png"></p>
<blockquote>
<p> 注意：其实可以N&#x3D;1，也就是极限情况的循环依赖：<code>自己依赖自己</code> </p>
<p> 另需注意：这里指的循环引用不是方法之间的循环调用，<strong>而是对象的相互依赖关系</strong>。（方法之间循环调用若有出口也是能够正常work的） </p>
</blockquote>
<p>可以设想一下这个场景：如果在日常开发中我们用new对象的方式，若构造函数之间发生这种<strong>循环依赖</strong>的话，程序会在运行时一直循环调用<strong>最终导致内存溢出</strong>，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>

<p>这是一个典型的循环依赖问题。本文说一下<code>Spring</code>是如果巧妙的解决平时我们会遇到的<code>三大循环依赖问题</code>的~</p>
<h4 id="Spring-Bean的循环依赖"><a href="#Spring-Bean的循环依赖" class="headerlink" title="Spring Bean的循环依赖"></a>Spring Bean的循环依赖</h4><p>谈到<code>Spring Bean</code>的循环依赖，有的小伙伴可能比较陌生，毕竟开发过程中好像对<code>循环依赖</code>这个概念<strong>无感知</strong>。其实不然，你有这种错觉，权是因为你工作在Spring的<code>襁褓</code>中，从而让你“高枕无忧”~ <strong>我十分坚信，小伙伴们在平时业务开发中一定一定写过如下结构的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其实就是Spring环境下典型的循环依赖场景。但是很显然，这种循环依赖场景，Spring已经完美的帮我们解决和规避了问题。所以即使平时我们这样循环引用，也能够整成进行我们的coding之旅~</p>
<h5 id="Spring中三大循环依赖场景演示"><a href="#Spring中三大循环依赖场景演示" class="headerlink" title="Spring中三大循环依赖场景演示"></a>Spring中<code>三大循环依赖场景</code>演示</h5><p>在Spring环境中，因为我们的Bean的实例化、初始化都是交给了容器，因此它的循环依赖主要表现为下面三种场景。为了方便演示，我准备了如下两个类： </p>
<h6 id="1、构造器注入循环依赖"><a href="#1、构造器注入循环依赖" class="headerlink" title="1、构造器注入循环依赖"></a>1、构造器注入循环依赖</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：项目启动失败抛出异常<code>BeanCurrentlyInCreationException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">&#x27;a&#x27;</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.beforeSingletonCreation(DefaultSingletonBeanRegistry.java:<span class="number">339</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">215</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">318</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">199</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 构造器注入构成的循环依赖，此种循环依赖方式<strong>是无法解决的</strong>，只能抛出<code>BeanCurrentlyInCreationException</code>异常表示循环依赖。这也是构造器注入的最大劣势（它有很多独特的优势，请小伙伴自行发掘） </p>
<p> <code>根本原因</code>：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是<code>已经实例化</code>，但还没初始化的状态。而构造器是完成实例化的东东，所以构造器的循环依赖无法解决~~~ </p>
</blockquote>
<h6 id="2、field属性注入（setter方法注入）循环依赖"><a href="#2、field属性注入（setter方法注入）循环依赖" class="headerlink" title="2、field属性注入（setter方法注入）循环依赖"></a>2、field属性注入（setter方法注入）循环依赖</h6><p>这种方式是我们<strong>最最最最</strong>为常用的依赖注入方式（所以猜都能猜到它肯定不会有问题啦）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：项目启动成功，能够正常work</strong></p>
<blockquote>
<p> 备注：setter方法注入方式因为原理和字段注入方式类似，此处不多加演示 </p>
</blockquote>
<h6 id="3、prototype-field属性注入循环依赖"><a href="#3、prototype-field属性注入循环依赖" class="headerlink" title="3、prototype field属性注入循环依赖"></a>3、<code>prototype</code> field属性注入循环依赖</h6><p><code>prototype</code>在平时使用情况较少，但是也并不是不会使用到，因此此种方式也需要引起重视。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<strong>需要注意的是</strong>本例中<strong>启动时是不会报错的</strong>（因为非单例Bean<code>默认</code>不会初始化，而是使用时才会初始化），所以很简单咱们只需要手动<code>getBean()</code>或者在一个单例Bean内<code>@Autowired</code>一下它即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单例Bean内注入</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> A a;</span><br></pre></td></tr></table></figure>

<p>这样子启动就报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;mytest.TestSpringBean&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;a&#x27;</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;a&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;b&#x27;</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;b&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;a&#x27;</span>; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">&#x27;a&#x27;</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line"></span><br><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:<span class="number">596</span>)</span><br><span class="line">	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:<span class="number">90</span>)</span><br><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:<span class="number">374</span>)</span><br></pre></td></tr></table></figure>

<p>如何解决？？？ 可能有的小伙伴看到网上有说使用<code>@Lazy</code>注解解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> A a;</span><br></pre></td></tr></table></figure>

<p>此处负责任的告诉你这样是解决不了问题的(<strong>可能会掩盖问题</strong>)，<code>@Lazy</code>只是延迟初始化而已，当你真正使用到它（初始化）的时候，依旧会报如上异常。</p>
<p>对于Spring循环依赖的情况总结如下：</p>
<ol>
<li>不能解决的情况： 1. 构造器注入循环依赖 2. <code>prototype</code> field属性注入循环依赖</li>
<li>能解决的情况： 1. field属性注入（setter方法注入）循环依赖</li>
</ol>
<h4 id="Spring解决循环依赖的原理分析"><a href="#Spring解决循环依赖的原理分析" class="headerlink" title="Spring解决循环依赖的原理分析"></a>Spring解决循环依赖的原理分析</h4><p>在这之前需要明白java中所谓的<code>引用传递</code>和<code>值传递</code>的区别。</p>
<blockquote>
<p> 说明：看到这句话可能有小伙伴就想喷我了。java中明明都是传递啊，这是我初学java时背了100遍的面试题，怎么可能有错？？？ 这就是我做这个申明的必要性：伙计，你的说法是正确的，<code>java中只有值传递</code>。但是本文借用<code>引用传递</code>来辅助讲解，希望小伙伴明白我想表达的意思~ </p>
</blockquote>
<p><strong><code>Spring的循环依赖的理论依据基于Java的引用传递</code></strong>，当获得对象的引用时，<strong>对象的属性是可以延后设置的</strong>。（但是构造器必须是在获取引用之前，毕竟你的引用是靠构造器给你生成的，儿子能先于爹出生？哈哈）</p>
<h5 id="Spring创建Bean的流程"><a href="#Spring创建Bean的流程" class="headerlink" title="Spring创建Bean的流程"></a>Spring创建Bean的流程</h5><p>首先需要了解是Spring它创建Bean的流程，我把它的大致调用栈绘图如下： </p>
<p><img src="http://static.cyblogs.com/oepgq3cnb0.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;oepgq3cnb0.png"></p>
<p> 对Bean的创建最为核心三个方法解释如下：</p>
<ul>
<li><code>createBeanInstance</code>：例化，其实也就是调用对象的<strong>构造方法</strong>实例化对象</li>
<li><code>populateBean</code>：填充属性，这一步主要是对bean的依赖属性进行注入(<code>@Autowired</code>)</li>
<li><code>initializeBean</code>：回到一些形如<code>initMethod</code>、<code>InitializingBean</code>等方法</li>
</ul>
<p>从对<code>单例Bean</code>的初始化可以看出，循环依赖主要发生在<strong>第二步（populateBean）</strong>，也就是field属性注入的处理。</p>
<h5 id="Spring容器的-三级缓存"><a href="#Spring容器的-三级缓存" class="headerlink" title="Spring容器的&#39;三级缓存&#39;"></a>Spring容器的<code>&#39;三级缓存&#39;</code></h5><p>在Spring容器的整个声明周期中，单例Bean有且仅有一个对象。这很容易让人想到可以用缓存来加速访问。 从源码中也可以看出Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至不惜使用了“三级缓存”，这也便是它设计的精妙之处~</p>
<p><code>三级缓存</code>其实它更像是Spring容器工厂的内的<code>术语</code>，采用三级缓存模式来解决循环依赖问题，这三级缓存分别指：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 从上至下 分表代表这“三级缓存”</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>); <span class="comment">//一级缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>); <span class="comment">// 二级缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>); <span class="comment">// 三级缓存</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line">	<span class="comment">// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~</span></span><br><span class="line">	<span class="comment">// 它在Bean开始创建时放值，创建完成时会将其移出~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Names of beans that have already been created at least once. */</span></span><br><span class="line">	<span class="comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span></span><br><span class="line">	<span class="comment">// 至少被创建了一次的  都会放进这里~~~~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<code>AbstractBeanFactory</code>继承自<code>DefaultSingletonBeanRegistry</code>~</p>
<ol>
<li><code>singletonObjects</code>：用于存放完全初始化好的 bean，<strong>从该缓存中取出的 bean 可以直接使用</strong></li>
<li><code>earlySingletonObjects</code>：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</li>
<li><code>singletonFactories</code>：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</li>
</ol>
<p><strong>获取单例Bean的源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">				singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						<span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isActuallyInCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先从<code>一级缓存singletonObjects</code>中去获取。（如果获取到就直接return）</li>
<li>如果获取不到或者对象正在创建中（<code>isSingletonCurrentlyInCreation()</code>），那就再从<code>二级缓存earlySingletonObjects</code>中获取。（如果获取到就直接return）</li>
<li>如果还是获取不到，且允许singletonFactories（allowEarlyReference&#x3D;true）通过<code>getObject()</code>获取。就从<code>三级缓存singletonFactory</code>.getObject()获取。<strong>（如果获取到了就从</strong><code>**singletonFactories**</code><strong>中移除，并且放进</strong><code>**earlySingletonObjects**</code><strong>。其实也就是从三级缓存</strong><code>**移动（是剪切、不是复制哦~）**</code><strong>到了二级缓存）</strong></li>
</ol>
<blockquote>
<p> <strong>加入<code>singletonFactories</code>三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</strong> </p>
</blockquote>
<p><code>getSingleton()</code>从缓存里获取单例对象步骤分析可知，Spring解决循环依赖的诀窍：<strong>就在于singletonFactories这个三级缓存</strong>。这个Cache里面都是<code>ObjectFactory</code>，它是解决问题的关键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它可以将创建对象的步骤封装到ObjectFactory中 交给自定义的Scope来选择是否需要创建对象来灵活的实现scope。  具体参见Scope接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">	T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 经过ObjectFactory.getObject()后，此时放进了二级缓存<code>earlySingletonObjects</code>内。这个时候对象已经实例化了，<code>虽然还不完美</code>，但是对象的引用已经可以被其它引用了。 </p>
</blockquote>
<p><strong>此处说一下二级缓存<code>earlySingletonObjects</code>它里面的数据什么时候添加什么移除？？?</strong></p>
<p><strong>添加</strong>：向里面添加数据只有一个地方，就是上面说的<code>getSingleton()</code>里从三级缓存里挪过来 <strong>移除</strong>：<code>addSingleton、addSingletonFactory、removeSingleton</code>从语义中可以看出添加单例、添加单例工厂<code>ObjectFactory</code>的时候都会删除二级缓存里面对应的缓存值，是互斥的</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p><code>Spring</code>容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，而对于创建完毕的Bean将从<code>当前创建Bean池</code>中清除掉。 这个“当前创建Bean池”指的是上面提到的<code>singletonsCurrentlyInCreation</code>那个集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title class_">ConfigurableBeanFactory</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">		<span class="comment">// 先去获取一次，如果不为null，此处就会走缓存了~~</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池</span></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// Create bean instance.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">// 这个getSingleton方法不是SingletonBeanRegistry的接口方法  属于实现类DefaultSingletonBeanRegistry的一个public重载方法~~~</span></span><br><span class="line">			<span class="comment">// 它的特点是在执行singletonFactory.getObject();前后会执行beforeSingletonCreation(beanName);和afterSingletonCreation(beanName);  </span></span><br><span class="line">			<span class="comment">// 也就是保证这个Bean在创建过程中，放入正在创建的缓存池里  可以看到它实际创建bean调用的是我们的createBean方法~~~~</span></span><br><span class="line">			sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					destroySingleton(beanName);</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法createBean所在地  这个接口方法是属于抽象父类AbstractBeanFactory的   实现在这个抽象类里</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 创建Bean对象，并且将对象包裹在BeanWrapper 中</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		<span class="comment">// 再从Wrapper中把Bean原始对象（非代理~~~）  这个时候这个Bean就有地址值了，就能被引用了~~~</span></span><br><span class="line">		<span class="comment">// 注意：此处是原始对象，这点非常的重要</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// earlySingletonExposure 用于表示是否”提前暴露“原始对象的引用，用于解决循环依赖。</span></span><br><span class="line">		<span class="comment">// 对于单例Bean，该变量一般为 true   但你也可以通过属性allowCircularReferences = false来关闭循环引用</span></span><br><span class="line">		<span class="comment">// isSingletonCurrentlyInCreation(beanName) 表示当前bean必须在创建中才行</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 上面讲过调用此方法放进一个ObjectFactory，二级缓存会对应删除的</span></span><br><span class="line">			<span class="comment">// getEarlyBeanReference的作用：调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference()这个方法  否则啥都不做</span></span><br><span class="line">			<span class="comment">// 也就是给调用者个机会，自己去实现暴露这个bean的应用的逻辑~~~</span></span><br><span class="line">			<span class="comment">// 比如在getEarlyBeanReference()里可以实现AOP的逻辑~~~  参考自动代理创建器AbstractAutoProxyCreator  实现了这个方法来创建代理对象</span></span><br><span class="line">			<span class="comment">// 若不需要执行AOP的逻辑，直接返回Bean</span></span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean; <span class="comment">//exposedObject 是最终返回的对象</span></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 填充属于，解决@Autowired依赖~</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		<span class="comment">// 执行初始化回调方法们~~~</span></span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查</span></span><br><span class="line">		<span class="comment">// 此段代码非常重要~~~~~但大多数人都忽略了它</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="comment">// 此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span></span><br><span class="line">			<span class="comment">//注意，注意：第二参数为false  表示不会再去三级缓存里查了~~~</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 此处非常巧妙的一点：：：因为上面各式各样的实例化、初始化的后置处理器都执行了，如果你在上面执行了这一句</span></span><br><span class="line">			<span class="comment">//  ((ConfigurableListableBeanFactory)this.beanFactory).registerSingleton(beanName, bean);</span></span><br><span class="line">			<span class="comment">// 那么此处得到的earlySingletonReference 的引用最终会是你手动放进去的Bean最终返回，完美的实现了&quot;偷天换日&quot; 特别适合中间件的设计</span></span><br><span class="line">			<span class="comment">// 我们知道，执行完此doCreateBean后执行addSingleton()  其实就是把自己再添加一次  **再一次强调，完美实现偷天换日**</span></span><br><span class="line">			<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			</span><br><span class="line">				<span class="comment">// 这个意思是如果经过了initializeBean()后，exposedObject还是木有变，那就可以大胆放心的返回了</span></span><br><span class="line">				<span class="comment">// initializeBean会调用后置处理器，这个时候可以生成一个代理对象，那这个时候它哥俩就不会相等了 走else去判断吧</span></span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125; </span><br><span class="line"></span><br><span class="line">				<span class="comment">// allowRawInjectionDespiteWrapping这个值默认是false</span></span><br><span class="line">				<span class="comment">// hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					<span class="comment">// 拿到它所依赖的Bean们~~~~ 下面会遍历一个一个的去看~~</span></span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// 一个个检查它所以Bean</span></span><br><span class="line">					<span class="comment">// removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面</span></span><br><span class="line">					<span class="comment">// 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true</span></span><br><span class="line">					<span class="comment">// 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖</span></span><br><span class="line">					<span class="comment">//（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）</span></span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 若存在真正依赖，那就报错（不要等到内存移除你才报错，那是非常不友好的） </span></span><br><span class="line">					<span class="comment">// 这个异常是BeanCurrentlyInCreationException，报错日志也稍微留意一下，方便定位错误~~~~</span></span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">								<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">								<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">								<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">								<span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 虽然是remove方法 但是它的返回值也非常重要</span></span><br><span class="line">	<span class="comment">// 该方法唯一调用的地方就是循环依赖的最后检查处~~~~~</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeSingletonIfCreatedForTypeCheckOnly</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">		<span class="comment">// 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">			removeSingleton(beanName);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里举例：例如是<code>field</code>属性依赖注入，在<code>populateBean</code>时它就会先去完成它所依赖注入的那个bean的实例化、初始化过程，最终返回到本流程继续处理，<strong>因此Spring这样处理是不存在任何问题的。</strong></p>
<p>这里有个小细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">	exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一句如果<code>exposedObject == bean</code>表示最终返回的对象就是原始对象，说明在<code>populateBean</code>和<code>initializeBean</code>没对他代理过，那就啥话都不说了<code>exposedObject = earlySingletonReference</code>，最终把二级缓存里的引用返回即可~</p>
<h4 id="流程总结（非常重要）"><a href="#流程总结（非常重要）" class="headerlink" title="流程总结（非常重要）"></a>流程总结（<code>非常重要</code>）</h4><p>此处以如上的A、B类的互相依赖注入为例，在这里表达出<strong>关键代码</strong>的走势：</p>
<p>1、入口处即是<strong>实例化、初始化A这个单例Bean</strong>。<code>AbstractBeanFactory.doGetBean(&quot;a&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(...)</span>&#123;</span><br><span class="line">	... </span><br><span class="line">	<span class="comment">// 标记beanName a是已经创建过至少一次的~~~ 它会一直存留在缓存里不会被移除（除非抛出了异常）</span></span><br><span class="line">	<span class="comment">// 参见缓存Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256))</span></span><br><span class="line">	<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">		markBeanAsCreated(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此时a不存在任何一级缓存中，且不是在创建中  所以此处返回null</span></span><br><span class="line">	<span class="comment">// 此处若不为null，然后从缓存里拿就可以了(主要处理FactoryBean和BeanFactory情况吧)</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这个getSingleton方法非常关键。</span></span><br><span class="line">	<span class="comment">//1、标注a正在创建中~</span></span><br><span class="line">	<span class="comment">//2、调用singletonObject = singletonFactory.getObject();（实际上调用的是createBean()方法）  因此这一步最为关键</span></span><br><span class="line">	<span class="comment">//3、此时实例已经创建完成  会把a移除整整创建的缓存中</span></span><br><span class="line">	<span class="comment">//4、执行addSingleton()添加进去。（备注：注册bean的接口方法为registerSingleton，它依赖于addSingleton方法）</span></span><br><span class="line">	sharedInstance = getSingleton(beanName, () -&gt; &#123; ... <span class="keyword">return</span> createBean(beanName, mbd, args); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、下面进入到最为复杂的<code>AbstractAutowireCapableBeanFactory.createBean/doCreateBean()</code>环节，创建A的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">()</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 使用构造器/工厂方法   instanceWrapper是一个BeanWrapper</span></span><br><span class="line">	instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	<span class="comment">// 此处bean为&quot;原始Bean&quot;   也就是这里的A实例对象：A@1234</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 是否要提前暴露（允许循环依赖）  现在此处A是被允许的</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 允许暴露，就把A绑定在ObjectFactory上，注册到三级缓存`singletonFactories`里面去保存着</span></span><br><span class="line">	<span class="comment">// Tips:这里后置处理器的getEarlyBeanReference方法会被促发，自动代理创建器在此处创建代理对象（注意执行时机 为执行三级缓存的时候）</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// exposedObject 为最终返回的对象，此处为原始对象bean也就是A@1234,下面会有用处</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean; </span><br><span class="line">	<span class="comment">// 给A@1234属性完成赋值，@Autowired在此处起作用~</span></span><br><span class="line">	<span class="comment">// 因此此处会调用getBean(&quot;b&quot;)，so 会重复上面步骤创建B类的实例</span></span><br><span class="line">	<span class="comment">// 此处我们假设B已经创建好了 为B@5678</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 需要注意的是在populateBean(&quot;b&quot;)的时候依赖有beanA，所以此时候调用getBean(&quot;a&quot;)最终会调用getSingleton(&quot;a&quot;)，</span></span><br><span class="line">	<span class="comment">//此时候上面说到的getEarlyBeanReference方法就会被执行。这也解释为何我们@Autowired是个代理对象，而不是普通对象的根本原因</span></span><br><span class="line">	</span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="comment">// 实例化。这里会执行后置处理器BeanPostProcessor的两个方法</span></span><br><span class="line">	<span class="comment">// 此处注意：postProcessAfterInitialization()是有可能返回一个代理对象的，这样exposedObject 就不再是原始对象了  特备注意哦~~~</span></span><br><span class="line">	<span class="comment">// 比如处理@Aysnc的AsyncAnnotationBeanPostProcessor它就是在这个时间里生成代理对象的（有坑，请小心使用@Aysnc）</span></span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 至此，相当于A@1234已经实例化完成、初始化完成（属性也全部赋值了~）</span></span><br><span class="line">	<span class="comment">// 这一步我把它理解为校验：校验：校验是否有循环引用问题~~~~~</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 注意此处第二个参数传的false，表示不去三级缓存里singletonFactories再去调用一次getObject()方法了~~~</span></span><br><span class="line">		<span class="comment">// 上面建讲到了由于B在初始化的时候，会触发A的ObjectFactory.getObject()  所以a此处已经在二级缓存earlySingletonObjects里了</span></span><br><span class="line">		<span class="comment">// 因此此处返回A的实例：A@1234</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">// 这个等式表示，exposedObject若没有再被代理过，这里就是相等的</span></span><br><span class="line">			<span class="comment">// 显然此处我们的a对象的exposedObject它是没有被代理过的  所以if会进去~</span></span><br><span class="line">			<span class="comment">// 这种情况至此，就全部结束了~~~</span></span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 继续以A为例，比如方法标注了@Aysnc注解，exposedObject此时候就是一个代理对象，因此就会进到这里来</span></span><br><span class="line">			<span class="comment">//hasDependentBean(beanName)是肯定为true，因为getDependentBeans(beanName)得到的是[&quot;b&quot;]这个依赖</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// A@1234依赖的是[&quot;b&quot;]，所以此处去检查b</span></span><br><span class="line">				<span class="comment">// 如果最终存在实际依赖的bean：actualDependentBeans不为空 那就抛出异常  证明循环引用了~</span></span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="comment">// 这个判断原则是：如果此时候b并还没有创建好，this.alreadyCreated.contains(beanName)=true表示此bean已经被创建过，就返回false</span></span><br><span class="line">					<span class="comment">// 若该bean没有在alreadyCreated缓存里，就是说没被创建过(其实只有CreatedForTypeCheckOnly才会是此仓库)</span></span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">							<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">							<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">							<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">							<span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于关键代码部分的步骤不太好拆分，为了更具象表达，那么使用下面一副图示帮助小伙伴们理解： </p>
<p><img src="http://static.cyblogs.com/qv40e3auxf.png" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;qv40e3auxf.png"></p>
<p><strong>最后的最后，由于我太暖心了_，再来个纯文字版的总结。</strong> 依旧以上面<code>A</code>、<code>B</code>类使用属性<code>field</code>注入循环依赖的例子为例，对整个流程做文字步骤总结如下：</p>
<ol>
<li>使用<code>context.getBean(A.class)</code>，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走<strong>A的创建之路~</strong></li>
<li><code>实例化</code>A（注意此处仅仅是实例化），并将它放进<code>缓存</code>（此时A已经实例化完成，已经可以被引用了）</li>
<li><code>初始化</code>A：<code>@Autowired</code>依赖注入B（此时需要去容器内获取B）</li>
<li>为了完成依赖注入B，会通过<code>getBean(B)</code>去容器内找B。但此时B在容器内不存在，就走向<strong>B的创建之路~</strong></li>
<li><code>实例化</code>B，并将其放入缓存。（此时B也能够被引用了）</li>
<li><code>初始化</code>B，<code>@Autowired</code>依赖注入A（此时需要去容器内获取A）</li>
<li><code>此处重要</code>：初始化B时会调用<code>getBean(A)</code>去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以<code>getBean(A)</code>能够正常返回</li>
<li><strong>B初始化成功</strong>（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的<code>getBean(B)</code>这句代码，回到了初始化A的流程中~）。</li>
<li>因为B实例已经成功返回了，因此最终<strong>A也初始化成功</strong></li>
<li><strong>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~</strong></li>
</ol>
<p>站的角度高一点，宏观上看Spring处理循环依赖的整个流程就是如此。希望这个宏观层面的总结能更加有助于小伙伴们对Spring解决循环依赖的原理的了解，<strong>同时也顺便能解释为何构造器循环依赖就不好使的原因。</strong></p>
<h5 id="循环依赖对AOP代理对象创建流程和结果的影响"><a href="#循环依赖对AOP代理对象创建流程和结果的影响" class="headerlink" title="循环依赖对AOP代理对象创建流程和结果的影响"></a>循环依赖对AOP代理对象创建<code>流程和结果</code>的影响</h5><p>我们都知道<strong>Spring AOP、事务</strong>等都是通过代理对象来实现的，而<strong>事务</strong>的代理对象是由自动代理创建器来自动完成的。也就是说Spring最终给我们放进容器里面的是一个代理对象，<strong>而非原始对象</strong>。</p>
<p>本文结合<code>循环依赖</code>，回头再看AOP代理对象的创建过程，和最终放进容器内的动作，非常有意思。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hello</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;service hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此<code>Service</code>类使用到了事务，所以最终会生成一个JDK动态代理对象<code>Proxy</code>。刚好它又存在<code>自己引用自己</code>的循环依赖。看看这个Bean的创建概要描述如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这段告诉我们：如果允许循环依赖的话，此处会添加一个ObjectFactory到三级缓存里面，以备创建对象并且提前暴露引用~</span></span><br><span class="line">	<span class="comment">// 此处Tips：getEarlyBeanReference是后置处理器SmartInstantiationAwareBeanPostProcessor的一个方法，它的功效为：</span></span><br><span class="line">	<span class="comment">// 保证自己被循环依赖的时候，即使被别的Bean @Autowire进去的也是代理对象~~~~  AOP自动代理创建器此方法里会创建的代理对象~~~</span></span><br><span class="line">	<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">	<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123; <span class="comment">// 需要提前暴露（支持循环依赖），就注册一个ObjectFactory到三级缓存</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此处注意：如果此处自己被循环依赖了  那它会走上面的getEarlyBeanReference，从而创建一个代理对象从三级缓存转移到二级缓存里</span></span><br><span class="line">	<span class="comment">// 注意此时候对象还在二级缓存里，并没有在一级缓存。并且此时可以知道exposedObject仍旧是原始对象~~~</span></span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 经过这两大步后，exposedObject还是原始对象（注意此处以事务的AOP为例子的，</span></span><br><span class="line">	<span class="comment">// 因为事务的AOP自动代理创建器在getEarlyBeanReference创建代理后，initializeBean就不会再重复创建了，二选一的，下面会有描述~~~）</span></span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 循环依赖校验（非常重要）~~~~</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 前面说了因为自己被循环依赖了，所以此时候代理对象还在二级缓存里~~~（备注：本利讲解的是自己被循环依赖了的情况）</span></span><br><span class="line">		<span class="comment">// so，此处getSingleton，就会把里面的对象拿出来，我们知道此时候它已经是个Proxy代理对象~~~</span></span><br><span class="line">		<span class="comment">// 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  </span></span><br><span class="line">		<span class="comment">// 这样就保证了我们容器里**最终实际上是代理对象**，而非原始对象~~~~~</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上演示的是<code>代理对象+自己存在循环依赖</code>的case：Spring用三级缓存很巧妙的进行解决了。 若是这种case：代理对象，但是自己并<strong>不存在循环依赖</strong>，过程稍微有点不一样儿了，如下描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 这些语句依旧会执行，三级缓存里是会加入的  表示它支持被循环引用嘛~~~</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此处注意，因为它没有被其它Bean循环引用（注意是循环引用，而不是直接引用~）,所以上面getEarlyBeanReference不会执行~</span></span><br><span class="line">	<span class="comment">// 也就是说此时二级缓存里并不会存在它~~~ 知晓这点特别的重要</span></span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="comment">// 重点在这：AnnotationAwareAspectJAutoProxyCreator自动代理创建器此处的postProcessAfterInitialization方法里，会给创建一个代理对象返回</span></span><br><span class="line">	<span class="comment">// 所以此部分执行完成后，exposedObject **已经是个代理对象**而不再是个原始对象了~~~~ 此时二级缓存里依旧无它，更别提一级缓存了</span></span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 循环依赖校验</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 前面说了一级、二级缓存里都木有它，然后这里传的又是false（表示不看三级缓存~~）</span></span><br><span class="line">		<span class="comment">// 所以毋庸置疑earlySingletonReference = null  so下面的逻辑就不用看了，直接return出去~~</span></span><br><span class="line">		<span class="comment">// 然后执行addSingleton()方法，由此可知  容器里最终存在的也还是代理对象~~~~~~</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;...</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析可知，即使自己只需要代理，并不被循环引用，最终存在Spring容器里的<strong>仍旧是</strong>代理对象。（so此时别人直接<code>@Autowired</code>进去的也是代理对象呀~~~）</p>
<p><strong>终极case：如果我关闭Spring容器的循环依赖能力，也就是把<code>allowCircularReferences</code>设值为false，那么会不会造成什么问题呢？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它用于关闭循环引用（关闭后只要有循环引用现象就直接报错~~）</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若关闭了循环依赖后，还存在上面A、B的循环依赖现象，启动便会报错如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">&#x27;a&#x27;</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.beforeSingletonCreation(DefaultSingletonBeanRegistry.java:<span class="number">339</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">215</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意此处异常类型也是<code>BeanCurrentlyInCreationException</code>异常，但是文案内容和上面强调的有所区别~~ 它报错位置在：<code>DefaultSingletonBeanRegistry.beforeSingletonCreation</code>这个位置~ </p>
</blockquote>
<p><code>报错浅析</code>：在实例化A后给其属性赋值时，会去实例化B。B实例化完成后会继续给B属性赋值，这时由于此时我们<code>关闭了循环依赖</code>，所以不存在<code>提前暴露</code>引用这么一说来给实用。因此B无法直接拿到A的引用地址，因此只能又去创建A的实例。<strong>而此时我们知道A其实已经正在创建中了</strong>，不能再创建了。so，就报错了~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为管理了循环依赖，所以此处不能再依赖自己的</span></span><br><span class="line">	<span class="comment">// 但是：我们的此bean还是需要AOP代理的~~~</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//private HelloService helloService;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hello</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;service hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样它的大致运行如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">( ... )</span> &#123;</span><br><span class="line">	<span class="comment">// 毫无疑问此时候earlySingletonExposure = false  也就是Bean都不会提前暴露引用了  显然就不能被循环依赖了~</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	...</span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="comment">// 若是事务的AOP  在这里会为源生Bean创建代理对象（因为上面没有提前暴露这个代理）</span></span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		... 这里更不用说，因为earlySingletonExposure=<span class="literal">false</span>  所以上面的代理对象exposedObject 直接<span class="keyword">return</span>了~</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到即使把这个开关给关了，最终放进容器了的仍旧是代理对象，显然<code>@Autowired</code>给属性赋值的也一定是代理对象。</p>
<p>最后，以<code>AbstractAutoProxyCreator</code>为例看看自动代理创建器是怎么配合实现：循环依赖+创建代理</p>
<blockquote>
<p> <code>AbstractAutoProxyCreator</code>是抽象类，它的三大实现子类<code>InfrastructureAdvisorAutoProxyCreator</code>、<code>AspectJAwareAdvisorAutoProxyCreator</code>、<code>AnnotationAwareAspectJAutoProxyCreator</code>小伙伴们应该会更加的熟悉些 </p>
</blockquote>
<p>该抽象类实现了创建代理的动作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @since 13.10.2003  它实现代理创建的方法有如下两个</span></span><br><span class="line"><span class="comment">// 实现了SmartInstantiationAwareBeanPostProcessor 所以有方法getEarlyBeanReference来只能的解决循环引用问题：提前把代理对象暴露出去~</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 下面两个方法是自动代理创建器创建代理对象的唯二的两个节点~</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提前暴露代理对象的引用  它肯定在postProcessAfterInitialization之前执行</span></span><br><span class="line">	<span class="comment">// 所以它并不需要判断啥的~~~~  创建好后放进缓存earlyProxyReferences里  注意此处value是原始Bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">		<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为它会在getEarlyBeanReference之后执行，所以此处的重要逻辑是下面的判断</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">			<span class="comment">// remove方法返回被移除的value，上面说了它记录的是原始bean</span></span><br><span class="line">			<span class="comment">// 若被循环引用了，那就是执行了上面的`getEarlyBeanReference`方法，所以此时remove返回值肯定是==bean的（注意此时方法入参的bean还是原始对象）</span></span><br><span class="line">			<span class="comment">// 若没有被循环引用，getEarlyBeanReference()不执行 所以remove方法返回null，所以就进入if执行此处的创建代理对象方法~~~</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">				<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知，自动代理创建器它保证了代理对象只会被创建一次，而且支持循环依赖的自动注入的依旧是代理对象。</p>
<p><strong><code>上面分析了三种case，现给出结论如下：</code></strong> 不管是自己被循环依赖了还是没有，<strong>甚至是把Spring容器的循环依赖给关了</strong>，它对AOP代理的创建流程有影响，<strong>但对结果是无影响的。</strong> 也就是说Spring很好的对调用者屏蔽了这些实现细节，使得使用者使用起来完全的无感知~</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>解决此类问题的关键是要对<code>SpringIOC</code>和<code>DI</code>的整个流程做到心中有数，要理解好本文章，建议有【相关阅读】里文章的大量知识的铺垫，同时呢本文又能<strong>进一步</strong>的帮助小伙伴理解到Spring Bean的实例化、初始化流程。</p>
<p>本文还是花了我一番心思的，个人觉得对Spring这部分的处理流程描述得还是比较详细的，希望我的总结能够给大家带来帮助。 <strong>另外为了避免循环依赖导致启动问题而又不会解决，有如下建议：</strong></p>
<ol>
<li><code>业务代码中</code>尽量不要使用构造器注入，即使它有很多优点。</li>
<li><code>业务代码中</code>为了简洁，尽量使用field注入而非setter方法注入</li>
<li>若你注入的同时，立马需要处理一些逻辑（一般见于框架设计中，业务代码中不太可能出现），可以使用setter方法注入辅助完成</li>
</ol>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497692">https://cloud.tencent.com/developer/article/1497692</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.cyblogs.com/2020/06/05/2020/06/Java4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E7%94%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/vernonchen.jpg">
      <meta itemprop="name" content="Vernon">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="简栈文化">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 简栈文化">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/05/2020/06/Java4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E7%94%A8%EF%BC%9F/" class="post-title-link" itemprop="url">Java4种引用类型到底如何用？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-06-05T00:00:00+08:00">2020-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-06-25 09:56:28" itemprop="dateModified" datetime="2025-06-25T09:56:28+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 <code>JDK.1.2</code> 之后，<code>Java</code> 对引用的概念进行了扩充，将引用分为了：</p>
<ul>
<li>强引用<code>（Strong Reference）</code></li>
<li>软引用<code>（Soft Reference）</code></li>
<li>弱引用<code>（Weak Reference）</code></li>
<li>虚引用<code>（Phantom Reference）</code>4 种，这 4 种引用的强度依次减弱。不同的引用在垃圾回收中体现也是不一样~</li>
</ul>
<h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p>我们先创建一个M对象，后面为了方便的感受GC的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:30 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">M</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>finalize</code>函数是对象在<code>gc</code>的时候，一定会调用该方法。我们重写一下该方法并且打印一行日志。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，<code>JVM</code>也会直接抛出<code>OutOfMemoryError</code>，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为<code>null</code>，这样一来，<code>JVM</code>就可以适时的回收对象了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 正常引用/强引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C001_01_NormalReference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">M</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">M</span>();</span><br><span class="line">        <span class="comment">// 将对象复制为空</span></span><br><span class="line">        m = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 手动触发GC</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为不是触发gc就一定会立马gc，所以让线程阻塞一下</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台日志输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#x27;127.0.0.1:53621&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">finalize</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:53621&#x27;, transport: &#x27;socket&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 软引用：当内存不足的时候，gc才会回收。非常适合做缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C001_02_SoftReference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 开辟一个20M的空间</span></span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; m = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;<span class="type">byte</span>[]&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]);</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 手动GC一下，看是否可以GC掉</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 避免gc不会立马触发，尝试休眠1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 然后再尝试获取</span></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 重新开辟一个空间</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">15</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为它是在内存不足的时候才会触发，所以我们在跑之前需要设置一下最大堆。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20M</span><br></pre></td></tr></table></figure>

<p>控制台日志输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#x27;127.0.0.1:54335&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">[B@4c3e4790</span><br><span class="line">[B@4c3e4790</span><br><span class="line">null</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:54335&#x27;, transport: &#x27;socket&#x27;</span><br></pre></td></tr></table></figure>

<p>你会发现就算我们<code>gc</code>了，后面还是会<code>get</code>得到，因为空间还足够。当后面<code>byte[] b</code>再继续申请空间的时候，发现空间不足了，这个时候就会触发<code>gc</code>动作，把软引用的部分清除掉。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 弱引用：是为了解决某些地方的内存泄露问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:32 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C001_03_WeakReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;M&gt; m = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;M&gt;(<span class="keyword">new</span> <span class="title class_">M</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;M&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;M&gt;();</span><br><span class="line">        tl.set(<span class="keyword">new</span> <span class="title class_">M</span>());</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台日志输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: &#x27;127.0.0.1:55151&#x27;, transport: &#x27;socket&#x27;</span><br><span class="line">com.cyblogs.java.learning.C001_ReferenceType.M@38cccef</span><br><span class="line">null</span><br><span class="line">finalize</span><br><span class="line">Disconnected from the target VM, address: &#x27;127.0.0.1:55151&#x27;, transport: &#x27;socket&#x27;</span><br></pre></td></tr></table></figure>

<p>我们看一下<code>ThreadLocal</code>的<code>set</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread&#x27;s copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread&#x27;s copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/QQ20200616-225739@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200616-225739@2x.jpg"></p>
<p>为什么<code>Entry</code>要使用弱引用？</p>
<ul>
<li><p>若是强引用，即使<code>tl=null</code>，但是<code>key</code>的引用还是指向<code>ThreadLocal</code>。所以内存会泄露~而弱引用不会</p>
</li>
<li><p>但是还会有内存泄露的问题，<code>ThreadLocal</code>被回收。<code>key</code>的值变成了<code>null</code>，则导致<code>value</code>的值再也无法被访问到，因此依然存在内存泄露问题。</p>
</li>
</ul>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 虚引用：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:33 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C001_04_PhantomReference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;M&gt; QUEUE = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;M&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; LIST = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        PhantomReference&lt;M&gt; m = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;M&gt;(<span class="keyword">new</span> <span class="title class_">M</span>(), QUEUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                LIST.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(m.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                Reference&lt;? <span class="keyword">extends</span> <span class="title class_">M</span>&gt; poll = QUEUE.poll();</span><br><span class="line">                <span class="keyword">if</span> (poll != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;虚引用对象被JVM回收了&quot;</span> + poll);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在零拷贝中就会使用到虚引用，但我们又无法去操作对外的内存。因为太弱了，我们也无法感知到~ 这里就需要利用到<code>ReferenceQueue</code>。</p>
<p><img src="http://static.cyblogs.com/QQ20200616-222909@2x.jpg" alt="http:&#x2F;&#x2F;static.cyblogs.com&#x2F;QQ20200616-222909@2x.jpg"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iK4y1x7tj">https://www.bilibili.com/video/BV1iK4y1x7tj</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liyutian/p/9690974.html">https://www.cnblogs.com/liyutian/p/9690974.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Vernon</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <a target="_blank" href="https://beian.miit.gov.cn">粤ICP备2025433887号</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
