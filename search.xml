<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 基本原理与常用命令</title>
    <url>/2019/06/20/2019/06/Git%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="Git-基本原理与常用命令"><a href="#Git-基本原理与常用命令" class="headerlink" title="Git 基本原理与常用命令"></a>Git 基本原理与常用命令</h3><h4 id="1、设置与帮助"><a href="#1、设置与帮助" class="headerlink" title="1、设置与帮助"></a>1、设置与帮助</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git help &lt;command&gt;          # 显示指定命令的help  </span><br><span class="line">2. git config --global user.name "your name"  </span><br><span class="line">3. git config --global user.email "your email"</span><br></pre></td></tr></table></figure>

<h4 id="2、修改与提交"><a href="#2、修改与提交" class="headerlink" title="2、修改与提交"></a>2、修改与提交</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git status                   # 查看工作区状态  </span><br><span class="line">2. git add &lt;file&gt;               # 将指定文件修改提交到本地暂存区  </span><br><span class="line">3. git add .                    # 将所有修改过的文件提都交暂存区，不包括删除，"."即表示正则匹配所有字符  </span><br><span class="line">4. git add --all                # 将所有工作区修改提交到暂存区，包括 delete 掉的文件  </span><br><span class="line">5. git add -A                   # 同上  </span><br><span class="line">6. git commit -m"comments"      # 将暂存区的内容提交到本地库，并加上备注  </span><br><span class="line">7. git commit &lt;file&gt;            # 提交暂存区指定文件  </span><br><span class="line">8. git commit .                 # 提交暂存区所有文件  </span><br><span class="line">9. git commit -a                # 将git add, git rm和git commit等操作都合并在一起做，不包括新建文件  </span><br><span class="line">10. git commit -am "comments"    # 同上+添加备注</span><br></pre></td></tr></table></figure>

<h4 id="3、撤销与恢复"><a href="#3、撤销与恢复" class="headerlink" title="3、撤销与恢复"></a>3、撤销与恢复</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git checkout  -- &lt;file&gt;     # 抛弃工作区指定文件的修改  </span><br><span class="line">2. git checkoout .             # 抛弃工作区所有的修改  </span><br><span class="line">3. git reset &lt;file&gt;            # 将指定文件从暂存区恢复到工作区  </span><br><span class="line">4. git reset -- .              # 将所有文件从暂存区恢复到工作区  </span><br><span class="line">5. git reset --hard            # 恢复最近一次提交过的状态，工作区所有修改被放弃</span><br></pre></td></tr></table></figure>

<h4 id="4、查看提交"><a href="#4、查看提交" class="headerlink" title="4、查看提交"></a>4、查看提交</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git show            # 显示某次提交的内容  </span><br><span class="line">2. git show $id  </span><br><span class="line">3. git log  </span><br><span class="line">4. git log &lt;file&gt;      # 查看该文件每次提交记录  </span><br><span class="line">5. git log -p &lt;file&gt;   # 查看每次详细修改内容的diff  </span><br><span class="line">6. git log -p -2       # 查看最近两次详细修改内容的diff  </span><br><span class="line">7. git log --stat      # 查看提交统计信息</span><br></pre></td></tr></table></figure>

<h4 id="5、差异对比"><a href="#5、差异对比" class="headerlink" title="5、差异对比"></a>5、差异对比</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git diff &lt;file&gt;                     # 比较当前文件和暂存区文件差异  </span><br><span class="line">2. git diff &lt;$id1&gt; &lt;$id2&gt;              # 比较两次提交之间的差异  </span><br><span class="line">3. git diff &lt;branch1&gt;..&lt;branch2&gt;       # 在两个分支之间比较  </span><br><span class="line">4. git diff --staged                   # 比较暂存区和版本库差异  </span><br><span class="line">5. git diff --stat                     # 仅仅比较统计信息</span><br></pre></td></tr></table></figure>

<h4 id="6、关于版本"><a href="#6、关于版本" class="headerlink" title="6、关于版本"></a>6、关于版本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git tag                              #查看版本  </span><br><span class="line">2. git tag [name]                       #创建版本  </span><br><span class="line">3. git tag -d [name]                    #删除版本  </span><br><span class="line">4. git tag -r                           #查看远程版本  </span><br><span class="line">5. git push origin [name]               #创建远程版本(本地版本push到远程)</span><br></pre></td></tr></table></figure>

<h4 id="7、关于分支"><a href="#7、关于分支" class="headerlink" title="7、关于分支"></a>7、关于分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git branch &lt;new_branch&gt;             # 创建新的分支  </span><br><span class="line">2. git checkout &lt;branch&gt;               # 切换到某个分支  </span><br><span class="line">3. git checkout -b &lt;new_branch&gt;        # 创建新的分支，并且切换过去  </span><br><span class="line">4. git branch -v                       # 查看各个分支最后提交信息  </span><br><span class="line">5. git branch -r                       # 查看远程分支  </span><br><span class="line">6. git branch --merged                 # 查看已经被合并到当前分支的分支  </span><br><span class="line">7. git branch --no-merged              # 查看尚未被合并到当前分支分支  </span><br><span class="line">8. git checkout $id                    # 把某历史提交checkout出来，无分支信息，切换到其他分支会自动删除  </span><br><span class="line">9. git checkout $id -b &lt;new_branch&gt;    # 把某历史提交checkout出来，创建成一个分支  </span><br><span class="line">10. git branch -d &lt;branch&gt;              # 删除某个分支  </span><br><span class="line">11. git branch -D &lt;branch&gt;              # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span><br></pre></td></tr></table></figure>

<h4 id="8、关于远程仓库"><a href="#8、关于远程仓库" class="headerlink" title="8、关于远程仓库"></a>8、关于远程仓库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git remote add origin &lt;remote&gt;       # 添加远程库  </span><br><span class="line">2. git remote -v                        # 查看远程服务器地址和仓库名称  </span><br><span class="line">3. git remote show origin               # 查看远程服务器仓库状态  </span><br><span class="line">4. git remote rm &lt;repository&gt;           # 删除远程仓库  </span><br><span class="line">5. git push -u origin master            # 客户端首次提交  </span><br><span class="line">6. git push -u origin develop           # 首次将本地develop分支提交到远程develop分支，并且track</span><br></pre></td></tr></table></figure>

<h4 id="9、跟踪远程库和本地库"><a href="#9、跟踪远程库和本地库" class="headerlink" title="9、跟踪远程库和本地库"></a>9、跟踪远程库和本地库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. git branch --set-upstream master origin/master  </span><br><span class="line">2. git branch --set-upstream develop origin/develop</span><br></pre></td></tr></table></figure>

<h4 id="10、本地支持多个Git服务"><a href="#10、本地支持多个Git服务" class="headerlink" title="10、本地支持多个Git服务"></a>10、本地支持多个Git服务</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /Users/chenyuan/.ssh</span><br><span class="line">lrwxr-xr-x  1 chenyuan  staff    42B May 23  2018 config -&gt; /Users/chenyuan/Dropbox/Mackup/.ssh/config # 这里配置多个git对应关系</span><br><span class="line"></span><br><span class="line">➜  .ssh  cat config</span><br><span class="line"></span><br><span class="line">Host git.coding.net # host</span><br><span class="line">HostName git.coding.net</span><br><span class="line">Port 22</span><br><span class="line">User chengcheng222e</span><br><span class="line">IdentityFile ~/.ssh/chengcheng222e_coding # 这里是coding.net的私钥路径</span><br><span class="line"></span><br><span class="line">Host github.com # host</span><br><span class="line">HostName github.com</span><br><span class="line">Port 22</span><br><span class="line">User chenyuan</span><br><span class="line">IdentityFile ~/.ssh/github_rsa # 这里是github.com的私钥路径</span><br></pre></td></tr></table></figure>

<h4 id="11、推荐一个特别好玩的Git游戏-Githug"><a href="#11、推荐一个特别好玩的Git游戏-Githug" class="headerlink" title="11、推荐一个特别好玩的Git游戏~ Githug"></a>11、推荐一个特别好玩的Git游戏~ Githug</h4><p><a href="https://wiki.jikexueyuan.com/project/githug-walkthrough/install.html" target="_blank" rel="noopener">Githug 安装和使用方法</a>，一共有55关。</p>
<h5 id="关卡列表"><a href="#关卡列表" class="headerlink" title="关卡列表"></a>关卡列表</h5><table>
<thead>
<tr>
<th align="left">关卡名称</th>
<th align="left">学习内容</th>
<th align="left">Git 命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-1.html" target="_blank" rel="noopener">第1关 init</a></td>
<td align="left">初始化仓库</td>
<td align="left">git init</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-2.html" target="_blank" rel="noopener">第2关 config</a></td>
<td align="left">设置用户名和电子邮箱地址</td>
<td align="left">git config</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-3.html" target="_blank" rel="noopener">第3关 add</a></td>
<td align="left">把文件添加到暂存区</td>
<td align="left">git add</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-4.html" target="_blank" rel="noopener">第4关 commit</a></td>
<td align="left">提交</td>
<td align="left">git commit</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-5.html" target="_blank" rel="noopener">第5关 clone</a></td>
<td align="left">克隆远程仓库</td>
<td align="left">git clone</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-6.html" target="_blank" rel="noopener">第6关 clone_to_folder</a></td>
<td align="left">克隆远程仓库，并指定本地目录名</td>
<td align="left">git clone</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-7.html" target="_blank" rel="noopener">第7关 ignore</a></td>
<td align="left">配置不被 Git 管理的文件</td>
<td align="left">vim .gitignore</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-8.html" target="_blank" rel="noopener">第8关 include</a></td>
<td align="left">配置不被 Git 管理的文件</td>
<td align="left">vim .gitignore</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-9.html" target="_blank" rel="noopener">第9关 status</a></td>
<td align="left">查看仓库状态</td>
<td align="left">git status</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-10.html" target="_blank" rel="noopener">第10关 number_of_files_committed</a></td>
<td align="left">查看仓库状态</td>
<td align="left">git status</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-11.html" target="_blank" rel="noopener">第11关 rm</a></td>
<td align="left">删除文件</td>
<td align="left">git rm</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-12.html" target="_blank" rel="noopener">第12关 rm_cached</a></td>
<td align="left">从暂存区中移除文件，系 git add 的逆操作</td>
<td align="left">git rm –cached</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-13.html" target="_blank" rel="noopener">第13关 stash</a></td>
<td align="left">保存而不提交</td>
<td align="left">git stash</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-14.html" target="_blank" rel="noopener">第14关 rename</a></td>
<td align="left">文件改名</td>
<td align="left">git mv</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-15.html" target="_blank" rel="noopener">第15关 restructure</a></td>
<td align="left">整理目录结构</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-16.html" target="_blank" rel="noopener">第16关 log</a></td>
<td align="left">查询日志</td>
<td align="left">git log</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-17.html" target="_blank" rel="noopener">第17关 tag</a></td>
<td align="left">打标签</td>
<td align="left">git tag</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-18.html" target="_blank" rel="noopener">第18关 push_tags</a></td>
<td align="left">把标签推送到远程仓库</td>
<td align="left">git push –tags</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-19.html" target="_blank" rel="noopener">第19关 commit_amend</a></td>
<td align="left">修改最后一次提交</td>
<td align="left">git commit –amend</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-20.html" target="_blank" rel="noopener">第20关 commit_in_future</a></td>
<td align="left">指定提交的日期</td>
<td align="left">git commit –date</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-21.html" target="_blank" rel="noopener">第21关 reset</a></td>
<td align="left">从暂存区中移除文件，系 git add 的逆操作</td>
<td align="left">git reset</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-22.html" target="_blank" rel="noopener">第22关 reset_soft</a></td>
<td align="left">撤销提交，系 git commit 的逆操作</td>
<td align="left">git reset –soft</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-23.html" target="_blank" rel="noopener">第23关 checkout_file</a></td>
<td align="left">撤销对一个文件的修改</td>
<td align="left">git checkout</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-24.html" target="_blank" rel="noopener">第24关 remote</a></td>
<td align="left">查询远程仓库</td>
<td align="left">git remote</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-25.html" target="_blank" rel="noopener">第25关 remote_url</a></td>
<td align="left">查询远程仓库的 URL</td>
<td align="left">git remote -v</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-26.html" target="_blank" rel="noopener">第26关 pull</a></td>
<td align="left">从远程仓库拉取更新</td>
<td align="left">git pull</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-27.html" target="_blank" rel="noopener">第27关 remote_add</a></td>
<td align="left">添加远程仓库</td>
<td align="left">git remote</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-28.html" target="_blank" rel="noopener">第28关 push</a></td>
<td align="left">把提交推送到远程仓库</td>
<td align="left">git push</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-29.html" target="_blank" rel="noopener">第29关 diff</a></td>
<td align="left">查看文件被修改的细节</td>
<td align="left">git diff</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-30.html" target="_blank" rel="noopener">第30关 blame</a></td>
<td align="left">查询每一行代码被谁编辑过</td>
<td align="left">git blame</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-31.html" target="_blank" rel="noopener">第31关 branch</a></td>
<td align="left">创建分支</td>
<td align="left">git branch</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-32.html" target="_blank" rel="noopener">第32关 checkout</a></td>
<td align="left">切换分支</td>
<td align="left">git checkout</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-33.html" target="_blank" rel="noopener">第33关 checkout_tag</a></td>
<td align="left">切换到标签</td>
<td align="left">git checkout</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-34.html" target="_blank" rel="noopener">第34关 checkout_tag_over_branch</a></td>
<td align="left">切换到标签</td>
<td align="left">git checkout</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-35.html" target="_blank" rel="noopener">第35关 branch_at</a></td>
<td align="left">在指定的提交处创建分支</td>
<td align="left">git branch</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-36.html" target="_blank" rel="noopener">第36关 delete_branch</a></td>
<td align="left">删除分支</td>
<td align="left">git branch -d</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-37.html" target="_blank" rel="noopener">第37关 push_branch</a></td>
<td align="left">推送分支到远程仓库</td>
<td align="left">git push</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-38.html" target="_blank" rel="noopener">第38关 merge</a></td>
<td align="left">合并分支</td>
<td align="left">git merge</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-39.html" target="_blank" rel="noopener">第39关 fetch</a></td>
<td align="left">从远程仓库抓取数据</td>
<td align="left">git fetch</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-40.html" target="_blank" rel="noopener">第40关 rebase</a></td>
<td align="left">变基合并</td>
<td align="left">git rebase</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-41.html" target="_blank" rel="noopener">第41关 repack</a></td>
<td align="left">重新打包</td>
<td align="left">git repack</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-42.html" target="_blank" rel="noopener">第42关 cherry-pick</a></td>
<td align="left">合并分支上指定的提交</td>
<td align="left">git cherry-pick</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-43.html" target="_blank" rel="noopener">第43关 grep</a></td>
<td align="left">搜索文本</td>
<td align="left">git grep</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-44.html" target="_blank" rel="noopener">第44关 rename_commit</a></td>
<td align="left">修改历史提交的说明</td>
<td align="left">git rebase -i</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-45.html" target="_blank" rel="noopener">第45关 squash</a></td>
<td align="left">把多次提交合并成一次提交</td>
<td align="left">git rebase -i</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-46.html" target="_blank" rel="noopener">第46关 merge_squash</a></td>
<td align="left">合并分支时把多次提交合并成一次提交</td>
<td align="left">git merge –squash</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-47.html" target="_blank" rel="noopener">第47关 reorder</a></td>
<td align="left">调整提交顺序</td>
<td align="left">git rebase -i</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-48.html" target="_blank" rel="noopener">第48关 bisect</a></td>
<td align="left">用二分法定位 bug</td>
<td align="left">git bisect</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-49.html" target="_blank" rel="noopener">第49关 stage_lines</a></td>
<td align="left">添加文件的部分行到暂存区</td>
<td align="left">git add –edit</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-50.html" target="_blank" rel="noopener">第50关 file_old_branch</a></td>
<td align="left">查看 Git 上的操作历史</td>
<td align="left">git reflog</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-51.html" target="_blank" rel="noopener">第51关 revert</a></td>
<td align="left">取消已推送到远程仓库的提交</td>
<td align="left">git revert</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-52.html" target="_blank" rel="noopener">第52关 restore</a></td>
<td align="left">恢复被删除的提交</td>
<td align="left">git reset –hard</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-53.html" target="_blank" rel="noopener">第53关 conflict</a></td>
<td align="left">解决冲突</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-54.html" target="_blank" rel="noopener">第54关 submodule</a></td>
<td align="left">把第三方库当作子模块</td>
<td align="left">git submodule</td>
</tr>
<tr>
<td align="left"><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough/level-55.html" target="_blank" rel="noopener">第55关 contribute</a></td>
<td align="left">捐献</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>把这个游戏全部通关，你的操作绝对又上N个台阶~</p>
<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="http://wiki.jikexueyuan.com/project/githug-walkthrough" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/githug-walkthrough</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>给一个即将大学毕业同学的回复</title>
    <url>/2019/06/05/2019/06/%E7%BB%99%E4%B8%80%E4%B8%AA%E5%8D%B3%E5%B0%86%E5%A4%A7%E5%AD%A6%E6%AF%95%E4%B8%9A%E5%90%8C%E5%AD%A6%E7%9A%84%E5%9B%9E%E5%A4%8D/</url>
    <content><![CDATA[<h4 id="1、问："><a href="#1、问：" class="headerlink" title="1、问："></a>1、问：</h4><h5 id="1-1、开发岗与算法岗的选择"><a href="#1-1、开发岗与算法岗的选择" class="headerlink" title="1.1、开发岗与算法岗的选择"></a>1.1、开发岗与算法岗的选择</h5><p>听同学说，开发岗相对于算法岗没有那么看重学历，更看重技术。而学习开发不如不读研，工作三年在公司的学习肯定比读研学习三年要好。算法的话，一般本科生是不会接触的，至少要研究生，这就可以发挥读研的优势，但是竞争也会更激烈，岗位相对较少，要求更高。</p>
<p>我自己对于算法，只看过一些最基础的机器学习视频。对于开发，本科学过<code>Java</code>，<code>C</code>,<code>C++</code>,有一定的编程能力。但是因为没有做过项目，没有过实习经验，对于一些业务，框架，设计模式，优化等几乎没有概念，也不知道在公司工作具体是要做些什么，对开发人员的要求是什么。</p>
<p>因为对这两者，都没有进行过深入的学习，所以也谈不上喜欢和不喜欢。所以也有人问，你喜欢哪个方向就可以尝试着去学，但我就是觉得在对一个东西不了解的情况下，谈不上好恶。</p>
<h5 id="1-2、前端后台的学习方法"><a href="#1-2、前端后台的学习方法" class="headerlink" title="1.2、前端后台的学习方法"></a>1.2、前端后台的学习方法</h5><p>因为一直以来受到的教育就是从0一步步学起，包括高考和考研，那是一种教科书式的学习。一直以来我也是用的这一套学习方法来学习开发，发现四处碰壁。比如我在完全不会前端的情况下，就从最基础的<code>HTML</code>，<code>CSS</code>学起，发现这些知识很简单，但是又特别多，特别杂乱，没办法坚持学下去。学完以后还要学<code>JS</code>，<code>ES6</code>语法，然后学习<code>React</code>框架这些。这样一步步学起了，已经不可能有那么多时间弄别的了，而且学习效率也是极低。</p>
<p>后来要同学告诉我要转变这些学习方法，要根据需求来学习，需要什么就学什么，要我好好利用<code>Github</code>，各大博客，好好学习别人的代码，和源码，然后自己尝试做一些项目，边做边学习，边总结。但是在这过程中也是困难重重，比如<code>Github</code>上看别人代码也看不太懂，自己做项目，也不知道拍脑袋做个什么项目出来，脑子是空白的。</p>
<p>之所以说前端，是因为好像看到很多做开发的同学，他们都是前端后台通吃，他们说都需要了解，竞争力会强一点，做全栈。如果倾向于做后台的话，前端大概要学习到什么程度。</p>
<p>我们实验室听说还有人去了华为的数据库组，完全不知道专门的数据库组是做什么的。</p>
<h5 id="1-3-对于acm和leetcode刷题"><a href="#1-3-对于acm和leetcode刷题" class="headerlink" title="1.3. 对于acm和leetcode刷题"></a>1.3. 对于acm和leetcode刷题</h5><p>本科唯一学过一段时间的，就是刷这些算法题。这些究竟对于公司做项目有没有用，还是说只是锻炼了逻辑思维，是能力的一种体现。如果为以后准备面试笔试，需不需要从现在开始每天刷几道题保持手感。</p>
<h5 id="1-4-开发岗的行情"><a href="#1-4-开发岗的行情" class="headerlink" title="1.4. 开发岗的行情"></a>1.4. 开发岗的行情</h5><p>这个差不多是问题1的详细。师兄的公司或者互联网公司，大多数真的是996这样的工作时间吗。另外它的工资水平和发展前景是什么样的，据说有按等级划分。还有同学说过程序员吃青春饭这一套，没有晋升到管理层，就容易被裁掉一说。做开发真的很辛苦吗。</p>
<p>总结下来，就是想向师兄了解一下，两种岗位的选择，开发岗的行情，开发的学习方法。</p>
<h4 id="2、答"><a href="#2、答" class="headerlink" title="2、答"></a>2、答</h4><p>首先值得肯定，写的很棒，是带思考的。</p>
<p>“思想比行动重要”这点是我最近几年才想明白的，以前我都觉得行动比思想重要，不喜欢天马行空。我们都是工科思维，讲行动、讲落地。但忽略一个前提，我们需要一个好的思想去引导。如果养成一个独立思考的能力，总能从不同的视角去看待问题，抛开其他不说，你就已经走在了所有人去前列。</p>
<p>回到你的问题，我站在我个人的角度谈谈，但最终你自己来判断。</p>
<h5 id="2-1、关于开发岗与算法岗"><a href="#2-1、关于开发岗与算法岗" class="headerlink" title="2.1、关于开发岗与算法岗"></a>2.1、关于开发岗与算法岗</h5><p>看了描述里面应该算是2个问题，一个是开发工程师与算法工程师的门槛。另外一个是读研与直接参加工作带来的效益谁好？</p>
<p>首先开发与算法工程师做的事情是不同的。不得不是说，算法工程师对于学历、专业深度会更深入。</p>
<p><strong>算法工程师：</strong>可能更多偏向于数学、物理、生物等，只是他用计算机语言来实现。</p>
<p><strong>开发工程师：</strong>需要理解业务、产品、以及架构能力，还有对于框架的应用，考虑更多的时候如何利用更多的工具造出更大、更高的建筑；</p>
<h5 id="2-2、前端与后端的学习"><a href="#2-2、前端与后端的学习" class="headerlink" title="2.2、前端与后端的学习"></a>2.2、前端与后端的学习</h5><p>在几年前，我们还在说前端没有什么搞头，还是后端的路子多一些，确实如此，后端才是这课树下面的根。但随着计算机技术的发展，现在前端也变得越来越强、越来越多样化。包括在写法与语法上都已经跟后端相似了。</p>
<p><strong>后端：</strong>注重系统的并发、高可用、稳定、安全、业务的分割、问题的定位、大数据分析等等；</p>
<p><strong>前端：</strong>注重渲染、交互、动画等等（前端我不是很专业，所以说不出太多所以然）</p>
<p>如果说按照薪水来划分，现在前端反而优势更明显，但是后面会稍微的遇到一些屏障，但不会太大。</p>
<p>再谈你说好多东西需要学习，那是肯定的。后端需要掌握的东西更多，你到后面会有一种感觉那就是：知识永远学习不完，了解底层的东西才是重要的。而且要知其然还要知其所以然。还有你会觉得知道的越多，越觉得自己了解的少。</p>
<p>在现在的行情里面，前后通吃是有必要的，因为前后是需要相互配合的。只有了解前端或者后端是如何做的，在沟通上或者设计上才会考虑的更全面。哪天真的如果自己要创业或者需要前后都自己上，那也显得很从容嘛！</p>
<h5 id="2-3、关于刷题"><a href="#2-3、关于刷题" class="headerlink" title="2.3、关于刷题"></a>2.3、关于刷题</h5><p>对于刚刚毕业的同学，这个是很重要的。因为缺少社会经验与项目经验，那么在一些原理、理论上的知识显得格外重要。刷题跟做试卷类似，做的越多，知道的也就越多。而且面试官也很看重这些东西，如果去BAT或者TMD这些公司，这些是必然的过关内容。</p>
<h5 id="2-4、职业生涯的发展"><a href="#2-4、职业生涯的发展" class="headerlink" title="2.4、职业生涯的发展"></a>2.4、职业生涯的发展</h5><p>如果是走技术，前期基本都是一样的，后期就会因人而异。</p>
<p><strong>基本的一个成长历程：</strong>初级开发→中级开发→高级开发→资深/专家开发→架构师→技术总监→CTO。</p>
<p>在高级或者资深这里，就会有分歧，这个也要看性格。</p>
<p><strong>纯技术：</strong>有的人就喜欢钻研技术、喜欢算法等，想下沉到最底层去，那就走纯技术路线，但道路会非常的孤独，如果真的是有所突破，那就是一下子出人头地。</p>
<p><strong>偏管理：</strong>首先是自己有一定的技术沉淀，后面就开始带领团队做事情了，更多的是跟人打交道，如何合理的分配、拆分需求等。对公司技术发展的整体规划，包括：技术、业务、人力等。</p>
<p>对于薪水，我觉得你完全不用担心，每个岗位都有他的平均水平。而且薪水与能力直接挂钩，与年纪没有必然的关系。然而，我觉得出来工作或者自己创业，都非常辛苦。天上不会掉馅饼，拿一份不辛苦还能那很多的钱的差事儿理论上不应该有，除非是富二代。但是，后期我们如果能做一些理财，我们的收入不完全靠一份薪水，我们也许不会那么累。</p>
<p>关于996，这个话题我也不好说。加班是很辛苦，确实也会带来一些成长，但我们不都会要求强制加班，相对还是比较自由。部分公司，加班是有加班费用或者补贴的。没结婚之前，估计对996没有那么介意，如果有家庭后，需要平衡家庭与工作的关系，可能会介意。</p>
<h5 id="2-5、总结"><a href="#2-5、总结" class="headerlink" title="2.5、总结"></a>2.5、总结</h5><p>上面说了这些，都是针对你的问题做的一个回复。但任何东西都会存在一些方法，我把我觉得参加工作后的一些心得分享给你，希望对你有一定的帮助，还是那句话：我瞎说，你自己来判断。</p>
<p>1、无论在哪儿，我们最终一定都是解决一个问题，避免不了跟人打交道，所以认识人是到一个新环境里面最先要做的事情，后面做的就是如何让人认识你了；</p>
<p>2、要逐步逐步的认识自己，这点很难却很重要。因为，自己大多的不开心或者郁闷，都是对于自己不认识造成的，比如：自己找不到目标；做的事情开始喜欢后面就不喜欢了；为什么做事情不够洒脱，顾着顾拿。总之就是让自己不盲目、越快的做事情；</p>
<p>3、人生是分阶段的，每个阶段做好每个阶段的事情就好了。但每个阶段时间长短是可以控制的，看如何突破自己的认知，一般可以找一个偶像作为目标，或者通过阅读来突破自己；</p>
<p>4、专业知识要成体系，不能是零零碎碎的，串联不起来。有的人是广度优先，后面找出一个喜欢的，在深度进去；还有人是深度优先，在某一个专业先扎根，然后再在周边扩展自己的广度。这个我觉得都行，看每个人的性格或者看当前你是否找到了喜好。</p>
<p>5、要学习的东西真的很多，但底层的东西并没有那么多。但很难说一开始就扎入到底层去，因为是有门槛的。大多数人都是先学会使用，知道一个API是如何如何的~ 后面才会去阅读源代码，跟其他同类型的做对比。看源代码是一个非常有意思的事情，看的越多越觉得简单。不过，刚刚开始肯定是相当痛苦的。</p>
<p>6、实践是检验真理的唯一标准！没错啊，很多东西没有捷径，那就是多做。对于开发来说，那就是多写代码，看一遍与敲一遍，完全不是同一个概念。</p>
<p>7、时间管理，到后面每个人的时间都是零碎的，被打断的。如何留给自己足够的时间是一门学门，可以多学习一些时间管理的方法；</p>
<p>8、保持一些原则性的东西会让自己活得简单些，符合的我就要，不符合的就不碰他。比如：</p>
<ul>
<li>尊重每一个人的意见；</li>
<li>拥有开放的心态，不要先排斥；</li>
<li>拥有较强的业务，技术的专业度；</li>
<li>拆分与总结能力；</li>
<li>良好的沟通能力；</li>
<li>一定的创新能力；</li>
</ul>
<p>每个人的人生道路轨迹都一样，自己走的路自己来把握。希望你可以走出一条星光大道出来。</p>
<p>仅供你参考。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>随感</tag>
      </tags>
  </entry>
  <entry>
    <title>我们如何看SpringBoot的源代码</title>
    <url>/2019/06/10/2019/06/%E6%88%91%E4%BB%AC%E5%A6%82%E4%BD%95%E7%9C%8BSpringBoot%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h4 id="我们如何看SpringBoot的源代码"><a href="#我们如何看SpringBoot的源代码" class="headerlink" title="我们如何看SpringBoot的源代码"></a>我们如何看SpringBoot的源代码</h4><h5 id="1、快速生成一个简单的SpringBoot项目"><a href="#1、快速生成一个简单的SpringBoot项目" class="headerlink" title="1、快速生成一个简单的SpringBoot项目"></a>1、快速生成一个简单的SpringBoot项目</h5><p>进入地址：<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> ，点击生成代码即可。</p>
<p><img src="http://static.cyblogs.com/QQ20190612-155510@2x.jpg" alt="http://static.cyblogs.com/QQ20190612-155510@2x.jpg"></p>
<h5 id="2、注解：-SpringBootApplication"><a href="#2、注解：-SpringBootApplication" class="headerlink" title="2、注解：@SpringBootApplication"></a>2、注解：@SpringBootApplication</h5><p>一个Web项目，只需要这一行注解。有这么厉害吗？我们一起看看它究竟做了什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringBootDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>@SpringBootApplication</code> annotation is equivalent to using <code>@Configuration</code>, <code>@EnableAutoConfiguration</code>, and <code>@ComponentScan</code> with their default attributes</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">		@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>看代码，明明是<code>@SpringBootConfiguration</code>呢，怎么说是<code>@Configuration</code>呢？</p>
<h6 id="2-1、注解：-SpringBootConfiguration"><a href="#2-1、注解：-SpringBootConfiguration" class="headerlink" title="2.1、注解：@SpringBootConfiguration"></a>2.1、注解：@SpringBootConfiguration</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再进入到里面去，发现竟然是<code>Component</code>注解？是不是非常熟悉呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br></pre></td></tr></table></figure>

<p>Spring provides further stereotype annotations: <code>@Component</code>, <code>@Service</code>, and <code>@Controller</code>. <code>@Component</code> is a generic stereotype for any Spring-managed component. <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> are specializations of <code>@Component</code> for more specific use cases (in the persistence, service, and presentation layers, respectively)。</p>
<h6 id="2-2、注解：-ComponentScan"><a href="#2-2、注解：-ComponentScan" class="headerlink" title="2.2、注解：@ComponentScan"></a>2.2、注解：@ComponentScan</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.SpringApplication</span><br><span class="line"><span class="comment">// 第1步</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">	refreshContext(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第2步</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// Called after the context has been refreshed.</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    listeners.running(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第3步</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">		Assert.isInstanceOf(AbstractApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">applicationContext</span>)</span>;</span><br><span class="line">		((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第4步</span></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">	<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第5步</span></span><br><span class="line">org.springframework.context.support.PostProcessorRegistrationDelegate</span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">        registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第6步</span></span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第7步</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第8步</span></span><br><span class="line">org.springframework.context.annotation.ConfigurationClassParser</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第9步</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), PropertySources<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">            <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">context</span>.<span class="title">annotation</span>.<span class="title">PropertySource</span>.<span class="title">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), ComponentScans<span class="class">.<span class="keyword">class</span>, <span class="title">ComponentScan</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">            !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                    <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process any @Import annotations</span></span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">    AnnotationAttributes importResource =</span><br><span class="line">            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第10步</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">        Collection&lt;SourceClass&gt; importCandidates, <span class="keyword">boolean</span> checkForCircularImports)</span> </span>&#123;</span><br><span class="line">    String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">    Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">    processImports(configClass, currentSourceClass, importSourceClasses, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第11步</span></span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportSelector</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(</span><br><span class="line">            autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第12步</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; configurations,</span></span></span><br><span class="line"><span class="function"><span class="params">        AutoConfigurationMetadata autoConfigurationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) &#123;</span><br><span class="line">        invokeAwareMethods(filter);</span><br><span class="line">        <span class="keyword">boolean</span>[] match = filter.match(candidates, autoConfigurationMetadata);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; match.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!match[i]) &#123;</span><br><span class="line">                skip[i] = <span class="keyword">true</span>;</span><br><span class="line">                candidates[i] = <span class="keyword">null</span>;</span><br><span class="line">                skipped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第13步</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;AutoConfigurationImportFilter&gt; <span class="title">getAutoConfigurationImportFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">this</span>.<span class="title">beanClassLoader</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第14步</span></span><br><span class="line">org.springframework.core.io.support.SpringFactoriesLoader</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第15步</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br></pre></td></tr></table></figure>

<p>也就是说，其实<code>spring.factories</code>是<code>spring-core</code>的功能。</p>
<p>看一下<code>spring-boot-autoconfigure</code>项目里面的<code>spring.factories</code>。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Initializers</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configuration Import Listeners</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.AutoConfigurationImportListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configuration Import Filters</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Failure analyzers</span></span><br><span class="line"><span class="meta">org.springframework.boot.diagnostics.FailureAnalyzer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Template availability providers</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span></span><br></pre></td></tr></table></figure>

<p>看到这里，是不是有一点解惑了，为什么我们什么都没有干，它就已经具备了那么多的功能。因为在项目启动的时候，已经就给我们内置了这么多的服务。</p>
<h5 id="3、容器在哪儿启动的？"><a href="#3、容器在哪儿启动的？" class="headerlink" title="3、容器在哪儿启动的？"></a>3、容器在哪儿启动的？</h5><h6 id="3-1-为什么是Tomcat默认启动？"><a href="#3-1-为什么是Tomcat默认启动？" class="headerlink" title="3.1 为什么是Tomcat默认启动？"></a>3.1 为什么是Tomcat默认启动？</h6><p>我们再回到开始的时候，为什么启动的时候看到了<code>Tomcat</code>的日志呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:56945', transport: 'socket'</span><br><span class="line"></span><br><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  '  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::                        </span><br><span class="line"></span><br><span class="line">2019-06-13 09:15:11.818  INFO 16978 --- [           main] c.e.s.SpringBootDemoApplication          : Starting SpringBootDemoApplication on bogon with PID 16978 (/Users/chenyuan/Dropbox/Workspaces/IdeaProjects/spring-boot-demo/target/classes started by chenyuan in /Users/chenyuan/Dropbox/Workspaces/IdeaProjects/spring-src-leaning)</span><br><span class="line">2019-06-13 09:15:11.823  INFO 16978 --- [           main] c.e.s.SpringBootDemoApplication          : No active profile set, falling back to default profiles: default</span><br><span class="line"></span><br><span class="line">// 这里日志显示，有一个embedded的tomcat启动了8080端口</span><br><span class="line">2019-06-13 09:15:13.597  INFO 16978 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="line">2019-06-13 09:15:13.644  INFO 16978 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2019-06-13 09:15:13.645  INFO 16978 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.14]</span><br><span class="line">2019-06-13 09:15:13.653  INFO 16978 --- [           main] o.a.catalina.core.AprLifecycleListener   : The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/Users/chenyuan/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.]</span><br><span class="line">2019-06-13 09:15:13.752  INFO 16978 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2019-06-13 09:15:13.752  INFO 16978 --- [           main] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1862 ms</span><br><span class="line">2019-06-13 09:15:14.018  INFO 16978 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'</span><br><span class="line">2019-06-13 09:15:14.226  INFO 16978 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''</span><br><span class="line">2019-06-13 09:15:14.231  INFO 16978 --- [           main] c.e.s.SpringBootDemoApplication          : Started SpringBootDemoApplication in 3.007 seconds (JVM running for 3.924)</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(name = <span class="string">"org.apache.catalina.startup.Tomcat"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TomcatServletWebServerFactoryCustomizer <span class="title">tomcatServletWebServerFactoryCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ServerProperties serverProperties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> TomcatServletWebServerFactoryCustomizer(serverProperties);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/QQ20190614-085006@2x.jpg" alt="http://static.cyblogs.com/QQ20190614-085006@2x.jpg"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-boot-demo/pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring-boot-starter-web/pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring-boot-starters/spring-boot-starter-tomcat/pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="3-2-如果要指定其他的容器呢？"><a href="#3-2-如果要指定其他的容器呢？" class="headerlink" title="3.2 如果要指定其他的容器呢？"></a>3.2 如果要指定其他的容器呢？</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>把项目中Tomca的starter注释掉，引入Jetty容器即可。</p>
<p>这么更换后，为什么就又能引入了呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryConfiguration</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">Server</span>.<span class="title">class</span>, <span class="title">Loader</span>.<span class="title">class</span>,<span class="title">WebAppContext</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">value</span> </span>= ServletWebServerFactory<span class="class">.<span class="keyword">class</span>, <span class="title">search</span> </span>= SearchStrategy.CURRENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedJetty</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JettyServletWebServerFactory <span class="title">JettyServletWebServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JettyServletWebServerFactory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>@ConditionalOnClass</code> and <code>@ConditionalOnMissingClass</code> annotations let <code>@Configuration</code> classes be included based on the presence or absence of specific classes. </p>
<p>这里的<code>Servlet.class, Server.class, Loader.class,WebAppContext.class</code> 就是Jetty里面的包。</p>
<p>这里还设计了一个工厂模式，获取一个WebServer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletWebServerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Gets a new fully configured but paused &#123;<span class="doctag">@link</span> WebServer&#125; instance. Clients should</span></span><br><span class="line"><span class="comment">	 * not be able to connect to the returned server until &#123;<span class="doctag">@link</span> WebServer#start()&#125; is</span></span><br><span class="line"><span class="comment">	 * called (which happens when the &#123;<span class="doctag">@link</span> ApplicationContext&#125; has been fully</span></span><br><span class="line"><span class="comment">	 * refreshed).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> initializers &#123;<span class="doctag">@link</span> ServletContextInitializer&#125;s that should be applied as</span></span><br><span class="line"><span class="comment">	 * the server starts</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a fully configured and started &#123;<span class="doctag">@link</span> WebServer&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> WebServer#stop()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">WebServer <span class="title">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-3-那是在什么时候初始化容器的呢？"><a href="#3-3-那是在什么时候初始化容器的呢？" class="headerlink" title="3.3 那是在什么时候初始化容器的呢？"></a>3.3 那是在什么时候初始化容器的呢？</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第1步</span></span><br><span class="line">org.springframework.context.support.AbstractApplicationContext</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第2步</span></span><br><span class="line">org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onRefresh();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		createWebServer();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Unable to start web server"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第3步</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">	ServletContext servletContext = getServletContext();</span><br><span class="line">	<span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">		ServletWebServerFactory factory = getWebServerFactory();</span><br><span class="line">		<span class="keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			getSelfInitializer().onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Cannot initialize servlet context"</span>,</span><br><span class="line">					ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看到<code>factory.getWebServer</code>，是不是就全部都串联起来了？</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7上安装Docker</title>
    <url>/2019/10/25/2019/10/CentOS7%E4%B8%8A%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h4 id="设置yum源"><a href="#设置yum源" class="headerlink" title="设置yum源"></a>设置yum源</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h4 id="让yum更新到最新"><a href="#让yum更新到最新" class="headerlink" title="让yum更新到最新"></a>让yum更新到最新</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure>

<h4 id="查看仓库中所有docker的版本"><a href="#查看仓库中所有docker的版本" class="headerlink" title="查看仓库中所有docker的版本"></a>查看仓库中所有docker的版本</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 ~]$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line"> * updates: mirrors.njupt.edu.cn</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line"> * extras: mirrors.njupt.edu.cn</span><br><span class="line">docker-ce.x86_64            3:19.03.4-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.3-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.2-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:19.03.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.9-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.8-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.7-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.6-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.5-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.4-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.3-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.2-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.3.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.2.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.06.0.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.03.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            18.03.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.12.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.12.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.09.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.09.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.06.2.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.06.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.06.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.03.3.ce-1.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.03.2.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.03.1.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.03.0.ce-1.el7.centos             docker-ce-stable</span><br><span class="line">Determining fastest mirrors</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line">Available Packages</span><br></pre></td></tr></table></figure>

<h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce #由于repo中默认只开启stable仓库</span><br><span class="line">sudo yum install &lt;FQPN&gt;  # 例如：sudo yum install docker-ce-18.09.9-3.el7</span><br></pre></td></tr></table></figure>

<h4 id="启动并加入开机启动项"><a href="#启动并加入开机启动项" class="headerlink" title="启动并加入开机启动项"></a>启动并加入开机启动项</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>

<h4 id="删除当前的Docker"><a href="#删除当前的Docker" class="headerlink" title="删除当前的Docker"></a>删除当前的Docker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine</span><br></pre></td></tr></table></figure>

<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="https://www.cnblogs.com/yufeng218/p/8370670.html" target="_blank" rel="noopener">https://www.cnblogs.com/yufeng218/p/8370670.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7查看和关闭防火墙</title>
    <url>/2019/10/24/2019/10/CentOS7%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<p>在搭建Kubernetes环境的时候报了一个错误，顺便温习一下防火墙的知识。</p>
<h4 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 Workspace]$ sudo firewall-cmd --state</span><br><span class="line">running</span><br></pre></td></tr></table></figure>

<h4 id="停止防火墙"><a href="#停止防火墙" class="headerlink" title="停止防火墙"></a>停止防火墙</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 Workspace]$ sudo systemctl stop firewalld.service </span><br><span class="line">[sudo] password for parallels: </span><br><span class="line">[parallels@CentOS7-Node1 Workspace]$ sudo firewall-cmd --state</span><br><span class="line">not running</span><br></pre></td></tr></table></figure>

<h4 id="禁止firewall开机启动"><a href="#禁止firewall开机启动" class="headerlink" title="禁止firewall开机启动"></a>禁止firewall开机启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure>

<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7系统上Kubernetes集群搭建</title>
    <url>/2019/10/26/2019/10/CentOS7%E7%B3%BB%E7%BB%9F%E4%B8%8AKubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h4><p>在自己的Mac系统里面利用<code>Parallels Desktop</code>创建3台虚拟机，具体信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CentOS7-Node1:</span><br><span class="line">  10.211.55.7 </span><br><span class="line">  parallels/centos-test</span><br><span class="line"></span><br><span class="line">CentOS7-Node2:</span><br><span class="line">  10.211.55.8</span><br><span class="line">  parallels/centos-test</span><br><span class="line"></span><br><span class="line">CentOS7-Node3:</span><br><span class="line">  10.211.55.9</span><br><span class="line">  parallels/centos-test</span><br></pre></td></tr></table></figure>

<h4 id="Master安装"><a href="#Master安装" class="headerlink" title="Master安装"></a>Master安装</h4><p>选择<code>CentOS7-Node1</code>机器作为Master节点。</p>
<h5 id="配置yum"><a href="#配置yum" class="headerlink" title="配置yum"></a>配置yum</h5><p>更新yum源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 yum.repos.d]$ cd /etc/yum.repos.d</span><br><span class="line">[parallels@CentOS7-Node1 yum.repos.d]$ sudo touch kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br></pre></td></tr></table></figure>

<h5 id="安装Kubernetes环境"><a href="#安装Kubernetes环境" class="headerlink" title="安装Kubernetes环境"></a>安装Kubernetes环境</h5><p>评估下来，利用kubeadm来搭建是大家比较推荐的，而且公司的集群也是。所以毫不忧虑就用kubeadm。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 yum.repos.d]$ yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">You need to be root to perform this command.</span><br><span class="line">[parallels@CentOS7-Node1 yum.repos.d]$ sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">kubernetes                                                                                                                                                         | 1.4 kB  00:00:00     </span><br><span class="line">kubernetes/primary                                                                                                                                                 |  58 kB  00:00:00     </span><br><span class="line">kubernetes                                                                                                                                                                        421/421</span><br><span class="line">Resolving Dependencies</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line">...... # 省略一堆无意义的日志</span><br><span class="line">Dependency Installed:</span><br><span class="line">  conntrack-tools.x86_64 0:1.4.4-5.el7_7.2             cri-tools.x86_64 0:1.13.0-0                    kubernetes-cni.x86_64 0:0.7.5-0      libnetfilter_cthelper.x86_64 0:1.0.0-10.el7_7.1     </span><br><span class="line">  libnetfilter_cttimeout.x86_64 0:1.0.0-6.el7_7.1      libnetfilter_queue.x86_64 0:1.0.2-2.el7_2      socat.x86_64 0:1.7.3.2-2.el7        </span><br><span class="line"></span><br><span class="line">Complete!</span><br></pre></td></tr></table></figure>

<h5 id="关于yum的配置与升级"><a href="#关于yum的配置与升级" class="headerlink" title="关于yum的配置与升级"></a>关于yum的配置与升级</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure>

<h5 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h5><p>启动Docker，加入开启机动项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 ~]$ sudo systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line">[sudo] password for parallels: </span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br></pre></td></tr></table></figure>

<h5 id="启动kubelet"><a href="#启动kubelet" class="headerlink" title="启动kubelet"></a>启动kubelet</h5><p>启动kubelet，加入开机启动项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line">[parallels@CentOS7-Node1 ~]$ sudo systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/kubelet.service to /usr/lib/systemd/system/kubelet.service.</span><br><span class="line">==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===</span><br><span class="line">Authentication is required to manage system services or units.</span><br><span class="line">Authenticating as: Parallels (parallels)</span><br><span class="line">Password: </span><br><span class="line">==== AUTHENTICATION COMPLETE ===</span><br></pre></td></tr></table></figure>

<p>kubeadm config</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 Workspace]$ kubeadm config print init-defaults</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 1.2.3.4</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /var/run/dockershim.sock</span><br><span class="line">  name: centos7-node1</span><br><span class="line">  taints:</span><br><span class="line">  - effect: NoSchedule</span><br><span class="line">    key: node-role.kubernetes.io/master</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns:</span><br><span class="line">  type: CoreDNS</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: k8s.gcr.io</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.16.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm config print init-defaults &gt; /home/parallels/Workspace/init.default.yaml</span><br></pre></td></tr></table></figure>

<h4 id="配置Docker"><a href="#配置Docker" class="headerlink" title="配置Docker"></a>配置Docker</h4><p>首先要安装好Docker环境，请参考之前的 <a href="http://www.cyblogs.com/centos7shang-an-zhuang-docker/">http://www.cyblogs.com/centos7shang-an-zhuang-docker/</a></p>
<p>Docker的一些相关命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce-18.09.9-3.el7 # 指定版本为18.09.9-3.el7</span><br><span class="line"></span><br><span class="line">systemctl status docker</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<h4 id="下载kubernetes的相关镜像"><a href="#下载kubernetes的相关镜像" class="headerlink" title="下载kubernetes的相关镜像"></a>下载kubernetes的相关镜像</h4><p>配置镜像地址，但没什么用。后面还是需要用到国内的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo '&#123;"registry-mirrors":["https://docker.mirrors.ustc.edu.cn"]&#125;' &gt; /etc/docker/daemon.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果提示没有权限，就手动vim添加进去。然后重启docker服务</span></span><br></pre></td></tr></table></figure>

<p>查看一下kubernetes依赖的镜像名称以及版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 Workspace]$ kubeadm config images list</span><br><span class="line">W1022 13:51:12.550171   19704 version.go:101] could not fetch a Kubernetes version from the internet: unable to get URL "https://dl.k8s.io/release/stable-1.txt": Get https://dl.k8s.io/release/stable-1.txt: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</span><br><span class="line">W1022 13:51:12.550458   19704 version.go:102] falling back to the local client version: v1.16.2</span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.16.2</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.16.2</span><br><span class="line">k8s.gcr.io/pause:3.1</span><br><span class="line">k8s.gcr.io/etcd:3.3.15-0</span><br><span class="line">k8s.gcr.io/coredns:1.6.2</span><br></pre></td></tr></table></figure>

<p>如果网络OK，应该直接执行这个命令即可，但实际会报错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 Workspace]$ sudo kubeadm config images pull --config=/home/parallels/Workspace/init.default.yaml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里由于网络拉取镜像的问题，基本无法操作，只能先去aliyun获取回来后再修改tag的方式,错误如下。</span></span><br><span class="line">[parallels@CentOS7-Node1 Workspace]$ sudo kubeadm config images pull --config=/home/parallels/Workspace/init.default.yaml</span><br><span class="line">[sudo] password for parallels: </span><br><span class="line">failed to pull image "k8s.gcr.io/kube-apiserver:v1.16.0": output: Error response from daemon: Get https://k8s.gcr.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</span><br><span class="line">, error: exit status 1</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure>
<h5 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h5><p>通过另外一种方式来获取镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch kubeadm.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">KUBE_VERSION=v1.16.0</span><br><span class="line">KUBE_PAUSE_VERSION=3.1</span><br><span class="line">ETCD_VERSION=3.3.15-0</span><br><span class="line">CORE_DNS_VERSION=1.6.2</span><br><span class="line"></span><br><span class="line">GCR_URL=k8s.gcr.io</span><br><span class="line">ALIYUN_URL=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line"></span><br><span class="line">images=(</span><br><span class="line">	kube-apiserver:$&#123;KUBE_VERSION&#125;</span><br><span class="line">	kube-controller-manager:$&#123;KUBE_VERSION&#125;</span><br><span class="line">	kube-scheduler:$&#123;KUBE_VERSION&#125;</span><br><span class="line">	kube-proxy:$&#123;KUBE_VERSION&#125;</span><br><span class="line">	pause:$&#123;KUBE_PAUSE_VERSION&#125;</span><br><span class="line">	etcd:$&#123;ETCD_VERSION&#125;</span><br><span class="line">	coredns:$&#123;CORE_DNS_VERSION&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">  docker pull $ALIYUN_URL/$imageName</span><br><span class="line">  docker tag  $ALIYUN_URL/$imageName $GCR_URL/$imageName</span><br><span class="line">  docker rmi  $ALIYUN_URL/$imageName</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u+x kubeadm.sh # 添加权限</span><br><span class="line">sudo ./kubeadm.sh</span><br></pre></td></tr></table></figure>

<p>剩下的就是耐心等待……</p>
<p>查看最终本地的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 Workspace]# docker images</span><br><span class="line">REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">k8s.gcr.io/kube-apiserver            v1.16.0             b305571ca60a        4 weeks ago         217MB</span><br><span class="line">k8s.gcr.io/kube-proxy                v1.16.0             c21b0c7400f9        4 weeks ago         86.1MB</span><br><span class="line">k8s.gcr.io/kube-controller-manager   v1.16.0             06a629a7e51c        4 weeks ago         163MB</span><br><span class="line">k8s.gcr.io/kube-scheduler            v1.16.0             301ddc62b80b        4 weeks ago         87.3MB</span><br><span class="line">k8s.gcr.io/etcd                      3.3.15-0            b2756210eeab        6 weeks ago         247MB</span><br><span class="line">k8s.gcr.io/coredns                   1.6.2               bf261d157914        2 months ago        44.1MB</span><br><span class="line">k8s.gcr.io/pause                     3.1                 da86e6ba6ca1        22 months ago       742kB</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[parallels@CentOS7-Node1 Workspace]$ sudo kubeadm init --config=init.default.yaml </span><br><span class="line">[init] Using Kubernetes version: v1.16.0</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Firewalld]: firewalld is active, please ensure ports [6443 10250] are open or your cluster may not function correctly</span><br><span class="line">        [WARNING IsDockerSystemdCheck]: detected "cgroupfs" as the Docker cgroup driver. The recommended driver is "systemd". Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">        [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 19.03.4. Latest validated version: 18.09</span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">        [ERROR Swap]: running with swap on is not supported. Please disable swap</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure>
<h5 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h5><p>解决掉防火墙的问题，请参阅：<a href="http://www.cyblogs.com/centos7cha-kan-he-guan-bi-fang-huo-qiang/">http://www.cyblogs.com/centos7cha-kan-he-guan-bi-fang-huo-qiang/</a> </p>
<h5 id="cgroupfs错误"><a href="#cgroupfs错误" class="headerlink" title="cgroupfs错误"></a>cgroupfs错误</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">detected "cgroupfs" as the Docker cgroup driver</span><br></pre></td></tr></table></figure>

<p>新增：/etc/docker/daemon.json</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": [</span><br><span class="line">    "https://registry.docker-cn.com"</span><br><span class="line">  ],</span><br><span class="line">  "live-restore": true,</span><br><span class="line">  "exec-opts": [</span><br><span class="line">    "native.cgroupdriver=systemd" # 修改用户</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新启动Docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<h5 id="禁止swap"><a href="#禁止swap" class="headerlink" title="禁止swap"></a>禁止swap</h5><p>还是发现需要禁止掉<code>swap</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Oct 22 16:35:36 CentOS7-Node1 kubelet[1395]: F1022 16:35:36.065168    1395 server.go:271] failed to run Kubelet: running with swap on is not supported, please disable swap! or set --fail-swap-on flag to false. /proc/swaps contained: [Filename                                Type                Size        Used        Priority /dev/dm-1                               partition        2097148        29952        -1]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line"><span class="meta">#</span><span class="bash">要永久禁掉swap分区，打开如下文件注释掉swap那一行</span></span><br><span class="line">sudo vi /etc/fstab</span><br></pre></td></tr></table></figure>


<p>再次启动<code>kubeadm init</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --config=init.default.yaml</span><br><span class="line"></span><br><span class="line">[init] Using Kubernetes version: v1.16.2</span><br><span class="line">...</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">...</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">...</span><br><span class="line">[certs] Using certificateDir folder "/etc/kubernetes/pki"</span><br><span class="line">...</span><br><span class="line">[kubeconfig] Using kubeconfig folder "/etc/kubernetes"</span><br><span class="line">...</span><br><span class="line">[kubelet-check] Initial timeout of 40s passed.</span><br><span class="line">[kubelet-check] It seems like the kubelet isn't running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to 'curl -sSL http://localhost:10248/healthz' failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line">[kubelet-check] It seems like the kubelet isn't running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to 'curl -sSL http://localhost:10248/healthz' failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line">[kubelet-check] It seems like the kubelet isn't running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to 'curl -sSL http://localhost:10248/healthz' failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line">[kubelet-check] It seems like the kubelet isn't running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to 'curl -sSL http://localhost:10248/healthz' failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line">[kubelet-check] It seems like the kubelet isn't running or healthy.</span><br><span class="line">[kubelet-check] The HTTP call equal to 'curl -sSL http://localhost:10248/healthz' failed with error: Get http://localhost:10248/healthz: dial tcp [::1]:10248: connect: connection refused.</span><br></pre></td></tr></table></figure>
<p>出现错误了,变更Docker的版本后，继续执行，还是会报错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ERROR FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml]: /etc/kubernetes/manifests/kube-apiserver.yaml already exists</span><br><span class="line">       [ERROR FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml]: /etc/kubernetes/manifests/kube-controller-manager.yaml already exists</span><br></pre></td></tr></table></figure>
<h5 id="重设kubeadm"><a href="#重设kubeadm" class="headerlink" title="重设kubeadm"></a>重设kubeadm</h5><p>这里需要重设<code>kubeadm</code>了。具体操作如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm reset</span><br><span class="line">echo '1' &gt; /proc/sys/net/bridge/bridge-nf-call-iptables </span><br><span class="line">echo '1' &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>
<h5 id="journalctl查看日志"><a href="#journalctl查看日志" class="headerlink" title="journalctl查看日志"></a>journalctl查看日志</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">journalctl -xefu kubelet</span><br></pre></td></tr></table></figure>
<p>这里还是会报错，因为之前的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">imageRepository: k8s.gcr.io</span><br><span class="line">kubernetesVersion: v1.16.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: "10.96.0.0/16"</span><br></pre></td></tr></table></figure>
<p>继续执行init的过程，<code>kubeadm init --config=/home/parallels/Workspace/init.default.yaml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">  You should now deploy a pod network to the cluster.</span><br><span class="line">Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 10.211.55.7:6443 --token imwj34.ksfiwzj5ga80du0r \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:7ffef85880ed43dd539afa045715f9ad5bef15e904cede96213d6cfd4adb0795</span><br></pre></td></tr></table></figure>
<p>真心不容易，这里一直反反复复执行。只要是<code>images</code>的版本问题以及<code>init</code>的过程容易出错。</p>
<h5 id="验证configmap"><a href="#验证configmap" class="headerlink" title="验证configmap"></a>验证configmap</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 ~]# kubectl get -n kube-system configmap   </span><br><span class="line">NAME                                 DATA   AGE</span><br><span class="line">coredns                              1      5m49s</span><br><span class="line">extension-apiserver-authentication   6      5m53s</span><br><span class="line">kube-proxy                           2      5m49s</span><br><span class="line">kubeadm-config                       2      5m50s</span><br><span class="line">kubelet-config-1.16                  1      5m50s</span><br></pre></td></tr></table></figure>
<h4 id="安装Node，加入集群"><a href="#安装Node，加入集群" class="headerlink" title="安装Node，加入集群"></a>安装Node，加入集群</h4><p>安装跟Master一直的基本环境，包括docker，kubelet，kubeadm等，重复上面的动作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp root@10.211.55.7:/home/parallels/Workspace/init.default.yaml .</span><br><span class="line">scp root@10.211.55.7:/home/parallels/Workspace/kubeadm.sh .</span><br><span class="line">yum install docker-ce-18.06.3.ce-3.el7</span><br></pre></td></tr></table></figure>
<p>为<code>kubeadm</code>命令生成配置文件，创建<code>join-config.yaml</code>，内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: JoinConfiguration</span><br><span class="line">discovery:</span><br><span class="line">  bootstrapToken:</span><br><span class="line">    apiServerEndpoint: 10.211.55.7:6443</span><br><span class="line">    token: imwj34.ksfiwzj5ga80du0r</span><br><span class="line">    unsafeSkipCAVerification: true</span><br><span class="line">  tlsBootstrapToken: imwj34.ksfiwzj5ga80du0r</span><br></pre></td></tr></table></figure>
<p>其中，apiServerEndpoint的值来自于Master的服务器地址，这里就是<code>10.211.55.7</code>。<code>token</code>和<code>tlsBootstrapToken</code>的值就来自于<code>kubeadm init</code>安装<code>Master</code>的最后一行提示信息。这里一定要注意yaml文件的格式，否则执行会报错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node2 Workspace]# kubeadm join  --config=join-config.yaml</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">        [ERROR Swap]: running with swap on is not supported. Please disable swap</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br><span class="line">[root@CentOS7-Node2 Workspace]# swapoff -a</span><br><span class="line">[root@CentOS7-Node2 Workspace]# kubeadm join  --config=join-config.yaml</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'</span><br><span class="line">[kubelet-start] Downloading configuration for the kubelet from the "kubelet-config-1.16" ConfigMap in the kube-system namespace</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"</span><br><span class="line">[kubelet-start] Activating the kubelet service</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure>
<h5 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h5><p>去Master机器，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 Workspace]# kubectl get nodes</span><br><span class="line">NAME            STATUS     ROLES    AGE     VERSION</span><br><span class="line">centos7-node1   NotReady   master   154m    v1.16.2</span><br><span class="line">centos7-node2   NotReady   &lt;none&gt;   2m49s   v1.16.2</span><br></pre></td></tr></table></figure>
<p>这里显示的是<code>NotReady</code>状态，是因为还没有安装<code>CNI</code>网络插件。我们选择<code>weave</code>插件来安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 Workspace]# kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"</span><br><span class="line">serviceaccount/weave-net created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/weave-net created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/weave-net created</span><br><span class="line">role.rbac.authorization.k8s.io/weave-net created</span><br><span class="line">rolebinding.rbac.authorization.k8s.io/weave-net created</span><br><span class="line">daemonset.apps/weave-net created</span><br></pre></td></tr></table></figure>

<h4 id="验证集群是否安装完成"><a href="#验证集群是否安装完成" class="headerlink" title="验证集群是否安装完成"></a>验证集群是否安装完成</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 Workspace]# kubectl get pods -n kube-system</span><br><span class="line">NAME                                    READY   STATUS              RESTARTS   AGE</span><br><span class="line">coredns-5644d7b6d9-9fr9p                0/1     ContainerCreating   0          172m</span><br><span class="line">coredns-5644d7b6d9-pmpkq                0/1     ContainerCreating   0          172m</span><br><span class="line">etcd-centos7-node1                      1/1     Running             0          171m</span><br><span class="line">kube-apiserver-centos7-node1            1/1     Running             0          171m</span><br><span class="line">kube-controller-manager-centos7-node1   1/1     Running             0          171m</span><br><span class="line">kube-proxy-ccnht                        1/1     Running             0          21m</span><br><span class="line">kube-proxy-rdq9l                        1/1     Running             0          172m</span><br><span class="line">kube-scheduler-centos7-node1            1/1     Running             0          171m</span><br><span class="line">weave-net-6hw26                         2/2     Running             0          8m7s</span><br><span class="line">weave-net-qv8vz                         2/2     Running             0          8m7s</span><br></pre></td></tr></table></figure>

<p>发现coredns一直处于ContainerCreating的状态。具体的看一下错误信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 Workspace]# kubectl describe pod coredns-5644d7b6d9-9fr9p -n kube-system</span><br><span class="line">Name:                 coredns-5644d7b6d9-9fr9p</span><br><span class="line">Namespace:            kube-system</span><br><span class="line">Priority:             2000000000</span><br><span class="line">Priority Class Name:  system-cluster-critical</span><br><span class="line">Node:                 centos7-node2/10.211.55.8</span><br><span class="line">Start Time:           Tue, 22 Oct 2019 20:49:47 +0800</span><br><span class="line">Labels:               k8s-app=kube-dns</span><br><span class="line">                      pod-template-hash=5644d7b6d9</span><br><span class="line">.... # 此处省略一些</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason                  Age        From                    Message</span><br><span class="line">  ----     ------                  ----       ----                    -------</span><br><span class="line">  Warning  FailedScheduling        &lt;unknown&gt;  default-scheduler       0/1 nodes are available: 1 node(s) had taints that the pod didn't tolerate.</span><br><span class="line">  Warning  FailedScheduling        &lt;unknown&gt;  default-scheduler       0/2 nodes are available: 2 node(s) had taints that the pod didn't tolerate.</span><br><span class="line">  Normal   Scheduled               &lt;unknown&gt;  default-scheduler       Successfully assigned kube-system/coredns-5644d7b6d9-9fr9p to centos7-node2</span><br><span class="line">  Warning  FailedCreatePodSandBox  2m         kubelet, centos7-node2  Failed create pod sandbox: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">  Normal   SandboxChanged          119s       kubelet, centos7-node2  Pod sandbox changed, it will be killed and re-created.</span><br></pre></td></tr></table></figure>

<p>这里可以看出一些错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Oct 22 10:50:15 CentOS7-Node1 kubelet[7649]: F1022 10:50:15.170550    7649 server.go:196] failed to load Kubelet config file /var/lib/kubelet/config.yaml, error failed to read kubelet config file "/var/lib/kubelet/config.yaml", </span><br><span class="line">Oct 22 10:50:15 CentOS7-Node1 systemd[1]: kubelet.service: main process exited, code=exited, status=255/n/a</span><br></pre></td></tr></table></figure>

<p>可以删除掉一个pod的方式让它重新启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 ~]# kubectl delete pod coredns-5644d7b6d9-9fr9p -n kube-system</span><br><span class="line">pod "coredns-5644d7b6d9-9fr9p" deleted</span><br></pre></td></tr></table></figure>

<p>看了太多的文章与博客，发现没有几个写的太完全的，都是写的成功的经验，实际上中间不知道有各种奇怪问题。说句实话，k8s很方便，但是门槛很高，依赖的东西真的太多太多了。特别是版本问题导致的问题，很难解决掉。</p>
<p>最后看一下成功的图片吧</p>
<p><img src="http://static.cyblogs.com/WX20191023-164029@2x.png" alt="http://static.cyblogs.com/WX20191023-164029@2x.png"></p>
<h4 id="常用命令汇总"><a href="#常用命令汇总" class="headerlink" title="常用命令汇总"></a>常用命令汇总</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart kubelet</span><br><span class="line"></span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"></span><br><span class="line">kubectl describe pod coredns-5644d7b6d9-lqtks -n kube-system</span><br><span class="line"></span><br><span class="line">kubectl delete pod coredns-5644d7b6d9-qh4bc -n kube-system</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许master节点部署pod</span></span><br><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁止master部署pod</span></span><br><span class="line">kubectl taint nodes k8s node-role.kubernetes.io/master=true:NoSchedule</span><br><span class="line"></span><br><span class="line">kubeadm reset</span><br><span class="line"></span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line"></span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line"></span><br><span class="line">journalctl -xefu kubelet</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.cnblogs.com/yufeng218/p/8370670.html" target="_blank" rel="noopener">https://www.cnblogs.com/yufeng218/p/8370670.html</a></li>
<li><a href="https://stackoverflow.com/questions/55531834/kubeadm-fails-to-initialize-when-kubeadm-init-is-called" target="_blank" rel="noopener">https://stackoverflow.com/questions/55531834/kubeadm-fails-to-initialize-when-kubeadm-init-is-called</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31398416" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31398416</a></li>
<li><a href="https://blog.csdn.net/M82_A1/article/details/97626309" target="_blank" rel="noopener">https://blog.csdn.net/M82_A1/article/details/97626309</a></li>
<li><a href="https://blog.csdn.net/liumiaocn/article/details/99608323" target="_blank" rel="noopener">https://blog.csdn.net/liumiaocn/article/details/99608323</a></li>
<li><a href="https://www.hi-linux.com/posts/54191.html" target="_blank" rel="noopener">https://www.hi-linux.com/posts/54191.html</a></li>
<li><a href="https://blog.csdn.net/BigData_Mining/article/details/88683459" target="_blank" rel="noopener">https://blog.csdn.net/BigData_Mining/article/details/88683459</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac系统上搭建Kubernetes环境</title>
    <url>/2019/10/28/2019/10/Mac%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%90%AD%E5%BB%BAKubernetes%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>大家在安装<code>Kubernetes</code>的时候，大多数人都遇到了一直处理starting的状态。其实都是因为依赖的<code>docker images</code>不存在。而且由于墙等问题的存在，大家可以安装之前提前把镜像下载好。</p>
<p>我这里找到了很多的文档，找齐了我这边能支持跑起来的<code>image</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  docker images</span><br><span class="line">REPOSITORY                                                                TAG       </span><br><span class="line">k8s.gcr.io/kube-apiserver                                                 v1.16.0   </span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver        v1.16.0   </span><br><span class="line">k8s.gcr.io/kube-proxy                                                     v1.16.0   </span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy            v1.16.0   </span><br><span class="line">k8s.gcr.io/kube-proxy                                                     v1.14.6   </span><br><span class="line">k8s.gcr.io/kube-apiserver                                                 v1.14.6   </span><br><span class="line">k8s.gcr.io/kube-scheduler                                                 v1.14.6   </span><br><span class="line">k8s.gcr.io/kube-controller-manager                                        v1.14.6   </span><br><span class="line">docker/kube-compose-controller                                            v0.4.23   </span><br><span class="line">docker/kube-compose-api-server                                            v0.4.23   </span><br><span class="line">k8s.gcr.io/coredns                                                        1.3.1     </span><br><span class="line">k8s.gcr.io/kubernetes-dashboard-amd64                                     v1.10.1   </span><br><span class="line">k8s.gcr.io/etcd                                                           3.3.10    </span><br><span class="line">k8s.gcr.io/kube-proxy-amd64                                               v1.10.11  </span><br><span class="line">k8s.gcr.io/kube-apiserver-amd64                                           v1.10.11  </span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64                                  v1.10.11  </span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64                                           v1.10.11  </span><br><span class="line">docker/kube-compose-controller                                            v0.4.12   </span><br><span class="line">docker/kube-compose-api-server                                            v0.4.12   </span><br><span class="line">k8s.gcr.io/etcd-amd64                                                     3.1.12    </span><br><span class="line">k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64                                    1.14.8    </span><br><span class="line">k8s.gcr.io/k8s-dns-sidecar-amd64                                          1.14.8    </span><br><span class="line">k8s.gcr.io/k8s-dns-kube-dns-amd64                                         1.14.8    </span><br><span class="line">k8s.gcr.io/pause-amd64                                                    3.1       </span><br><span class="line">k8s.gcr.io/pause                                                          3.1       </span><br><span class="line">k8s.gcr.io/storage-provisioner                                            v1.8.1    </span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/storage-provisioner   v1.8.1</span><br></pre></td></tr></table></figure>

<p>再启动，等一会儿就应该能看到Docker与Kubernetes都起来了。</p>
<p><img src="http://static.cyblogs.com/WX20191015-184532@2x.png" alt="http://static.cyblogs.com/WX20191015-184532@2x.png"></p>
<h4 id="创建kubernetes-dashboard"><a href="#创建kubernetes-dashboard" class="headerlink" title="创建kubernetes-dashboard"></a>创建kubernetes-dashboard</h4><p>接下来我们可以使用 <code>kubectl</code> 命令来创建简单的 <code>kubernetes-dashboard</code> 服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个可以把文件下载下来，后面就可以本地了。</span></span><br><span class="line"></span><br><span class="line">kubectl apply -f /Users/chenyuan/Tools/Docker/kubernetes/kubernetes-dashboard.yaml</span><br><span class="line"></span><br><span class="line">secret "kubernetes-dashboard-certs" created</span><br><span class="line">serviceaccount "kubernetes-dashboard" created</span><br><span class="line">role "kubernetes-dashboard-minimal" created</span><br><span class="line">rolebinding "kubernetes-dashboard-minimal" created</span><br><span class="line">deployment "kubernetes-dashboard" created</span><br><span class="line">service "kubernetes-dashboard" created</span><br></pre></td></tr></table></figure>

<p>服务安装完毕后可以查看部署的容器与服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  kubectl get deployments --namespace kube-system</span><br><span class="line">NAME                   READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">coredns                2/2     2            2           4d3h</span><br><span class="line">kubernetes-dashboard   1/1     1            1           3d8h</span><br><span class="line">➜  kubernetes  kubectl get services --namespace kube-system</span><br><span class="line">NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP,9153/TCP   4d3h</span><br><span class="line">kubernetes-dashboard   ClusterIP   10.96.229.197   &lt;none&gt;        443/TCP                  4d2h</span><br></pre></td></tr></table></figure>

<h4 id="启动dashboard"><a href="#启动dashboard" class="headerlink" title="启动dashboard"></a>启动dashboard</h4><p>在 Dashboard 启动完毕后，可以使用 kubectl 提供的 Proxy 服务来访问该面板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl proxy --address&#x3D;&#39;0.0.0.0&#39;  --accept-hosts&#x3D;&#39;^*$&#39;</span><br></pre></td></tr></table></figure>

<p>启动服务后，不要切断控制台，不然服务就中断了。</p>
<p>浏览器输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8001&#x2F;api&#x2F;v1&#x2F;namespaces&#x2F;kube-system&#x2F;services&#x2F;https:kubernetes-dashboard:&#x2F;proxy&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/WX20191015-182857@2x.png" alt="http://static.cyblogs.com/WX20191015-182857@2x.png"></p>
<h4 id="获取Token"><a href="#获取Token" class="headerlink" title="获取Token"></a>获取Token</h4><p>然后并没有跳过的按钮，所以必须通过<code>Kubeconfig</code>或者<code>Token</code>的方式。</p>
<p>我这里是通过Token，那我们怎么知道Token的值是多少呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  kubectl get secret -n=kube-system</span><br><span class="line">NAME                                             TYPE                                  DATA   AGE</span><br><span class="line">...</span><br><span class="line">default-token-sznp4                              kubernetes.io/service-account-token   3      4d3h</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里只列出default-token-sznp4</span></span><br></pre></td></tr></table></figure>

<p>获取Token值，然后把得到的值输入进去就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  kubectl describe secret -n=kube-system default-token-sznp4</span><br><span class="line">Name:         default-token-sznp4</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: default</span><br><span class="line">              kubernetes.io/service-account.uid: 064afefb-ebf6-11e9-ac8c-025000000001</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1025 bytes</span><br><span class="line">namespace:  11 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkZWZhdWx0LXRva2VuLXN6bnA0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImRlZmF1bHQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIwNjRhZmVmYi1lYmY2LTExZTktYWM4Yy0wMjUwMDAwMDAwMDEiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06ZGVmYXVsdCJ9.u5HTqt7A_4H_0f9ny-AgfmWNo7TSWZsRpjXot1iN8G6oOnt4uDQiS_kiUduwtqqeYC2hjZ2yKPt0NNML9Op1RSAEuTkXiRvJxnCX8GjQeqCD4lzXeqqQ9mTxCVlGijJLaP5VJ2qQtLM0Gwt9eJCYxugGqqHqys7QXdPzcH3WESno0tXNt25klC5ZXNFSeyE-AqLpP3SjmW7W6IBHx89uY28SXmdvTjnCuZyaBlpkgOensdMS7-BpycTzq63NIcp5TR7tM3AdHjsUlSJ2D9YqW_xzMcEDncmjKpbVJ6W9w494L-Z0dOjHkI7gaQSE2Bwi6AqCaGEWKTgMCSWmIBfkrg</span><br></pre></td></tr></table></figure>

<h4 id="通过compose的case启动服务"><a href="#通过compose的case启动服务" class="headerlink" title="通过compose的case启动服务"></a>通过compose的case启动服务</h4><p>去Github找了一个Demo，跑几个服务起来。案例地址：<a href="mailto:git@github.com">git@github.com</a>:docker/compose-on-kubernetes.git</p>
<p>我把其中的案例copy到了我自己的目录，大概是这样子。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  tree -L 2</span><br><span class="line">.</span><br><span class="line">├── config-exercise</span><br><span class="line">│   └── config-demo</span><br><span class="line">├── db</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   └── words.sql</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── kubernetes-dashboard.yaml</span><br><span class="line">├── web</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── dispatcher.go</span><br><span class="line">│   └── static</span><br><span class="line">└── words</span><br><span class="line">    ├── Dockerfile</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure>

<p>着重看一下<code>docker-compose</code>内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  cat docker-compose.yml</span><br><span class="line">version: '3.3'</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: web</span><br><span class="line">    image: dockerdemos/lab-web</span><br><span class="line">    ports:</span><br><span class="line">     - "80:80"</span><br><span class="line"></span><br><span class="line">  words:</span><br><span class="line">    build: words</span><br><span class="line">    image: dockerdemos/lab-words</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    build: db</span><br><span class="line">    image: dockerdemos/lab-db</span><br><span class="line">    volumes:</span><br><span class="line">    - test-volume:/test-volume</span><br></pre></td></tr></table></figure>

<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>然后刷新页面，就可以看到搭建的节点都在<code>Kubernetes</code>的控制台上面可以发现了。</p>
<p><img src="http://static.cyblogs.com/WX20191015-174028@2x.png" alt="http://static.cyblogs.com/WX20191015-174028@2x.png"></p>
<p>用Docker命令查看本地的服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Desktop  docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">02d0691dee78        19b138d3318a        "docker-entrypoint.s…"   11 minutes ago      Up 11 minutes                           k8s_db_db-0_default_d8be11b3-ef2e-11e9-ac8c-025000000001_0</span><br><span class="line">f719b60a99c8        b1e9c4adf655        "java -Xmx8m -Xms8m …"   11 minutes ago      Up 11 minutes                           k8s_words_words-745db75bdf-4slj7_default_d8734615-ef2e-11e9-ac8c-025000000001_0</span><br><span class="line">4a2ce12bd5e8        b1e9c4adf655        "java -Xmx8m -Xms8m …"   11 minutes ago      Up 11 minutes                           k8s_words_words-745db75bdf-bfz5c_default_d8799138-ef2e-11e9-ac8c-025000000001_0</span><br><span class="line">755679d0813b        a7ba5776710d        "/dispatcher"            11 minutes ago      Up 11 minutes                           k8s_web_web-8ffd8b7f4-scdmz_default_d86e9b2e-ef2e-11e9-ac8c-025000000001_0</span><br><span class="line">ab8bbda27700        b1e9c4adf655        "java -Xmx8m -Xms8m …"   11 minutes ago      Up 11 minutes                           k8s_words_words-745db75bdf-w2dxd_default_d878bdf2-ef2e-11e9-ac8c-025000000001_0</span><br><span class="line">5c5943bd4f34        b1e9c4adf655        "java -Xmx8m -Xms8m …"   11 minutes ago      Up 11 minutes                           k8s_words_words-745db75bdf-bzdbg_default_d86ebe31-ef2e-11e9-ac8c-025000000001_0</span><br><span class="line">6e1b7bbffaa9        b1e9c4adf655        "java -Xmx8m -Xms8m …"   11 minutes ago      Up 11 minutes                           k8s_words_words-745db75bdf-2xwgr_default_d87525d6-ef2e-11e9-ac8c-025000000001_0</span><br></pre></td></tr></table></figure>

<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>应用栈创建完毕后，可以使用 kubectl 查看创建的 Pods:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>

<p>也可以来查看部署的集群与服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure>

<p>可以看到这里的 web 有所谓的 LoadBalancer 类型，即可以对外提供服务。最后我们还可以用 stack 与 kubectl 命令来删除应用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stack remove demo </span><br><span class="line"></span><br><span class="line">kubectl delete deployment kubernetes-dashboard --namespace kube-system</span><br></pre></td></tr></table></figure>

<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>一次tddl-sequence问题的排查</title>
    <url>/2019/10/10/2019/10/%E4%B8%80%E6%AC%A1tddl-sequence%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在测试环境，有个同事发现了一个<code>ID</code>插入的时候报了主键冲突。这是一件很奇怪的事情，在大家的理解中，使用了<code>Sequence</code>功能，每个节点的内存拿的<code>ID段</code>应该都是不同的，不可能会出现这个问题。不然这又要颠覆认知了~ </p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li>是否有人手动插入了一条数据，然后出入的时候手动设置了<code>ID</code>呢？</li>
<li>是否有人手动调整了<code>Sequence</code>的<code>value</code>呢?</li>
<li>为什么数据库还存在了<code>ID</code>相同，但在不同表的数据呢？是不是多线程写的有毛病啊？</li>
</ul>
<h3 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h3><ul>
<li>确认没有人手动插入<code>ID</code>，都是用程序获取的方式；</li>
<li>那有时间与精力去手动设置<code>Sequence</code>的<code>value</code>啊，确实谁去没事儿管这个；</li>
<li>数据<code>ID</code>相同数据在不同表，明显是2台不同的项目<code>Node</code>导致的。</li>
</ul>
<p>总结：确定问题出现了2台机器获取的<code>Sequence</code>的<code>value</code>范围冲突了。</p>
<p>问题表现出来的确实如此，难道真的要颠覆我们的认知吗？因为问题算比较严重，所以非常的重视。一定要找到问题的原因所在！</p>
<h3 id="具体排查"><a href="#具体排查" class="headerlink" title="具体排查"></a>具体排查</h3><p>此时，我们发现代码有一处调整过，就是配置<code>TDDL</code>的<code>Sequence</code>的<code>innerStep</code>（内部步长），由原来的<code>1000</code>调整为<code>5000</code>。为什么调整大了，是因为在数据迁移的时候，数据量很大，减少由于<code>ID</code>扩容对数据库操作的时间（其实在这里，可以看出这位开发同学已经非常优秀了，其他地方也一定会非常的注意性能的设计）。</p>
<p>这里我的认知也是，就算我修改内部步长跟其他人不一样，也不会影响Sequence冲突的问题啊，这个Sequence应该会自己保证。不知道大家是不是跟我的想法也一样？</p>
<p>抱着半怀疑<code>Sequence</code>的<code>Bug</code>问题与一定要解决掉问题的思绪，大家来开始撸源代码了。这才是解决问题的王道~</p>
<p>这里参考的版本是：<code>tddl-sequence-3.2.jar</code>，用的是<code>GroupSequence</code>。</p>
<h4 id="找出问题的根源点"><a href="#找出问题的根源点" class="headerlink" title="找出问题的根源点"></a>找出问题的根源点</h4><p>第一步会撸<code>nextValue()</code>方法，下面贴一下核心代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newValue = oldValue + outStep; <span class="comment">// 新的值就是数据库中老的值 + 外部步长的求和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> affectedRows = stmt.executeUpdate();<span class="comment">// 把新的值再更新到数据库中去</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SequenceRange(newValue + <span class="number">1</span>, newValue + innerStep);<span class="comment">// 该结点的范围就是[newValue + 1, newValue + innerStep]</span></span><br></pre></td></tr></table></figure>

<p>在这里就初步判断，这里有大坑。如果2个项目的内部步长不一致，范围就会存在交集，问题确实是这个问题导致的，但是这不符合常理，为什么设计者要这么设计？此时的心情就是必须要<code>tddl-sequence</code>撸清楚。</p>
<p>下面把看源码时候不太理解的部分解答清楚。</p>
<h4 id="内部步长与外部步长的关系"><a href="#内部步长与外部步长的关系" class="headerlink" title="内部步长与外部步长的关系"></a>内部步长与外部步长的关系</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outStep = innerStep * dscount; <span class="comment">// 外部步长 = 内部步长 * sequence所在的数据源个数</span></span><br></pre></td></tr></table></figure>

<p>这应该算是tddl-sequence里面的一个约定了吧，<code>outStep</code>算是每次修改的<code>sequence</code>里value的步长或者说单元。</p>
<p>一般大家的<code>dscount</code>配置的是<code>1</code>，也就是<code>00</code>库。</p>
<h4 id="步长有调整怎么办？"><a href="#步长有调整怎么办？" class="headerlink" title="步长有调整怎么办？"></a>步长有调整怎么办？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (value % outStep) == (index * innerStep); <span class="comment">// 这里不相等，就意味着outStep有调整过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果说我们只有一个dscount，这里的index=0，理论上value就要是outStep的整数倍</span></span><br><span class="line"></span><br><span class="line">adjust = <span class="keyword">true</span>; <span class="comment">// 这里儿我们要配置为true,当发现调整了步长，就会自动调节sequence表了</span></span><br><span class="line"><span class="comment">// 具体如何调整的</span></span><br><span class="line">newValue = (newValue - newValue % outStep) + outStep + index * innerStep; </span><br><span class="line"><span class="comment">// newValue - newValue % outStep 就是把数据缩减到最近一个可以整除outStep的值，然后再加上一个outStep。</span></span><br></pre></td></tr></table></figure>

<h4 id="回顾问题"><a href="#回顾问题" class="headerlink" title="回顾问题"></a>回顾问题</h4><p>回顾到事情上来，具体例子说明：</p>
<p>用我们组的小伙伴画的神图</p>
<p><img src="http://static.cyblogs.com/7ba2efab-2797-4bda-a62c-21a3a3d6b4eb.jpg" alt="http://static.cyblogs.com/7ba2efab-2797-4bda-a62c-21a3a3d6b4eb.jpg"></p>
<p>解释一下，2个不同的应用一个步长是<code>5000</code>，一个步长是<code>1000</code>。步长大的会覆盖步长小的节点；</p>
<p>数据库的<code>value=1000</code>时候；</p>
<p><strong>projectA</strong>：<code>outStep=5000</code>拿到的范围是：<code>[6000, 11000]</code>，先获取<code>sequence</code>；</p>
<p><strong>projectB</strong>：<code>outStep=1000</code>拿到的范围是：<code>[7000, 8000]</code>，后获取<code>sequence</code>；</p>
<p>那如果步长大的节点先插入了数据并且使用了步长小的节点还未使用的<code>ID</code>值，那后面步长小的结点过来插入的时候就报主键冲突了。</p>
<h3 id="疑问点？"><a href="#疑问点？" class="headerlink" title="疑问点？"></a>疑问点？</h3><p>为什么数据库的值是<code>1000</code>，步长是<code>5000</code>的时候。获取的范围是<code>[6000,11000]</code>呢？浪费了<code>5000</code>啊。</p>
<p>这个问题就是由于步长调整导致的，因为sequence要让数据库的值是outStep的整数倍。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>TDDL</tag>
        <tag>Sequence</tag>
      </tags>
  </entry>
  <entry>
    <title>自己搭建Gitlab服务器</title>
    <url>/2019/10/15/2019/10/%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BAGitlab%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="更换yum源"><a href="#更换yum源" class="headerlink" title="更换yum源"></a>更换yum源</h3><p>为了加快速度，首先可以更换<code>yum</code>的源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ94tq694y3Z ghost]#touch /etc/yum.repos.d/gitlab_gitlab-ce.repo</span><br></pre></td></tr></table></figure>

<p>替换内容为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[gitlab-ce]</span><br><span class="line">name=Gitlab CE Repository</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>用root用户安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install curl openssh-server openssh-clients postfix cronie</span><br><span class="line">service postfix start</span><br><span class="line">chkconfig postfix on</span><br><span class="line"></span><br><span class="line">yum makecache</span><br><span class="line">yum install gitlab-ce</span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<p>由于自己的阿里云服务器太渣渣了，所以在这里一直卡主了。看了一下阿里云的服务监控。内存已经爆满了，不得不去花钱升级了一下配置。现在是<code>1CPU</code> and <code>2GB</code>内存。</p>
<p>继续执行，还是报错了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Running handlers:</span><br><span class="line">There was an error running gitlab-ctl reconfigure:</span><br><span class="line"></span><br><span class="line">execute[semodule -i /opt/gitlab/embedded/selinux/rhel/7/gitlab-7.2.0-ssh-keygen.pp] (gitlab::selinux line 20) had an error: Errno::ENOMEM: execute[Guard resource] (dynamically defined) had an error: Errno::ENOMEM: Cannot allocate memory - fork(2)</span><br></pre></td></tr></table></figure>

<p>查看内存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ94tq694y3Z ghost]# free  -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          1841       1760         80         52          5         76</span><br><span class="line">-/+ buffers/cache:       1678        162</span><br><span class="line">Swap:            0          0          0</span><br></pre></td></tr></table></figure>

<p>解决<code>Cannot allocate memory - fork</code>问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ94tq694y3Z swapfile]# mkdir /swapfile</span><br><span class="line">[root@iZ94tq694y3Z swapfile]# cd /swapfile</span><br><span class="line">[root@iZ94tq694y3Z swapfile]# dd if=/dev/zero of=swap bs=1024 count=2000000</span><br><span class="line">2000000+0 records in</span><br><span class="line">2000000+0 records out</span><br><span class="line">2048000000 bytes (2.0 GB) copied, 12.8547 s, 159 MB/s</span><br><span class="line">[root@iZ94tq694y3Z swapfile]# mkswap -f  swap</span><br><span class="line">Setting up swapspace version 1, size = 1999996 KiB</span><br><span class="line">no label, UUID=da70ea74-4bac-484a-9c14-2c20e265c267</span><br><span class="line">[root@iZ94tq694y3Z swapfile]# swapon swap</span><br><span class="line">swapon: /swapfile/swap: insecure permissions 0644, 0600 suggested.</span><br><span class="line">[root@iZ94tq694y3Z swapfile]# free -h</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          1.8G       1.7G        68M        52M       1.2M        85M</span><br><span class="line">-/+ buffers/cache:       1.6G       155M</span><br><span class="line">Swap:         1.9G         0B       1.9G</span><br></pre></td></tr></table></figure>

<p>再重新执行<code>gitlab-ctl reconfigure</code>成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Running handlers:</span><br><span class="line">Running handlers complete</span><br><span class="line">Chef Client finished, 35/743 resources updated in 01 minutes 31 seconds</span><br><span class="line">gitlab Reconfigured!</span><br></pre></td></tr></table></figure>

<p>继续配置：<code>gitlab-rails console production</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ94tq694y3Z swapfile]# gitlab-rails console production</span><br><span class="line">DEPRECATION WARNING: Passing the environment's name as a regular argument is deprecated and will be removed in the next Rails version. Please, use the -e option instead. (called from require at bin/rails:4)</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"> GitLab:       12.3.5 (2417d5becc7)</span><br><span class="line"> GitLab Shell: 10.0.0</span><br><span class="line"> PostgreSQL:   10.9</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Loading production environment (Rails 5.2.3)</span><br><span class="line">irb(main):001:0&gt; </span><br><span class="line">irb(main):002:0&gt; user = User.where(id:1).first</span><br><span class="line">=&gt; #&lt;User id:1 @root&gt;</span><br><span class="line">irb(main):003:0&gt; 'chg''xxxxxx'</span><br><span class="line">=&gt; "xxxxxx"</span><br><span class="line">irb(main):004:0&gt; user.save!</span><br><span class="line">Enqueued ActionMailer::DeliveryJob (Job ID: c9f8831f-25c1-429c-bc3a-073a2a1e5fb8) to Sidekiq(mailers) with arguments: "DeviseMailer", "password_change", "deliver_now", #&lt;GlobalID:0x00007fa89b887368 @uri=#&lt;URI::GID gid://gitlab/User/1&gt;&gt;</span><br><span class="line">=&gt; true</span><br><span class="line">irb(main):005:0&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><p>所有gitlab的配置都在<code>/etc/gitlab/gitlab.rb</code>了里面。我这里只修改了其中的几项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">web_server['external_users'] = ['root'] #支持的用户</span><br><span class="line"></span><br><span class="line">nginx['enable'] = false # 不用自带的nginx，用自己安装的</span><br><span class="line"></span><br><span class="line">external_url 'https://gitlab.cyblogs.com' # 配置域名</span><br><span class="line"></span><br><span class="line">unicorn['port'] = 8081 # 服务端口号</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置邮箱</span></span><br><span class="line">gitlab_rails['smtp_enable'] = true</span><br><span class="line">gitlab_rails['smtp_address'] = "smtp.sina.com"</span><br><span class="line">gitlab_rails['smtp_port'] = 465</span><br><span class="line">gitlab_rails['smtp_user_name'] = "chengcheng222e@sina.com"</span><br><span class="line">gitlab_rails['smtp_password'] = "xxxxxx"</span><br><span class="line">gitlab_rails['smtp_domain'] = "sina.com"</span><br><span class="line">gitlab_rails['smtp_authentication'] = "plain"</span><br><span class="line">gitlab_rails['smtp_enable_starttls_auto'] = true</span><br><span class="line">gitlab_rails['smtp_tls'] = false</span><br></pre></td></tr></table></figure>

<p>配置nginx：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">[root@iZ94tq694y3Z conf.d]# cat gitlab.cyblogs.com.conf </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要通过域名解析到这里来，大家自己去搜索相关的教程</span></span><br><span class="line"><span class="attribute">upstream</span> gitlab.cyblogs.com &#123;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8081</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  gitlab.cyblogs.com ;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  http://gitlab.cyblogs.com;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> HOST default;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /assets &#123;</span><br><span class="line">          <span class="attribute">root</span>  /opt/gitlab/embedded/service/gitlab-rails/public;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> /<span class="number">500</span>.html;</span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">502</span> /<span class="number">502</span>.html;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ ^/(404|500|502)(-custom)?\.html$</span> &#123;</span><br><span class="line">          <span class="attribute">root</span> /opt/gitlab/embedded/service/gitlab-rails/public;</span><br><span class="line">          internal;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GitLab备份和恢复"><a href="#GitLab备份和恢复" class="headerlink" title="GitLab备份和恢复"></a>GitLab备份和恢复</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以将此命令写入crontab，以实现定时备份</span></span><br><span class="line">/usr/bin/gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure>

<h3 id="Gitlab完全卸载"><a href="#Gitlab完全卸载" class="headerlink" title="Gitlab完全卸载"></a>Gitlab完全卸载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止gitlab</span></span><br><span class="line">gitlab-ctl stop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除</span></span><br><span class="line">rpm -e gitlab-ee</span><br><span class="line"><span class="meta">#</span><span class="bash"> 彻底删除</span></span><br><span class="line">find / -name gitlab | xargs rm -rf</span><br></pre></td></tr></table></figure>

<h3 id="GitLab常用命令"><a href="#GitLab常用命令" class="headerlink" title="GitLab常用命令"></a>GitLab常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gitlab-ctl start    # 启动所有 gitlab 组件；</span><br><span class="line">gitlab-ctl stop        # 停止所有 gitlab 组件；</span><br><span class="line">gitlab-ctl restart        # 重启所有 gitlab 组件；</span><br><span class="line">gitlab-ctl status        # 查看服务状态；</span><br><span class="line">vim /etc/gitlab/gitlab.rb        # 修改gitlab配置文件；</span><br><span class="line">gitlab-ctl reconfigure        # 重新编译gitlab的配置；</span><br><span class="line">gitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab；</span><br><span class="line">gitlab-ctl tail        # 查看日志；</span><br><span class="line">gitlab-ctl tail nginx/gitlab_access.log</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>浏览器输入：<a href="http://gitlab.cyblogs.com/users/sign_in" target="_blank" rel="noopener">http://gitlab.cyblogs.com/users/sign_in</a></p>
<p><img src="http://static.cyblogs.com/WX20191014-222324@2x.png" alt="http://static.cyblogs.com/WX20191014-222324@2x.png"></p>
<p>还有很多的配置还未配置，有待慢慢研究~</p>
<h3 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h3><ul>
<li><a href="http://blog.gqylpy.com/gqy/25446/" target="_blank" rel="noopener">http://blog.gqylpy.com/gqy/25446/</a></li>
<li><a href="https://docs.gitlab.com/omnibus/settings/nginx.html" target="_blank" rel="noopener">https://docs.gitlab.com/omnibus/settings/nginx.html</a> </li>
<li><a href="https://gitlab.com/gitlab-org/gitlab-workhorse/issues/26" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-workhorse/issues/26</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Gitlab</category>
        <category>基础服务</category>
      </categories>
      <tags>
        <tag>Gitlab</tag>
        <tag>基础服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring在Web容器中的启动过程</title>
    <url>/2019/11/08/2019/11/Spring%E5%9C%A8Web%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>spring-framework：5.1.x</p>
<p>spring-boot: v2.1.2.RELEASE</p>
<h4 id="看一眼历史的感觉"><a href="#看一眼历史的感觉" class="headerlink" title="看一眼历史的感觉"></a>看一眼历史的感觉</h4><p>先看一眼我们很久以前用的XML的配置方式，我举得用最原始的方式来学习会相对于简单，因为很多的配置都是显性的。我只截取最核心的部分，大概找一下感觉。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"2.4"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">             http://java.sun.com/xml/ns/j2ee  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> <span class="comment">&lt;!--参数名字不能随意取，约定的。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的配置基本就把一个SpringMVC的项目配置完成了，大家都了解。<code>web.xml</code>是一个WEB项目的入口，而这里面就把Spring与Servlet关联起来了。</p>
<p>Loader1：<code>org.springframework.web.context.ContextLoaderListener</code>  父<code>IOC</code>容器，管理所有的<code>Bean</code>。</p>
<p>Loader2：<code>org.springframework.web.servlet.DispatcherServlet</code> 子<code>IOC</code>容器，主要关于与<code>WEB</code>相关的一些配置，比如：<code>Controller</code>、<code>HandlerMapping</code>等等。</p>
<p>这里粗略的描述一下WEB项目的一个加载顺序：listener → filter → servlet。</p>
<h4 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.web.context.ContextLoaderListener</span><br><span class="line">javax.servlet.ServletContextListener</span><br><span class="line">javax.servlet.ServletContext</span><br><span class="line">javax.servlet.ServletContextEvent</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ContextLoaderListener（spring中的类）继承ContextLoader（spring中的类），并实现ServletContextListener（servlet中的接口），ServletContextListener监听ServletContext，当容器启动时，会触发ServletContextEvent事件，该事件由ServletContextListener来处理，启动初始化ServletContext时，调用contextInitialized方法。而ContextLoaderListener实现了ServletContextListener，所以，当容器启动时，触发ServletContextEvent事件，让ContextLoaderListener执行实现方法contextInitialized(ServletContextEvent sce);</p>
<p>引自：<a href="https://www.jianshu.com/p/c1384f3d5698" target="_blank" rel="noopener">https://www.jianshu.com/p/c1384f3d5698</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">	initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们细看一下我们是如何初始化一个<code>Context</code>的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确定我们容器是哪个Context</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) </span><br><span class="line">  <span class="comment">// public static final String CONTEXT_CLASS_PARAM = "contextClass";</span></span><br><span class="line">	String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">	<span class="keyword">if</span> (contextClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Failed to load custom context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		contextClassName = defaultStrategies.getProperty(WebApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Failed to load default context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</code>  这句话实际上是优先用用户配置的，否则才会取默认的。如果我们自己配置要在哪儿配置了。对的还是要在我们的web.xml里面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.StaticWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那我们默认的是哪个呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line">		<span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line">		<span class="comment">// by application developers.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load 'ContextLoader.properties': "</span> + ex.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"ContextLoader.properties"</span>;</span><br></pre></td></tr></table></figure>

<p>是滴，有一个properties文件，里面就是默认的Context配置。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.web.context.WebApplicationContext</span>=<span class="string">org.springframework.web.context.support.XmlWebApplicationContext</span></span><br></pre></td></tr></table></figure>

<p>实际上，我们默认的就是<code>XmlWebApplicationContext</code>。继续扫读<code>web.xml</code>的配置来加载与<code>Spring</code>相关的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public static final String CONFIG_LOCATION_PARAM = "contextConfigLocation";</span></span><br><span class="line"><span class="comment">// 这里就是all.xml/application.xml/context.xml 等的加载地方</span></span><br><span class="line">String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line"><span class="keyword">if</span> (configLocationParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">	wac.setConfigLocation(configLocationParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用refresh开始构建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wac.refresh(); &#x2F;&#x2F; 然而这里我觉得要单独拿一个篇章来讲Spring是如何来加载Bean。</span><br></pre></td></tr></table></figure>

<h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><ul>
<li>HttpServlet 及以上部分是 Servlet 标准中提供的接口及类</li>
<li>DispatcherServlet、FrameworkServlet、HttpServletBean 三者是 SpringMVC 提供的类，且后者依次分别是前者的父类。</li>
</ul>
<p><img src="http://static.cyblogs.com/WX20191114-20465.png" alt="http://static.cyblogs.com/WX20191114-20465.png"></p>
<p>因为是Servlet，所有会调用init来初始化。</p>
<p><code>org.springframework.web.servlet.HttpServletBean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		<span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">		PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">		<span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">				ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">				bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span><br><span class="line">				initBeanWrapper(bw);</span><br><span class="line">				bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">					logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">		initServletBean();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.springframework.web.servlet.FrameworkServlet</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">	getServletContext().log(<span class="string">"Initializing Spring "</span> + getClass().getSimpleName() + <span class="string">" '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">"Initializing Servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 看到这里，回到之前说初始化ContextLoaderListener的initWebApplicationContext</span></span><br><span class="line">		<span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">		initFrameworkServlet();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">		logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		String value = <span class="keyword">this</span>.enableLoggingRequestDetails ?</span><br><span class="line">				<span class="string">"shown which may lead to unsafe logging of potentially sensitive data"</span> :</span><br><span class="line">				<span class="string">"masked to prevent unsafe logging of potentially sensitive data"</span>;</span><br><span class="line">		logger.debug(<span class="string">"enableLoggingRequestDetails='"</span> + <span class="keyword">this</span>.enableLoggingRequestDetails +</span><br><span class="line">				<span class="string">"': request parameters and headers will be "</span> + value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">"Completed initialization in "</span> + (System.currentTimeMillis() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.springframework.web.servlet.FrameworkServlet</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//public static final Class&lt;?&gt; DEFAULT_CONTEXT_CLASS = XmlWebApplicationContext.class;</span></span><br><span class="line">		Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">		<span class="keyword">if</span> (!ConfigurableWebApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">contextClass</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">					<span class="string">"Fatal initialization error in servlet with name '"</span> + getServletName() +</span><br><span class="line">					<span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +</span><br><span class="line">					<span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ConfigurableWebApplicationContext wac =</span><br><span class="line">				(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">		wac.setEnvironment(getEnvironment());</span><br><span class="line">		wac.setParent(parent);</span><br><span class="line">		String configLocation = getContextConfigLocation();</span><br><span class="line">		<span class="keyword">if</span> (configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">			wac.setConfigLocation(configLocation);</span><br><span class="line">		&#125;</span><br><span class="line">		configureAndRefreshWebApplicationContext(wac); <span class="comment">// 这里面又会调用wac.refresh();</span></span><br><span class="line">		<span class="keyword">return</span> wac;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，我们的2个容器都是默认用的<code>XmlWebApplicationContext</code>。</p>
<p>那问哪些<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ViewResolver</code>是在哪儿加载进来的？</p>
<p><code>org.springframework.web.servlet.DispatcherServlet#onRefresh</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">		initMultipartResolver(context);</span><br><span class="line">		initLocaleResolver(context);</span><br><span class="line">		initThemeResolver(context);</span><br><span class="line">		<span class="comment">// 初始化HandlerMapping</span></span><br><span class="line">		initHandlerMappings(context);</span><br><span class="line">    <span class="comment">// 初始化HandlerAdapter</span></span><br><span class="line">		initHandlerAdapters(context);</span><br><span class="line">		initHandlerExceptionResolvers(context);</span><br><span class="line">		initRequestToViewNameTranslator(context);</span><br><span class="line">		initViewResolvers(context);</span><br><span class="line">		initFlashMapManager(context);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">				obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">			Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">					(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">									userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(formatMappings(userType, methods));</span><br><span class="line">			&#125;</span><br><span class="line">			methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">				Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">				registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历Handler中的所有方法，找出其中被@RequestMapping注解标记的方法。</li>
<li>然后遍历这些方法，生成RequestMappingInfo实例。</li>
<li>将RequestMappingInfo实例以及处理器方法注册到缓存中。</li>
</ul>
<p><code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">getMappingForMethod</span><span class="params">(Method method, Class&lt;?&gt; handlerType)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class); 只要打了注解@RequestMapping的方法</span></span><br><span class="line">	RequestMappingInfo info = createRequestMappingInfo(method);</span><br><span class="line">	<span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">		RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);</span><br><span class="line">		<span class="keyword">if</span> (typeInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">			info = typeInfo.combine(info);</span><br><span class="line">		&#125;</span><br><span class="line">		String prefix = getPathPrefix(handlerType);</span><br><span class="line">		<span class="keyword">if</span> (prefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">			info = RequestMappingInfo.paths(prefix).build().combine(info);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">				assertUniqueMethodMapping(handlerMethod, mapping);</span><br><span class="line">				<span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"></span><br><span class="line">				List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line">				<span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">					<span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				String name = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">					name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">					addMappingName(name, handlerMethod);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">				<span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>把一些请求的映射关系放入到Map中，为后续的路由功能做数据初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, HandlerMethod&gt; mappingLookup = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; urlLookup = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>对于Request参数的一些封装&amp;映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RequestMappingInfo <span class="title">combine</span><span class="params">(RequestMappingInfo other)</span> </span>&#123;</span><br><span class="line">		String name = combineNames(other);</span><br><span class="line">		PatternsRequestCondition patterns = <span class="keyword">this</span>.patternsCondition.combine(other.patternsCondition);</span><br><span class="line">		RequestMethodsRequestCondition methods = <span class="keyword">this</span>.methodsCondition.combine(other.methodsCondition);</span><br><span class="line">		ParamsRequestCondition params = <span class="keyword">this</span>.paramsCondition.combine(other.paramsCondition);</span><br><span class="line">		HeadersRequestCondition headers = <span class="keyword">this</span>.headersCondition.combine(other.headersCondition);</span><br><span class="line">		ConsumesRequestCondition consumes = <span class="keyword">this</span>.consumesCondition.combine(other.consumesCondition);</span><br><span class="line">		ProducesRequestCondition produces = <span class="keyword">this</span>.producesCondition.combine(other.producesCondition);</span><br><span class="line">		RequestConditionHolder custom = <span class="keyword">this</span>.customConditionHolder.combine(other.customConditionHolder);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RequestMappingInfo(name, patterns,</span><br><span class="line">				methods, params, headers, consumes, produces, custom.getCondition());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>一般我们对关心的是一个url是如何组装的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PatternsRequestCondition <span class="title">combine</span><span class="params">(PatternsRequestCondition other)</span> </span>&#123;</span><br><span class="line">		Set&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.patterns.isEmpty() &amp;&amp; !other.patterns.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (String pattern1 : <span class="keyword">this</span>.patterns) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String pattern2 : other.patterns) &#123;</span><br><span class="line">					result.add(<span class="keyword">this</span>.pathMatcher.combine(pattern1, pattern2));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.patterns.isEmpty()) &#123;</span><br><span class="line">			result.addAll(<span class="keyword">this</span>.patterns);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!other.patterns.isEmpty()) &#123;</span><br><span class="line">			result.addAll(other.patterns);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			result.add(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PatternsRequestCondition(result, <span class="keyword">this</span>.pathHelper, <span class="keyword">this</span>.pathMatcher,</span><br><span class="line">				<span class="keyword">this</span>.useSuffixPatternMatch, <span class="keyword">this</span>.useTrailingSlashMatch, <span class="keyword">this</span>.fileExtensions);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这是从注释上<code>copy</code>下来的注解，主要有这里的<code>pathMatcher</code>来组装。</p>
<p><img src="http://static.cyblogs.com/WX20191115-093733@2x.png" alt="http://static.cyblogs.com/WX20191115-093733@2x.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">combine</span><span class="params">(String pattern1, String pattern2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(pattern1) &amp;&amp; !StringUtils.hasText(pattern2)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(pattern1)) &#123;</span><br><span class="line">			<span class="keyword">return</span> pattern2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(pattern2)) &#123;</span><br><span class="line">			<span class="keyword">return</span> pattern1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">boolean</span> pattern1ContainsUriVar = (pattern1.indexOf(<span class="string">'&#123;'</span>) != -<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (!pattern1.equals(pattern2) &amp;&amp; !pattern1ContainsUriVar &amp;&amp; match(pattern1, pattern2)) &#123;</span><br><span class="line">			<span class="comment">// /* + /hotel -&gt; /hotel ; "/*.*" + "/*.html" -&gt; /*.html</span></span><br><span class="line">			<span class="comment">// However /user + /user -&gt; /usr/user ; /&#123;foo&#125; + /bar -&gt; /&#123;foo&#125;/bar</span></span><br><span class="line">			<span class="keyword">return</span> pattern2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// /hotels/* + /booking -&gt; /hotels/booking</span></span><br><span class="line">		<span class="comment">// /hotels/* + booking -&gt; /hotels/booking</span></span><br><span class="line">		<span class="keyword">if</span> (pattern1.endsWith(<span class="keyword">this</span>.pathSeparatorPatternCache.getEndsOnWildCard())) &#123;</span><br><span class="line">			<span class="keyword">return</span> concat(pattern1.substring(<span class="number">0</span>, pattern1.length() - <span class="number">2</span>), pattern2);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// /hotels/** + /booking -&gt; /hotels/**/booking</span></span><br><span class="line">		<span class="comment">// /hotels/** + booking -&gt; /hotels/**/booking</span></span><br><span class="line">		<span class="keyword">if</span> (pattern1.endsWith(<span class="keyword">this</span>.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) &#123;</span><br><span class="line">			<span class="keyword">return</span> concat(pattern1, pattern2);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> starDotPos1 = pattern1.indexOf(<span class="string">"*."</span>);</span><br><span class="line">		<span class="keyword">if</span> (pattern1ContainsUriVar || starDotPos1 == -<span class="number">1</span> || <span class="keyword">this</span>.pathSeparator.equals(<span class="string">"."</span>)) &#123;</span><br><span class="line">			<span class="comment">// simply concatenate the two patterns</span></span><br><span class="line">			<span class="keyword">return</span> concat(pattern1, pattern2);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String ext1 = pattern1.substring(starDotPos1 + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> dotPos2 = pattern2.indexOf(<span class="string">'.'</span>);</span><br><span class="line">		String file2 = (dotPos2 == -<span class="number">1</span> ? pattern2 : pattern2.substring(<span class="number">0</span>, dotPos2));</span><br><span class="line">		String ext2 = (dotPos2 == -<span class="number">1</span> ? <span class="string">""</span> : pattern2.substring(dotPos2));</span><br><span class="line">		<span class="keyword">boolean</span> ext1All = (ext1.equals(<span class="string">".*"</span>) || ext1.isEmpty());</span><br><span class="line">		<span class="keyword">boolean</span> ext2All = (ext2.equals(<span class="string">".*"</span>) || ext2.isEmpty());</span><br><span class="line">		<span class="keyword">if</span> (!ext1All &amp;&amp; !ext2All) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot combine patterns: "</span> + pattern1 + <span class="string">" vs "</span> + pattern2);</span><br><span class="line">		&#125;</span><br><span class="line">		String ext = (ext1All ? ext2 : ext1);</span><br><span class="line">		<span class="keyword">return</span> file2 + ext;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>还是稍微的有点粗，也只描述了我们最最关心的一些点。后面再继续的对每个细节点做一个总结。</p>
<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="https://www.jianshu.com/p/c1384f3d5698" target="_blank" rel="noopener">https://www.jianshu.com/p/c1384f3d5698</a></li>
<li><a href="https://www.cnblogs.com/cyhbyw/p/8683251.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyhbyw/p/8683251.html</a></li>
<li><a href="https://blog.csdn.net/J080624/article/details/56278461" target="_blank" rel="noopener">https://blog.csdn.net/J080624/article/details/56278461</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>详细分析用Kubeconfig或者Token登录的方式</title>
    <url>/2019/10/05/2019/10/%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%E7%94%A8Kubeconfig%E6%88%96%E8%80%85Token%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  kubectl patch svc -n kube-system kubernetes-dashboard -p '&#123;"spec":&#123;"type":"NodePort"&#125;&#125;'</span><br><span class="line">service/kubernetes-dashboard patched</span><br><span class="line">➜  kubernetes  kubectl create serviceaccount dashboard-admin -n kube-system</span><br><span class="line">serviceaccount/dashboard-admin created</span><br><span class="line">➜  kubernetes  kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/dashboard-cluster-admin created</span><br></pre></td></tr></table></figure>

<h4 id="确定NAME"><a href="#确定NAME" class="headerlink" title="确定NAME"></a>确定NAME</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  kubectl get secret -n=kube-system</span><br><span class="line">NAME                                             TYPE                                  DATA   AGE</span><br><span class="line">attachdetach-controller-token-jxx56              kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">bootstrap-signer-token-9hb7w                     kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">certificate-controller-token-m8mpc               kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">clusterrole-aggregation-controller-token-sb7dv   kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">coredns-token-tdchv                              kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">cronjob-controller-token-2f79z                   kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">daemon-set-controller-token-svzw7                kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">dashboard-admin-token-mwjwf                      kubernetes.io/service-account-token   3      61s</span><br><span class="line">default-token-sznp4                              kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">deployment-controller-token-qdh74                kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">disruption-controller-token-hd7sb                kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">endpoint-controller-token-wnnrr                  kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">expand-controller-token-jc8ls                    kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">generic-garbage-collector-token-x2p5z            kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">horizontal-pod-autoscaler-token-vf4kn            kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">job-controller-token-mtz64                       kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">kube-proxy-token-6xgld                           kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">kubernetes-dashboard-certs                       Opaque                                0      5d3h</span><br><span class="line">kubernetes-dashboard-key-holder                  Opaque                                2      5d3h</span><br><span class="line">kubernetes-dashboard-token-lx9kx                 kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">namespace-controller-token-8scnl                 kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">node-controller-token-rh4fk                      kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">persistent-volume-binder-token-xhwzv             kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">pod-garbage-collector-token-7wtzh                kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">pv-protection-controller-token-9nqsb             kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">pvc-protection-controller-token-59kcr            kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">replicaset-controller-token-pq8q9                kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">replication-controller-token-tp9zd               kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">resourcequota-controller-token-wm4j6             kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">service-account-controller-token-g2h2r           kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">service-controller-token-7qrks                   kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">statefulset-controller-token-gcrtq               kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">token-cleaner-token-swg2m                        kubernetes.io/service-account-token   3      5d3h</span><br><span class="line">ttl-controller-token-tgwnf                       kubernetes.io/service-account-token   3      5d3h</span><br></pre></td></tr></table></figure>

<h4 id="获取TOKEN"><a href="#获取TOKEN" class="headerlink" title="获取TOKEN"></a>获取TOKEN</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  kubectl describe secret -n=kube-system dashboard-admin-token-mwjwf</span><br><span class="line">Name:         dashboard-admin-token-mwjwf</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: dashboard-admin</span><br><span class="line">              kubernetes.io/service-account.uid: 0c547a29-f000-11e9-a91a-025000000001</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1025 bytes</span><br><span class="line">namespace:  11 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4tbXdqd2YiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiMGM1NDdhMjktZjAwMC0xMWU5LWE5MWEtMDI1MDAwMDAwMDAxIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmRhc2hib2FyZC1hZG1pbiJ9.cvbCJYR98zNWQeRjW4QmEqVPKD4CxL5EpR7bwEfCZqU_hJiNIKJubIGYWAkbB47waEBFOgIU9Aj98BGqtIAki-eL_kZFVYDIrQGzYQHZVngmCcUwG0u_PKazH9bgU_sfsw9t2_FZv-pD8aiVpGXtbS9EFWpf-VTIrZS-CSlTp0LEgPZLir8Jp_T3X4sbBfgtMbHTzkbz8WCvL_SeWxRIf7o-hLY703KNU4hkbNUxhC2ur73Irp3dSpgyANrS3G3cQjM1Uinh7pJl1ay-gRd0jPCwcZxUW3XKfLqS2-vwIpnYZ_j26Dj9oqDChAIxhK2T6VfBOdpp93AlXzT3_0VSYQ</span><br></pre></td></tr></table></figure>

<h4 id="生成Kubeconfig文件"><a href="#生成Kubeconfig文件" class="headerlink" title="生成Kubeconfig文件"></a>生成<code>Kubeconfig</code>文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes  DASH_TOCKEN=$(kubectl get secret -n kube-system dashboard-admin-token-mwjwf -o jsonpath=&#123;.data.token&#125;|base64 -D)</span><br><span class="line">➜  kubernetes  kubectl config set-cluster kubernetes --server=https://kubernetes.docker.internal:6443 --kubeconfig=/Users/chenyuan/Tools/Docker/kubernetes/dashbord-admin.conf</span><br><span class="line">Cluster "kubernetes" set.</span><br><span class="line">➜  kubernetes  kubectl config set-credentials dashboard-admin --token=$DASH_TOCKEN --kubeconfig=/Users/chenyuan/Tools/Docker/kubernetes/dashbord-admin.conf</span><br><span class="line">User "dashboard-admin" set.</span><br><span class="line">➜  kubernetes  kubectl config set-context dashboard-admin@kubernetes --cluster=kubernetes --user=dashboard-admin --kubeconfig=/Users/chenyuan/Tools/Docker/kubernetes/dashbord-admin.conf</span><br><span class="line">Context "dashboard-admin@kubernetes" created.</span><br><span class="line">➜  kubernetes  kubectl config use-context dashboard-admin@kubernetes --kubeconfig=/Users/chenyuan/Tools/Docker/kubernetes/dashbord-admin.conf</span><br><span class="line">Switched to context "dashboard-admin@kubernetes".</span><br></pre></td></tr></table></figure>

<h4 id="启动服务验证"><a href="#启动服务验证" class="headerlink" title="启动服务验证"></a>启动服务验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl proxy --address='0.0.0.0'  --accept-hosts='^*$'  </span><br><span class="line"></span><br><span class="line">访问：http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/WX20191016-190028@2x.png" alt="http://static.cyblogs.com/WX20191016-190028@2x.png"></p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手与四次挥手</title>
    <url>/2019/11/10/2019/11/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>作为一名后端开发人员，其实需要掌握的知识还真的需要很多的很多的。这也是我自己一直为什么觉得作为程序员是一种幸福，因为很多的知识与技术都掌握在了其他的人前面，可能享受到这个世界知识带来的红利。但技术也是孤独的，越是往深的地方走，越是觉得自己的无知。</p>
<p>这几个月对于知识的深入也是养成了一些习惯，对于源码与原理性的东西越发的感兴趣。也想着自己多输出一些东西出来。也算是记录自己的一个成长吧！</p>
<h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><p>三次握手主要是针对于Client与Server建立连接来描述的。</p>
<p><img src="https://img-blog.csdn.net/20170911145000723" alt="https://img-blog.csdn.net/20170911145000723"></p>
<p><strong>第一次握手：</strong>由客户端发起TCP连接的请求，此时客户端发送一条报文，其中包含SYN标志位，将SYN设置为1； 以及seq位。设seq = x ; 该报文段成为SYN报文段；</p>
<p><strong>第二次握手：</strong>服务器收到这条报文后，返回给客户端一条报文，包含ack位、SYN、以及seq位。 其中ack = x+1; SYN = 1; seq = y。该报文段称为SYNACK报文段；</p>
<p><strong>第三次握手：</strong>当客户端收到SYNACK报文段之后，客户端需要再给服务器发送另外一个报文段，进行确认。该报文段的SYN = 0, seq = x +１，ack = y+1; </p>
<p>总结一下，就是客户端先跟服务端做一个试探，看看服务端是不是可以被连接的，如果回复是可以的，那么客户端才真的发起请求过去。</p>
<h4 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h4><p>四次挥手主要是针对于Client与Server关闭连接来描述的。</p>
<p><img src="https://img-blog.csdnimg.cn/20191102213543484.png" alt="https://img-blog.csdnimg.cn/20191102213543484.png"></p>
<p>TCP连接数据传输结束后，通信的双方client与server都可以选择释放当前TCP连接，此时client与server都处于ESTABLISHED(连接确立)状态，TCP连接释放从此状态开始，我们假设是client的应用进程主动发起TCP连接释放：</p>
<p><strong>第一次挥手：</strong>client向server主动发送连接释放报文（FIN=1,seq=u），报文的首部控制位FIN=1,代表自己的数据已经发送完毕，并且要求释放TCP连接。序号seq=u，u的值为client前面已传送数据的最后一个字节序号加1，client发送完后进入FIN-WAIT-1(终止等待1)状态。</p>
<p><strong>第二次挥手：</strong>server收到client的连接释放报文后即给出确认报文（ACK=1,ack=u+1,seq=v），序号seq=v,值为server前面已传送数据的最后一个字节序号加1,然后server进入CLOSE-WAIT（关闭等待）状态。这时候client到server这个方向连接就释放了，TCP连接处于 半关闭（half-close）状态，client不再发送数据，但是server仍然可以发送数据给client。client收到server确认后进入FIN-WAIT-2(终止等待2)状态，然后等待server发出连接释放报文。</p>
<p><strong>第三次挥手：</strong>处于CLOSE-WAIT状态的server发送完所有数据后，主动释放连接，server发送的连接释放报文（FIN=1，ACK=1,seq=W，ack=u+1），因为半关闭状态，server可能又发送了一些数据，所以序号的值为W，同时保持确认号ack=U+1与上次一致，发送完毕后，server进入LAST-ACK（最后确认）状态，等待client确认。</p>
<p><strong>第四次挥手：</strong>client收到server连接释放报文后，给出确认报文(ACK=1,ack=w+1,seq=u+1),此时连接还没释放掉，client要时间等待计时器设置的2MSL的时间，才最终进入CLOSED状态。时间MSL是最长报文寿命时长，RFC793建议为2分钟，但是现在网络中，这个时间设置更小。也就是说client要等待4分钟才能进入CLOSED状态，开始下一个连接。</p>
<h4 id="疑问点"><a href="#疑问点" class="headerlink" title="疑问点"></a>疑问点</h4><h5 id="1、为什么client在TIME-WAIT状态必须等待2MSL的时间？"><a href="#1、为什么client在TIME-WAIT状态必须等待2MSL的时间？" class="headerlink" title="1、为什么client在TIME-WAIT状态必须等待2MSL的时间？"></a>1、为什么client在TIME-WAIT状态必须等待2MSL的时间？</h5><ul>
<li>为了保证client的最后发送的ACK报文能到达server。因为这个ACK报文可能丢失，导致处于LAST-ACK状态的server收不到对自己释放连接报文的确认。若是server超时重传了这个报文，client就能在2MSL时间内收到，并且重新一次确认，并重启2MSL计时器。</li>
<li>防止出现“已失效的连接请求报文段”出现，2MSL时间，可以使本连接持续时间内的报文段都从网络中消失。建立下一个TCP连接时就不会出现上次旧连接请求报文段。</li>
</ul>
<h5 id="2、如果一方突然出故障了怎么办？"><a href="#2、如果一方突然出故障了怎么办？" class="headerlink" title="2、如果一方突然出故障了怎么办？"></a>2、如果一方突然出故障了怎么办？</h5><p>在TCP连接建立后，client与server传输过程中，假设client突然出故障了，server显然无法再收到client数据了，但是server不能白白等下去。这时TCP的保活计时器（keepalive timer）就登场了。server每收到一次client的数据，就重新设置一下计时器，时间通常是2小时，若2小时内没有再收到client数据，server就会发送一次探测报文段，以后每隔75分钟发送一次，若一连发送10次，client都没有任何响应，server会认为client故障了，直接关闭连接。</p>
<p><img src="https://img-blog.csdnimg.cn/20191103114603194.png" alt="https://img-blog.csdnimg.cn/20191103114603194.png"></p>
<p>该篇博文基本上属于一个科普性的文章，基本也是参考了<a href="https://blog.csdn.net/magic_1024/article/details/102874749" target="_blank" rel="noopener">@magic_1024</a> 与 <a href="https://blog.csdn.net/qq_39833075/article/details/77933471" target="_blank" rel="noopener">@qq_39833075</a> 的文章，尊重别人的原创。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.jianshu.com/p/23c76a127e2d" target="_blank" rel="noopener">https://www.jianshu.com/p/23c76a127e2d</a></li>
<li><a href="https://blog.csdn.net/magic_1024/article/details/102874749" target="_blank" rel="noopener">https://blog.csdn.net/magic_1024/article/details/102874749</a></li>
<li><a href="https://blog.csdn.net/qq_39833075/article/details/77933471" target="_blank" rel="noopener">https://blog.csdn.net/qq_39833075/article/details/77933471</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>让网站使用https的方式访问</title>
    <url>/2019/11/03/2019/11/%E8%AE%A9%E7%BD%91%E7%AB%99%E4%BD%BF%E7%94%A8https%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h4 id="证书申请"><a href="#证书申请" class="headerlink" title="证书申请"></a>证书申请</h4><p>关于证书申请，其实我们可以申请免费的证书即可，在阿里云或者腾讯云等地方都能申请到免费一年的证书，具体的申请步骤这里就就不细细描述了，因为比较简单。但这里指的提醒一下的是，二级域名与三级域名是要区别开来的，一个证书对应一个域名。</p>
<p>比如：<code>cyblogs.com</code>、<code>gitlab.cyblogs.com</code>是需要单独申请的，我这里的话因为域名解析是在dnspod解析的，所以我也就在它那里申请了。</p>
<p>如果是在阿里云申请，而在其他地方做的域名解析，第一次需要单独配置一次解析才行。</p>
<p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20191103175026.png" alt="http://static.cyblogs.com/QQ截图20191103175026.png"></p>
<h4 id="Nginx的安装技巧"><a href="#Nginx的安装技巧" class="headerlink" title="Nginx的安装技巧"></a>Nginx的安装技巧</h4><p><code>gitlab.cyblogs.com.conf</code>文件内容，之类把你的证书存放在你想放的位置，我这里是：<code>/usr/local/nginx/ssl</code>。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> gitlab &#123;</span><br><span class="line">  <span class="attribute">server</span> unix:/var/opt/gitlab/gitlab-rails/sockets/gitlab.socket fail_timeout=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> gitlab-workhorse &#123;</span><br><span class="line">  <span class="attribute">server</span> unix://var/opt/gitlab/gitlab-workhorse/socket fail_timeout=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">0.0.0.0:80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> gitlab.cyblogs.com;</span><br><span class="line">  <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">  <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">  <span class="attribute">access_log</span>  /usr/local/nginx/conf/logs/gitlab_access.log;</span><br><span class="line">  <span class="attribute">error_log</span>   /usr/local/nginx/conf/logs/gitlab_error.log;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">0.0.0.0:443</span> ssl;</span><br><span class="line">  <span class="attribute">server_name</span> gitlab.cyblogs.com;</span><br><span class="line">  <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">  <span class="attribute">root</span> /opt/gitlab/embedded/service/gitlab-rails/public;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">client_max_body_size</span> <span class="number">20m</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">ssl_certificate</span>        /usr/local/nginx/ssl/gitlab.cyblogs.com_bundle.crt;</span><br><span class="line">  <span class="attribute">ssl_certificate_key</span>    /usr/local/nginx/ssl/gitlab.cyblogs.com.key;</span><br><span class="line">  <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">  <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">  <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">  <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">access_log</span>  /usr/local/nginx/conf/logs/gitlab_access.log;</span><br><span class="line">  <span class="attribute">error_log</span>   /usr/local/nginx/conf/logs/gitlab_error.log;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> /uploads/ &#123;</span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span>      <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span>   <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">proxy_redirect</span>          <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    Host                <span class="variable">$http_host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Real-IP           <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Forwarded-For     <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Forwarded-Proto   <span class="variable">$scheme</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Frame-Options     SAMEORIGIN;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://gitlab;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="variable">@gitlab</span> &#123;</span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span>      <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span>   <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">proxy_redirect</span>          <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    Host                <span class="variable">$http_host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Real-IP           <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Forwarded-For     <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Forwarded-Proto   <span class="variable">$scheme</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Frame-Options     SAMEORIGIN;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8081;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ ^/[\w\.-]+/[\w\.-]+/gitlab-lfs/objects</span> &#123;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">418</span> = <span class="variable">@gitlab</span>-workhorse;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">418</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ ^/[\w\.-]+/[\w\.-]+/(info/refs|git-upload-pack|git-receive-pack)$</span> &#123;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">418</span> = <span class="variable">@gitlab</span>-workhorse;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">418</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ ^/[\w\.-]+/[\w\.-]+/repository/archive</span> &#123;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">418</span> = <span class="variable">@gitlab</span>-workhorse;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">418</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ ^/api/v3/projects/.*/repository/archive</span> &#123;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">418</span> = <span class="variable">@gitlab</span>-workhorse;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">418</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ ^/[\w\.-]+/[\w\.-]+/builds/download</span> &#123;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">418</span> = <span class="variable">@gitlab</span>-workhorse;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">418</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ /ci/api/v1/builds/[0-9]+/artifacts</span> &#123;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">418</span> = <span class="variable">@gitlab</span>-workhorse;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">418</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="variable">@gitlab</span>-workhorse &#123;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_read_timeout</span>      <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span>   <span class="number">300</span>;</span><br><span class="line">     <span class="attribute">proxy_redirect</span>          <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span>    Host                <span class="variable">$http_host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Real-IP           <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Forwarded-Ssl     <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Forwarded-For     <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>    X-Forwarded-Proto   <span class="variable">$scheme</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://gitlab-workhorse;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ ^/(assets)/</span> &#123;</span><br><span class="line">    <span class="attribute">root</span> /opt/gitlab/embedded/service/gitlab-rails/public;</span><br><span class="line">    <span class="attribute">gzip_static</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">expires</span> max;</span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control public;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ /</span> &#123;</span><br><span class="line">    <span class="attribute">root</span> /opt/gitlab/embedded/service/gitlab-rails/public;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/index.html <span class="variable">$uri</span>.html <span class="variable">@gitlab</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">error_page</span> <span class="number">502</span> /<span class="number">502</span>.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SSH拉取OK，Http方式不行"><a href="#SSH拉取OK，Http方式不行" class="headerlink" title="SSH拉取OK，Http方式不行"></a>SSH拉取OK，Http方式不行</h4><p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20191103175454.png" alt="http://static.cyblogs.com/QQ截图20191103175454.png"></p>
<p>首先这里显示的还是<code>http</code>的方式，并不是<code>https</code>的方式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Desktop  git clone https://gitlab.cyblogs.com/root/testdemo.git</span><br><span class="line">Cloning into 'cyblogs-blog'...</span><br><span class="line">fatal: unable to access 'https://gitlab.cyblogs.com/root/testdemo.git/': The requested URL returned error: 502</span><br><span class="line">➜  Desktop  git clone https://gitlab.cyblogs.com/cyblogs/cyblogs-blog.git</span><br><span class="line">Cloning into 'cyblogs-blog'...</span><br><span class="line">fatal: unable to access 'https://gitlab.cyblogs.com/cyblogs/cyblogs-blog.git/': The requested URL returned error: 502</span><br></pre></td></tr></table></figure>

<p>通过看日志分析，发现错误的日志信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ94tq694y3Z logs]# less gitlab_error.log </span><br><span class="line">2019/10/18 16:30:13 [crit] 15450#0: *97 stat() "/opt/gitlab/embedded/service/gitlab-rails/public/uploads/-/system/user/avatar/2/avatar.png.html" failed (13: Permission denied), client: xxx.xx.xx.xx, server: gitlab.cyblogs.com, request: "GET /uploads/-/system/user/avatar/2/avatar.png?width=23 HTTP/1.1", host: "gitlab.cyblogs.com", referrer: "https://gitlab.cyblogs.com/testcase/config-repo"</span><br><span class="line"></span><br><span class="line">2019/11/02 16:40:10 [crit] 1374#0: *24502 connect() to unix://var/opt/gitlab/gitlab-workhorse/socket failed (13: Permission denied) while connecting to upstream, client: 210.22.21.66, server: gitlab.cyblogs.com, request: "GET /root/testdemo.git/info/refs?service=git-upload-pack HTTP/1.1", upstream: "http://unix://var/opt/gitlab/gitlab-workhorse/socket:/root/testdemo.git/info/refs?service=git-upload-pack", host: "gitlab.cyblogs.com"</span><br></pre></td></tr></table></figure>

<p>这里会一直报一个权限问题。<code>unix://var/opt/gitlab/gitlab-workhorse/socket failed (13: Permission denied)</code>，然后我就各种搜索，真心地没有几篇文章说的很好的。还不如耐心的看gitlab的官网配置，还算比较详细。</p>
<p><a href="https://docs.gitlab.com/omnibus/settings/nginx.html" target="_blank" rel="noopener">https://docs.gitlab.com/omnibus/settings/nginx.html</a></p>
<p>看了大量的文章，最终得到解决步骤。</p>
<h5 id="对于nginx启动配置"><a href="#对于nginx启动配置" class="headerlink" title="对于nginx启动配置"></a>对于<code>nginx</code>启动配置</h5><p>首先，自己的搭建的nginx启动的时候不要用root启动，需要创建一个用户。我这里就是<code>nginx</code>用户了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@iZ94tq694y3Z ~]# groups nginx</span><br><span class="line">nginx : nginx gitlab-www # 这里的gitlab-www是gitlab-ctl reconfigure后加入进去的</span><br><span class="line">[root@iZ94tq694y3Z ~]#</span><br></pre></td></tr></table></figure>

<p>需要在<code>nginx.conf</code>中<code>user</code>该用户。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">[root@iZ94tq694y3Z conf]# cat nginx.conf</span><br><span class="line"><span class="attribute">user</span>  nginx nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h5 id="对于gitlab-rb配置"><a href="#对于gitlab-rb配置" class="headerlink" title="对于gitlab.rb配置"></a>对于<code>gitlab.rb</code>配置</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZ94tq694y3Z gitlab]# cat gitlab.rb | grep -v ^# 只要生效的配置</span><br><span class="line"><span class="meta">#</span><span class="bash"> 域名访问的配置</span></span><br><span class="line">external_url 'https://gitlab.cyblogs.com'</span><br><span class="line"></span><br><span class="line">gitlab_rails['smtp_enable'] = true</span><br><span class="line">gitlab_rails['smtp_address'] = "smtp.sina.com"</span><br><span class="line">gitlab_rails['smtp_port'] = 465</span><br><span class="line">gitlab_rails['smtp_user_name'] = "chengcheng222e@sina.com"</span><br><span class="line">gitlab_rails['smtp_password'] = "xxxxxx"</span><br><span class="line">gitlab_rails['smtp_domain'] = "sina.com"</span><br><span class="line">gitlab_rails['smtp_authentication'] = "plain"</span><br><span class="line">gitlab_rails['smtp_enable_starttls_auto'] = true</span><br><span class="line">gitlab_rails['smtp_tls'] = false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置gitlab_workhorse，nginx部分有用到这块</span></span><br><span class="line">gitlab_workhorse['enable'] = true</span><br><span class="line">gitlab_workhorse['ha'] = false</span><br><span class="line">gitlab_workhorse['listen_network'] = "unix"</span><br><span class="line">gitlab_workhorse['listen_umask'] = 000</span><br><span class="line">gitlab_workhorse['listen_addr'] = "/var/opt/gitlab/gitlab-workhorse/socket"</span><br><span class="line">gitlab_workhorse['auth_backend'] = "http://localhost:8081"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改端口号为8081端口</span></span><br><span class="line">unicorn['port'] = 8081</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">特别是web_server部分，需要把nginx启动启用加入权限</span></span><br><span class="line">web_server['external_users'] = ['nginx'] </span><br><span class="line">web_server['username'] = 'nginx'</span><br><span class="line">web_server['group'] = 'nginx'</span><br><span class="line">web_server['home'] = '/usr/local/nginx'</span><br><span class="line"></span><br><span class="line">nginx['enable'] = false</span><br><span class="line">nginx['redirect_http_to_https'] = true</span><br><span class="line">nginx['listen_port'] = 8081</span><br></pre></td></tr></table></figure>

<p>如何定位错误，之类需要看nginx的日志与gitlab的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看nginx</span></span><br><span class="line">tailf /usr/local/nginx/conf/logs/gitlab_error.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看gitlab</span></span><br><span class="line">gitlab-ctl tail</span><br></pre></td></tr></table></figure>

<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 回家切换成Windows系统了</span></span><br><span class="line">Administrator@CHENYUAN MINGW64 ~/Desktop</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://gitlab.cyblogs.com/root/testdemo.git</span></span><br><span class="line">Cloning into 'testdemo'...</span><br><span class="line">remote: Enumerating objects: 3, done.</span><br><span class="line">remote: Counting objects: 100% (3/3), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br></pre></td></tr></table></figure>



<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="https://www.cnblogs.com/rysinal/p/7358758.html" target="_blank" rel="noopener">https://www.cnblogs.com/rysinal/p/7358758.html</a></li>
<li><a href="https://stackoverflow.com/questions/35327882/what-permissions-does-nginx-need-for-the-gitlab-workhorse-socket" target="_blank" rel="noopener">https://stackoverflow.com/questions/35327882/what-permissions-does-nginx-need-for-the-gitlab-workhorse-socket</a></li>
<li><a href="https://docs.gitlab.com/omnibus/settings/nginx.html" target="_blank" rel="noopener">https://docs.gitlab.com/omnibus/settings/nginx.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes集群的CA认证</title>
    <url>/2019/12/15/2019/12/Kubernetes%E9%9B%86%E7%BE%A4%E7%9A%84CA%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h4 id="kube-apiserver默认配置"><a href="#kube-apiserver默认配置" class="headerlink" title="kube-apiserver默认配置"></a>kube-apiserver默认配置</h4><p>查看一下<code>kube-apiserver</code>的一些启动配置项，确认存放地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 manifests]# ll</span><br><span class="line">total 16</span><br><span class="line">-rw-------. 1 root root 1759 Dec 10 12:15 etcd.yaml</span><br><span class="line">-rw-------. 1 root root 2602 Dec 10 12:15 kube-apiserver.yaml</span><br><span class="line">-rw-------. 1 root root 2531 Dec 10 12:15 kube-controller-manager.yaml</span><br><span class="line">-rw-------. 1 root root 1119 Dec 10 12:15 kube-scheduler.yaml</span><br><span class="line">[root@CentOS7-Node1 manifests]# pwd</span><br><span class="line">/etc/kubernetes/manifests</span><br></pre></td></tr></table></figure>

<p>可以通过查看<code>yaml</code>文件的方式查看</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[root@CentOS7-Node1</span> <span class="string">manifests]#</span> <span class="string">cat</span> <span class="string">kube-apiserver.yaml</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">control-plane</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kube-apiserver</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--advertise-address=10.211.55.7</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--allow-privileged=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--authorization-mode=Node,RBAC</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--client-ca-file=/etc/kubernetes/pki/ca.crt</span> <span class="comment">#指定CA根证书文件</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--enable-admission-plugins=NodeRestriction</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--enable-bootstrap-token-auth=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--etcd-servers=https://127.0.0.1:2379</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--insecure-port=0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client.key</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-allowed-names=front-proxy-client</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-extra-headers-prefix=X-Remote-Extra-</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-group-headers=X-Remote-Group</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--requestheader-username-headers=X-Remote-User</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--secure-port=6443</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--service-account-key-file=/etc/kubernetes/pki/sa.pub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--service-cluster-ip-range=10.96.0.0/12</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--tls-cert-file=/etc/kubernetes/pki/apiserver.crt</span> <span class="comment">#指定ApiServer证书文件</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--tls-private-key-file=/etc/kubernetes/pki/apiserver.key</span> <span class="comment">#指定ApiServer私钥文件</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/kube-apiserver:v1.16.0</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">8</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="number">10.211</span><span class="number">.55</span><span class="number">.7</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">6443</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">15</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">250m</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/ssl/certs</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">ca-certs</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/pki</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">etc-pki</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">k8s-certs</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="string">system-cluster-critical</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/etc/ssl/certs</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ca-certs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/etc/pki</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">etc-pki</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">k8s-certs</span></span><br><span class="line"><span class="attr">status:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们注意到有如下三个启动参数：</p>
<ul>
<li><code>--client-ca-file</code>: 指定CA根证书文件为<code>/etc/kubernetes/pki/ca.pem</code>，内置CA公钥用于验证某证书是否是CA签发的证书</li>
<li><code>--tls-private-key-file</code>: 指定ApiServer私钥文件为<code>/etc/kubernetes/pki/apiserver-key.pem</code></li>
<li><code>--tls-cert-file</code>：指定ApiServer证书文件为<code>/etc/kubernetes/pki/apiserver.pem</code></li>
</ul>
<h5 id="直接获取nodes节点"><a href="#直接获取nodes节点" class="headerlink" title="直接获取nodes节点"></a>直接获取nodes节点</h5><p>用默认的CA认证尝试一下从其他节点查看pods的信息，直接来获取master节点的pods信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node2 Workspace]# kubectl --server=https://10.211.55.7:6443 get nodes</span><br><span class="line">Please enter Username: # 这里会提示需要输入用户名，但我们并不知道用户名是什么？</span><br></pre></td></tr></table></figure>

<h5 id="通过CA认证方式"><a href="#通过CA认证方式" class="headerlink" title="通过CA认证方式"></a>通过CA认证方式</h5><p>然后我们尝试用默认的CA认证，首先把master节点上的CA文件copy到我们的其他节点去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp /etc/kubernetes/pki/ca.crt root@10.211.55.8:/home/parallels/Workspace/</span><br><span class="line">scp /etc/kubernetes/pki/apiserver-kubelet-client.crt root@10.211.55.8:/home/parallels/Workspace/</span><br><span class="line">scp /etc/kubernetes/pki/apiserver-kubelet-client.key root@10.211.55.8:/home/parallels/Workspace/</span><br></pre></td></tr></table></figure>

<p>通过设置<code>certificate-authority</code>、<code>client-certificate</code>、<code>client-key</code>来访问。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node2 Workspace]# kubectl --server=https://10.211.55.7:6443 \</span><br><span class="line">--certificate-authority=/home/parallels/Workspace/ca.crt  \</span><br><span class="line">--client-certificate=/home/parallels/Workspace/apiserver-kubelet-client.crt \</span><br><span class="line">--client-key=/home/parallels/Workspace/apiserver-kubelet-client.key \</span><br><span class="line">get nodes</span><br><span class="line">NAME            STATUS   ROLES    AGE     VERSION</span><br><span class="line">centos7-node1   Ready    master   5h28m   v1.16.2</span><br><span class="line">centos7-node2   Ready    &lt;none&gt;   149m    v1.16.2</span><br></pre></td></tr></table></figure>

<p>操作成功！</p>
<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="https://www.cnblogs.com/breezey/p/9101705.html" target="_blank" rel="noopener">https://www.cnblogs.com/breezey/p/9101705.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-基本概念</title>
    <url>/2019/12/05/2019/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>数据结构（Data Structure）</strong>是带有结构特性的数据元素的集合，它研究的是数据的<a href="https://baike.baidu.com/item/逻辑结构/9663235" target="_blank" rel="noopener">逻辑结构</a>和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p>
<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><ul>
<li><p><strong>数组</strong>（英语：Array），是由相同类型的元素（element）的集合所组成的<a href="https://zh.wikipedia.org/wiki/数据结构" target="_blank" rel="noopener">数据结构</a>，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
</li>
<li><p><strong>栈</strong>（英语：stack）又称为<strong>栈</strong>或<strong>堆叠</strong>，是计算机科学中的一种抽象数据类型，只允许在有序的线性数据集合的一端（称为堆栈顶端，英语：top）进行加入数据（英语：push）和移除数据（英语：pop）的运算。因而按照后进先出（LIFO, Last In First Out）的原理运作。</p>
</li>
<li><p><strong>队列</strong>，又称为<strong>伫列</strong>（queue），是<a href="https://zh.wikipedia.org/wiki/先進先出" target="_blank" rel="noopener">先进先出</a>（FIFO, First-In-First-Out）的<a href="https://zh.wikipedia.org/wiki/线性表" target="_blank" rel="noopener">线性表</a>。在具体应用中通常用<a href="https://zh.wikipedia.org/wiki/链表" target="_blank" rel="noopener">链表</a>或者<a href="https://zh.wikipedia.org/wiki/数组" target="_blank" rel="noopener">数组</a>来实现。队列只允许在后端（称为<em>rear</em>）进行插入操作，在前端（称为<em>front</em>）进行删除操作。</p>
</li>
<li><p><strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种<a href="https://zh.wikipedia.org/wiki/线性表" target="_blank" rel="noopener">线性表</a>，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的<a href="https://zh.wikipedia.org/wiki/指標_(電腦科學)" target="_blank" rel="noopener">指针</a>(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的<a href="https://zh.wikipedia.org/wiki/複雜度" target="_blank" rel="noopener">复杂度</a>，比另一种线性表<a href="https://zh.wikipedia.org/wiki/顺序表" target="_blank" rel="noopener">顺序表</a>快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。最常见的三种链表结构有：单链表、双向链表、循环链表。 </p>
</li>
<li><p><strong>树</strong>（英语：tree）是一种<a href="https://zh.wikipedia.org/wiki/抽象資料型別" target="_blank" rel="noopener">抽象数据类型</a>（ADT）或是实现这种抽象数据类型的<a href="https://zh.wikipedia.org/wiki/資料結構" target="_blank" rel="noopener">数据结构</a>，用来模拟具<a href="https://zh.wikipedia.org/wiki/樹狀結構" target="_blank" rel="noopener">有树状结构</a>性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的<a href="https://zh.wikipedia.org/wiki/集合" target="_blank" rel="noopener">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个节点都只有有限个子节点或无子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
<li>树里面没有环路(cycle)</li>
</ul>
</li>
<li><p><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<a href="https://zh.wikipedia.org/wiki/鍵" target="_blank" rel="noopener">键</a>（Key）而直接访问在内存存储位置的<a href="https://zh.wikipedia.org/wiki/数据结构" target="_blank" rel="noopener">数据结构</a>。也就是说，它通过计算一个关于键值的函数，将所需查询的数据<a href="https://zh.wikipedia.org/wiki/映射" target="_blank" rel="noopener">映射</a>到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<a href="https://zh.wikipedia.org/wiki/散列函数" target="_blank" rel="noopener">散列函数</a>，存放记录的数组称做<strong>散列表</strong>。</p>
</li>
<li><p><strong>堆</strong>（英语：Heap）是<a href="https://zh.wikipedia.org/wiki/计算机科学" target="_blank" rel="noopener">计算机科学</a>中的一种特别的树状<a href="https://zh.wikipedia.org/wiki/数据结构" target="_blank" rel="noopener">数据结构</a>。若是满足以下特性，即可称为堆：“给定堆中任意<a href="https://zh.wikipedia.org/wiki/節點" target="_blank" rel="noopener">节点</a>P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值”。若母节点的值恒<strong>小于等于</strong>子节点的值，此堆称为<strong>最小堆</strong>（min heap）；反之，若母节点的值恒<strong>大于等于</strong>子节点的值，此堆称为<strong>最大堆</strong>（max heap）。在堆中最顶端的那一个节点，称作<strong>根节点</strong>（root node），根节点本身没有<strong>母节点</strong>（parent node）。</p>
</li>
<li><p><strong>图</strong>（Graph）是由顶点的有穷非空集合和顶点之间的边的集合组成，通常表示为：G(V,E)。其中，G 表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<ul>
<li><p>图中数据元素叫做顶点（Vertext）。</p>
</li>
<li><p>在图中，不允许没有顶点。若 V 是图的顶点的集合，那么，V 是非空<br>有穷集合。</p>
</li>
<li><p>图的任意两个顶点之间都可能有关系，它们的关系用边来表示。边集可<br>以是空的。</p>
</li>
</ul>
</li>
</ul>
<p><img src="http://static.cyblogs.com/WX20191219-151801@2x.png" alt="http://static.cyblogs.com/WX20191219-151801@2x.png"></p>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>再了解树之前，我们对一些专业术语普及一下：度、阶、高度、深度、根、叶子、兄弟节点、关键字。</p>
<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="https://www.jianshu.com/p/230e6fde9c75" target="_blank" rel="noopener">https://www.jianshu.com/p/230e6fde9c75</a></li>
<li><a href="https://www.cnblogs.com/maybe2030/p/4732377.html" target="_blank" rel="noopener">https://www.cnblogs.com/maybe2030/p/4732377.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes启动一个Pod</title>
    <url>/2019/12/20/2019/12/Kubernetes%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AAPod/</url>
    <content><![CDATA[<h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>在实际的投产中，公司一般所有企业的私有镜像：我们公司选择的是：<a href="https://goharbor.io/。" target="_blank" rel="noopener">https://goharbor.io/。</a></p>
<p>首先获取一个nginx的镜像，待会儿需要直接启动这个镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p>确认镜像已经在列表中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 parallels]# docker images</span><br><span class="line">REPOSITORY     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx          latest              231d40e811cd        2 weeks ago         126MB</span><br></pre></td></tr></table></figure>

<h4 id="创建Pod"><a href="#创建Pod" class="headerlink" title="创建Pod"></a>创建Pod</h4><p>直接在master节点上运行一个镜像，并且启动2台机器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 parallels]# kubectl run my-nginx --image=nginx --replicas=2 --port=80</span><br><span class="line">kubectl run --generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run --generator=run-pod/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/my-nginx created</span><br><span class="line">[root@CentOS7-Node1 parallels]# kubectl get pod</span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE</span><br><span class="line">my-nginx-75897978cd-87dnh   1/1     Running   0          4m36s</span><br><span class="line">my-nginx-75897978cd-nwnrm   1/1     Running   0          4m36s</span><br></pre></td></tr></table></figure>

<p>这里需要等待一定的时间，容器的状态由<code>ContainerCreating</code>变为<code>Running</code>。</p>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod_name&gt;</span><br><span class="line">kubectl logs -f &lt;pod_name&gt; # 类似tail -f的方式查看(tail -f 实时查看日志文件 tail -f 日志文件log)</span><br></pre></td></tr></table></figure>

<p>实际的验证操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 parallels]# kubectl logs my-nginx-75897978cd-87dnh</span><br><span class="line">Error from server: Get https:&#x2F;&#x2F;10.211.55.8:10250&#x2F;containerLogs&#x2F;default&#x2F;my-nginx-75897978cd-87dnh&#x2F;my-nginx: dial tcp 10.211.55.8:10250: connect: no route to host</span><br><span class="line">[root@CentOS7-Node1 parallels]# kubectl logs my-nginx-75897978cd-nwnrm</span><br></pre></td></tr></table></figure>

<h4 id="显示Pod资源的详细信息"><a href="#显示Pod资源的详细信息" class="headerlink" title="显示Pod资源的详细信息"></a>显示Pod资源的详细信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 parallels]# kubectl describe pod my-nginx-75897978cd-87dnh</span><br><span class="line">Name:         my-nginx-75897978cd-87dnh</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         centos7-node2/10.211.55.8</span><br><span class="line">Start Time:   Thu, 12 Dec 2019 21:26:18 +0800</span><br><span class="line">Labels:       pod-template-hash=75897978cd</span><br><span class="line">              run=my-nginx</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           10.32.0.2</span><br><span class="line">IPs:</span><br><span class="line">  IP:           10.32.0.2</span><br><span class="line">Controlled By:  ReplicaSet/my-nginx-75897978cd</span><br><span class="line">Containers:</span><br><span class="line">  my-nginx:</span><br><span class="line">    Container ID:   docker://43bda4badd180e540ae95bb8b4cd1b2e174b702c616f4e705e48ff6c57a30d40</span><br><span class="line">    Image:          nginx</span><br><span class="line">    Image ID:       docker-pullable://nginx@sha256:50cf965a6e08ec5784009d0fccb380fc479826b6e0e65684d9879170a9df8566</span><br><span class="line">    Port:           80/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Thu, 12 Dec 2019 21:29:00 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-8s7rp (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True </span><br><span class="line">  Ready             True </span><br><span class="line">  ContainersReady   True </span><br><span class="line">  PodScheduled      True </span><br><span class="line">Volumes:</span><br><span class="line">  default-token-8s7rp:</span><br><span class="line">    Type:        Secret (a volume populated by a Secret)</span><br><span class="line">    SecretName:  default-token-8s7rp</span><br><span class="line">    Optional:    false</span><br><span class="line">QoS Class:       BestEffort</span><br><span class="line">Node-Selectors:  &lt;none&gt;</span><br><span class="line">Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s</span><br><span class="line">                 node.kubernetes.io/unreachable:NoExecute for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age        From                    Message</span><br><span class="line">  ----    ------     ----       ----                    -------</span><br><span class="line">  Normal  Scheduled  &lt;unknown&gt;  default-scheduler       Successfully assigned default/my-nginx-75897978cd-87dnh to centos7-node2</span><br><span class="line">  Normal  Pulling    15m        kubelet, centos7-node2  Pulling image "nginx"</span><br><span class="line">  Normal  Pulled     13m        kubelet, centos7-node2  Successfully pulled image "nginx"</span><br><span class="line">  Normal  Created    13m        kubelet, centos7-node2  Created container my-nginx</span><br><span class="line">  Normal  Started    13m        kubelet, centos7-node2  Started container my-nginx</span><br></pre></td></tr></table></figure>

<h4 id="查看所有pod"><a href="#查看所有pod" class="headerlink" title="查看所有pod"></a>查看所有pod</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 parallels]# kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE     NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">default       my-nginx-75897978cd-87dnh               1/1     Running   0          21m</span><br><span class="line">default       my-nginx-75897978cd-nwnrm               1/1     Running   0          21m</span><br><span class="line">kube-system   coredns-5644d7b6d9-tfkwk                1/1     Running   0          2d9h</span><br><span class="line">kube-system   coredns-5644d7b6d9-zwpg9                1/1     Running   0          2d9h</span><br><span class="line">kube-system   etcd-centos7-node1                      1/1     Running   0          2d9h</span><br><span class="line">kube-system   kube-apiserver-centos7-node1            1/1     Running   0          2d</span><br><span class="line">kube-system   kube-controller-manager-centos7-node1   1/1     Running   4          2d9h</span><br><span class="line">kube-system   kube-proxy-8tqsb                        1/1     Running   0          2d9h</span><br><span class="line">kube-system   kube-proxy-rxdfv                        1/1     Running   0          2d6h</span><br><span class="line">kube-system   kube-proxy-vdkhd                        1/1     Running   0          47h</span><br><span class="line">kube-system   kube-scheduler-centos7-node1            1/1     Running   4          2d9h</span><br><span class="line">kube-system   weave-net-4q5kr                         2/2     Running   0          2d8h</span><br><span class="line">kube-system   weave-net-767sf                         2/2     Running   0          2d6h</span><br><span class="line">kube-system   weave-net-f2pgl                         2/2     Running   1          47h</span><br></pre></td></tr></table></figure>

<h4 id="进入一个Pod"><a href="#进入一个Pod" class="headerlink" title="进入一个Pod"></a>进入一个Pod</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 parallels]#  kubectl exec -it my-nginx-75897978cd-87dnh -n default -- /bash/sh</span><br><span class="line">Error from server: error dialing backend: dial tcp 10.211.55.8:10250: connect: no route to host</span><br></pre></td></tr></table></figure>

<p>出现这个错误是因为在机器<code>10.211.55.8</code>没有关闭掉防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node2 Workspace]# systemctl disable firewalld &amp;&amp; systemctl stop firewalld</span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="line">Removed symlink /etc/systemd/system/basic.target.wants/firewalld.service.</span><br></pre></td></tr></table></figure>

<p>再次进入<code>Pod</code>就成功了，但是什么命令都没有。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@CentOS7-Node1 parallels]#  kubectl exec -it my-nginx-75897978cd-87dnh -n default bash</span><br><span class="line">root@my-nginx-75897978cd-87dnh:/# ifconfig</span><br><span class="line">bash: ifconfig: command not found</span><br><span class="line">root@my-nginx-75897978cd-87dnh:/# ps aux | grep nginx</span><br><span class="line">bash: ps: command not found</span><br><span class="line">root@my-nginx-75897978cd-87dnh:/#</span><br></pre></td></tr></table></figure>

<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/explore-intro/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/explore-intro/</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Code Review最佳实践</title>
    <url>/2020/01/09/2020/01/Code%20Review%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>我一直认为Code Review（代码审查）是软件开发中的最佳实践之一，可以有效提高整体代码质量，及时发现代码中可能存在的问题。包括像Google、微软这些公司，Code Review都是基本要求，代码合并之前必须要有人审查通过才行。</p>
<p>然而对于我观察到的大部分软件开发团队来说，认真做Code Review的很少，有的流于形式，有的可能根本就没有Code Review的环节，代码质量只依赖于事后的测试。也有些团队想做好代码审查，但不知道怎么做比较好。</p>
<p> 网上关于如何做Code Review的文章已经有很多了，这里我结合自己的一些经验，也总结整理了一下Code Review的最佳实践，希望能对大家做好Code Review有所帮助。</p>
<h4 id="Code-Review有什么好处？"><a href="#Code-Review有什么好处？" class="headerlink" title="Code Review有什么好处？"></a>Code Review有什么好处？</h4><p>很多团队或个人不做Code Review，根源还是不觉得这是一件有意义的事情，不觉得有什么好处。这个问题要从几个角度来看。</p>
<ul>
<li><strong>首先是团队知识共享的角度</strong> </li>
</ul>
<p>一个开发团队中，水平有高有低，每个人侧重的领域也有不同。怎么让高水平的帮助新人成长？怎么让大家都对自己侧重领域之外的知识保持了解？怎么能有人离职后其他人能快速接手？这些都是团队管理者关心的问题。</p>
<p>而代码审查，就是一个很好的知识共享的方式。通过代码审查，高手可以直接指出新手代码中的问题，新手可以马上从高手的反馈中学习到好的实践，得到更快的成长；通过代码审查，前端也可以去学习后端的代码，做功能模块A的可以去了解功能模块B的。</p>
<p>可能有些高手觉得给新手代码审查浪费时间，自己也没收获。其实不然，新人成长了，就可以更多的帮高手分担繁重的任务；代码审查中花时间，就少一些帮新人填坑擦屁股的时间；良好的沟通能力、发现问题的能力、帮助其他人成长，都是技术转管理或技术上更上一层楼必不可少的能力，而通过代码审查可以有效的去练习这些方面的能力。</p>
<ul>
<li><strong>然后是代码质量的角度</strong></li>
</ul>
<p>现实中的项目总是人手缺进度紧，所以被压缩的往往就是自动化测试和代码审查，结果影响代码质量，欠下技术债务，最后还是要加倍偿还。</p>
<p>也有人寄希望于开发后的人工测试，然而对于代码质量来说，很多问题通过测试是测试不出来的，只能通过代码审查。比如说代码的可读性可维护性，比如代码的结构，比如一些特定条件才触发的死循环、逻辑算法错误，还有一些安全上的漏洞也更容易通过代码审查发现和预防。 </p>
<p>也有人觉得自己水平高就不需要代码审查了。对于高手来说，让别人审查自己的代码，可以让其他人学习到好的实践；在让其他人审查的同时，在给别人说明自己代码的时候，也等于自己对自己的代码进行了一次审查。这其实就跟我们上学时做数学题一样，真正能拿高分的往往是那些做完后还会认真检查的。</p>
<ul>
<li><strong>还有团队规范的角度</strong> </li>
</ul>
<p>每个团队都有自己的代码规范，有自己的基于架构设计的开发规范，然而时间一长，就会发现代码中出现很多不遵守代码规范的情况，有很多绕过架构设计的代码。比如难以理解和不规范的命名，比如三层架构里面UI层绕过业务逻辑层直接调用数据访问层代码。 </p>
<p>如果这些违反规范的代码被纠正的晚了，后面再要修改就成本很高了，而且团队的规范也会慢慢的形同虚设。</p>
<p>通过代码审查，就可以及时的去发现和纠正这些问题，保证团队规范的执行。</p>
<p>关于代码审查的好处，还有很多，也不一一列举。还是希望能认识到<strong>Code Review和写自动化测试一样，都是属于磨刀不误砍柴工的工作，在上面投入一点点时间，未来会收获代码质量，会节约整体的开发时间。</strong></p>
<h4 id="该怎么做？"><a href="#该怎么做？" class="headerlink" title="该怎么做？"></a>该怎么做？</h4><p>现在很多人都已经有意识到Code Review的重要性了，只是苦于不知道如何去实践，不知道怎么样算是好的Code Review实践。</p>
<h4 id="把Code-Review作为开发流程的必选项而不是可选项"><a href="#把Code-Review作为开发流程的必选项而不是可选项" class="headerlink" title="把Code Review作为开发流程的必选项而不是可选项"></a>把Code Review作为开发流程的必选项而不是可选项</h4><p>在很早以前，我就尝试过将代码审查作为代码流程的一部分，但只是一个可选项，没有Code Review也可以把代码合并到master。这样的结果就是想起来才会去做Code Review，去检查的时候已经有了太多的代码变更，审查起来非常困难，另外就算审查出问题，也很难得以修改。 </p>
<p>我们现在对代码的审查则是作为开发流程的一个必选项，每次开发新功能或者修复Bug，开一个新的分支，分支要合并到master有两个必要条件：</p>
<ul>
<li>所有的自动化测试通过</li>
<li>有至少一个人Code Review通过，如果是新手的PR，还必须有资深程序员Code Review通过</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/564/201907/564-20190720013237180-1803130612.png" alt="img"></p>
<p>图片来源：How to Do Code Reviews Like a Human</p>
<p>这样把Code Review作为开发流程的一个必选项后，就很好的保证了代码在合并之前有过Code Review。而且这样合并前要求代码审查的流程，好处也很明显：</p>
<ul>
<li>由于每一次合并前都要做代码审查，这样一般一次审查的代码量也不会太大，对于审查者来说压力也不会太大</li>
<li>如果在Code Review时发现问题，被审查者希望代码能尽快合并，也会积极的对审查出来的问题进行修改，不至于对审查结果太过抵触</li>
</ul>
<p>如果你觉得Code Review难以推行，不妨先尝试着把Code Review变成你开发流程的一个必选项。</p>
<h4 id="把Code-Review变成一种开发文化而不仅仅是一种制度"><a href="#把Code-Review变成一种开发文化而不仅仅是一种制度" class="headerlink" title="把Code Review变成一种开发文化而不仅仅是一种制度"></a>把Code Review变成一种开发文化而不仅仅是一种制度</h4><p>把Code Review 作为开发流程的必选项后，不代表Code Review这件事就可以执行的很好，因为Code Review 的执行，很大部分程度上依赖于审查者的认真审查，以及被审查者的积极配合，两者缺一不可！</p>
<p>如果仅仅只是当作一个流程制度，那么就可能会流于形式。最终结果就是看起来有Code Review，但没有人认真审查，随便看下就通过了，或者发现问题也不愿意修改。</p>
<p>真要把Code Review这件事做好，必须让Code Review变成团队的一种文化，开发人员从心底接受这件事，并认真执行这件事。</p>
<p>要形成这样的文化，不那么容易，也没有想象的那么难，比如这些方面可以参考：</p>
<ul>
<li>首先，得让开发人员认识到Code Review这件事为自己、为团队带来的好处</li>
<li>然后，得要有几个人做好表率作用，榜样的力量很重要</li>
<li>还有，对于管理者来说，你激励什么，往往就会得到什么</li>
<li>最后，像写自动化测试一样，<strong>把Code Review要作为开发任务的一部分，给审查者和被审查者都留出专门的时间去做这件事</strong>，不能光想着马儿跑得快又舍不得给马儿吃草 </li>
</ul>
<p>如何形成这样的文化，有心的话，还有很多方法可以尝试。只有真正让大家都认同和践行，才可能去做好Code Review这件事。</p>
<h4 id="一些Code-Review的经验技巧"><a href="#一些Code-Review的经验技巧" class="headerlink" title="一些Code Review的经验技巧"></a>一些Code Review的经验技巧</h4><p>在做好Code Review这件事上，还有一些经验技巧可以参考。</p>
<h4 id="选什么工具辅助做CODE-REVIEW？"><a href="#选什么工具辅助做CODE-REVIEW？" class="headerlink" title="选什么工具辅助做CODE REVIEW？"></a>选什么工具辅助做CODE REVIEW？</h4><p>现在很多源代码管理工具都自带Code Review工具，典型的像Github、Gitlab、微软的Azure DevOps，尤其是像Gitlab，还可以自己在本地搭建环境，根据自己的需要灵活配置。 </p>
<h4 id="配合什么样的开发流程比较好？"><a href="#配合什么样的开发流程比较好？" class="headerlink" title="配合什么样的开发流程比较好？"></a>配合什么样的开发流程比较好？</h4><p>像<a href="https://guides.github.com/introduction/flow/" target="_blank" rel="noopener">Github Flow</a>这样基于分支开发的流程是特别适合搭配Code Review的。其实不管什么样的开发流程，关键点在于代码合并到master（主干）之前，要先做Code Review。</p>
<h4 id="真遇到紧急情况，来不及代码审查怎么办？"><a href="#真遇到紧急情况，来不及代码审查怎么办？" class="headerlink" title="真遇到紧急情况，来不及代码审查怎么办？"></a>真遇到紧急情况，来不及代码审查怎么办？</h4><p>虽然原则上，必须要Code Review才能合并，但有时候确实会存在一些紧急情况，比如说线上故障补丁，而又没有其他人在线，那么这种情况下，最好是在任务管理系统中，创建一个Ticket，用来后续跟踪，确保后续补上Code Review，并对Code Review结果有后续的代码更新。</p>
<h4 id="先设计再编码"><a href="#先设计再编码" class="headerlink" title="先设计再编码"></a>先设计再编码</h4><p>有些新人发现自己的代码提交PR（Pull Request）后，会收到一堆的Code Review意见，必须要做大量的改动。这多半是因为在开始做之前，没有做好设计，做出来后才发现问题很多。 </p>
<p>建议在做一个新功能之前，写一个简单的设计文档，表达清楚自己的设计思路，找资深的先帮你做一下设计的审查，发现设计上的问题。设计上没问题了，再着手开发，那么到Review的时候，相对问题就会少很多。</p>
<h4 id="代码在提交CODE-REVIEW之前，作者要自己先REVIEW和测试一遍"><a href="#代码在提交CODE-REVIEW之前，作者要自己先REVIEW和测试一遍" class="headerlink" title="代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍"></a>代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍</h4><p>我在做代码审查的时候，有时候会发现一些非常明显的问题，有些甚至自己都没有测试过，就等着别人Code Review和测试帮助发现问题。这种依赖心理无论是对自己还是对团队都是很不负责任的。 </p>
<p><strong>一个好的开发人员，代码在提交Code Review之前，肯定是要自己先Review一遍，把该写的自动化测试代码写上，自己把基本的测试用例跑一遍的。</strong> </p>
<p>我对于团队提交的PR，有个要求就是要在PR的描述中增加截图或者录屏，就是为了通过截图或者录屏，确保提交PR的人自己是先测试过的。这也是一个有效的辅助手段。</p>
<h4 id="PR要小"><a href="#PR要小" class="headerlink" title="PR要小"></a>PR要小</h4><p>在做Code Review的时候，如果有大量的文件修改，那么Review起来是很困难的，但如果PR比较小，相对就比较容易Review，也容易发现代码中可能存在的问题。</p>
<p>所以在提交PR时，PR要小，如果是比较大的改动，那么最好分批提交，以减轻审查者的压力。</p>
<p><img src="https://img2018.cnblogs.com/blog/564/201907/564-20190720013159632-1726452152.jpg" alt="img"></p>
<h4 id="对评论进行分级"><a href="#对评论进行分级" class="headerlink" title="对评论进行分级"></a>对评论进行分级</h4><p>在做Code Review时，需要针对审查出有问题的代码行添加评论，如果只是评论，有时候对于被审查者比较难甄别评论所代表的含义，是不是必须要修改。</p>
<p>建议可以对Review的评论进行分级，不同级别的结果可以打上不同的Tag，比如说：</p>
<ul>
<li><p>[blocker]: 在评论前面加上一个blocker标记，表示这个代码行的问题必须要修改</p>
</li>
<li><p>[optional]：在评论前面加上一个[optional]标记，表示这个代码行的问题可改可不改</p>
</li>
<li><p>[question]：在评论前面加上一个[question]标记，表示对这个代码行不理解，有问题需要问，被审查者需要针对问题进行回复澄清 </p>
</li>
</ul>
<p>类似这样的分级可以帮助被审查者直观了解Review结果，提高Review效率。</p>
<h4 id="评论要友好，避免负面词汇；有说不清楚的问题当面沟通"><a href="#评论要友好，避免负面词汇；有说不清楚的问题当面沟通" class="headerlink" title="评论要友好，避免负面词汇；有说不清楚的问题当面沟通"></a>评论要友好，避免负面词汇；有说不清楚的问题当面沟通</h4><p>虽然评论是主要的Code Review沟通方式，但也不要过于依赖，有时候面对面的沟通效率更高，也容易消除误解。</p>
<p>另外文明用语，不要用一些负面的词汇。 </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Code Review是一种非常好的开发实践，如果你还没开始，不妨逐步实践起来；如果已经做了效果不好，不妨对照一下，看有没有把Code Review作为开发流程的必选项而不是可选项？有没有把Code Review变成一种开发文化而不仅仅是一种制度？</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>CodeReview</category>
        <category>流程管理</category>
      </categories>
      <tags>
        <tag>CodeReview</tag>
        <tag>流程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10导入Spring源码Gradle错误</title>
    <url>/2019/11/25/2019/11/Win10%E5%AF%BC%E5%85%A5Spring%E6%BA%90%E7%A0%81Gradle%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>我是Mac系统与Win10系统同时使用，但大部分还是在Mac系统上，有时候为了保持2个系统的“一致性”，会用到一些云盘或者Git等。这次是属于保证学习spring源代码的时候版本内容一致。</p>
<p><a href="https://github.com/spring-projects/spring-framework/tree/v5.1.4.RELEASE" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/tree/v5.1.4.RELEASE</a></p>
<p>spring-framework是用gradle来管理包依赖的，在编译过程中，Win系统同遇到了一些问题。</p>
<h4 id="升级gradle"><a href="#升级gradle" class="headerlink" title="升级gradle"></a>升级gradle</h4><p>之前我是用的gradle-4.10.2，找了一些文章建议升级，所以我干脆就升级到最新的版本。</p>
<p>官网下载地址：<a href="https://gradle.org/releases/，然后我选择的是6.0的版本。" target="_blank" rel="noopener">https://gradle.org/releases/，然后我选择的是6.0的版本。</a></p>
<p>配置<code>GRADLE_HOME</code>与<code>path</code>：</p>
<p>配置GRADLE_HOME：</p>
<p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20191117000656.png" alt="http://static.cyblogs.com/QQ截图20191117000656.png"></p>
<p>配置path：</p>
<p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20191117000716.png" alt="http://static.cyblogs.com/QQ截图20191117000716.png"></p>
<h4 id="修改build-gradle"><a href="#修改build-gradle" class="headerlink" title="修改build.gradle"></a>修改build.gradle</h4><p>对比图：</p>
<p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20191117001201.png" alt="http://static.cyblogs.com/QQ截图20191117001201.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		maven &#123; url "https://repo.spring.io/plugins-release" &#125;</span><br><span class="line">		maven &#123;url "https://plugins.gradle.org/m2/"&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dependencies &#123;</span><br><span class="line">		classpath("io.spring.gradle:propdeps-plugin:0.0.9.RELEASE")</span><br><span class="line">		classpath("org.asciidoctor:asciidoctorj-pdf:1.5.0-alpha.16")</span><br><span class="line">		classpath("org.jetbrains.dokka:dokka-gradle-plugin:0.9.15")</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3rd party plugin repositories can be configured in settings.gradle</span><br><span class="line">plugins &#123;</span><br><span class="line">	id "io.spring.dependency-management" version "1.0.5.RELEASE" apply false</span><br><span class="line">	id "org.jetbrains.kotlin.jvm" version "1.2.71" apply false</span><br><span class="line">	id "org.jetbrains.dokka" version "0.9.15"</span><br><span class="line">	id "org.asciidoctor.convert" version "1.5.8"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20191117070823.png" alt="http://static.cyblogs.com/QQ截图20191117070823.png"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/zyt19870409/article/details/89486802" target="_blank" rel="noopener">https://blog.csdn.net/zyt19870409/article/details/89486802</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>KeepAlived保证Mysql主从自动切换</title>
    <url>/2020/01/10/2020/01/KeepAlived%E4%BF%9D%E8%AF%81Mysql%E4%B8%BB%E4%BB%8E%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>前面有几篇文章对于MySQL主从搭建做了一些铺垫:</p>
<p>文章一：<a href="http://www.cyblogs.com/mysql-binlogshe-zhi/">MySQL中Binlog的常用设置</a></p>
<p>文章二：<a href="http://www.cyblogs.com/mysqlzhu-cong-tong-bu-shi-jian-pian/">MySQL主从同步-原理&amp;实践篇</a></p>
<p>先启动Master与Slave的2台mysql服务器，具体信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~  docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">8f31266d08fc        docker-mysql-master:v1   "/usr/sbin/init"    49 minutes ago      Up 49 minutes       0.0.0.0:33063-&gt;3306/tcp   docker-mysql-client</span><br><span class="line">a579aa381425        docker-mysql-slave:v1    "/usr/sbin/init"    19 hours ago        Up 19 hours         0.0.0.0:33062-&gt;3306/tcp   docker-mysql-slave</span><br><span class="line">a40a40c6bde7        docker-mysql-master:v1   "/usr/sbin/init"    19 hours ago        Up 19 hours         0.0.0.0:33061-&gt;3306/tcp   docker-mysql-master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入master</span></span><br><span class="line">➜  ~  docker exec -it 8166c07dd6c7 bash</span><br><span class="line">[root@8166c07dd6c7 /]#</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入slave</span></span><br><span class="line">➜  ~  docker exec -it 208c30295ec9 bash</span><br><span class="line">[root@208c30295ec9 /]#</span><br></pre></td></tr></table></figure>

<p>Master机器（172.17.0.2）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'master_account'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;  </span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'master_account'</span>@<span class="string">'%'</span>;  </span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'172.17.0.3'</span>,master_user=<span class="string">'slave_account'</span>,master_password=<span class="string">'123456'</span>,master_log_file=<span class="string">'mysql-bin.000001'</span>,master_log_pos=<span class="number">120</span>;</span><br></pre></td></tr></table></figure>

<p>Slave机器（172.17.0.3）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'slave_account'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123456'</span>;  </span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'slave_account'</span>@<span class="string">'%'</span>;  </span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'172.17.0.2'</span>,master_user=<span class="string">'master_account'</span>,master_password=<span class="string">'123456'</span>,master_log_file=<span class="string">'mysql-bin.000008'</span>,master_log_pos=<span class="number">862</span>;</span><br></pre></td></tr></table></figure>

<p>分别在Master与Slave机器验证，必须是互相同步OK的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#并且保证主从是同步的</span></span><br><span class="line">mysql&gt; show slave status\G;</span><br><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>

<p>SQL验证，分别在Master执行脚本需要在Slave上看到数据同步。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Master</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person_01 (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">'chenyuan'</span>, <span class="number">20</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="comment"># Slave</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person_01 (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">11</span>, <span class="string">'chenyuan11'</span>, <span class="number">20</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="comment"># 2边数据一致就OK</span></span><br><span class="line">mysql&gt; select * from person_01;</span><br><span class="line">+<span class="comment">------+------------+------+--------+</span></span><br><span class="line">| id   | first_name | age  | gender |</span><br><span class="line">+<span class="comment">------+------------+------+--------+</span></span><br><span class="line">|    1 | Bob        |   25 | M      |</span><br><span class="line">|    2 | Jane       |   20 | F      |</span><br><span class="line">|    3 | Jack       |   30 | M      |</span><br><span class="line">|    4 | Bill       |   32 | M      |</span><br><span class="line">|    5 | Nick       |   22 | M      |</span><br><span class="line">|    6 | Kathy      |   18 | F      |</span><br><span class="line">|    7 | Steve      |   36 | M      |</span><br><span class="line">|    8 | Anne       |   25 | F      |</span><br><span class="line">|    1 | Vernon     |  300 | M      |</span><br><span class="line">|   10 | chenyuan   |   20 | M      |</span><br><span class="line">|   11 | chenyuan11 |   20 | M      |</span><br><span class="line">+<span class="comment">------+------------+------+--------+</span></span><br><span class="line">11 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="安装KeepAlived"><a href="#安装KeepAlived" class="headerlink" title="安装KeepAlived"></a>安装KeepAlived</h4><p>安装好gcc，gcc-c++，make</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install gcc gcc-c++ autoconf automake</span><br><span class="line">yum install initscripts -y</span><br></pre></td></tr></table></figure>

<p>分别在Maste机器、Slave机器安装好keepalived</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> master</span></span><br><span class="line">[root@8166c07dd6c7 /]# yum install -y keepalived</span><br><span class="line">...</span><br><span class="line">Complete!</span><br><span class="line">[root@8166c07dd6c7 /]# keepalived -v</span><br><span class="line">Keepalived v1.3.5 (03/19,2017), git commit v1.3.5-6-g6fa32f2</span><br><span class="line">Copyright(C) 2001-2017 Alexandre Cassen, &lt;acassen@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> slave</span></span><br><span class="line">[root@208c30295ec9 /]# yum install keepalived</span><br><span class="line">...</span><br><span class="line">Complete!</span><br><span class="line">[root@8166c07dd6c7 /]# keepalived -v</span><br><span class="line">Keepalived v1.3.5 (03/19,2017), git commit v1.3.5-6-g6fa32f2</span><br><span class="line">Copyright(C) 2001-2017 Alexandre Cassen, &lt;acassen@gmail.com&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配置KeepAlived"><a href="#配置KeepAlived" class="headerlink" title="配置KeepAlived"></a>配置KeepAlived</h4><h5 id="配置Master机器keepalived"><a href="#配置Master机器keepalived" class="headerlink" title="配置Master机器keepalived"></a>配置Master机器keepalived</h5><p>新增<code>shutdown.sh</code>脚本，并且赋值可以执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 shutdown.sh</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">pkill keepalived</span><br></pre></td></tr></table></figure>

<p>配置<code>keepalived.conf</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@8166c07dd6c7 keepalived]# vi /etc/keepalived/keepalived.conf</span><br><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id HA_MySQL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    nopreempt</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass chenyuan</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.17.0.4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 172.17.0.99 3306 &#123;</span><br><span class="line">    delay_loop 2</span><br><span class="line">    lb_algo wrr</span><br><span class="line">    lb_kind DR</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 172.17.0.99 3306 &#123;</span><br><span class="line">        weight 3</span><br><span class="line">        notify_down /etc/keepalived/bin/shutdown.sh</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">            connect_port 3306</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动好<code>keepalived</code>服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@a40a40c6bde7 bin]# systemctl start keepalived.service</span><br><span class="line">[root@a40a40c6bde7 bin]# ps aux | grep keepalived</span><br><span class="line">root       494  0.0  0.1 123016  2104 ?        Ss   14:59   0:00 keepalived</span><br><span class="line">root       495  0.0  0.3 125268  7164 ?        S    14:59   0:00 keepalived</span><br><span class="line">root       496  0.0  0.2 125140  5700 ?        S    14:59   0:00 keepalived</span><br><span class="line">root       515  0.0  0.1  12532  2164 pts/1    S+   14:59   0:00 grep --color=auto keepalived</span><br><span class="line"></span><br><span class="line">[root@a40a40c6bde7 bin]# systemctl stop keepalived.service</span><br></pre></td></tr></table></figure>

<h5 id="配置Slave机器keepalived"><a href="#配置Slave机器keepalived" class="headerlink" title="配置Slave机器keepalived"></a>配置Slave机器keepalived</h5><p>新增<code>shutdown.sh</code>脚本，并且赋值可以执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 shutdown.sh</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">pkill keepalived</span><br></pre></td></tr></table></figure>

<p>配置<code>keepalived.conf</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id HA_MySQL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    # nopreempt</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass chenyuan</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.17.0.99</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 172.17.0.99 3306 &#123;</span><br><span class="line">    delay_loop 2</span><br><span class="line">    lb_algo wrr</span><br><span class="line">    lb_kind DR</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 172.17.0.3 3306 &#123;</span><br><span class="line">        weight 3</span><br><span class="line">        notify_down /etc/keepalived/bin/shutdown.sh</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">            connect_port 3306</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样也是启动好keepalived服务。</p>
<h4 id="查看虚拟IP是否已经起来"><a href="#查看虚拟IP是否已经起来" class="headerlink" title="查看虚拟IP是否已经起来"></a>查看虚拟IP是否已经起来</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@a40a40c6bde7 mysql]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">21: eth0@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 172.17.0.99/32 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@a579aa381425 support-files]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link&#x2F;ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link&#x2F;tunnel6 :: brd ::</span><br><span class="line">23: eth0@if24: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.3&#x2F;16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>由此可见，现在172.17.0.99/32`是在master节点上。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>通过<code>docker-mysql-client</code>机器来登录数据库，下面显示登录成功。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root@8f31266d08fc bin]<span class="comment"># ./mysql -h 172.17.0.99 -u root -p</span></span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands <span class="keyword">end</span> <span class="keyword">with</span> ; or \g.</span><br><span class="line">Your MySQL connection id is 173</span><br><span class="line">Server version: 5.6.45-log MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type '<span class="keyword">help</span>;' or '\h' for help. <span class="keyword">Type</span> <span class="string">'\c'</span> <span class="keyword">to</span> <span class="keyword">clear</span> the <span class="keyword">current</span> <span class="keyword">input</span> statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like 'server_id';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| server_id     | 1     |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>把mysql进程直接杀掉，类似于机器down的情况。然后再次查看server_id,短暂的失去联系，即可很快的恢复。</p>
<p>杀掉Master的进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@a40a40c6bde7 mysql]# ps aux | grep mysql</span><br><span class="line">root      2559  0.0  0.1  15268  2952 pts/2    S    10:13   0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/usr/local/mysql/data --pid-file=/usr/local/mysql/data/a40a40c6bde7.pid</span><br><span class="line">mysql     2859  0.2 23.0 1686996 471820 pts/2  Sl   10:13   0:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=a40a40c6bde7.err --pid-file=/usr/local/mysql/data/a40a40c6bde7.pid --socket=/tmp/mysql.sock --port=3306</span><br><span class="line">root      2909  0.0  0.1  12532  2084 pts/2    S+   10:27   0:00 grep --color=auto mysql</span><br><span class="line">[root@a40a40c6bde7 mysql]# kill -9 2559</span><br><span class="line">[root@a40a40c6bde7 mysql]# kill -9 2859</span><br></pre></td></tr></table></figure>

<p>在<code>docker-mysql-client</code>节点上继续查看<code>server_id</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like 'server_id';</span><br><span class="line">ERROR 2013 (HY000): Lost connection to MySQL server during query</span><br><span class="line">mysql&gt; show variables like 'server_id';</span><br><span class="line">ERROR 2006 (HY000): MySQL server has gone away</span><br><span class="line">No connection. Trying to reconnect...</span><br><span class="line">Connection id:    62</span><br><span class="line">Current database: *** NONE ***</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like 'server_id';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| server_id     | 2     |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>最后还需要反过来验证一边，就是让<code>Slave</code>机器的<code>mysql</code>服务挂掉，让<code>VIP</code>切换到<code>Master</code>节点去。</p>
<h4 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h4><p>不能启动keepalived服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to get D-Bus connection: Operation not permitted</span><br><span class="line">docker run -itd --name docker-mysql-slave --privileged -v &#x2F;Users&#x2F;chenyuan&#x2F;Data&#x2F;docker&#x2F;mysql-data-slave:&#x2F;usr&#x2F;local&#x2F;mysql -v &#x2F;Users&#x2F;chenyuan&#x2F;Tools:&#x2F;root&#x2F;Tools -e MYSQL_ROOT_PASSWORD&#x3D;root -p 33062:3306 docker-mysql-slave:v1 &#x2F;usr&#x2F;sbin&#x2F;init</span><br><span class="line">注意这里的--privileged 与 &#x2F;usr&#x2F;sbin&#x2F;init</span><br></pre></td></tr></table></figure>

<p>通过vip登录报错</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'root'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.jianshu.com/p/8a5308888ef1" target="_blank" rel="noopener">https://www.jianshu.com/p/8a5308888ef1</a></li>
<li><a href="https://www.jianshu.com/p/f693b5b08016" target="_blank" rel="noopener">https://www.jianshu.com/p/f693b5b08016</a></li>
<li><a href="https://blog.csdn.net/shiyu1157758655/article/details/78672110" target="_blank" rel="noopener">https://blog.csdn.net/shiyu1157758655/article/details/78672110</a></li>
<li><a href="https://blog.csdn.net/u010533511/article/details/88168410" target="_blank" rel="noopener">https://blog.csdn.net/u010533511/article/details/88168410</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>基础运维</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中Binlog的常用设置</title>
    <url>/2020/01/12/2020/01/MySQL%E4%B8%ADBinlog%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="获取mysql镜像"><a href="#获取mysql镜像" class="headerlink" title="获取mysql镜像"></a>获取mysql镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~  docker pull mysql</span><br><span class="line">➜  ~  docker images</span><br><span class="line">REPOSITORY                                                                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mysql                                                                     latest              d435eee2caa5        3 weeks ago         456MB</span><br></pre></td></tr></table></figure>

<h4 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~  docker run -itd --name docker-mysql-master -v /Users/chenyuan/Data/docker/mysql-data-master:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -p 33061:3306 mysql</span><br><span class="line">88820868af121cbac02f48a8c8e5c9eae5c6cf7241eefd3646634e14526a940f</span><br><span class="line">➜  ~  docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                                NAMES</span><br><span class="line">88820868af12        mysql               "docker-entrypoint.s…"   About a minute ago   Up About a minute   33060/tcp, 0.0.0.0:33061-&gt;3306/tcp   docker-mysql-master</span><br><span class="line">➜  ~  docker exec -it 88820868af12 bash</span><br><span class="line">root@88820868af12:/#</span><br><span class="line">root@88820868af12:/# mysql -uroot -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 8</span><br><span class="line">Server version: 8.0.18 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span></span><br></pre></td></tr></table></figure>

<p>确定挂载的mysql-data文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  mysql-data-master  ll</span><br><span class="line">total 356592</span><br><span class="line">drwxr-x---   12 chenyuan  staff   384B Dec 19 17:46 #innodb_temp</span><br><span class="line">-rw-r-----    1 chenyuan  staff   1.2K Dec 19 17:46 88820868af12.err</span><br><span class="line">-rw-r-----    1 chenyuan  staff    56B Dec 19 17:45 auto.cnf</span><br><span class="line">-rw-r-----    1 chenyuan  staff   2.9M Dec 19 17:46 binlog.000001</span><br><span class="line">-rw-r-----    1 chenyuan  staff   155B Dec 19 17:46 binlog.000002</span><br><span class="line">-rw-r-----    1 chenyuan  staff    32B Dec 19 17:46 binlog.index</span><br><span class="line">-rw-------    1 chenyuan  staff   1.6K Dec 19 17:45 ca-key.pem</span><br><span class="line">-rw-r--r--    1 chenyuan  staff   1.1K Dec 19 17:45 ca.pem</span><br><span class="line">-rw-r--r--    1 chenyuan  staff   1.1K Dec 19 17:45 client-cert.pem</span><br><span class="line">-rw-------    1 chenyuan  staff   1.6K Dec 19 17:45 client-key.pem</span><br><span class="line">-rw-r-----    1 chenyuan  staff   5.3K Dec 19 17:46 ib_buffer_pool</span><br><span class="line">-rw-r-----    1 chenyuan  staff    48M Dec 19 17:46 ib_logfile0</span><br><span class="line">-rw-r-----    1 chenyuan  staff    48M Dec 19 17:45 ib_logfile1</span><br><span class="line">-rw-r-----    1 chenyuan  staff    12M Dec 19 17:46 ibdata1</span><br><span class="line">-rw-r-----    1 chenyuan  staff    12M Dec 19 17:46 ibtmp1</span><br><span class="line">drwxr-x---    8 chenyuan  staff   256B Dec 19 17:46 mysql</span><br><span class="line">-rw-r-----    1 chenyuan  staff    29M Dec 19 17:46 mysql.ibd</span><br><span class="line">drwxr-x---  105 chenyuan  staff   3.3K Dec 19 17:45 performance_schema</span><br><span class="line">-rw-------    1 chenyuan  staff   1.6K Dec 19 17:45 private_key.pem</span><br><span class="line">-rw-r--r--    1 chenyuan  staff   452B Dec 19 17:45 public_key.pem</span><br><span class="line">-rw-r--r--    1 chenyuan  staff   1.1K Dec 19 17:45 server-cert.pem</span><br><span class="line">-rw-------    1 chenyuan  staff   1.6K Dec 19 17:45 server-key.pem</span><br><span class="line">drwxr-x---    3 chenyuan  staff    96B Dec 19 17:46 sys</span><br><span class="line">-rw-r-----    1 chenyuan  staff    12M Dec 19 17:46 undo_001</span><br><span class="line">-rw-r-----    1 chenyuan  staff    10M Dec 19 17:46 undo_002</span><br><span class="line">➜  mysql-data-master  pwd</span><br><span class="line">/Users/chenyuan/Data/docker/mysql-data-master</span><br></pre></td></tr></table></figure>

<h4 id="Binlog配置"><a href="#Binlog配置" class="headerlink" title="Binlog配置"></a>Binlog配置</h4><p>查看binlog日志的地方，通过命令查看。因为没有设置过所以看不到。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> mysql&gt; show variables like <span class="string">'%datadir%'</span>;</span></span><br><span class="line">Empty set (0.01 sec)</span><br><span class="line"></span><br><span class="line">root@88820868af12:/etc/mysql# pwd</span><br><span class="line">/etc/mysql</span><br><span class="line">root@88820868af12:/etc/mysql# ls -l</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 1 root root 4096 Nov 23 01:48 conf.d</span><br><span class="line">-rw-rw-r-- 1 root root 1174 Nov 23 01:48 my.cnf</span><br><span class="line">-rw-r--r-- 1 root root 1469 Sep 20 09:04 my.cnf.fallback</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后面设置好后，就能看到了。</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show variables like <span class="string">'%datadir%'</span>;</span></span><br><span class="line">+---------------+------------------------+</span><br><span class="line">| Variable_name | Value                  |</span><br><span class="line">+---------------+------------------------+</span><br><span class="line">| datadir       | /usr/local/mysql/data/ |</span><br><span class="line">+---------------+------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="当前容器提交为镜像"><a href="#当前容器提交为镜像" class="headerlink" title="当前容器提交为镜像"></a>当前容器提交为镜像</h4><p>到这里遇到一个非常好玩的事情，就是获取的mysql镜像是一个非常干净的容器，常用的命令都没有。比如：yum、ifconfig、cat等。所以我需要把当前的容器打一个镜像包。并且docker run的时候要挂载一个本地的目录，避免待会儿需要上传一些工具包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时，将容器暂停。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~  docker commit -a "chengcheng222e@sina.com" -m "created by vernon" 88820868af12  mysql-versnon:v1</span><br><span class="line">sha256:e9691f399c321ea221b48e6142e9501f0ee69964fa4be687ac189f8444d75d66</span><br><span class="line">➜  ~  docker images</span><br><span class="line">REPOSITORY                                                                TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mysql-versnon                                                             v1                  e9691f399c32        13 seconds ago      456MB</span><br><span class="line">mysql                                                                     latest              d435eee2caa5        3 weeks ago         456MB</span><br><span class="line"></span><br><span class="line">➜  Tools docker run -itd --name docker-mysql-master -v /Users/chenyuan/Data/docker/mysql-data-master:/var/lib/mysql -v /Users/chenyuan/Tools:/root/tools -e MYSQL_ROOT_PASSWORD=root -p 33061:3306 mysql-versnon:v1</span><br></pre></td></tr></table></figure>

<p>这里注意一下，因为<code>docker pull mysql</code>镜像中的<code>shell</code>里面命令太少了，非常的不方便。这里建议大家还是利用<code>dockefile</code>的方式或者是<code>docker pull centos</code>的方式来安装mysql，不然你会怀疑人生。</p>
<p><img src="http://static.cyblogs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191228233247.jpg" alt="http://static.cyblogs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191228233247.jpg"></p>
<p>通过<code>dockerfile</code>的方式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER 2019-09-27 chenyuan chengcheng222e@sina.com</span><br><span class="line"></span><br><span class="line"># Linux lib</span><br><span class="line">RUN yum install -y tar</span><br><span class="line">RUN yum install -y unzip</span><br><span class="line">RUN yum install -y initscripts</span><br><span class="line"></span><br><span class="line"># Software space</span><br><span class="line">RUN mkdir -p ~&#x2F;tools&#x2F;</span><br><span class="line">COPY jdk1.8.0_45.tar.gz ~&#x2F;tools&#x2F;</span><br><span class="line">COPY mysql-5.6.45-linux-glibc2.12-x86_64.tar.gz ~&#x2F;tools&#x2F;</span><br><span class="line"></span><br><span class="line"># JDK</span><br><span class="line">WORKDIR ~&#x2F;tools&#x2F;</span><br><span class="line">RUN tar -zxvf jdk1.8.0_45.tar.gz</span><br><span class="line">RUN mv jdk1.8.0_45 &#x2F;opt&#x2F;</span><br><span class="line">RUN ln -s &#x2F;opt&#x2F;jdk1.8.0_45&#x2F;bin&#x2F;* &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;</span><br><span class="line">ENV JAVA_HOME &#x2F;opt&#x2F;jdk1.8.0_45</span><br><span class="line">ENV JRE_HOME $&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">ENV CLASSPATH .:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">ENV PATH $&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line"># MySQL</span><br><span class="line">RUN cd ~&#x2F;tools&#x2F;</span><br><span class="line">RUN yum -y install numactl</span><br><span class="line">RUN yum -y install libaio</span><br><span class="line">RUN yum -y install pwgen</span><br><span class="line">RUN yum install -y perl-Data-Dumper</span><br><span class="line">RUN tar -zxvf mysql-5.6.45-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line">RUN mv mysql-5.6.45-linux-glibc2.12-x86_64 &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line">RUN groupadd mysql</span><br><span class="line">RUN useradd -g mysql mysql</span><br><span class="line">RUN chown -R mysql &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line">RUN chgrp -R mysql &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line"></span><br><span class="line">RUN cp &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld</span><br><span class="line">COPY my.cnf &#x2F;etc&#x2F;my.cnf</span><br><span class="line">RUN &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;scripts&#x2F;mysql_install_db --user&#x3D;mysql --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data</span><br><span class="line">ENV PATH $PATH:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin</span><br><span class="line">EXPOSE 3306</span><br></pre></td></tr></table></figure>

<h4 id="my-conf配置"><a href="#my-conf配置" class="headerlink" title="my.conf配置"></a>my.conf配置</h4><p>修改my.conf的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">user&#x3D;mysql</span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">basedir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql</span><br><span class="line">datadir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">socket &#x3D; &#x2F;tmp&#x2F;mysql.sock</span><br><span class="line"></span><br><span class="line">server-id &#x3D; 1</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br><span class="line"></span><br><span class="line">sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure>

<h4 id="Binlog格式"><a href="#Binlog格式" class="headerlink" title="Binlog格式"></a>Binlog格式</h4><p>Binlog的格式也有三种：STATEMENT、ROW、MIXED 。</p>
<ul>
<li><p>STATMENT模式：基于SQL语句的复制（statement-based replication, SBR），每一条会修改数据的sql语句会记录到binlog中。</p>
<ul>
<li>优点：不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。</li>
<li>缺点：在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)</li>
</ul>
</li>
<li><p>基于行的复制（row-based replication, RBR）：不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了。</p>
<ul>
<li>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。</li>
<li>缺点：会产生大量的日志，尤其是alter table的时候会让日志暴涨。</li>
</ul>
</li>
<li><p>混合模式复制（mixed-based replication, MBR）：以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。</p>
</li>
</ul>
<h4 id="设置Binglog"><a href="#设置Binglog" class="headerlink" title="设置Binglog"></a>设置Binglog</h4><p>通过<code>show variables</code>的方式来查看binlog的一个实际情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%log_bin%&#39;;</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| Variable_name                   | Value |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| log_bin                         | OFF   |</span><br><span class="line">| log_bin_basename                |       |</span><br><span class="line">| log_bin_index                   |       |</span><br><span class="line">| log_bin_trust_function_creators | OFF   |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF   |</span><br><span class="line">| sql_log_bin                     | ON    |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，没有开启binlog日志，那么我们接下来开启binlog。</p>
<p>在/etc/my.cnf里面开启binlog配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-id &#x3D; 1</span><br><span class="line">log-bin&#x3D;mysql-bin</span><br></pre></td></tr></table></figure>

<p>再次查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%log_bin%&#39;;</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">| Variable_name                   | Value                                 |</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">| log_bin                         | ON                                    |</span><br><span class="line">| log_bin_basename                | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql-bin       |</span><br><span class="line">| log_bin_index                   | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;mysql-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                                   |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                                   |</span><br><span class="line">| sql_log_bin                     | ON                                    |</span><br><span class="line">+---------------------------------+---------------------------------------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>查看binlog_format</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like 'binlog_format';</span><br><span class="line">+<span class="comment">---------------+-----------+</span></span><br><span class="line">| Variable_name | Value     |</span><br><span class="line">+<span class="comment">---------------+-----------+</span></span><br><span class="line">| binlog_format | STATEMENT |</span><br><span class="line">+<span class="comment">---------------+-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="comment"># 默认的格式就是 STATEMENT</span></span><br></pre></td></tr></table></figure>

<p>确定binlog日志文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show binlog events;</span></span><br><span class="line">+------------------+-----+-------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| Log_name         | Pos | Event_type  | Server_id | End_log_pos | Info                                  |</span><br><span class="line">+------------------+-----+-------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| mysql-bin.000001 |   4 | Format_desc |         1 |         120 | Server ver: 5.6.45-log, Binlog ver: 4 |</span><br><span class="line">+------------------+-----+-------------+-----------+-------------+---------------------------------------+</span><br></pre></td></tr></table></figure>

<p>创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`person`</span> (</span><br><span class="line">    -&gt;   <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt;   <span class="string">`first_name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt;   <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt;   <span class="string">`gender`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">    -&gt; ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br><span class="line">    -&gt; ;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'Bob'</span>, <span class="number">25</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'Jane'</span>, <span class="number">20</span>, <span class="string">'F'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'Jack'</span>, <span class="number">30</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'Bill'</span>, <span class="number">32</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">'Nick'</span>, <span class="number">22</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'Kathy'</span>, <span class="number">18</span>, <span class="string">'F'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">'Steve'</span>, <span class="number">36</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.person (<span class="keyword">id</span>, first_name, age, gender) <span class="keyword">VALUES</span> (<span class="number">8</span>, <span class="string">'Anne'</span>, <span class="number">25</span>, <span class="string">'F'</span>);</span><br></pre></td></tr></table></figure>

<p>查看binlog</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show binlog events <span class="keyword">in</span> <span class="string">'mysql-bin.000001'</span>;</span></span><br><span class="line">+------------------+------+-------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Log_name         | Pos  | Event_type  | Server_id | End_log_pos | Info                                                                                                                                                                                                         |</span><br><span class="line">+------------------+------+-------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| mysql-bin.000001 |    4 | Format_desc |         1 |         120 | Server ver: 5.6.45-log, Binlog ver: 4                                                                                                                                                                        |</span><br><span class="line">| mysql-bin.000001 |  120 | Query       |         1 |         386 | use `test`; CREATE TABLE `person` (</span><br><span class="line">  `id` int(11) DEFAULT NULL,</span><br><span class="line">  `first_name` varchar(20) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `gender` char(1) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 |</span><br><span class="line">| mysql-bin.000001 |  386 | Query       |         1 |         465 | BEGIN                                                                                                                                                                                                        |</span><br><span class="line">| mysql-bin.000001 |  465 | Query       |         1 |         619 | use `test`; INSERT INTO test.person (id, first_name, age, gender) VALUES (1, 'Bob', 25, 'M')                                                                                                                 |</span><br><span class="line">| mysql-bin.000001 |  619 | Xid         |         1 |         650 | COMMIT /* xid=14 */                                                                                                                                                                                          |</span><br><span class="line">| mysql-bin.000001 |  650 | Query       |         1 |         729 | BEGIN                                                                                                                                                                                                        |</span><br><span class="line">| mysql-bin.000001 |  729 | Query       |         1 |         884 | use `test`; INSERT INTO test.person (id, first_name, age, gender) VALUES (2, 'Jane', 20, 'F')                                                                                                                |</span><br><span class="line">| mysql-bin.000001 |  884 | Xid         |         1 |         915 | COMMIT /* xid=15 */                                                                                                                                                                                          |</span><br><span class="line">| mysql-bin.000001 |  915 | Query       |         1 |         994 | BEGIN                                                                                                                                                                                                        |</span><br><span class="line">| mysql-bin.000001 |  994 | Query       |         1 |        1149 | use `test`; INSERT INTO test.person (id, first_name, age, gender) VALUES (3, 'Jack', 30, 'M')                                                                                                                |</span><br><span class="line">| mysql-bin.000001 | 1149 | Xid         |         1 |        1180 | COMMIT /* xid=16 */                                                                                                                                                                                          |</span><br><span class="line">| mysql-bin.000001 | 1180 | Query       |         1 |        1259 | BEGIN                                                                                                                                                                                                        |</span><br><span class="line">| mysql-bin.000001 | 1259 | Query       |         1 |        1414 | use `test`; INSERT INTO test.person (id, first_name, age, gender) VALUES (4, 'Bill', 32, 'M')                                                                                                                |</span><br><span class="line">| mysql-bin.000001 | 1414 | Xid         |         1 |        1445 | COMMIT /* xid=17 */                                                                                                                                                                                          |</span><br><span class="line">| mysql-bin.000001 | 1445 | Query       |         1 |        1524 | BEGIN                                                                                                                                                                                                        |</span><br><span class="line">| mysql-bin.000001 | 1524 | Query       |         1 |        1679 | use `test`; INSERT INTO test.person (id, first_name, age, gender) VALUES (5, 'Nick', 22, 'M')                                                                                                                |</span><br><span class="line">| mysql-bin.000001 | 1679 | Xid         |         1 |        1710 | COMMIT /* xid=18 */                                                                                                                                                                                          |</span><br><span class="line">| mysql-bin.000001 | 1710 | Query       |         1 |        1789 | BEGIN                                                                                                                                                                                                        |</span><br><span class="line">| mysql-bin.000001 | 1789 | Query       |         1 |        1945 | use `test`; INSERT INTO test.person (id, first_name, age, gender) VALUES (6, 'Kathy', 18, 'F')                                                                                                               |</span><br><span class="line">| mysql-bin.000001 | 1945 | Xid         |         1 |        1976 | COMMIT /* xid=19 */                                                                                                                                                                                          |</span><br><span class="line">| mysql-bin.000001 | 1976 | Query       |         1 |        2055 | BEGIN                                                                                                                                                                                                        |</span><br><span class="line">| mysql-bin.000001 | 2055 | Query       |         1 |        2211 | use `test`; INSERT INTO test.person (id, first_name, age, gender) VALUES (7, 'Steve', 36, 'M')                                                                                                               |</span><br><span class="line">| mysql-bin.000001 | 2211 | Xid         |         1 |        2242 | COMMIT /* xid=20 */                                                                                                                                                                                          |</span><br><span class="line">| mysql-bin.000001 | 2242 | Query       |         1 |        2321 | BEGIN                                                                                                                                                                                                        |</span><br><span class="line">| mysql-bin.000001 | 2321 | Query       |         1 |        2476 | use `test`; INSERT INTO test.person (id, first_name, age, gender) VALUES (8, 'Anne', 25, 'F')                                                                                                                |</span><br><span class="line">| mysql-bin.000001 | 2476 | Xid         |         1 |        2507 | COMMIT /* xid=21 */                                                                                                                                                                                          |</span><br><span class="line">+------------------+------+-------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">26 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show variables like 'binlog_format'</span><br><span class="line">set globle binlog_format='MIXED'</span><br><span class="line">show variables like 'log_bin'</span><br><span class="line">show binary logs</span><br></pre></td></tr></table></figure>

<h4 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题:"></a>遇到问题:</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysql@c738746e9623 support-files]$ ./mysql.server start</span><br><span class="line">Starting MySQL... ERROR! The server quit without updating PID file (/usr/local/mysql/data/c738746e9623.pid).</span><br><span class="line"></span><br><span class="line">log_bin=ON</span><br><span class="line">log_bin_basename=/var/lib/mysql/mysql-bin</span><br><span class="line">log_bin_index=/var/lib/mysql/mysql-bin.index</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改为</span></span><br><span class="line">server-id = 1</span><br><span class="line">log-bin=mysql-bin</span><br></pre></td></tr></table></figure>

<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="https://www.cnblogs.com/grey-wolf/p/10437811.html" target="_blank" rel="noopener">https://www.cnblogs.com/grey-wolf/p/10437811.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Binlog</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁分类</title>
    <url>/2020/01/11/2020/01/MySQL%E9%94%81%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="MySQL锁分类"><a href="#MySQL锁分类" class="headerlink" title="MySQL锁分类"></a>MySQL锁分类</h4><p>每次在听别人说锁的时候，是不是会有点儿晕？（一会儿排它锁，一会儿GAP锁…）因为你站在不同的角度来说，它的名字就会不同。<code>根据我们DB的引擎、隔离级别不同，导致的锁的情况也会不同</code>。</p>
<p>下面根据几种不同的类型对锁做一个划分：</p>
<p><strong>力度划分：</strong></p>
<ul>
<li><p><strong>表级锁：</strong>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定，开销小，加锁快，粒度大，锁冲突概率大，并发度低，适用于读多写少的情况。</p>
</li>
<li><p><strong>页级锁：</strong>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。</p>
</li>
<li><p><strong>行级锁：</strong>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。Innodb存储引擎，默认选项。</p>
</li>
</ul>
<p><strong>模式划分：</strong></p>
<ul>
<li><strong>记录锁：</strong>其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。</li>
<li><strong>GAP锁：</strong>只在RR和Serializable级别下生效.通过gap锁防止其他事务在一定区间插入、删除、修改，来避免幻行问题。</li>
<li><strong>Next-key锁：</strong>是 MySQL 的 InnoDB 存储引擎的一种锁实现，MVCC 不能解决幻读的问题，Next-Key Locks 就是为了解决这个问题而存在的。</li>
<li><strong>意向锁：</strong>意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。意向锁分为两种<strong>意向共享锁</strong>（intention shared lock, IS）与<strong>意向排他锁</strong>（intention exclusive lock, IX）。</li>
<li><strong><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-insert-intention-locks" target="_blank" rel="noopener">插入意向锁</a>：</strong>普通的Gap Lock 不允许 在 （上一条记录，本记录） 范围内插入数据，插入意向锁Gap Lock 允许 在 （上一条记录，本记录） 范围内插入数据。</li>
</ul>
<p><strong>机制划分：</strong></p>
<ul>
<li><strong>悲观锁：</strong>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。</li>
<li><strong>乐观锁：</strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。</li>
</ul>
<p><strong>兼容性划分：</strong></p>
<ul>
<li><strong>共享锁：</strong>多个事务只能读数据不能改数据。</li>
<li><strong>排它锁：</strong>又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li>
</ul>
<p><img src="http://static.cyblogs.com/WX20191219-140410@2x.png" alt="http://static.cyblogs.com/WX20191219-140410@2x.png"></p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>脏读（Dirty Read）</strong></th>
<th><strong>不可重复读（NonRepeatable Read）</strong></th>
<th><strong>幻读（Phantom Read）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（Read uncommitted）</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>已提交读（Read committed）</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读（Repeatable read）</td>
<td>不可能</td>
<td>不可能</td>
<td>可能</td>
</tr>
<tr>
<td>可串行化（Serializable ）</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<ul>
<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</li>
<li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。</li>
<li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。</li>
<li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</li>
</ul>
<p>如何查看一个数据库的隔离级别呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1、查看当前会话</span><br><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">这是我本地的mysql数据库，也就是说默认的级别就是：REPEATABLE-<span class="keyword">READ</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、查看系统当前隔离级别</span><br><span class="line">mysql&gt; <span class="keyword">select</span> @@global.tx_isolation;</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| REPEATABLE-READ       |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="查看数据库死锁日志"><a href="#查看数据库死锁日志" class="headerlink" title="查看数据库死锁日志"></a>查看数据库死锁日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; innodb_locks记录了所有innodb正在等待的锁，和被等待的锁</span><br><span class="line">select * from information_schema.innodb_locks;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; innodb_lock_waits记录了所有innodb锁的持有和等待关系</span><br><span class="line">select * from information_schema.innodb_lock_waits;</span><br><span class="line"></span><br><span class="line">show engine innodb status \G</span><br></pre></td></tr></table></figure>

<p>说明：通过<code>show engine innodb status</code> 查看的日志是最新一次记录死锁的日志，但是查看不到完整的事务的sql，通常显示当前正在等待锁的sql；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 表示事务4641对表&#96;sys&#96;.&#96;new_table&#96;持有了IX锁</span><br><span class="line">TABLE LOCK table &#96;sys&#96;.&#96;new_table&#96; trx id 4641 lock mode IX</span><br><span class="line">&#x2F;&#x2F; space id&#x3D;38，space id可以唯一确定一张表，表示了锁所在的表</span><br><span class="line">&#x2F;&#x2F; page no 3，表示锁所在的页号</span><br><span class="line">&#x2F;&#x2F; index PRIMARY 表示锁位于名为PRIMARY的索引上</span><br><span class="line">&#x2F;&#x2F; lock_mode X locks rec but not gap 表示x record lock</span><br><span class="line">&#x2F;&#x2F; 下方的数据表示了被锁定的索引数据，最上面一行代表索引列的十六进制值，在这里表示的就是id&#x3D;3的数据</span><br><span class="line">RECORD LOCKS space id 38 page no 3 n bits 80 index PRIMARY of table &#96;sys&#96;.&#96;new_table&#96; trx id 4641 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 8; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000003; asc     ;;</span><br><span class="line"> 1: len 6; hex 0000000011e9; asc       ;;</span><br><span class="line"> 2: len 7; hex a70000011b0128; asc       (;;</span><br><span class="line"> 3: len 4; hex 8000012c; asc    ,;;</span><br><span class="line"> 4: len 1; hex 63; asc c;;</span><br><span class="line"> 5: len 4; hex 80000006; asc     ;;</span><br><span class="line"> 6: len 3; hex 636363; asc ccc;;</span><br><span class="line"> 7: len 2; hex 3333; asc 33;;</span><br><span class="line">&#x2F;&#x2F; lock_mode X表示的是next-key lock，即当前记录的record lock+前一个间隙的gap lock</span><br><span class="line">&#x2F;&#x2F; 这个锁在名为idx1的索引上，对应的索引列的值为100（hex 64对应十进制），对应聚簇索引的值为1</span><br><span class="line">RECORD LOCKS space id 38 page no 5 n bits 80 index idx1 of table &#96;sys&#96;.&#96;new_table&#96; trx id 4643 lock_mode X</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 00000064; asc    d;;</span><br><span class="line"> 1: len 4; hex 00000001; asc     ;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; lock_mode X locks gap before rec表示的是对应索引记录前一个间隙的gap lock</span><br><span class="line">RECORD LOCKS space id 38 page no 5 n bits 80 index idx1 of table &#96;sys&#96;.&#96;new_table&#96; trx id 4643 lock_mode X locks gap before rec</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 800000c8; asc     ;;</span><br><span class="line"> 1: len 4; hex 00000002; asc     ;;</span><br></pre></td></tr></table></figure>

<p><strong>死锁日志解析：</strong></p>
<ul>
<li><p>lock_mode X locks rec but not gap：模式排它锁，类型行锁；</p>
</li>
<li><p>lock_mode X locks gap before rec ：模式排它锁，类型gap锁；</p>
</li>
<li><p>lock_mode X locks gap before rec insert intention：模式排它锁，类型插入意向锁；</p>
</li>
<li><p>lock_mode X：Next-key锁；</p>
</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><p>索引记录的间隙上用来避免幻读。</p>
</li>
<li><p>Select（Serializable隔离级别除外）不会加锁，而是执行快照读。</p>
</li>
<li><p>写操作都会加锁，具体加锁方式取决于隔离级别、索引命中情况以及修改的索引情况。</p>
</li>
<li><p>为了减少锁的范围，避免死锁的发生，应该尽量让查询条件命中索引，而且命中的越精确加锁越少。同时如果能接受RC级别对一致性的破坏，可以将隔离级别调整成RC。</p>
</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://juejin.im/post/5b82e0196fb9a019f47d1823" target="_blank" rel="noopener">https://juejin.im/post/5b82e0196fb9a019f47d1823</a></li>
<li><a href="https://juejin.im/post/5cef617e518825095b331caf" target="_blank" rel="noopener">https://juejin.im/post/5cef617e518825095b331caf</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/31875702" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31875702</a></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></li>
<li><a href="https://blog.csdn.net/bigtree_3721/article/details/73731377" target="_blank" rel="noopener">https://blog.csdn.net/bigtree_3721/article/details/73731377</a></li>
<li><a href="https://juejin.im/post/5cd8283ae51d453a907b4b29" target="_blank" rel="noopener">https://juejin.im/post/5cd8283ae51d453a907b4b29</a></li>
<li><a href="https://segmentfault.com/a/1190000019745324" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019745324</a></li>
<li><a href="http://www.fanyilun.me/2017/04/20/MySQL加锁分析/" target="_blank" rel="noopener">http://www.fanyilun.me/2017/04/20/MySQL加锁分析</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从同步-原理&amp;实践篇</title>
    <url>/2020/01/13/2020/01/MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5-%E5%8E%9F%E7%90%86&amp;%E5%AE%9E%E8%B7%B5%E7%AF%87/</url>
    <content><![CDATA[<h4 id="什么是mysql的主从复制？"><a href="#什么是mysql的主从复制？" class="headerlink" title="什么是mysql的主从复制？"></a>什么是mysql的主从复制？</h4><p>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>
<h4 id="Mysql复制原理"><a href="#Mysql复制原理" class="headerlink" title="Mysql复制原理"></a>Mysql复制原理</h4><p>原理：</p>
<p><img src="http://static.cyblogs.com/MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.jpg" alt="http://static.cyblogs.com/MySQL主从同步.jpg"></p>
<p>（1）<code>Master</code>服务器将数据的改变记录二进制<code>Binlog</code>日志，当<code>Master</code>上的数据发生改变时，则将其改变写入二进制日志中；</p>
<p>（2）<code>Slave</code>服务器会在一定时间间隔内对<code>Master</code>二进制日志进行探测其是否发生改变，如果发生改变，则开始一个<code>I/OThread</code>请求<code>Master</code>二进制事件</p>
<p>（3）同时主节点为每个<code>I/O</code>线程启动一个<code>Dump</code>线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后<code>I/OThread</code>和<code>SQLThread</code>将进入睡眠状态，等待下一次被唤醒。</p>
<h4 id="Undo-log与Redo-log原理分析"><a href="#Undo-log与Redo-log原理分析" class="headerlink" title="Undo log与Redo log原理分析"></a>Undo log与Redo log原理分析</h4><h5 id="Undo-log原理"><a href="#Undo-log原理" class="headerlink" title="Undo log原理"></a>Undo log原理</h5><p><code>Undo log</code>是把所有没有<code>COMMIT</code>的事务回滚到事务开始前的状态，系统崩溃时，可能有些事务还没有<code>COMMIT</code>，在系统恢复时，这些没有<code>COMMIT</code>的事务就需要借助<code>Undo log</code>来进行回滚。</p>
<p>使用<code>Undo log</code>时要求：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1、记录修改日志时（Redo log），(T，x，v）中v为x修改前的值，这样才能借助这条日志来回滚；</span><br><span class="line">2、事务提交后，必须在事务的所有修改（包括记录的修改日志）都持久化后才能写<span class="keyword">COMMIT</span> T日志；这样才能保证，宕机恢复时，已经<span class="keyword">COMMIT</span>的事务的所有修改都已经持久化，不需要回滚。</span><br></pre></td></tr></table></figure>

<p>使用<code>Undo log</code>时事务执行顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1、记录<span class="keyword">START</span> T </span><br><span class="line"><span class="number">2</span>、记录需要修改的记录的旧值（要求持久化）</span><br><span class="line"><span class="number">3</span>、根据事务的需要更新数据库（要求持久化）</span><br><span class="line"><span class="number">4</span>、记录<span class="keyword">COMMIT</span> T</span><br></pre></td></tr></table></figure>

<p>使用<code>Undo log</code>进行宕机回滚</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1、扫描日志，找出所有已经<span class="keyword">START</span>,还没有<span class="keyword">COMMIT</span>的事务。</span><br><span class="line"><span class="number">2</span>、针对所有未<span class="keyword">COMMIT</span>的日志，根据<span class="keyword">Redo</span> <span class="keyword">log</span>来进行回滚。</span><br></pre></td></tr></table></figure>

<p>如果数据库访问很多，日志量也会很大，宕机恢复时，回滚的工作量也就很大，为了加快回滚，可以通过<code>Checkpoint</code>机制来加速回滚。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">从后往前，扫描Undo log</span><br><span class="line">1、如果先遇到checkpoint_start, 则将checkpoint_start之后的所有未提交的事务进行回滚；</span><br><span class="line">2、如果先遇到checkpoint_end, 则将前一个checkpoint_start之后所有未提交的事务进行回滚；（在checkpoint的过程中，可能有很多新的事务<span class="keyword">START</span>或者<span class="keyword">COMMIT</span>)。</span><br></pre></td></tr></table></figure>

<p>使用<code>Undo log</code>，在写<code>COMMIT</code>日志时，要求<code>Redo log</code>以及事务的所有修改都必须已经持久化，这种做法通常很影响性能。</p>
<h5 id="Redo-log原理"><a href="#Redo-log原理" class="headerlink" title="Redo log原理"></a>Redo log原理</h5><p><code>Redo log</code>是指在回放日志的时候把已经<code>COMMIT</code>的事务重做一遍，对于没有<code>COMMIT</code>的事务按照<code>abort</code>处理，不进行任何操作。</p>
<p>使用<code>Redo log</code>时，要求：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1、记录Redo log时，(T,x，v）中的v必须是x修改后的值，否则不能通过Redo log来恢复已经<span class="keyword">COMMIT</span>的事务。</span><br><span class="line"><span class="number">2</span>、写<span class="keyword">COMMIT</span> T日志之前，事务的修改不能进行持久化，否则恢复时，对于未<span class="keyword">COMMIT</span>的操作，可能有数据已经修改，但重放<span class="keyword">Redo</span> <span class="keyword">log</span>不会对该事务做任何处理，从而不能保证事务的原子性。</span><br></pre></td></tr></table></figure>

<p>使用<code>Redo log</code>时事务执行顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1、记录<span class="keyword">START</span> T</span><br><span class="line"><span class="number">2</span>、记录事务需要修改记录的新值（要求持久化）</span><br><span class="line"><span class="number">3</span>、记录<span class="keyword">COMMIT</span> T（要求持久化）</span><br><span class="line"><span class="number">4</span>、将事务相关的修改写入数据库</span><br></pre></td></tr></table></figure>

<p>使用<code>Redo log</code>重做事务</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">1、扫描日志，找到所有已经<span class="keyword">COMMIT</span>的事务；</span><br><span class="line"><span class="number">2</span>、对于已经<span class="keyword">COMMIT</span>的事务，根据<span class="keyword">Redo</span> <span class="keyword">log</span>重做事务；</span><br></pre></td></tr></table></figure>

<p>根据<code>Checkpoint</code>来加速恢复</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">从后往前，扫描Redo log</span><br><span class="line">1，如果先遇到checkpoint_start, 则把T1~Tn以及checkpoint_start之后的所有已经<span class="keyword">COMMIT</span>的事务进行重做；</span><br><span class="line"><span class="number">2.</span> 如果先遇到checkpoint_end, 则T1~Tn以及前一个checkpoint_start之后所有已经<span class="keyword">COMMIT</span>的事务进行重做；</span><br></pre></td></tr></table></figure>

<p>与<code>Undo log</code>类似，在使用时对持久化以及事务操作顺序的要求都比较高，可以将两者结合起来使用，在恢复时，对于已经<code>COMMIT</code>的事务使用<code>Redo log</code>进行重做，对于没有<code>COMMIT</code>的事务，使用<code>Undo log</code>进行回滚。<code>Redo/Undo log</code>结合起来使用时，要求同时记录操作修改前和修改后的值，如（T，x，v，w），v为x修改前的值，w为x修改后的值，具体操作顺序为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 记录START T</span><br><span class="line">2. 记录修改日志（T，x，v，w）（要求持久化，其中v用于undo，w用于redo）</span><br><span class="line">3. 更新数据库</span><br><span class="line">4. 记录 COMMIT T</span><br></pre></td></tr></table></figure>

<h4 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h4><p>上一篇已经对于<code>Binlog</code>设置做了一些初步的实践：<a href="http://www.cyblogs.com/mysql-binlogshe-zhi/">http://www.cyblogs.com/mysql-binlogshe-zhi/</a>，还是在本地利用<code>Docker</code>的方式启动了2个容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~  docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">662e8531eb70        centos:7            &quot;&#x2F;bin&#x2F;bash&quot;         2 hours ago         Up 2 hours          0.0.0.0:33062-&gt;3306&#x2F;tcp   docker-mysql-slave</span><br><span class="line">c738746e9623        centos:7            &quot;&#x2F;bin&#x2F;bash&quot;         4 hours ago         Up 4 hours          0.0.0.0:33061-&gt;3306&#x2F;tcp   docker-mysql-master</span><br></pre></td></tr></table></figure>

<p>一个是<code>docker-mysql-master</code>作为主节点，<code>docker-mysql-slave</code>作为从节点，最后实现一个主从同步的功能。</p>
<h4 id="Master节点"><a href="#Master节点" class="headerlink" title="Master节点"></a>Master节点</h4><h5 id="设置slave-account账户"><a href="#设置slave-account账户" class="headerlink" title="设置slave_account账户"></a>设置slave_account账户</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root@c738746e9623 bin]<span class="comment"># ./mysql -u root -p</span></span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands <span class="keyword">end</span> <span class="keyword">with</span> ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.6.45-log MySQL Community Server (GPL)</span><br><span class="line">mysql&gt; grant replication slave on *.* to 'slave_account'@'%' identified by '123456';</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<h5 id="Master节点的my-cnf"><a href="#Master节点的my-cnf" class="headerlink" title="Master节点的my.cnf"></a>Master节点的my.cnf</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root@c738746e9623 bin]<span class="comment"># cat /etc/my.cnf</span></span><br><span class="line">[client]</span><br><span class="line">default-character-<span class="keyword">set</span>=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"><span class="keyword">default</span>-<span class="built_in">character</span>-<span class="keyword">set</span>=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="keyword">user</span>=mysql</span><br><span class="line"><span class="keyword">default</span>-<span class="keyword">storage</span>-<span class="keyword">engine</span>=<span class="keyword">INNODB</span></span><br><span class="line"><span class="built_in">character</span>-<span class="keyword">set</span>-<span class="keyword">server</span>=utf8</span><br><span class="line">basedir = /usr/<span class="keyword">local</span>/mysql</span><br><span class="line">datadir = /usr/<span class="keyword">local</span>/mysql/<span class="keyword">data</span></span><br><span class="line">port = <span class="number">3306</span></span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="keyword">server</span>-<span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">log</span>-<span class="keyword">bin</span>=mysql-<span class="keyword">bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">binlog</span>-<span class="keyword">ignore</span>-db = mysql</span><br><span class="line"><span class="keyword">binlog</span>-<span class="keyword">ignore</span>-db = information_schema</span><br><span class="line"></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure>

<h5 id="查看master节点状态"><a href="#查看master节点状态" class="headerlink" title="查看master节点状态"></a>查看master节点状态</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+<span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB         | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line">| mysql-bin.000002 |      120 |              | mysql,information_schema |                   |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="Slave节点"><a href="#Slave节点" class="headerlink" title="Slave节点"></a>Slave节点</h4><h5 id="Slave节点my-cnf"><a href="#Slave节点my-cnf" class="headerlink" title="Slave节点my.cnf"></a>Slave节点my.cnf</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@662e8531eb70 mysql]#cat /etc/my.cnf</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8</span><br><span class="line">basedir = /usr/local/mysql</span><br><span class="line">datadir = /usr/local/mysql/data</span><br><span class="line">port = 3306</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line">server-id = 2</span><br><span class="line"></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure>

<h5 id="配置与主节点同步的配置"><a href="#配置与主节点同步的配置" class="headerlink" title="配置与主节点同步的配置"></a>配置与主节点同步的配置</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; change master to master_host='172.17.0.2',master_user='slave_account',master_password='123456',master_log_file='mysql-bin.000002',master_log_pos=120;</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.06 sec)</span><br></pre></td></tr></table></figure>

<h5 id="启动同步"><a href="#启动同步" class="headerlink" title="启动同步"></a>启动同步</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<h5 id="查看一个主从同步的状态"><a href="#查看一个主从同步的状态" class="headerlink" title="查看一个主从同步的状态"></a>查看一个主从同步的状态</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 172.17.0.2</span><br><span class="line">                  Master_User: slave_account</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000002</span><br><span class="line">          Read_Master_Log_Pos: 120</span><br><span class="line">               Relay_Log_File: 662e8531eb70-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 283</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000002</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">           Replicate_Do_Table:</span><br><span class="line">       Replicate_Ignore_Table:</span><br><span class="line">      Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error:</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 120</span><br><span class="line">              Relay_Log_Space: 463</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File:</span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File:</span><br><span class="line">           Master_SSL_CA_Path:</span><br><span class="line">              Master_SSL_Cert:</span><br><span class="line">            Master_SSL_Cipher:</span><br><span class="line">               Master_SSL_Key:</span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error:</span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error:</span><br><span class="line">  Replicate_Ignore_Server_Ids:</span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: 7323857e-254b-11ea-9b62-0242ac110002</span><br><span class="line">             Master_Info_File: &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;master.info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I&#x2F;O thread to update it</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind:</span><br><span class="line">      Last_IO_Error_Timestamp:</span><br><span class="line">     Last_SQL_Error_Timestamp:</span><br><span class="line">               Master_SSL_Crl:</span><br><span class="line">           Master_SSL_Crlpath:</span><br><span class="line">           Retrieved_Gtid_Set:</span><br><span class="line">            Executed_Gtid_Set:</span><br><span class="line">                Auto_Position: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="Master节点写数据"><a href="#Master节点写数据" class="headerlink" title="Master节点写数据"></a>Master节点写数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE TABLE `person_01` (</span></span><br><span class="line">    -&gt;   `id` int(11) DEFAULT NULL,</span><br><span class="line">    -&gt;   `first_name` varchar(20) DEFAULT NULL,</span><br><span class="line">    -&gt;   `age` int(11) DEFAULT NULL,</span><br><span class="line">    -&gt;   `gender` char(1) DEFAULT NULL</span><br><span class="line">    -&gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">    -&gt; ;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show tables;</span></span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| person         |</span><br><span class="line">| person_01      |</span><br><span class="line">+----------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO test.person_01 (id, first_name, age, gender) VALUES (1, <span class="string">'Bob'</span>, 25, <span class="string">'M'</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO test.person_01 (id, first_name, age, gender) VALUES (2, <span class="string">'Jane'</span>, 20, <span class="string">'F'</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO test.person_01 (id, first_name, age, gender) VALUES (3, <span class="string">'Jack'</span>, 30, <span class="string">'M'</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO test.person_01 (id, first_name, age, gender) VALUES (4, <span class="string">'Bill'</span>, 32, <span class="string">'M'</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO test.person_01 (id, first_name, age, gender) VALUES (5, <span class="string">'Nick'</span>, 22, <span class="string">'M'</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO test.person_01 (id, first_name, age, gender) VALUES (6, <span class="string">'Kathy'</span>, 18, <span class="string">'F'</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO test.person_01 (id, first_name, age, gender) VALUES (7, <span class="string">'Steve'</span>, 36, <span class="string">'M'</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO test.person_01 (id, first_name, age, gender) VALUES (8, <span class="string">'Anne'</span>, 25, <span class="string">'F'</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from person_01;</span></span><br><span class="line">+------+------------+------+--------+</span><br><span class="line">| id   | first_name | age  | gender |</span><br><span class="line">+------+------------+------+--------+</span><br><span class="line">|    1 | Bob        |   25 | M      |</span><br><span class="line">|    2 | Jane       |   20 | F      |</span><br><span class="line">|    3 | Jack       |   30 | M      |</span><br><span class="line">|    4 | Bill       |   32 | M      |</span><br><span class="line">|    5 | Nick       |   22 | M      |</span><br><span class="line">|    6 | Kathy      |   18 | F      |</span><br><span class="line">|    7 | Steve      |   36 | M      |</span><br><span class="line">|    8 | Anne       |   25 | F      |</span><br><span class="line">+------+------------+------+--------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line">Bye</span><br><span class="line">[root@c738746e9623 bin]# 主节点</span><br></pre></td></tr></table></figure>

<h4 id="Slave节点查数据"><a href="#Slave节点查数据" class="headerlink" title="Slave节点查数据"></a>Slave节点查数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show tables;</span></span><br><span class="line">+----------------+</span><br><span class="line">| Tables_in_test |</span><br><span class="line">+----------------+</span><br><span class="line">| person_01      |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select * from person_01;</span></span><br><span class="line">+------+------------+------+--------+</span><br><span class="line">| id   | first_name | age  | gender |</span><br><span class="line">+------+------------+------+--------+</span><br><span class="line">|    1 | Bob        |   25 | M      |</span><br><span class="line">|    2 | Jane       |   20 | F      |</span><br><span class="line">|    3 | Jack       |   30 | M      |</span><br><span class="line">|    4 | Bill       |   32 | M      |</span><br><span class="line">|    5 | Nick       |   22 | M      |</span><br><span class="line">|    6 | Kathy      |   18 | F      |</span><br><span class="line">|    7 | Steve      |   36 | M      |</span><br><span class="line">|    8 | Anne       |   25 | F      |</span><br><span class="line">+------+------------+------+--------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line">Bye</span><br><span class="line">[root@662e8531eb70 mysql]# 从节点</span><br></pre></td></tr></table></figure>

<p>这样子就做好了最简单的主从同步。主从同步只是最基础的高可用架构。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/xuanxuan_good/article/details/54427154" target="_blank" rel="noopener">https://blog.csdn.net/xuanxuan_good/article/details/54427154</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/96212530" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96212530</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Sleuth服务链路追踪</title>
    <url>/2020/01/14/2020/01/Spring%20Cloud%20Sleuth%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h4 id="Zipkin服务追踪原理"><a href="#Zipkin服务追踪原理" class="headerlink" title="Zipkin服务追踪原理"></a>Zipkin服务追踪原理</h4><p>创造一些追踪标识符（tracingId，spanId，parentId），最终将一个request的流程树构建出来，各业务系统在彼此调用时，将特定的跟踪消息传递至zipkin,zipkin在收集到跟踪信息后将其聚合处理、存储、展示等，用户可通过web UI方便获得网络延迟、调用链路、系统依赖等等。</p>
<p><img src="http://static.cyblogs.com/140563-20170613131120462-1419921670.png" alt="http://static.cyblogs.com/140563-20170613131120462-1419921670.png"></p>
<p>transport作用：收集被trace的services的spans，并将它们转化为zipkin common Span，之后把这些Spans传递的存储层</p>
<p>collector会对一个到来的被trace的数据（span）进行验证、存储并设置索引(Cassandra/ES-search/Memory)</p>
<h5 id="Zipkin基本概念-amp-核心数据结构"><a href="#Zipkin基本概念-amp-核心数据结构" class="headerlink" title="Zipkin基本概念&amp;核心数据结构"></a>Zipkin基本概念&amp;核心数据结构</h5><ul>
<li>Annotation（用途：用于定位一个request的开始和结束，cs/sr/ss/cr含有额外的信息，比如说时间点）：<ul>
<li>cs：Client Start,表示客户端发起请求一个span的开始</li>
<li>sr：Server Receive,表示服务端收到请求</li>
<li>ss：Server Send,表示服务端完成处理，并将结果发送给客户端</li>
<li>cr：Client Received,表示客户端获取到服务端返回信息一个span的结束，当这个annotation被记录了，这个RPC也被认为完成。客户端调用时间=cr-cs，服务端处理时间=sr-ss。</li>
</ul>
</li>
<li>Span：一个请求（包含一组Annotation和BinaryAnnotation）；它是基本工作单元，一次链路调用(可以是RPC，DB等没有特定的限制)创建一个span，通过一个64位ID标识它。<ul>
<li>span通过还有其他的数据，例如描述信息，时间戳，key-value对的(Annotation)tag信息，parent-id等,其中parent-id可以表示span调用链路来源，通俗的理解<strong>span就是一次请求信息</strong></li>
</ul>
</li>
<li>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识通过traceId（全局的跟踪ID，是跟踪的入口点，根据需求来决定在哪生成traceId）、spanId（请求跟踪ID，比如一次rpc等）和parentId（上一次            请求跟踪ID，用来将前后的请求串联起来），被收集到的span会汇聚成一个tree，从而提供出一个request的整体流程。</li>
</ul>
<p>整个描述：在一次Trace中，每个服务的<strong>每一次调用</strong>，就是一个<strong>基本工作单元</strong>，就像上图中的每一个树节点，称之为<strong>span</strong>。每一个span都有一个<strong>id作为唯一标识</strong>，同样每一次Trace都会生成一个<strong>traceId在span中作为追踪标识</strong>，另外再通过一个<strong>parentId标明本次调用的发起者</strong>（就是发起者的span-id）。当span有了上面三个标识后，就可以很清晰的将多个span进行梳理串联，最终归纳出一条完整的跟踪链路。</p>
<h4 id="代码实践操作"><a href="#代码实践操作" class="headerlink" title="代码实践操作"></a>代码实践操作</h4><h5 id="无存储方式，只需要控制台"><a href="#无存储方式，只需要控制台" class="headerlink" title="无存储方式，只需要控制台"></a>无存储方式，只需要控制台</h5><p>本文的源代码在：<a href="mailto:git@github.com">git@github.com</a>:chengcheng222e/springcloud-learn.git 欢迎大家去fork。</p>
<p>/Users/chenyuan/Workspaces/Github/springcloud-learn/eureka-server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-server</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8001</span></span><br><span class="line"><span class="meta">eureka.instance.hostname</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>/Users/chenyuan/Workspaces/Github/springcloud-learn/zipkin-server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.allei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"><span class="keyword">import</span> zipkin.server.internal.EnableZipkinServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableZipkinServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipkinApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ZipkinApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">zipkin-server</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:8001/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">zipkin.instance.hostname</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.zipkin.base-url</span>=<span class="string">http://$&#123;zipkin.instance.hostname&#125;:$&#123;server.port&#125;/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.sleuth.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">spring.sleuth.sampler.probability</span>=<span class="string">1.0</span></span><br><span class="line"><span class="meta">spring.sleuth.hystrix.strategy.enabled</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>/Users/chenyuan/Workspaces/Github/springcloud-learn/trace-a</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.allei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceAApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/trace-a"</span>, method = RequestMethod.GET)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">trace</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		log.info(<span class="string">"call trace-a-----&gt;"</span>);</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1l</span>);</span><br><span class="line">		<span class="keyword">return</span> restTemplate().getForEntity(<span class="string">"http://trace-b/trace-b"</span>, String<span class="class">.<span class="keyword">class</span>).<span class="title">getBody</span>()</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(TraceAApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">trace-a</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">10001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:8001/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.zipkin.base-url</span>=<span class="string">http://localhost:10000</span></span><br><span class="line"><span class="meta">spring.sleuth.sampler.percentage</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># log trace detail</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web.servlet.DispatcherServlet</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>/Users/chenyuan/Workspaces/Github/springcloud-learn/trace-b</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.allei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.math.RandomUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceBApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/trace-b"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">trace</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"call trace-b-----&gt;"</span>);</span><br><span class="line">		TimeUnit.SECONDS.sleep(RandomUtils.nextInt(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> restTemplate().getForEntity(<span class="string">"http://trace-c/trace-c"</span>, String<span class="class">.<span class="keyword">class</span>).<span class="title">getBody</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TraceBApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">trace-b</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">10002</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:8001/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.zipkin.base-url</span>=<span class="string">http://localhost:10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.sleuth.sampler.percentage</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log trace detail</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web.servlet.DispatcherServlet</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>


<p>/Users/chenyuan/Workspaces/Github/springcloud-learn/trace-c</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.allei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.math.RandomUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceCApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/trace-c"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">trace</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"call trace-c-----&gt;"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(RandomUtils.nextInt(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello trace"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TraceCApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">trace-c</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">10003</span></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:8001/eureka/</span></span><br><span class="line"><span class="meta">spring.zipkin.base-url</span>=<span class="string">http://localhost:10000</span></span><br><span class="line"><span class="meta">spring.sleuth.sampler.percentage</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># log trace detail</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web.servlet.DispatcherServlet</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>全部把服务启动起来，然后我们去注册中心看一下启动的服务情况。</p>
<p><a href="http://localhost:8001/eureka/" target="_blank" rel="noopener">http://localhost:8001/eureka/</a></p>
<p><img src="http://static.cyblogs.com/WX20200110-120329@2x.png" alt="http://static.cyblogs.com/WX20200110-120329@2x.png"></p>
<p>我们从trace-a服务触发一个服务：</p>
<p><img src="http://static.cyblogs.com/WX20200110-120512@2x.png" alt="http://static.cyblogs.com/WX20200110-120512@2x.png"></p>
<p>查阅一下日志</p>
<p><code>/Users/chenyuan/Workspaces/Github/springcloud-learn/trace-a</code> 日志</p>
<p><img src="http://static.cyblogs.com/WX20200110-120630.png" alt="http://static.cyblogs.com/WX20200110-120630.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2020-01-10 12:04:51.226 DEBUG [trace-a,c8df468b969a0917,c8df468b969a0917,false] 2626 --- [io-10001-exec-1] o.s.web.servlet.DispatcherServlet        : GET "/trace-a", parameters=&#123;&#125;</span><br><span class="line">2020-01-10 12:04:51.240  INFO [trace-a,c8df468b969a0917,c8df468b969a0917,false] 2626 --- [io-10001-exec-1] com.allei.TraceAApplication              : call trace-a-----&gt;</span><br><span class="line">2020-01-10 12:04:52.528  INFO [trace-a,c8df468b969a0917,a4c77f10471bb209,false] 2626 --- [io-10001-exec-1] c.netflix.config.ChainedDynamicProperty  : Flipping property: trace-b.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</span><br><span class="line">2020-01-10 12:04:52.558  INFO [trace-a,c8df468b969a0917,a4c77f10471bb209,false] 2626 --- [io-10001-exec-1] c.n.u.concurrent.ShutdownEnabledTimer    : Shutdown hook installed for: NFLoadBalancer-PingTimer-trace-b</span><br><span class="line">2020-01-10 12:04:52.558  INFO [trace-a,c8df468b969a0917,a4c77f10471bb209,false] 2626 --- [io-10001-exec-1] c.netflix.loadbalancer.BaseLoadBalancer  : Client: trace-b instantiated a LoadBalancer: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=trace-b,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:null</span><br><span class="line">2020-01-10 12:04:52.564  INFO [trace-a,c8df468b969a0917,a4c77f10471bb209,false] 2626 --- [io-10001-exec-1] c.n.l.DynamicServerListLoadBalancer      : Using serverListUpdater PollingServerListUpdater</span><br><span class="line">2020-01-10 12:04:52.588  INFO [trace-a,c8df468b969a0917,a4c77f10471bb209,false] 2626 --- [io-10001-exec-1] c.netflix.config.ChainedDynamicProperty  : Flipping property: trace-b.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</span><br><span class="line">2020-01-10 12:04:52.590  INFO [trace-a,c8df468b969a0917,a4c77f10471bb209,false] 2626 --- [io-10001-exec-1] c.n.l.DynamicServerListLoadBalancer      : DynamicServerListLoadBalancer for client trace-b initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=trace-b,current list of Servers=[172.18.232.69:10002],Load balancer stats=Zone stats: &#123;defaultzone=[Zone:defaultzone;	Instance count:1;	Active connections count: 0;	Circuit breaker tripped count: 0;	Active connections per server: 0.0;]</span><br><span class="line">&#125;,Server stats: [[Server:172.18.232.69:10002;	Zone:defaultZone;	Total Requests:0;	Successive connection failure:0;	Total blackout seconds:0;	Last connection made:Thu Jan 01 08:00:00 CST 1970;	First connection made: Thu Jan 01 08:00:00 CST 1970;	Active Connections:0;	total failure count in last (1000) msecs:0;	average resp time:0.0;	90 percentile resp time:0.0;	95 percentile resp time:0.0;	min resp time:0.0;	max resp time:0.0;	stddev resp time:0.0]</span><br><span class="line">]&#125;ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@128e37fa</span><br><span class="line">2020-01-10 12:04:53.573  INFO [trace-a,,,] 2626 --- [erListUpdater-0] c.netflix.config.ChainedDynamicProperty  : Flipping property: trace-b.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</span><br><span class="line">2020-01-10 12:04:54.397 DEBUG [trace-a,c8df468b969a0917,c8df468b969a0917,false] 2626 --- [io-10001-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK</span><br><span class="line">2020-01-10 12:04:54.731 DEBUG [trace-a,4eb7430157ffd40f,4eb7430157ffd40f,false] 2626 --- [io-10001-exec-2] o.s.web.servlet.DispatcherServlet        : GET "/favicon.ico", parameters=&#123;&#125;</span><br><span class="line">2020-01-10 12:04:54.749 DEBUG [trace-a,4eb7430157ffd40f,4eb7430157ffd40f,false] 2626 --- [io-10001-exec-2] o.s.web.servlet.DispatcherServlet        : Completed 200 OK</span><br><span class="line">2020-01-10 12:06:16.665  INFO [trace-a,,,] 2626 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2020-01-10 12:11:16.661  INFO [trace-a,,,] 2626 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br></pre></td></tr></table></figure>

<p><code>/Users/chenyuan/Workspaces/Github/springcloud-learn/trace-b</code> 日志</p>
<p><img src="http://static.cyblogs.com/WX20200110-120711.png" alt="http://static.cyblogs.com/WX20200110-120711.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2020-01-10 12:04:52.733 DEBUG [trace-b,c8df468b969a0917,a4c77f10471bb209,false] 2862 --- [io-10002-exec-1] o.s.web.servlet.DispatcherServlet        : GET "/trace-b", parameters=&#123;&#125;</span><br><span class="line">2020-01-10 12:04:52.752  INFO [trace-b,c8df468b969a0917,a4c77f10471bb209,false] 2862 --- [io-10002-exec-1] com.allei.TraceBApplication              : call trace-b-----&gt;</span><br><span class="line">2020-01-10 12:04:53.062  INFO [trace-b,c8df468b969a0917,e9651abffa9bf1d2,false] 2862 --- [io-10002-exec-1] c.netflix.config.ChainedDynamicProperty  : Flipping property: trace-c.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</span><br><span class="line">2020-01-10 12:04:53.108  INFO [trace-b,c8df468b969a0917,e9651abffa9bf1d2,false] 2862 --- [io-10002-exec-1] c.n.u.concurrent.ShutdownEnabledTimer    : Shutdown hook installed for: NFLoadBalancer-PingTimer-trace-c</span><br><span class="line">2020-01-10 12:04:53.108  INFO [trace-b,c8df468b969a0917,e9651abffa9bf1d2,false] 2862 --- [io-10002-exec-1] c.netflix.loadbalancer.BaseLoadBalancer  : Client: trace-c instantiated a LoadBalancer: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=trace-c,current list of Servers=[],Load balancer stats=Zone stats: &#123;&#125;,Server stats: []&#125;ServerList:null</span><br><span class="line">2020-01-10 12:04:53.116  INFO [trace-b,c8df468b969a0917,e9651abffa9bf1d2,false] 2862 --- [io-10002-exec-1] c.n.l.DynamicServerListLoadBalancer      : Using serverListUpdater PollingServerListUpdater</span><br><span class="line">2020-01-10 12:04:53.146  INFO [trace-b,c8df468b969a0917,e9651abffa9bf1d2,false] 2862 --- [io-10002-exec-1] c.netflix.config.ChainedDynamicProperty  : Flipping property: trace-c.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</span><br><span class="line">2020-01-10 12:04:53.148  INFO [trace-b,c8df468b969a0917,e9651abffa9bf1d2,false] 2862 --- [io-10002-exec-1] c.n.l.DynamicServerListLoadBalancer      : DynamicServerListLoadBalancer for client trace-c initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name=trace-c,current list of Servers=[172.18.232.69:10003],Load balancer stats=Zone stats: &#123;defaultzone=[Zone:defaultzone;	Instance count:1;	Active connections count: 0;	Circuit breaker tripped count: 0;	Active connections per server: 0.0;]</span><br><span class="line">&#125;,Server stats: [[Server:172.18.232.69:10003;	Zone:defaultZone;	Total Requests:0;	Successive connection failure:0;	Total blackout seconds:0;	Last connection made:Thu Jan 01 08:00:00 CST 1970;	First connection made: Thu Jan 01 08:00:00 CST 1970;	Active Connections:0;	total failure count in last (1000) msecs:0;	average resp time:0.0;	90 percentile resp time:0.0;	95 percentile resp time:0.0;	min resp time:0.0;	max resp time:0.0;	stddev resp time:0.0]</span><br><span class="line">]&#125;ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@4e144ec0</span><br><span class="line">2020-01-10 12:04:54.124  INFO [trace-b,,,] 2862 --- [erListUpdater-0] c.netflix.config.ChainedDynamicProperty  : Flipping property: trace-c.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</span><br><span class="line">2020-01-10 12:04:54.374 DEBUG [trace-b,c8df468b969a0917,a4c77f10471bb209,false] 2862 --- [io-10002-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK</span><br><span class="line">2020-01-10 12:06:57.545  INFO [trace-b,,,] 2862 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2020-01-10 12:11:57.541  INFO [trace-b,,,] 2862 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br></pre></td></tr></table></figure>

<p><code>/Users/chenyuan/Workspaces/Github/springcloud-learn/trace-c</code> 日志 </p>
<p><img src="http://static.cyblogs.com/WX20200110-120747.png" alt="http://static.cyblogs.com/WX20200110-120747.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2020-01-10 12:04:53.306 DEBUG [trace-c,c8df468b969a0917,e9651abffa9bf1d2,false] 3211 --- [io-10003-exec-1] o.s.web.servlet.DispatcherServlet        : GET "/trace-c", parameters=&#123;&#125;</span><br><span class="line">2020-01-10 12:04:53.320  INFO [trace-c,c8df468b969a0917,e9651abffa9bf1d2,false] 3211 --- [io-10003-exec-1] com.allei.TraceCApplication              : call trace-c-----&gt;</span><br><span class="line">2020-01-10 12:04:54.346 DEBUG [trace-c,c8df468b969a0917,e9651abffa9bf1d2,false] 3211 --- [io-10003-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK</span><br><span class="line">2020-01-10 12:08:09.576  INFO [trace-c,,,] 3211 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2020-01-10 12:13:09.572  INFO [trace-c,,,] 3211 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br></pre></td></tr></table></figure>


<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.cnblogs.com/mxmbk/p/9820936.html" target="_blank" rel="noopener">https://www.cnblogs.com/mxmbk/p/9820936.html</a></li>
<li><a href="https://juejin.im/post/5c3d4df0f265da61307517ad" target="_blank" rel="noopener">https://juejin.im/post/5c3d4df0f265da61307517ad</a></li>
<li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">https://github.com/openzipkin/zipkin</a></li>
<li><a href="https://www.cnblogs.com/sxdcgaq8080/p/10007735.html" target="_blank" rel="noopener">https://www.cnblogs.com/sxdcgaq8080/p/10007735.html</a></li>
<li><a href="https://blog.csdn.net/u010046908/article/details/54773323" target="_blank" rel="noopener">https://blog.csdn.net/u010046908/article/details/54773323</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
        <category>Sleuth</category>
      </categories>
      <tags>
        <tag>Sleuth</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务传播属性有那么难吗？看这一篇就够了</title>
    <url>/2020/01/15/2020/01/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E6%9C%89%E9%82%A3%E4%B9%88%E9%9A%BE%E5%90%97%EF%BC%9F%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    <content><![CDATA[<p>学习东西要知行合一，如果只是知道理论而没实践过，那么掌握的也不会特别扎实，估计过几天就会忘记，接下来我们一起实践来学习Spring事务的传播属性。</p>
<h4 id="传播属性"><a href="#传播属性" class="headerlink" title="传播属性"></a>传播属性</h4><p>传播属性定义的是<strong>当一个事务方法碰到另一个事务方法时的处理行为</strong>，一共有七种行为，定义如下</p>
<table>
<thead>
<tr>
<th>传播性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>PROPAGATION_REQUIRED</code></td>
<td>0</td>
<td>支持当前事务，如果没有就新建事务</td>
</tr>
<tr>
<td><code>PROPAGATION_SUPPORTS</code></td>
<td>1</td>
<td>支持当前事务，如果没有就不以事务的方式运行</td>
</tr>
<tr>
<td><code>PROPAGATION_MANDATORY</code></td>
<td>2</td>
<td>支持当前事务，如果当前没事务就抛异常</td>
</tr>
<tr>
<td><code>PROPAGATION_REQUIRES_NEW</code></td>
<td>3</td>
<td>无论当前是否有事务，都会新起一个事务</td>
</tr>
<tr>
<td><code>PROPAGATION_NOT_SUPPORTED</code></td>
<td>4</td>
<td>不支持事务，如果当前存在事务，就将此事务挂起不以事务方式运行</td>
</tr>
<tr>
<td><code>PROPAGATION_NEVER</code></td>
<td>5</td>
<td>不支持事务，如果有事务就抛异常</td>
</tr>
<tr>
<td><code>PROPAGATION_NESTED</code></td>
<td>6</td>
<td>如果当前存在事务，在当前事务中再新起一个事务</td>
</tr>
</tbody></table>
<p>其实只看概念的话已经很直截了当了说明了每个传播性的作用，此时我们再用具体的例子演示一下每个传播性属性下的行为。</p>
<p>此次演示我们使用的是H2数据库，这个数据库是作用在内存里面的，所以对于我们演示事务效果来说正好，无需我们在进行其他的配置了，我们新建一个表。将下面语句放在<code>schema.sql</code>文件里面即可，SpringBoot程序在启动的时候就会自动为我们在内存里面建立这样的一个表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> FOO (<span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">IDENTITY</span>, BAR <span class="built_in">VARCHAR</span>(<span class="number">64</span>));</span><br></pre></td></tr></table></figure>

<p>演示之前我们会定义两个类<code>FooService</code>和<code>BarService</code>。我们使用<code>BarService</code>里面的方法进行调用<code>FooService</code>中的方法。</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>在进行事务演示之前，其实可以分为以下几种情况，根据排列组合，我们可以得出以下八种情况</p>
<ul>
<li>调用者：有无事务</li>
<li>调用者：是否有异常</li>
<li>被调用者：有无事务<strong>(这个是通过传播属性进行控制的)</strong>所以并不在排列组合中</li>
<li>被调用者：是否有异常</li>
</ul>
<table>
<thead>
<tr>
<th>调用者是否有事务</th>
<th>调用者是否有异常</th>
<th>被调用者是否有异常</th>
</tr>
</thead>
<tbody><tr>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>有</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>有</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>无</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<h5 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h5><p>其中的<code>RollbackException</code>是我们自己定义的一个异常类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarServiceImpl</span> <span class="keyword">implements</span> <span class="title">BarService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooService fooService;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">// PROPAGATION_REQUIRED演示 无事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequiredNoTransactional</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">        fooService.testRequiredTransactional();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用者"><a href="#调用者" class="headerlink" title="调用者"></a>调用者</h5><p>在<code>BarService</code>中定义两个方法，一个是带着事务的，一个是不带事务的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">hasTransactional</span>() <span class="title">throws</span> <span class="title">RollbackException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransactional</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们就根据俄上面定义的八种情况进行事务传播属性的学习。</p>
<h5 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a><code>PROPAGATION_REQUIRED</code></h5><blockquote>
<p>在此传播属性下，被调用方是否新建事务取决去调用者是否带着事务。</p>
</blockquote>
<p>想要了解这个传播属性的特性，其实我们演示上面八种情况的两个例子就够了</p>
<table>
<thead>
<tr>
<th>调用者是否有事务</th>
<th>调用者是否有异常</th>
<th>被调用者是否有异常</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<ul>
<li>第一种情况我们在被调用者抛出异常的情况下，如果查询不到插入的数据，那么就说明被调用者在调用者没有事务的情况下自己新建了事务。</li>
<li>第二种情况我们在调用者抛出异常的情况下，如果查询不到插入的数据，那么就说明被调用者在调用者有事务的情况下就加入当前事务了。</li>
</ul>
<p>我们先来看一下被调用者的类的方法例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class FooServiceImpl implements FooService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    // REQUIRED传播属性-被调用者有异常抛出</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)</span><br><span class="line">    public void testRequiredHasException() throws RollbackException &#123;</span><br><span class="line">        jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ("</span>+Global.REQUIRED_HAS_EXCEPTION+<span class="string">")"</span>);</span><br><span class="line">        throw new RollbackException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // REQUIRED传播属性-被调用者无异常抛出</span><br><span class="line">    @Override</span><br><span class="line">    @Transactional(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)</span><br><span class="line">    public void testRequiredNoException() throws RollbackException &#123;</span><br><span class="line">        jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ("</span>+Global.REQUIRED_NO_EXCEPTION+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看一下调用者方法的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarServiceImpl</span> <span class="keyword">implements</span> <span class="title">BarService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">hasTransactional</span>() <span class="title">throws</span> <span class="title">RollbackException</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用者有事务,抛异常  被调用者无异常</span></span><br><span class="line">        fooService.testRequiredNoException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RollbackException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无事务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noTransactional</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用者无事务,不抛异常  被调用者有异常</span></span><br><span class="line">        fooService.testRequiredHasException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们在程序调用时进行查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String noException = Global.REQUIRED_NO_EXCEPTION;</span><br><span class="line">String hasException = Global.REQUIRED_HAS_EXCEPTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    barService.noTransactional();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    log.info(<span class="string">"第一种情况 &#123;&#125;"</span>,</span><br><span class="line">            jdbcTemplate</span><br><span class="line">                    .queryForObject(<span class="string">"SELECT COUNT(*) FROM FOO WHERE BAR='"</span>+hasException+<span class="string">"'"</span>, Long<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    barService.hasTransactional();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    log.info(<span class="string">"第二种情况 &#123;&#125;"</span>,</span><br><span class="line">            jdbcTemplate</span><br><span class="line">                    .queryForObject(<span class="string">"SELECT COUNT(*) FROM FOO WHERE BAR='"</span>+noException+<span class="string">"'"</span>, Long<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看打印出来的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-10-16 13:02:04.142  INFO 11869 --- [           main] c.e.t.t.TransactionApplication           : 第一种情况 0</span><br><span class="line">2019-10-16 13:02:04.143  INFO 11869 --- [           main] c.e.t.t.TransactionApplication           : 第二种情况 0</span><br></pre></td></tr></table></figure>

<p>我们看到我们都没有查到相应的数据，说明数据都回滚了。此时我们应该就理解了那句话<strong>支持当前事务，如果没有就新建事务</strong>。</p>
<h5 id="PROPAGATION-SUPPORTS"><a href="#PROPAGATION-SUPPORTS" class="headerlink" title="PROPAGATION_SUPPORTS"></a><code>PROPAGATION_SUPPORTS</code></h5><blockquote>
<p>被调用者是否有事务，完全依赖于调用者，调用者有事务则有事务，调用者没事务则没事务。</p>
</blockquote>
<p>接下来我们还是用上面的两个例子进行演示</p>
<table>
<thead>
<tr>
<th>调用者是否有事务</th>
<th>调用者是否有异常</th>
<th>被调用者是否有异常</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<ul>
<li>第一种情况：被调用者抛出异常的情况下，如果仍能查询到数据，说明事务没有回滚，说明被调用者没有事务</li>
<li>第二种情况：调用者抛出异常情况下，如果查不到数据，说明两个方法在一个事务中</li>
</ul>
<p>接下来仍然是例子演示</p>
<p>被调用者，只是将<code>@Transactional</code>注解中的<code>propagation</code>属性更换为了<code>Propagation.SUPPORTS</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SUPPORTS传播属性-被调用者有异常抛出</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.SUPPORTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSupportsHasException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.SUPPORTS_HAS_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RollbackException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SUPPORTS传播属性-被调用者无异常抛出</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.SUPPORTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSupportsNoException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.SUPPORTS_NO_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者和上面的例子调用一样，我们直接查看执行效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-10-16 13:50:27.738  INFO 12174 --- [           main] c.e.t.t.TransactionApplication           : 第一种情况 1</span><br><span class="line">2019-10-16 13:50:27.741  INFO 12174 --- [           main] c.e.t.t.TransactionApplication           : 第二种情况 0</span><br></pre></td></tr></table></figure>

<p>我们看到了在第一种情况下查到了数据，说明在第一种情况下被调用者是没有事务的。此时我们应该就理解了这句话 <strong>支持当前事务，如果没有就不以事务的方式运行</strong>。</p>
<h5 id="PROPAGATION-MANDATORY"><a href="#PROPAGATION-MANDATORY" class="headerlink" title="PROPAGATION_MANDATORY"></a><code>PROPAGATION_MANDATORY</code></h5><p>依然是这两个例子进行演示</p>
<table>
<thead>
<tr>
<th>调用者是否有事务</th>
<th>调用者是否有异常</th>
<th>被调用者是否有异常</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<ul>
<li>第一种情况：因为调用者没有事务，所以此传播属性下应该是抛异常的</li>
<li>第二种情况：被调用者的事务和调用者事务是同样的</li>
</ul>
<p>接下来是被调用者的代码例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MANDATORY传播属性-被调用者有异常抛出</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.MANDATORY)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMandatoryHasException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.SUPPORTS_HAS_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RollbackException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MANDATORY传播属性-被调用者无异常抛出</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.MANDATORY)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMandatoryNoException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.SUPPORTS_NO_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者和上面的例子调用一样，我们直接查看执行效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-10-16 13:58:39.178 ERROR 12317 --- [           main] c.e.t.t.TransactionApplication           : org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory'</span><br><span class="line">2019-10-16 13:58:39.276  INFO 12317 --- [           main] c.e.t.t.TransactionApplication           : 第一种情况 0</span><br><span class="line">2019-10-16 13:58:39.281  INFO 12317 --- [           main] c.e.t.t.TransactionApplication           : 第二种情况 0</span><br></pre></td></tr></table></figure>

<p>我们发现和我们推测一样，说明被调用者是不会自己新建事务的，此时我们应该就理解了这句话<strong>支持当前事务，如果当前没事务就抛异常</strong>。</p>
<h5 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a><code>PROPAGATION_REQUIRES_NEW</code></h5><blockquote>
<p>此传播属性下，无论调用者是否有事务，被调用者都会新建一个事务</p>
</blockquote>
<table>
<thead>
<tr>
<th>调用者是否有事务</th>
<th>调用者是否有异常</th>
<th>被调用者是否有异常</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<ul>
<li>第一种情况：调用者无事务，被调用者会新建事务，所以查不到数据</li>
<li>第二种情况：调用者有事务，被调用者会新建一个事务，所以调用者抛异常影响不到被调用者，所以能查到数据</li>
</ul>
<p>接下来我们演示代码。</p>
<p>被调用者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// REQUIRES_NEW传播属性-被调用者有异常抛出</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequiresNewHasException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.REQUIRES_NEW_HAS_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RollbackException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES_NEW传播属性-被调用者无异常抛出</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequiresNewNoException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.REQUIRES_NEW_NO_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者的例子和上面的相同，我们直接来看执行情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-10-16 16:29:20.296  INFO 15553 --- [           main] c.e.t.t.TransactionApplication           : 第一种情况 0</span><br><span class="line">2019-10-16 16:29:20.298  INFO 15553 --- [           main] c.e.t.t.TransactionApplication           : 第二种情况 1</span><br></pre></td></tr></table></figure>

<p>我们发现和我们的推论是一样的，说明调用者的事务和被调用者的事务完全无关。此时我们应该就理解这句话了<strong>无论当前是否有事务，都会新起一个事务</strong>。</p>
<h5 id="PROPAGATION-NOT-SUPPORTED"><a href="#PROPAGATION-NOT-SUPPORTED" class="headerlink" title="PROPAGATION_NOT_SUPPORTED"></a><code>PROPAGATION_NOT_SUPPORTED</code></h5><blockquote>
<p>无论调用者是否有事务，被调用者都不以事务的方法运行</p>
</blockquote>
<p>同样是这两个例子</p>
<table>
<thead>
<tr>
<th>调用者是否有事务</th>
<th>调用者是否有异常</th>
<th>被调用者是否有异常</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<ul>
<li>第一种情况：被调用者都不会有事务，那么在抛异常之后就能查到相应的数据</li>
<li>第二种情况：在调用者有事务的情况下，被调用者也会在无事务环境下运行，所以我们依然能查到数据</li>
</ul>
<p>接下来验证我们的猜测</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NOT_SUPPORTED传播属性-被调用者有异常抛出</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.NOT_SUPPORTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNotSupportHasException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.NOT_SUPPORTS_HAS_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RollbackException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NOT_SUPPORTED传播属性-被调用者无异常抛出</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.NOT_SUPPORTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNotSupportNoException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.NOT_SUPPORTS_NO_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后查看执行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-10-16 16:38:35.065  INFO 15739 --- [           main] c.e.t.t.TransactionApplication           : 第一种情况 1</span><br><span class="line">2019-10-16 16:38:35.067  INFO 15739 --- [           main] c.e.t.t.TransactionApplication           : 第二种情况 1</span><br></pre></td></tr></table></figure>

<p>我们可以看到在最后两种情况都查到了数据，根据演示效果应该可以理解这句话了，<strong>不支持事务，如果当前存在事务，就将此事务挂起不以事务方式运行</strong>。</p>
<h5 id="PROPAGATION-NEVER"><a href="#PROPAGATION-NEVER" class="headerlink" title="PROPAGATION_NEVER"></a><code>PROPAGATION_NEVER</code></h5><blockquote>
<p>调用者有事务，被调用者就会抛出异常</p>
</blockquote>
<table>
<thead>
<tr>
<th>调用者是否有事务</th>
<th>调用者是否有异常</th>
<th>被调用者是否有异常</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<p>这个就不演示，相信大家看到这里应该都会明白在第一种情况下我们是能够查到数据的。在第二种情况下由于调用者带着事务，所以会抛异常。</p>
<h5 id="PROPAGATION-NESTED"><a href="#PROPAGATION-NESTED" class="headerlink" title="PROPAGATION_NESTED"></a><code>PROPAGATION_NESTED</code></h5><blockquote>
<p>此传播属性下，被调用者的事务是调用者的事务的子集。</p>
</blockquote>
<p>我们重点说一下<code>NESTED</code>的传播属性的特性</p>
<table>
<thead>
<tr>
<th>调用者是否有事务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>有</td>
<td>被调用者会新起一个事务，此事务和调用者事务是一个嵌套的关系</td>
</tr>
<tr>
<td>无</td>
<td>被调用者会自己新起一个事务</td>
</tr>
</tbody></table>
<p>关于什么是嵌套事务的关系，我们用下面三个例子能够进行演示。</p>
<table>
<thead>
<tr>
<th>调用者是否有事务</th>
<th>调用者是否有异常</th>
<th>被调用者是否有异常</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>有</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>有</td>
<td>无</td>
<td>有</td>
</tr>
</tbody></table>
<ul>
<li>第一种情况：如果查不到数据，则说明在调用者无事务情况下，被调用者会新起一个事务</li>
<li>第二种情况：如果查不到数据，说明外层事务能够影响内层事务</li>
<li>第三种情况：如果查到数据，说明内层事务不影响外层事务</li>
</ul>
<p>接下来我们编写具体的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NESTED传播属性-回滚事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.NESTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNestedHasException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.NESTED_HAS_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">   <span class="comment">// TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RollbackException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NESTED传播属性-不回滚事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>,<span class="title">propagation</span> </span>= Propagation.NESTED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNestedNoException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.NESTED_NO_EXCEPTION+<span class="string">"')"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后接下来的调用者也会有点区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasTransactionalNoException</span><span class="params">()</span> <span class="keyword">throws</span> RollbackException </span>&#123;</span><br><span class="line">    <span class="comment">// NESTED传播属性 - 调用者有事务,不抛异常  被调用者有异常</span></span><br><span class="line">    jdbcTemplate.execute(<span class="string">"INSERT INTO FOO (BAR) VALUES ('"</span>+Global.NESTED_HAS_EXCEPTION_TWO+<span class="string">"')"</span>);</span><br><span class="line">    fooService.testNestedHasException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-10-16 18:01:06.387  INFO 17172 --- [           main] c.e.t.t.TransactionApplication           : 第一种情况 0</span><br><span class="line">2019-10-16 18:01:06.389  INFO 17172 --- [           main] c.e.t.t.TransactionApplication           : 第二种情况 0</span><br><span class="line">2019-10-16 18:01:06.390  INFO 17172 --- [           main] c.e.t.t.TransactionApplication           : 第三种情况 1</span><br></pre></td></tr></table></figure>

<p>可以看出来嵌套事务的本质就是<strong>外层会影响内层，内层不影响外层</strong>。而<code>REQUIRES_NEW</code>则是<strong>互不影响</strong>。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>到现在我们已经全部分析完了七种传播属性，从写这篇文章开始到结束其中也碰到过一些坑，有些是不自己实践一遍是根本不知道的，所以我还是建议读者看完这篇文章以后自己进行实践，演示各种情况，只有这样才能够烂熟于心。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat是如何实现异步Servlet的</title>
    <url>/2020/01/16/2020/01/Tomcat%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5Servlet%E7%9A%84/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>通过我之前的Tomcat系列文章，相信看我博客的同学对Tomcat应该有一个比较清晰的了解了，在前几篇博客我们讨论了Tomcat在SpringBoot框架中是如何启动的，讨论了Tomcat的内部组件是如何设计以及请求是如何流转的，那么我们这篇博客聊聊Tomcat的异步Servlet，Tomcat是如何实现异步Servlet的以及异步Servlet的使用场景。</p>
<h4 id="手撸一个异步的Servlet"><a href="#手撸一个异步的Servlet" class="headerlink" title="手撸一个异步的Servlet"></a>手撸一个异步的Servlet</h4><p>我们直接借助SpringBoot框架来实现一个Servlet,这里只展示Servlet代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/async"</span>,asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService =Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//开启异步,获取异步上下文</span></span><br><span class="line">        <span class="keyword">final</span> AsyncContext ctx = req.startAsync();</span><br><span class="line">        <span class="comment">// 提交线程池异步执行</span></span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"async Service 准备执行了"</span>);</span><br><span class="line">                    <span class="comment">//模拟耗时任务</span></span><br><span class="line">                    Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line">                    ctx.getResponse().getWriter().print(<span class="string">"async servlet"</span>);</span><br><span class="line">                    log.info(<span class="string">"async Service 执行了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后执行完成后完成回调。</span></span><br><span class="line">                ctx.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现了一个异步的Servlet,实现了<code>doGet</code>方法注意在SpringBoot中使用需要再启动类加上<code>@ServletComponentScan</code>注解来扫描Servlet。既然代码写好了，我们来看看实际运行效果。</p>
<p><img src="http://static.cyblogs.com/async%20Servlet%20result.png" alt="http://static.cyblogs.com/async%20Servlet%20result.png"></p>
<p>我们发送一个请求后，看到页面有响应，同时，看到请求时间花费了10.05s,那么我们这个Servlet算是能正常运行啦。有同学肯定会问，这不是异步servlet吗？你的响应时间并没有加快，有什么用呢？对，我们的响应时间并不能加快，还是会取决于我们的业务逻辑，但是我们的异步servlet请求后，依赖于业务的异步执行，我们可以立即返回，也就是说，Tomcat的线程可以立即回收，默认情况下，Tomcat的核心线程是<strong>10</strong>，最大线程数是<strong>200</strong>,我们能及时回收线程，也就意味着我们能处理更多的请求，能够增加我们的吞吐量，这也是异步Servlet的主要作用。</p>
<h4 id="异步Servlet的内部原理"><a href="#异步Servlet的内部原理" class="headerlink" title="异步Servlet的内部原理"></a>异步Servlet的内部原理</h4><p>了解完异步Servlet的作用后，我们来看看，Tomcat是如何是先异步Servlet的。其实上面的代码，主要核心逻辑就两部分，<code>final AsyncContext ctx = req.startAsync()</code>和<code>ctx.complete()</code>那我们来看看他们究竟做了什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AsyncContext <span class="title">startAsync</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">         ServletResponse response)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!isAsyncSupported()) &#123;</span><br><span class="line">         IllegalStateException ise =</span><br><span class="line">                 <span class="keyword">new</span> IllegalStateException(sm.getString(<span class="string">"request.asyncNotSupported"</span>));</span><br><span class="line">         log.warn(sm.getString(<span class="string">"coyoteRequest.noAsync"</span>,</span><br><span class="line">                 StringUtils.join(getNonAsyncClassNames())), ise);</span><br><span class="line">         <span class="keyword">throw</span> ise;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (asyncContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">         asyncContext = <span class="keyword">new</span> AsyncContextImpl(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     asyncContext.setStarted(getContext(), request, response,</span><br><span class="line">             request==getRequest() &amp;&amp; response==getResponse().getResponse());</span><br><span class="line">     asyncContext.setTimeout(getConnector().getAsyncTimeout());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> asyncContext;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们发现<code>req.startAsync()</code>只是保存了一个异步上下文，同时设置一些基础信息，比如<code>Timeout</code>,顺便提一下，这里设置的默认超时时间是<strong>30S</strong>，如果你的异步处理逻辑超过<strong>30S</strong>,此时执行<code>ctx.complete()</code>就会抛出IllegalStateException 异常。</p>
<p>我们来看看<code>ctx.complete()</code>的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            logDebug(<span class="string">"complete   "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        check();</span><br><span class="line">        request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//类：AbstractProcessor </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(ActionCode actionCode, Object param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ASYNC_COMPLETE: &#123;</span><br><span class="line">            clearDispatches();</span><br><span class="line">            <span class="keyword">if</span> (asyncStateMachine.asyncComplete()) &#123;</span><br><span class="line">                processSocketEvent(SocketEvent.OPEN_READ, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类：AbstractProcessor </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processSocketEvent</span><span class="params">(SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">        SocketWrapperBase&lt;?&gt; socketWrapper = getSocketWrapper();</span><br><span class="line">        <span class="keyword">if</span> (socketWrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            socketWrapper.processSocket(event, dispatch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类：AbstractEndpoint</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">            SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">            SocketProcessorBase&lt;S&gt; sc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (processorCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sc = processorCache.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.reset(socketWrapper, event);</span><br><span class="line">            &#125;</span><br><span class="line">            Executor executor = getExecutor();</span><br><span class="line">            <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.run();</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以，这里最终会调用<code>AbstractEndpoint</code>的<code>processSocket</code>方法，之前看过我前面博客的同学应该有印象，<code>EndPoint</code>是用来接受和处理请求的，接下来就会交给<code>Processor</code>去进行协议处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类：AbstractProcessorLight</span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分diam</span></span><br><span class="line">        SocketState state = SocketState.CLOSED;</span><br><span class="line">        Iterator&lt;DispatchType&gt; dispatches = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">                DispatchType nextDispatch = dispatches.next();</span><br><span class="line">                state = dispatch(nextDispatch.getSocketStatus());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.DISCONNECT) &#123;</span><br><span class="line">            </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) &#123;</span><br><span class="line">                state = dispatch(status);</span><br><span class="line">                <span class="keyword">if</span> (state == SocketState.OPEN) &#123;</span><br><span class="line">                    state = service(socketWrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">                state = SocketState.LONG;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_READ)&#123;</span><br><span class="line">                state = service(socketWrapper);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = SocketState.CLOSED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (state == SocketState.ASYNC_END ||</span><br><span class="line">                dispatches != <span class="keyword">null</span> &amp;&amp; state != SocketState.CLOSED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这部分是重点，<code>AbstractProcessorLight</code>会根据<code>SocketEvent</code>的状态来判断是不是要去调用<code>service(socketWrapper)</code>,该方法最终会去调用到容器，从而完成业务逻辑的调用，我们这个请求是执行完成后调用的，肯定不能进容器了，不然就是死循环了，这里通过<code>isAsync()</code>判断，就会进入<code>dispatch(status)</code>,最终会调用<code>CoyoteAdapter</code>的<code>asyncDispatch</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncDispatch</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res,</span></span></span><br><span class="line"><span class="function"><span class="params">            SocketEvent status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        Request request = (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">        Response response = (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">        AsyncContextImpl asyncConImpl = request.getAsyncContextInternal();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!request.isAsync()) &#123;</span><br><span class="line">                response.setSuspended(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status==SocketEvent.TIMEOUT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!asyncConImpl.timeout()) &#123;</span><br><span class="line">                    asyncConImpl.setErrorState(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status==SocketEvent.ERROR) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!request.isAsyncDispatching() &amp;&amp; request.isAsync()) &#123;</span><br><span class="line">                WriteListener writeListener = res.getWriteListener();</span><br><span class="line">                ReadListener readListener = req.getReadListener();</span><br><span class="line">                <span class="keyword">if</span> (writeListener != <span class="keyword">null</span> &amp;&amp; status == SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">                    ClassLoader oldCL = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        oldCL = request.getContext().bind(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                        res.onWritePossible();<span class="comment">//这里执行浏览器响应，写入数据</span></span><br><span class="line">                        <span class="keyword">if</span> (request.isFinished() &amp;&amp; req.sendAllDataReadEvent() &amp;&amp;</span><br><span class="line">                                readListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            readListener.onAllDataRead();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                       </span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        request.getContext().unbind(<span class="keyword">false</span>, oldCL);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里判断异步正在进行，说明这不是一个完成方法的回调，是一个正常异步请求，继续调用容器。</span></span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br><span class="line">                Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    asyncConImpl.setErrorState(t, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意，这里，如果超时或者出错，request.isAsync()会返回false，这里是为了尽快的输出错误给客户端。</span></span><br><span class="line">            <span class="keyword">if</span> (!request.isAsync()) &#123;</span><br><span class="line">                <span class="comment">//这里也是输出逻辑</span></span><br><span class="line">                request.finishRequest();</span><br><span class="line">                response.finishResponse();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//销毁request和response</span></span><br><span class="line">            <span class="keyword">if</span> (!success || !request.isAsync()) &#123;</span><br><span class="line">                updateWrapperErrorCount(request, response);</span><br><span class="line">                request.recycle();</span><br><span class="line">                response.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是<code>ctx.complete()</code>执行最终的方法了（当然省略了很多细节），完成了数据的输出，最终输出到浏览器。</p>
<p>这里有同学可能会说，我知道异步执行完后，调用<code>ctx.complete()</code>会输出到浏览器，但是，第一次doGet请求执行完成后，Tomcat是怎么知道不用返回到客户端的呢？关键代码在<code>CoyoteAdapter</code>中的<code>service</code>方法，部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">          <span class="comment">//省略部分代码</span></span><br><span class="line">          <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">              request.setAsyncSupported(</span><br><span class="line">                      connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">              connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                      request, response);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">              async = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//输出数据到客户端</span></span><br><span class="line">              request.finishRequest();</span><br><span class="line">              response.finishResponse();</span><br><span class="line">          <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">              updateWrapperErrorCount(request, response);</span><br><span class="line">              <span class="comment">//销毁request和response</span></span><br><span class="line">              request.recycle();</span><br><span class="line">              response.recycle();</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码在调用完<code>Servlet</code>后，会通过<code>request.isAsync()</code>来判断是否是异步请求，如果是异步请求，就设置<code>async = true</code>。如果是非异步请求就执行输出数据到客户端逻辑，同时销毁<code>request</code>和<code>response</code>。这里就完成了请求结束后不响应客户端的操作。</p>
<h4 id="为什么说Spring-Boot的-EnableAsync注解不是异步Servlet"><a href="#为什么说Spring-Boot的-EnableAsync注解不是异步Servlet" class="headerlink" title="为什么说Spring Boot的@EnableAsync注解不是异步Servlet"></a>为什么说Spring Boot的@EnableAsync注解不是异步Servlet</h4><p>因为之前准备写本篇文章的时候就查询过很多资料，发现很多资料写SpringBoot异步编程都是依赖于<code>@EnableAsync</code>注解，然后在<code>Controller</code>用多线程来完成业务逻辑，最后汇总结果，完成返回输出。这里拿一个掘金大佬的文章来举例《<a href="https://juejin.im/post/5d9e7cfa6fb9a04e1f12ec02" target="_blank" rel="noopener">新手也能看懂的 SpringBoot 异步编程指南</a>》，这篇文章写得很通俗易懂，非常不错，从业务层面来说，确实是异步编程，但是有一个问题，抛开业务的并行处理来说，针对整个请求来说，并不是异步的，也就是说不能立即释放Tomcat的线程，从而不能达到异步Servlet的效果。这里我参考上文也写了一个demo，我们来验证下，为什么它不是异步的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"testAsynch Start"</span>);</span><br><span class="line">            CompletableFuture&lt;String&gt; test1 = service.test1();</span><br><span class="line">            CompletableFuture&lt;String&gt; test2 = service.test2();</span><br><span class="line">            CompletableFuture&lt;String&gt; test3 = service.test3();</span><br><span class="line">            CompletableFuture.allOf(test1, test2, test3);</span><br><span class="line">            log.info(<span class="string">"test1====="</span> + test1.get());</span><br><span class="line">            log.info(<span class="string">"test2====="</span> + test2.get());</span><br><span class="line">            log.info(<span class="string">"test3====="</span> + test3.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">"test1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">"test2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">"test3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatdebugApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TomcatdebugApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"AsynchThread-"</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我运行下，看看效果</p>
<p><img src="http://static.cyblogs.com/Spring%20boot%20%E5%BC%82%E6%AD%A51.gif" alt="http://static.cyblogs.com/Spring%20boot%20异步1.gif"></p>
<p>这里我请求之后，在调用容器执行业务逻辑之前打了一个断点，然后在返回之后的同样打了一个断点，在<code>Controller</code>执行完之后，请求才回到了<code>CoyoteAdapter</code>中，并且判断<code>request.isAsync()</code>,根据图中看到，是为<code>false</code>,那么接下来就会执行<code>request.finishRequest()</code>和<code>response.finishResponse()</code> 来执行响应的结束，并销毁请求和响应体。很有趣的事情是，我实验的时候发现，在执行<code>request.isAsync()</code>之前，浏览器的页面上已经出现了响应体，这是SpringBoot框架已经通过<code>StringHttpMessageConverter</code>类中的<code>writeInternal</code>方法已经进行输出了。</p>
<p><strong>以上分析的核心逻辑就是</strong>，Tomcat的线程执行<code>CoyoteAdapter</code>调用容器后，必须要等到请求返回，然后再判断是否是异步请求，再处理请求，然后执行完毕后，线程才能进行回收。而我一最开始的异步Servlet例子，执行完doGet方法后，就会立即返回，也就是会直接到<code>request.isAsync()</code>的逻辑，然后整个线程的逻辑执行完毕，线程被回收。</p>
<h4 id="聊聊异步Servlet的使用场景"><a href="#聊聊异步Servlet的使用场景" class="headerlink" title="聊聊异步Servlet的使用场景"></a>聊聊异步Servlet的使用场景</h4><p>分析了这么多，那么异步Servlet的使用场景有哪些呢？其实我们只要抓住一点就可以分析了，就是异步Servlet提高了系统的吞吐量，可以接受更多的请求。假设web系统中Tomcat的线程不够用了，大量请求在等待，而此时Web系统应用层面的优化已经不能再优化了，也就是无法缩短业务逻辑的响应时间了，这个时候，如果想让减少用户的等待时间，提高吞吐量，可以尝试下使用异步Servlet。</p>
<p><strong>举一个实际的例子</strong>：比如做一个短信系统，短信系统对实时性要求很高，所以要求等待时间尽可能短，而发送功能我们实际上是委托运营商去发送的，也就是说我们要调用接口，假设并发量很高，那么这个时候业务系统调用我们的发送短信功能，就有可能把我们的Tomcat线程池用完，剩下的请求就会在队列中等待，那这个时候，短信的延时就上去了，为了解决这个问题，我们可以引入异步Servlet,接受更多的短信发送请求，从而减少短信的延时。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这篇文章我从手写一个异步Servlet来开始，分析了异步Servlet的作用，以及Tomcat内部是如何实现异步Servlet的，然后我也根据互联网上流行的SpringBoot异步编程来进行说明，其在Tomcat内部并不是一个异步的Servlet。最后，我谈到了异步Servlet的使用场景，分析了什么情况下可以尝试异步Servlet。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Zipkin链路追踪HTTP与RabbitMQ方式</title>
    <url>/2020/01/30/2020/01/Zipkin%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AAHTTP%E4%B8%8ERabbitMQ%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>上一篇只是单纯的从原理上以及控制台上去实践系统之间的打通，但是如果能从页面上去看每一个请求日志的链路情况就更好了。其实zipkin是提供了一个UI后台管理给到我们的。</p>
<p><strong>注意点：</strong>关于 Zipkin 的服务端，在使用 Spring Boot 2.x 版本后，官方就不推荐自行定制编译了，反而是直接提供了编译好的 jar 包来给我们使用。具体请查阅：<a href="https://zipkin.io/pages/quickstart.html" target="_blank" rel="noopener">https://zipkin.io/pages/quickstart.html</a> （最直接、权威的就是阅读官方网站）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sSL https://zipkin.io/quickstart.sh | bash -s</span><br><span class="line">java -jar zipkin.jar</span><br></pre></td></tr></table></figure>

<h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><p>Zipkin 分为两端，一个是 Zipkin 服务端，一个是 Zipkin 客户端，客户端也就是微服务的应用。<br>客户端会配置服务端的 URL 地址，一旦发生服务间的调用的时候，会被配置在微服务里面的 Sleuth 的监听器监听，并生成相应的 Trace 和 Span 信息发送给服务端。<br>发送的方式主要有两种，一种是 HTTP 报文的方式，还有一种是消息总线的方式如 RabbitMQ。</p>
<p>不论哪种方式，我们都需要：</p>
<ul>
<li>一个 Eureka 服务注册中心，这里我们就用之前的 <code>eureka</code> 项目来当注册中心。</li>
<li>一个 Zipkin 服务端。</li>
<li>三个微服务应用，<code>trace-a</code> 和 <code>trace-b</code> 和 <code>trace-c</code>，其中 <code>trace-a</code> 中有一个 REST 接口 <code>/trace-a</code>，调用该接口后将触发对 <code>trace-b</code> 应用的调用，最后调用<code>trace-c</code>。其实2个服务就够了~</li>
</ul>
<h4 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h4><p>也是因为一些环境问题，总是导致ui后管一直没有数据，这次参考了很多文章一级官网网址来操作的，才得以显示数据。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud-dependencies.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud-dependencies.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-dependencies.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式一：通过HTTP"><a href="#方式一：通过HTTP" class="headerlink" title="方式一：通过HTTP"></a>方式一：通过HTTP</h4><p>客户端的pom文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>客户端的properties文件内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">trace-a</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">10001</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:8001/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.sleuth.web.client.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.sleuth.sampler.probability</span>=<span class="string">1.0</span></span><br><span class="line"><span class="meta">spring.zipkin.base-url</span>=<span class="string">http://localhost:9411</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log trace detail</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web.servlet.DispatcherServlet</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>访问层部分Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.allei;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceAApplication</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/trace-a"</span>, method = RequestMethod.GET)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">trace</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		log.info(<span class="string">"call trace-a-----&gt;"</span>);</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">1l</span>);</span><br><span class="line">		<span class="keyword">return</span> restTemplate().getForEntity(<span class="string">"http://trace-b/trace-b"</span>, String<span class="class">.<span class="keyword">class</span>).<span class="title">getBody</span>()</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(TraceAApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是确定一下注册中心，保证服务都有起来。</p>
<p><img src="http://static.cyblogs.com/WX20200113-155940@2x.png" alt="http://static.cyblogs.com/WX20200113-155940@2x.png"></p>
<p>通过上面的脚本拉取最新的zipkin服务，此时的版本是：2.19.2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Desktop  curl -sSL https://zipkin.io/quickstart.sh | bash -s</span><br><span class="line">Thank you for trying Zipkin!</span><br><span class="line">This installer is provided as a quick-start helper, so you can try Zipkin out</span><br><span class="line">without a lengthy installation process.</span><br><span class="line"></span><br><span class="line">Fetching version number of latest io.zipkin:zipkin-server release...</span><br><span class="line">Latest release of io.zipkin:zipkin-server seems to be 2.19.2</span><br><span class="line"></span><br><span class="line">Downloading io.zipkin:zipkin-server:2.19.2:exec to zipkin.jar...</span><br></pre></td></tr></table></figure>

<p>并且启动服务：嗯~ logo已经更换的更加的骚气~</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Desktop  java -jar zipkin.jar</span><br><span class="line"></span><br><span class="line">                  oo</span><br><span class="line">                 oooo</span><br><span class="line">                oooooo</span><br><span class="line">               oooooooo</span><br><span class="line">              oooooooooo</span><br><span class="line">             oooooooooooo</span><br><span class="line">           ooooooo  ooooooo</span><br><span class="line">          oooooo     ooooooo</span><br><span class="line">         oooooo       ooooooo</span><br><span class="line">        oooooo   o  o   oooooo</span><br><span class="line">       oooooo   oo  oo   oooooo</span><br><span class="line">     ooooooo  oooo  oooo  ooooooo</span><br><span class="line">    oooooo   ooooo  ooooo  ooooooo</span><br><span class="line">   oooooo   oooooo  oooooo  ooooooo</span><br><span class="line">  oooooooo      oo  oo      oooooooo</span><br><span class="line">  ooooooooooooo oo  oo ooooooooooooo</span><br><span class="line">      oooooooooooo  oooooooooooo</span><br><span class="line">          oooooooo  oooooooo</span><br><span class="line">              oooo  oooo</span><br><span class="line"></span><br><span class="line">     ________ ____  _  _____ _   _</span><br><span class="line">    |__  /_ _|  _ \| |/ /_ _| \ | |</span><br><span class="line">      / / | || |_) | ' / | ||  \| |</span><br><span class="line">     / /_ | ||  __/| . \ | || |\  |</span><br><span class="line">    |____|___|_|   |_|\_\___|_| \_|</span><br><span class="line"></span><br><span class="line">:: version 2.19.2 :: commit 56d907b ::</span><br></pre></td></tr></table></figure>

<p>当浏览器访问<code>trace-a</code>服务的时候，去后管页面查看就能看到服务列表以及日志情况。</p>
<p>图一：</p>
<p><img src="http://static.cyblogs.com/WX20200113-145151@2x.png" alt="http://static.cyblogs.com/WX20200113-145151@2x.png"></p>
<p>图二：</p>
<p><img src="http://static.cyblogs.com/WX20200113-145220@2x.png" alt="http://static.cyblogs.com/WX20200113-145220@2x.png"></p>
<h4 id="方式二：RabbitMQ"><a href="#方式二：RabbitMQ" class="headerlink" title="方式二：RabbitMQ"></a>方式二：RabbitMQ</h4><h5 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~  brew install rabbitmq</span><br><span class="line">Updating Homebrew...</span><br><span class="line">==&gt; Auto-updated Homebrew!</span><br><span class="line">Updated 4 taps (homebrew/cask, caskroom/versions, caskroom/cask and adoptopenjdk/openjdk).</span><br><span class="line"></span><br><span class="line">==&gt; Downloading https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.0/rabbitmq-server-generic-unix-3.8.0.tar.xz</span><br><span class="line">==&gt; Downloading from https://github-production-release-asset-2e65be.s3.amazonaws.com/924551/71891480-e44b-11e9-80fd-c06739f04c5e?X-Amz-Algorith</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; /usr/bin/unzip -qq -j /usr/local/Cellar/rabbitmq/3.8.0/plugins/rabbitmq_management-3.8.0.ez rabbitmq_management-3.8.0/priv/www/cli/rabbitmq</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Management Plugin enabled by default at http://localhost:15672</span><br><span class="line"></span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /usr/local/etc/bash_completion.d</span><br><span class="line"></span><br><span class="line">To have launchd start rabbitmq now and restart at login:</span><br><span class="line">  brew services start rabbitmq</span><br><span class="line">Or, if you don't want/need a background service you can just run:</span><br><span class="line">  rabbitmq-server</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/local/Cellar/rabbitmq/3.8.0: 277 files, 18.2MB, built in 34 seconds</span><br><span class="line">==&gt; `brew cleanup` has not been run in 30 days, running now...</span><br><span class="line">Removing: /usr/local/Cellar/jpeg/9b... (20 files, 724KB)</span><br><span class="line">Removing: /usr/local/Cellar/libpng/1.6.34... (26 files, 1.2MB)</span><br><span class="line">Removing: /usr/local/Cellar/libtiff/4.0.8_5... (245 files, 3.4MB)</span><br><span class="line">Removing: /usr/local/Cellar/wxmac/3.0.3.1_1... (810 files, 24.3MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/Cask/minikube--0.25.0... (41.3MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Logs/Homebrew/go... (64B)</span><br><span class="line">Removing: /Users/chenyuan/Library/Logs/Homebrew/readline... (64B)</span><br><span class="line">Removing: /Users/chenyuan/Library/Logs/Homebrew/sqlite... (64B)</span><br><span class="line">Removing: /Users/chenyuan/Library/Logs/Homebrew/kubernetes-cli... (64B)</span><br><span class="line">Pruned 0 symbolic links and 2 directories from /usr/local</span><br></pre></td></tr></table></figure>

<p>安装的路径在：<code>/usr/local/Cellar/rabbitmq/3.8.0</code>，利用brew安装软件速度可能会很慢，大家可以去更换一下源就变好了。但这个其实也不一定。</p>
<h5 id="启动RabbitMQ"><a href="#启动RabbitMQ" class="headerlink" title="启动RabbitMQ"></a>启动RabbitMQ</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  sbin  rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##      RabbitMQ 3.8.0</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Copyright (C) 2007-2019 Pivotal Software, Inc.</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#####  ##</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"><span class="comment">#########  Licensed under the MPL.  See https://www.rabbitmq.com/</span></span></span><br><span class="line"></span><br><span class="line">  Doc guides: https://rabbitmq.com/documentation.html</span><br><span class="line">  Support:    https://rabbitmq.com/contact.html</span><br><span class="line">  Tutorials:  https://rabbitmq.com/getstarted.html</span><br><span class="line">  Monitoring: https://rabbitmq.com/monitoring.html</span><br><span class="line"></span><br><span class="line">  Logs: /usr/local/var/log/rabbitmq/rabbit@localhost.log</span><br><span class="line">        /usr/local/var/log/rabbitmq/rabbit@localhost_upgrade.log</span><br><span class="line"></span><br><span class="line">  Config file(s): (none)</span><br><span class="line"></span><br><span class="line">  Starting broker... completed with 6 plugins.</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/WX20200111-064208@2x.png" alt="http://static.cyblogs.com/WX20200111-064208@2x.png"></p>
<p>默认密码账号为guest/guest。登录进入后就能看到界面了。</p>
<p><img src="http://static.cyblogs.com/WX20200111-064349@2x.png" alt="http://static.cyblogs.com/WX20200111-064349@2x.png"></p>
<p>配置客户端pom文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 新加入</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了觉得不是http的模式导致的数据，故意让地址写错</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.zipkin.base-url</span>=<span class="string">http://localhost:9412</span></span><br></pre></td></tr></table></figure>

<p>然后客户端就什么都不用管了。但是服务端因为是下载的Jar的方式，让其支持RabbitMQ只能通过环境变量的方式来启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RABBIT_ADDRESSES=localhost java -jar zipkin.jar</span><br></pre></td></tr></table></figure>

<p>这个时候会发现RabbitMQ会有一个zipkin的队列。</p>
<p><img src="http://static.cyblogs.com/WX20200113-150636@2x.png" alt="http://static.cyblogs.com/WX20200113-150636@2x.png">可配置的环境变量如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">环境变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zipkin.collector.rabbitmq.concurrency</code></td>
<td align="left"><code>RABBIT_CONCURRENCY</code></td>
<td align="left">并发消费者数量，默认为 <code>1</code></td>
</tr>
<tr>
<td align="left"><code>zipkin.collector.rabbitmq.connection-timeout</code></td>
<td align="left"><code>RABBIT_CONNECTION_TIMEOUT</code></td>
<td align="left">建立连接时的超时时间，默认为 <code>60000</code> 毫秒，即 1 分钟</td>
</tr>
<tr>
<td align="left"><code>zipkin.collector.rabbitmq.queue</code></td>
<td align="left"><code>RABBIT_QUEUE</code></td>
<td align="left">从中获取 span 信息的队列，默认为 <code>zipkin</code></td>
</tr>
<tr>
<td align="left"><code>zipkin.collector.rabbitmq.uri</code></td>
<td align="left"><code>RABBIT_URI</code></td>
<td align="left">符合 <a href="https://www.rabbitmq.com/uri-spec.html" target="_blank" rel="noopener">RabbitMQ URI 规范</a> 的 URI，例如 <code>amqp://user:pass@host:10000/vhost</code></td>
</tr>
</tbody></table>
<p>如果设置了 URI，则以下属性将被忽略。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">环境变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zipkin.collector.rabbitmq.addresses</code></td>
<td align="left"><code>RABBIT_ADDRESSES</code></td>
<td align="left">用逗号分隔的 RabbitMQ 地址列表，例如 <code>localhost:5672,localhost:5673</code></td>
</tr>
<tr>
<td align="left"><code>zipkin.collector.rabbitmq.password</code></td>
<td align="left"><code>RABBIT_PASSWORD</code></td>
<td align="left">连接到 RabbitMQ 时使用的密码，默认为 <code>guest</code></td>
</tr>
<tr>
<td align="left"><code>zipkin.collector.rabbitmq.username</code></td>
<td align="left"><code>RABBIT_USER</code></td>
<td align="left">连接到 RabbitMQ 时使用的用户名，默认为 <code>guest</code></td>
</tr>
<tr>
<td align="left"><code>zipkin.collector.rabbitmq.virtual-host</code></td>
<td align="left"><code>RABBIT_VIRTUAL_HOST</code></td>
<td align="left">使用的 RabbitMQ virtual host，默认为 <code>/</code></td>
</tr>
<tr>
<td align="left"><code>zipkin.collector.rabbitmq.use-ssl</code></td>
<td align="left"><code>RABBIT_USE_SSL</code></td>
<td align="left">设置为 <code>true</code> 则用 SSL 的方式与 RabbitMQ 建立链接</td>
</tr>
</tbody></table>
<p>然后访问 <a href="http://localhost:10001/trace-a" target="_blank" rel="noopener">http://localhost:10001/trace-a</a> 并刷新 Zipkin UI，看到如下内容，就说明 Sleuth+Zipkin+RabbitMQ 整合成功了。</p>
<p><img src="http://static.cyblogs.com/WX20200113-150738@2x.png" alt="http://static.cyblogs.com/WX20200113-150738@2x.png"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.cnblogs.com/mxmbk/p/9820936.html" target="_blank" rel="noopener">https://www.cnblogs.com/mxmbk/p/9820936.html</a></li>
<li><a href="https://juejin.im/post/5c3d4df0f265da61307517ad" target="_blank" rel="noopener">https://juejin.im/post/5c3d4df0f265da61307517ad</a></li>
<li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">https://github.com/openzipkin/zipkin</a></li>
<li><a href="https://www.cnblogs.com/sxdcgaq8080/p/10007735.html" target="_blank" rel="noopener">https://www.cnblogs.com/sxdcgaq8080/p/10007735.html</a></li>
<li><a href="https://blog.csdn.net/u010046908/article/details/54773323" target="_blank" rel="noopener">https://blog.csdn.net/u010046908/article/details/54773323</a></li>
<li><a href="https://windmt.com/2018/04/24/spring-cloud-12-sleuth-zipkin/" target="_blank" rel="noopener">https://windmt.com/2018/04/24/spring-cloud-12-sleuth-zipkin/</a></li>
<li><a href="https://zipkin.io/pages/quickstart.html" target="_blank" rel="noopener">https://zipkin.io/pages/quickstart.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Zipkin</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Zipkin</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么国外程序员爱用 Mac？</title>
    <url>/2020/01/07/2020/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%BD%E5%A4%96%E7%A8%8B%E5%BA%8F%E5%91%98%E7%88%B1%E7%94%A8%20Mac%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="http://static.cyblogs.com/macispopular.jpg" alt="http://static.cyblogs.com/macispopular.jpg"></p>
<p>Mac 在国外很受欢迎，尤其是在 设计/web开发/IT 人员圈子里。普通用户喜欢 Mac 可以理解，毕竟 Mac 设计美观，简单好用，没有病毒。那么为什么<a href="http://www.vpsee.com/2012/06/share-some-geeks-desks/" target="_blank" rel="noopener">专业人士也对 Mac 情有独钟</a>呢？从个人使用经验来看我想有下面几个原因：</p>
<p>1、Mac OS X 是基于 Unix 的。这一点太重要了，尤其是对开发人员，至少对于我来说很重要，这意味着Unix 下一堆好用的工具都可以随手捡到。如果你是个 windows 开发人员，我想你会在 windows 上装一套cygwin 环境吧？你不用 flex/yacc，grep，screen，ssh，make？好多 open source 的项目只提供cygwin/gcc/make 的编译环境。Mac 就是基于 BSD Unix 的，所有这些都是 built in 的。</p>
<p>2、开发环境。c/c++/java/perl/python/php/ruby/lisp，各种 shell，应有尽有，直接支持，非常方便。你要在 windows 上开发 C++，要装个 Visual Studio 编译器吧？或者其他的 C++ 编译器；你要开发 Java，你要下载 Java SDK 吧，说不定还要一个 Elipse 或者 Netbean；你要用 Perl，要安装一个 Perl 解释器吧，Active Perl？你要 python/php/ruby，你要安装……？开发程序需要库，图像处理，视频处理，人工智能之类大部分库都是只支持 Unix/Linux 的。Mac 基于 Unix，所以这些通通都和 Mac 能很好和睦相处。</p>
<p>3、编辑器 Vi/Emac。作为 程序员/IT 人员一个好用的编辑器太重要了，因为写程序/改系统配置都需要编辑器。我在 Mac 上差不多1/2的时间是 browser/email，另外1/2时间差不多就是 Vi 了。</p>
<p>4、没有病毒/木马。用了5年多的 Mac 就没看到病毒长成什么样，我还看不到 Mac 上装杀毒软件的需要。</p>
<p>5、不需要维护。Mac 买来就直接用，磁盘碎片整理？不需要。装驱动？Mac 装好了，驱动就好了。重装系统？我5年没有重装过一次（期间换了几次不同的 Mac）。</p>
<p>6、简洁。Mac 上所有的操作都简洁到了极致，尽量避免干扰用户，增加了程序员的生产力。比如切换无线网功能，在 Mac 上切换只需要1次鼠标点击就可以完成，在 windows 上需要点击多次鼠标（包括一些很愚蠢的确认对话框）；再比如卸载 USB 盘，Mac 只需要1次鼠标点击，windows 至少需要点击右下角图标、停止设备、确认对话框等多次点击。</p>
<p>7、多窗口切换。这个很方便管理打开的程序/文档。我经常要在多个虚拟窗口切换，比如看浏览网页/邮件一个窗口，写程序/文档一个窗口。</p>
<p>8、程序员文化。国外程序员是以 Unix 为主流成长起来的。这一点和国内不同，中国程序员/开发人员大都是从90年代的 DOS 开始的，随着 Windows 的壮大，成长了一批使用 Microsoft 工具的程序员。这也解释了为什么自从 Mac 切换到 Unix 阵营后，Mac 会发展这么快。基于 Unix 的 Mac 一经推出后，迅速赢得了一大批老 Unix hacker 和新 Web 2.0/Linux hacker 的关注，正是因为这些忠实的 fans 影响了他们的人际网络，圈子，博客，从而影响了整个程序员文化。有点像 Ruby on Rails，开始是一小部分人（精英人士）试用，这些人感觉不错就在博客，研讨会等各种场合鼓吹，从而在 Web 开发领域刮起一阵 Ruby 风。</p>
<p>9、苹果很酷。每台电脑，每个系列都设计完美，从包装盒，宣传册，广告，电源线，电脑内部，电脑外观，电脑软件都精心设计，风格统一。甚至微小到螺丝，看过苹果机箱上的螺丝，机箱里面的数据线吗？那个也是设计。每个 Mac 上都标记着：Designed by Apple in California，而不是 Desgined in USA，苹果就是这么酷，“我们是一家加州公司”。苹果的保密措施可以说做到了极致，产品官方不发售就在市场上看不到踪影。</p>
<p>10、企业家精神。苹果的传奇经历吸引了大批硅谷创业者，Apple/Google/Microsoft/Amazon/eBay/Yahoo 代表了创新，进取的企业家精神。这不是一个大原因，但可以看作是 Mac 在国外，尤其是在美国，尤其是在硅谷，尤其是在大学这么流行的一个小原因吧。据调查2007年美国大学 Mac 市场占有率第一，这些大学精英们毕业以后走上工作岗位，走上社会，再过几年其中一部分走入中层，走进高层，他们会如何影响 Mac 呢？</p>
<p>如果对于类似讨论有兴趣可以看看 VPSee 在 Top Language 讨论组上的回复：<a href="http://www.vpsee.com/2010/05/re-tl-why-choose-a-mac/" target="_blank" rel="noopener">[TL] Re: [初级] 为何要选择 Mac？</a>对了，你如果还是对上面那张图片有所怀疑的话，可以看看下面这张图片，来自最近的 <a href="http://techcrunch.com/2010/05/22/over-300-battle-at-disrupt-hackathon/" target="_blank" rel="noopener">TechCrunch Hacker 大会</a>。</p>
<p><img src="http://static.cyblogs.com/hackathon.jpg" alt="http://static.cyblogs.com/hackathon.jpg"></p>
<p>而最经典的就是下面的评论，可以看好久好久~   点击阅读原文。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.vpsee.com/2009/06/why-programmers-love-mac" target="_blank" rel="noopener">https://www.vpsee.com/2009/06/why-programmers-love-mac</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>京东 Nginx 平台化实践</title>
    <url>/2020/01/04/2020/01/%E4%BA%AC%E4%B8%9C%20Nginx%20%E5%B9%B3%E5%8F%B0%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>Nginx 是优秀的 HTTP 和反向代理服务器，京东各部门都在广泛使用，但普遍都面临着一些问题：</p>
<ol>
<li>配置复杂，专业性强。</li>
<li>配置文件无法批量修改且配置变更依赖重启操作。</li>
<li>不同应用依赖不同模块、配置项，管理混乱。</li>
<li>同一应用的 Nginx 无法批量、快速扩容。</li>
</ol>
<p>所有问题的根源在于 Nginx 是一个单机系统，虽然模块化、高性能，但在互联网高速发展的今天，像京东这样拥有大规模 Nginx、业务集群的场景下，所有问题都有可能被无限放大，针对这种现状我们设计研发了 JEN（JD EXTENDED NGINX），截止目前 JEN 已覆盖京东金融大部分核心业务，如夺宝吧，卡超市，白条等。</p>
<h4 id="一、整体结构"><a href="#一、整体结构" class="headerlink" title="一、整体结构"></a>一、整体结构</h4><p><img src="https://static001.infoq.cn/resource/image/10/71/1093915db6a8b308f7c07353e1f70c71.png" alt="京东Nginx平台化实践"></p>
<p>图 1：JEN 结构图</p>
<p>如上图，运维通过 Web 控制台做相应的配置操作，若是分流、限流等配置，则信息入库等待 Nginx 通过 Restful API 同步规则后开始生效；若是平滑升级、重启等强运维性操作，则 Web 控制台通过控制 Ansible 对 Nginx 进行相应操作。</p>
<p><img src="https://static001.infoq.cn/resource/image/b9/99/b93c343d7eb05fec4cb98733e312fc99.png" alt="京东Nginx平台化实践"></p>
<p>图 2：Nginx 和 Web 控制台多机房部署图</p>
<p>JEN 特点：</p>
<ol>
<li>支持 Nginx 自动发现，分组管理，状态监控。</li>
<li>统一入口，通过抽象配置，简化操作管控 Nginx 集群生命周期，并支持规则批量配置，操作批量执行。</li>
<li>扩展了原生 Nginx 的分流、限流功能，支持规则的内存实时同步，无需修改配置文件，更无需重启 Nginx 进程。</li>
</ol>
<h5 id="1-基础信息"><a href="#1-基础信息" class="headerlink" title="1. 基础信息"></a>1. 基础信息</h5><p><strong>Web 上所有的展示和操作全部基于对基础信息的计算整合</strong>，主要包含两类：</p>
<ol>
<li>分组信息（业务线、应用、机房、Nginx IP）</li>
<li>Nginx 属性，例如 upstream 信息，server_name，listen_port 等，主要来源 Nginx 读取 Nginx.conf 内容后的信息上报（心跳）</li>
</ol>
<p>对于分组信息，JEN 支持以下两种方式填充：</p>
<ol>
<li>调用外部服务的 Restful API 导入完整的基础信息。</li>
<li>对自动发现的 Nginx 做分组的手工编辑。</li>
</ol>
<p><img src="https://static001.infoq.cn/resource/image/4c/47/4c07bedd4a9c985d9db3280465ae7547.png" alt="京东Nginx平台化实践"></p>
<p>图 3：各分组间关系图</p>
<p>如上图，分组包括业务线、应用、机房、Nginx 共四层关系，在大规模集群环境下可以通过这种关系并结合 Nginx 属性，支持对所有操作的批量执行，如批量修改配置文件，批量升级重启等，解放生产力。</p>
<h5 id="2-规则获取"><a href="#2-规则获取" class="headerlink" title="2. 规则获取"></a>2. 规则获取</h5><p>用户在 Web 控制台配置后，在 Nginx 端我们实现了全异步的模块支持定时向 Web 获取属于当前 Nginx 的规则信息，规则存储内存，即时生效，其中：</p>
<p>​    a）规则信息每个进程存储一份，避免进程间资源共享导致锁竞争。</p>
<p>​    b）版本号设计，保证规则和心跳的绝对顺序，不因丢包、延迟等网络因素导致版本错乱，而且在规则未变更时 Nginx 无需频繁解析大量规则信息而消耗 CPU 资源。</p>
<h5 id="3-安全"><a href="#3-安全" class="headerlink" title="3. 安全"></a>3. 安全</h5><p>JEN 支持三类角色，每种角色支持不同的操作权限（默认是普通用户角色，无写权限），任何角色对 Web 的任何操作都会被记录，并在 Web 提供了入口支持多维度操作日志查询，便于审计</p>
<h5 id="4-监控"><a href="#4-监控" class="headerlink" title="4. 监控"></a>4. 监控</h5><p>我们实现了更为全面的监控信息采集与展示，包括：</p>
<p>​    a）扩展了 tengine 的主动探测模块，支持上游服务器的平均、当前延时统计。</p>
<p>​    b）通过与 Web 的心跳保持支持 Nginx 存活状态监控。</p>
<p>​    c）支持 TCP 连接信息，in/out 流量，QPS，1xx 到 5xx 回应报文等信息监控。</p>
<p>以上的监控信息支持分组统计（业务线、应用、机房）和大屏展示，便于相关人员（业务，运维）实时监控应用状态。</p>
<h4 id="二、分流"><a href="#二、分流" class="headerlink" title="二、分流"></a>二、分流</h4><p>概念：根据请求特征（IP，header 中任意关键字）支持把某些特定请求分流到单个或多个上游服务器中，如下图：</p>
<p><img src="https://static001.infoq.cn/resource/image/3a/2a/3a4f504f6736a62b83d9d0b863b14f2a.png" alt="京东Nginx平台化实践"></p>
<p>图 4：分流示例图</p>
<p>分流主要适用灰度发布，ab testing 等场景，另外我们也对分流功能做了扩展，支持 Web 控制台一键启停上游服务器，便于当应用服务器需要维护或升级时，用户请求正常访问。</p>
<h4 id="三、限流"><a href="#三、限流" class="headerlink" title="三、限流"></a>三、限流</h4><p>京东 618 等大促，货物都提前堆积在购物车，等待零点秒杀，换成工程师的语言来说，就是前一秒的 QPS 很低，但是下一秒 QPS 非常高，流量大意味着机器负载高，若一个应用的一两台机器没有扛住，这样就会导致整个应用集群雪崩。</p>
<p>限流不可盲目，首先需要根据业务特点选择合适的限流算法（漏桶算法、令牌桶算法），其次需要结合历史流量、应用服务能力、营销力度等因素综合评定限流参数，最后决定以何种优雅的方式反馈用户。</p>
<p>Nginx 在实现上通过共享内存共享限流中间信息的方式来达到多进程间的状态统一。在 JEN 设计初衷，原本计划和分流一致，即每个进程存储一份限流规则，限流只在当前进程内限流，但不可避免的会出现如下问题：</p>
<ol>
<li>每个进程“你限你的，我限我的”，信息不一致进而导致限流不准确。</li>
<li>类似用户 ID 的限流，在京东这样拥有庞大日活用户的场景下，每个进程需要开辟足够大的内存才能避免限流算法中对于红黑树节点的频繁置换，这样一来 Nginx 占用内存就会随着进程数成倍扩大。</li>
</ol>
<p>我们的做法：</p>
<ol>
<li>预分配共享内存，Nginx 获取到限流规则时动态适配一块共享内存。</li>
<li>规则共享，生效后实时同步至所有进程，规则链保证所有旧版本规则只有在当前流量更新之后才会删除，如下图：</li>
</ol>
<p><img src="https://static001.infoq.cn/resource/image/49/43/4922c60a2c03ba60f9196ab1629c6f43.png" alt="京东Nginx平台化实践"></p>
<p>图 5：规则链</p>
<p>我们在限流功能上的几点扩展：</p>
<ol>
<li><p>支持错误页定制，除了返回 Nginx 静态页，还支持 302 错误页重定向，根据在 Web 控制台的配置可以重定向到任何外部链接，但 302 重定向存在一个问题：用户浏览器的 URL 和内容都发生了变更，意味着用户需要重新输入 URL 重新请求或者是重复之前的操作步骤，用户体验差可能导致用户放弃此次购买行为而转投它家。在逻辑上我们通过 Nginx 的 subrequest 机制支持返回内容发生变更而 URL 保持不变，这样一来每当用户被限流，只需重新刷新页面即可重复之前的操作步骤。</p>
<p><img src="https://static001.infoq.cn/resource/image/b6/83/b67e5cad9dd073337ff98a3556f51e83.png" alt="京东Nginx平台化实践"></p>
<p>图 6：两种错误页对比</p>
</li>
<li><p>通过扩展限流算法支持限流后一段时间不可用，例如按 IP 限流且某个 IP 已经触发限流，则支持该 IP 一段时间内不可访问，无需重新通过算法计算。</p>
</li>
<li><p>同步实现了黑名单、白名单功能，通过白名单避免一些复杂场景下的限流“误杀”（例如 nat 网络下按 ip 限流）。</p>
</li>
</ol>
<h4 id="四、运维特性"><a href="#四、运维特性" class="headerlink" title="四、运维特性"></a>四、运维特性</h4><p>运维特性主要指 Nginx 的安装、升级、配置文件修改、启停等操作，运维特性与之前介绍内容的最大区别在于需要重启操作，所以结合第三方工具 Ansible 是比较合适的想法（Ansible 相对于 Puppet 等运维工具，其迁移成本相对较小）。</p>
<p>在实际生产中 Ansible 和 Web 为避免单点需要集群部署，我们的方案是：Web 和 Ansible 在同一 PC 上部署，相关数据改用 DB 存储替代 Ansible 本地文件存储，通过这种简单的改造可以方便 Ansible 和 Web 这组“套件”进行扩容。</p>
<p><img src="https://static001.infoq.cn/resource/image/a6/89/a62d97e491d50b1f70c7af425d37ec89.png" alt="京东Nginx平台化实践"></p>
<p>图 7：自动化运维操作逻辑图</p>
<p>如上图，用户通过 Web 操作控制 Ansible 对 Nginx 进行升级、重启等操作，Web 是 Nginx 操作的统一入口，这是平台化的重要意义所在，可以放弃 SSH，Shell 甚至是监控系统，开始在 JEN 自给自足了。</p>
<p>通过主动拉取或者是用户在页面导入、手工配置，JEN 会为所有 Nginx 存储配置文件，这样不仅原本因为每个应用都依赖不同的配置项而导致管理混乱的局面得到了改善，而且也可以方便的对配置文件做些扩展，例如历史记录追溯，配置比对，配置复用，操作回滚等。</p>
<p>在页面执行相关操作时，Web 会读取 Ansible 的标准输出并在页面实时展示，为了让使用者以相对友好的方式获知进度我们对 Ansible 做了优化：</p>
<ol>
<li>丰富了标准输出的内容，尽量细化到每一个步骤。</li>
<li>格式化标准输出，便于 Web 获取和展示。</li>
</ol>
<p>Nginx 在生产环境大规模部署，倘若因为一些原因导致 Nginx 大规模异常，这是我们不希望看到的，所以在可靠性方面，JEN 也提供了多种机制来保证：</p>
<ol>
<li><p>三层错误校验，保证只有在完全正确的情况下才会重启和更新进程，中途发生任何错误不影响线上服务</p>
<p>a）在 Web 填充表单时做第一层校验。</p>
<p>b）在目标机器做操作时做第二层检测，例如先执行 Nginx –t 校验。</p>
<p>c）执行完毕做第三层校验，例如端口是否启动，进程数是否一致等。</p>
</li>
<li><p>灰度执行</p>
<p>a）单个 Nginx 依次执行，有任何异常立即中断开始人工介入。</p>
<p>b）按百分比支持批量执行，例如某个机房的 Nginx 先升级 10%。</p>
</li>
</ol>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>以上整理了京东在 Nginx 平台化方面的一些实践，JEN 提供了统一入口管控整个 Nginx 生命周期，并支持规则的批量修改即时生效，我们希望这些实践经验能对所有读者产生帮助。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>从1+1=2来理解Java字节码</title>
    <url>/2020/01/01/2020/01/%E4%BB%8E1+1=2%E6%9D%A5%E7%90%86%E8%A7%A3Java%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>前不久《深入理解Java虚拟机》第三版发布了，赶紧买来看了看新版的内容，这本书更新了很多新版本虚拟机的内容，还对以前的部分内容进行了重构，还是值得去看的。本着复习和巩固的态度，我决定来编译一个简单的类文件来分析Java的字节码内容，来帮助理解和巩固Java字节码知识，希望也对阅读本文的你有所帮助。</p>
<blockquote>
<p>说明：本次采用的环境是OpenJdk12</p>
</blockquote>
<h4 id="编译“1-1”代码"><a href="#编译“1-1”代码" class="headerlink" title="编译“1+1”代码"></a>编译“1+1”代码</h4><p>首先我们需要写个简单的小程序，1+1的程序，学习就要从最简单的1+1开始，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.luozhou.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: luozhou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-12-25 21:28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJava</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>+<span class="number">1</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写好java类文件后，首先执行命令<code>javac TestJava.java</code> 编译类文件，生成<code>TestJava.class</code>。 然后执行反编译命令<code>javap -verbose TestJava</code>，字节码结果显示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Compiled from <span class="string">"TestJava.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">top</span>.<span class="title">luozhou</span>.<span class="title">test</span>.<span class="title">TestJava</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">56</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#14         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #15.#16        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #17.#18        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #4 = Class              #19            // top/luozhou/test/TestJava</span><br><span class="line">   #5 = Class              #20            // java/lang/Object</span><br><span class="line">   #6 = Utf8               &lt;init&gt;</span><br><span class="line">   #7 = Utf8               ()V</span><br><span class="line">   #8 = Utf8               Code</span><br><span class="line">   #9 = Utf8               LineNumberTable</span><br><span class="line">  #10 = Utf8               main</span><br><span class="line">  #11 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #12 = Utf8               SourceFile</span><br><span class="line">  #13 = Utf8               TestJava.java</span><br><span class="line">  #14 = NameAndType        #6:#7          // "&lt;init&gt;":()V</span><br><span class="line">  #15 = Class              #21            // java/lang/System</span><br><span class="line">  #16 = NameAndType        #22:#23        // out:Ljava/io/PrintStream;</span><br><span class="line">  #17 = Class              #24            // java/io/PrintStream</span><br><span class="line">  #18 = NameAndType        #25:#26        // println:(I)V</span><br><span class="line">  #19 = Utf8               top/luozhou/test/TestJava</span><br><span class="line">  #20 = Utf8               java/lang/Object</span><br><span class="line">  #21 = Utf8               java/lang/System</span><br><span class="line">  #22 = Utf8               out</span><br><span class="line">  #23 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #24 = Utf8               java/io/PrintStream</span><br><span class="line">  #25 = Utf8               println</span><br><span class="line">  #26 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> top.luozhou.test.TestJava();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_2</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         2: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         6: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解析字节码"><a href="#解析字节码" class="headerlink" title="解析字节码"></a>解析字节码</h4><p><strong>1.基础信息</strong></p>
<p>上述结果删除了部分不影响解析的冗余信息，接下来我们便来解析字节码的结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> minor version: 0 次版本号，为0表示未使用</span><br><span class="line"> major version: 56 主版本号，56表示jdk12，表示只能运行在jdk12版本以及之后的虚拟机中</span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br></pre></td></tr></table></figure>

<p><code>ACC_PUBLIC</code>:这就是一个是否是public类型的访问标志。</p>
<p><code>ACC_SUPER</code>: 这个falg是为了解决通过 <code>invokespecial</code> 指令调用 super 方法的问题。可以将它理解成 Java 1.0.2 的一个缺陷补丁，只有通过这样它才能正确找到 super 类方法。从 Java 1.0.2 开始，编译器始终会在字节码中生成 ACC_SUPER 访问标识。感兴趣的同学可以点击<a href="https://bugs.openjdk.java.net/browse/JDK-6527033" target="_blank" rel="noopener">这里</a>来了解更多。</p>
<p><strong>2.常量池</strong></p>
<p>接下来，我们将要分析常量池,你也可以对照上面整体的字节码来理解。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#1 = Methodref          #5.#14         // java/lang/Object."&lt;init&gt;":()V</span><br></pre></td></tr></table></figure>

<p>这是一个方法引用，这里的<code>#5</code>表示索引值，然后我们可以发现索引值为5的字节码如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#5 = Class              #20            // java/lang/Object</span><br></pre></td></tr></table></figure>

<p>它表示这是一个<code>Object</code>类，同理<code>#14</code>指向的是一个<code>&quot;&quot;:()V</code>表示引用的是初始化方法。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#2 = Fieldref           #15.#16        // java/lang/System.out:Ljava/io/PrintStream;</span><br></pre></td></tr></table></figure>

<p>上面这段表示是一个字段引用，同样引用了<code>#15</code>和<code>#16</code>,实际上引用的就是<code>java/lang/System</code>类中的<code>PrintStream</code>对象。其他的常量池分析思路是一样的，鉴于篇幅我就不一一说明了，只列下其中的几个关键类型和信息。</p>
<p><code>NameAndType</code>:这个表示是名称和类型的常量表，可以指向方法名称或者字段的索引，在上面的字节码中都是表示的实际的方法。</p>
<p><code>Utf8</code>：<strong>我们经常使用的是字符编码，但是这个不是只有字符编码的意思</strong>，它表示一种字符编码是<code>Utf8</code>的字符串。它是虚拟机中最常用的表结构，你可以理解为它可以描述方法，字段，类等信息。 比如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#4 = Class              #19 </span><br><span class="line">#19 = Utf8               top/luozhou/test/TestJava</span><br></pre></td></tr></table></figure>

<p>这里表示<code>#4</code>这个索引下是一个类，然后指向的类是<code>#19</code>,<code>#19</code>是一个<code>Utf8</code>表，最终存放的是<code>top/luozhou/test/TestJava</code>,那么这样一连接起来就可以知道<code>#4</code>位置引用的类是<code>top/luozhou/test/TestJava</code>了。</p>
<p><strong>3.构造方法信息</strong></p>
<p>接下来，我们分析下构造方法的字节码，我们知道，一个类初始化的时候最先执行它的构造方法，如果你没有写构造方法，系统会默认给你添加一个无参的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> top.luozhou.test.TestJava();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><code>descriptor: ()V</code> :表示这是一个没有返回值的方法。</p>
<p><code>flags: ACC_PUBLIC</code>:是公共方法。</p>
<p><code>stack=1, locals=1, args_size=1</code> :表示栈中的数量为1，局部变量表中的变量为1，调用参数也为1。</p>
<p>这里为什么都是1呢？这不是默认的构造方法吗？哪来的参数？其实Java语言有一个潜规则：<strong>在任何实例方法里面都可以通过<code>this</code>来访问到此方法所属的对象</strong>。而这种机制的实现就是通过Java编译器在编译的时候作为入参传入到方法中了，熟悉<code>python</code>语言的同学肯定会知道，在<code>python</code>中定义一个方法总会传入一个<code>self</code>的参数,这也是传入此实例的引用到方法内部，Java只是把这种机制后推到编译阶段完成而已。所以，这里的1都是指<code>this</code>这个参数而已。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="number">0</span>: aload_0</span><br><span class="line">     1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">     <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">LineNumberTable:</span><br><span class="line">    line <span class="number">8</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>经过上面这个分析对于这个构造方法表达的意思也就很清晰了。</p>
<p><code>aload_0</code>:表示把局部变量表中的第一个变量加载到栈中，也就是<code>this</code>。</p>
<p><code>invokespecial</code>:直接调用初始化方法。</p>
<p><code>return</code>:调用完毕方法结束。</p>
<p><code>LineNumberTable:</code>这是一个行数的表，用来记录字节码的偏移量和代码行数的映射关系。<code>line 8: 0</code>表示，源码中第8行对应的就是偏移量<code>0</code>的字节码，因为是默认的构造方法，所以这里并无法直观体现出来。</p>
<p>另外这里会执行<code>Object</code>的构造方法是因为，<code>Object</code>是所有类的父类，子类的构造要先构造父类的构造方法。</p>
<p><strong>4.main方法信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_2</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         2: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         <span class="number">5</span>: iload_1</span><br><span class="line">         6: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>有了之前构造方法的分析，我们接下来分析<code>main</code>方法也会熟悉很多，重复的我就略过了，这里重点分析<code>code</code>部分。</p>
<p><code>stack=2, locals=2, args_size=1</code>:这里的栈和局部变量表为2，参数还是为1。这是为什么呢？因为<code>main</code>方法中声明了一个变量<code>a</code>,所以局部变量表要加一个，栈也是，所以他们是2。那为什么<code>args_size</code>还是1呢？你不是说默认会把<code>this</code>传入的吗？应该是2啊。<strong>注意：之前说的是在任何实例方法中，而这个main方法是一个静态方法，静态方法直接可以通过类+方法名访问，并不需要实例对象，所以这里就没必要传入了</strong>。</p>
<p><code>0: iconst_2</code>:将<code>int</code>类型2推送到栈顶。</p>
<p><code>1: istore_1</code>:将栈顶<code>int</code>类型数值存入第二个本地变量。</p>
<p><code>2: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream;</code>:获取<code>PrintStream</code>类。</p>
<p><code>5: iload_1</code>: 把第二个<code>int</code>型本地变量推送到栈顶。</p>
<p><code>6: invokevirtual #3 // Method java/io/PrintStream.println:(I)V</code>:调用<code>println</code>方法。</p>
<p><code>9: return</code>:调用完毕结束方法。</p>
<p>这里的<code>LineNumberTable</code>是有源码的，我们可以对照下我前面描述是否正确： <img src="http://static.cyblogs.com/sourceCode.png" alt="img"></p>
<p><code>line 10: 0</code>: 第10行表示<code>0: iconst_2</code>字节码，这里我们发现编译器直接给我们计算好了把2推送到栈顶了。</p>
<p><code>line 11: 2</code>:第11行源码对应的是<code>2: getstatic</code> 获取输出的静态类<code>PrintStream</code>。</p>
<p><code>line 12: 9</code>:12行源码对应的是<code>return</code>，表示方法结束。</p>
<p>这里我也画了一个动态图片来演示<code>main</code>方法执行的过程，希望能够帮助你理解： <img src="http://static.cyblogs.com/main%E6%96%B9%E6%B3%95gif.gif" alt="img"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这篇文章我从1+1的的源码编译开始，分析了生成后的Java字节码，包括类的基本信息，常量池，方法调用过程等，通过这些分析，我们对Java字节码有了比较基本的了解，也知道了Java编译器会把优化手段通过编译好的字节码体现出来，比如我们的1+1=2，字节码字节赋值一个2给变量，而不是进行加法运算，从而优化了我们的代码，提搞了执行效率。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://bugs.openjdk.java.net/browse/JDK-6527033" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-6527033</a></li>
</ol>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的了解Lambda表达式么？</title>
    <url>/2020/01/05/2020/01/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="lambda表达式实战"><a href="#lambda表达式实战" class="headerlink" title="lambda表达式实战"></a>lambda表达式实战</h4><h5 id="从例子引出lambda"><a href="#从例子引出lambda" class="headerlink" title="从例子引出lambda"></a>从例子引出lambda</h5><blockquote>
<p>传递Runnable创建Thread</p>
</blockquote>
<ul>
<li>java8之前</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>java 8 之后</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上边的例子比较简单，但是有两个疑问。<strong>什么是</strong>Lambda表达式？<strong>怎么使用</strong>lambda表达式？</p>
</blockquote>
<h4 id="什么是Lambda表达式？"><a href="#什么是Lambda表达式？" class="headerlink" title="什么是Lambda表达式？"></a>什么是Lambda表达式？</h4><blockquote>
<p>从上述例子入手，首先我们知道<strong>Lambda一般代表的是一个匿名对象</strong>；其次我们点击“-&gt;”,IDE会帮助我们进入到符合Lambda规范的函数接口。我们来观察下这个符合规范的类的变化。</p>
</blockquote>
<ul>
<li>java7 <a href="https://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/a48fd0b4f7b1/src/share/classes/java/lang/Runnable.java" target="_blank" rel="noopener">Runnable</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略注释</span></span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>java8 <a href="https://hg.openjdk.java.net/jdk8u/hs-dev/jdk/file/3eb4e20b34cb/src/share/classes/java/lang/Runnable.java" target="_blank" rel="noopener">Runnable</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略注释</span></span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们发现java8后Runnable接口新增了一个注解@FunctionalInterface。下边我们一起来看下这个注解是什么。</p>
</blockquote>
<h5 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="FunctionalInterface"></a>FunctionalInterface</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An informative annotation type used to indicate that an interface</span></span><br><span class="line"><span class="comment"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span></span><br><span class="line"><span class="comment"> * defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class="line"><span class="comment"> * method.  Since &#123;<span class="doctag">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment"> * default methods&#125; have an implementation, they are not abstract.  If</span></span><br><span class="line"><span class="comment"> * an interface declares an abstract method overriding one of the</span></span><br><span class="line"><span class="comment"> * public methods of &#123;<span class="doctag">@code</span> java.lang.Object&#125;, that also does</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count</span></span><br><span class="line"><span class="comment"> * since any implementation of the interface will have an</span></span><br><span class="line"><span class="comment"> * implementation from &#123;<span class="doctag">@code</span> java.lang.Object&#125; or elsewhere.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class="line"><span class="comment"> * lambda expressions, method references, or constructor references.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a type is annotated with this annotation type, compilers are</span></span><br><span class="line"><span class="comment"> * required to generate an error message unless:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;However, the compiler will treat any interface meeting the</span></span><br><span class="line"><span class="comment"> * definition of a functional interface as a functional interface</span></span><br><span class="line"><span class="comment"> * regardless of whether or not a &#123;<span class="doctag">@code</span> FunctionalInterface&#125;</span></span><br><span class="line"><span class="comment"> * annotation is present on the interface declaration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 4.3.2. The Class Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.8 Functional Interfaces</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.4.3 Interface Method Body</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上边文档的核心意思是：@FunctionInterface注解是为了表明这个类是一个函数式接口。</li>
<li>函数式接口有这样的特点：只有一个抽象方法。java8提供了default方法，以及超类Object中的方法(toString,Equals),这些方法不计算抽象方法数量的统计中。</li>
<li>使用上：函数式接口可以配合<strong>lambda表达式</strong>、<strong>方法引用</strong>、<strong>构造引用使用</strong>。</li>
<li>如果类上标记了这个注解，编译器会在编译期进行检查</li>
<li>最后，<strong>即使我们没有标注这个注解，编译器也会将它看待成一个函数式接口</strong></li>
</ul>
<blockquote>
<p>好了，从上边我们知道了lambda的特点，接下来我们来聊下怎么使用?</p>
</blockquote>
<h4 id="如何使用Lambda"><a href="#如何使用Lambda" class="headerlink" title="如何使用Lambda"></a>如何使用Lambda</h4><blockquote>
<p>首先，我们去官网查阅Java8<a href="https://docs.oracle.com/javase/8/" target="_blank" rel="noopener">新特性</a>，找到<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda表达式</a>的说明。我们从这个文档的<strong>“Syntax of Lambda Expressions”</strong>部分入手，大概可以得到如下的结论。</p>
</blockquote>
<h5 id="Lambda的组成"><a href="#Lambda的组成" class="headerlink" title="Lambda的组成"></a>Lambda的组成</h5><blockquote>
<p>Lambda主要由下边几部分组成;参数列表，连接符，主体。</p>
</blockquote>
<ul>
<li><p>参数列表</p>
<ul>
<li>圆括号内部，参数以“,”分割开来。如(String a,Object b)。</li>
<li>此外，参数的类型和括号，有些时候是<strong>可以省略</strong></li>
</ul>
</li>
<li><p>箭头记号</p>
<ul>
<li>通过“-&gt;”这种特殊符号形式，连接前后。</li>
</ul>
</li>
<li><p>主体</p>
<ul>
<li><p>可以由单个表达式，或者语句块组成。</p>
</li>
<li><p>单个表达式，如”System.out.println(“xxx”)”</p>
</li>
<li><p>语句块</p>
<ul>
<li>示例1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	System.out.println(<span class="string">"xxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例2</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// do something return some result</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="Lambda的完整用法示例"><a href="#Lambda的完整用法示例" class="headerlink" title="Lambda的完整用法示例"></a>Lambda的完整用法示例</h5><h6 id="无返回值的lambda的用例"><a href="#无返回值的lambda的用例" class="headerlink" title="无返回值的lambda的用例"></a>无返回值的lambda的用例</h6><blockquote>
<p>目的，将具体业务实现交给调用者处理。</p>
</blockquote>
<ul>
<li>定义一个无返回值，符合FunctionInterface规范的接口对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Print</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">(String string)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用示例1"><a href="#使用示例1" class="headerlink" title="使用示例1"></a>使用示例1</h6><blockquote>
<p>我这里的业务逻辑是根据输入参数，执行日志打印操作。实际业务场景下，可能对应的是发送邮件或者MQ这样的具体操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintSomeThing(name-&gt;System.out.println(name),<span class="string">"Hello baigt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintSomeThing</span><span class="params">(Print&lt;String&gt; str,String name)</span> </span>&#123;</span><br><span class="line">        str.printName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用示例1-的延伸使用"><a href="#使用示例1-的延伸使用" class="headerlink" title="使用示例1 的延伸使用"></a>使用示例1 的延伸使用</h6><ul>
<li>定义 一个使用类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doctor</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String interest;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Doctor</span><span class="params">(String name, String interest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.interest = interest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(Print&lt;String&gt; str)</span> </span>&#123;</span><br><span class="line">            str.printName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Doctor doctor=<span class="keyword">new</span> Doctor(<span class="string">"baigt"</span>,<span class="string">"java and javascript"</span>);</span><br><span class="line">doctor.printName(name-&gt;System.out.println(name));</span><br></pre></td></tr></table></figure>

<h5 id="有返回值的lambda的用例"><a href="#有返回值的lambda的用例" class="headerlink" title="有返回值的lambda的用例"></a>有返回值的lambda的用例</h5><blockquote>
<p>目的，将具体业务实现交给调用者处理，并将结果返回。</p>
</blockquote>
<ul>
<li>定义一个有返回值，符合FunctionInterface规范的接口对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GetSomething</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getThing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义一个使用者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doctor</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String interest;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Doctor</span><span class="params">(String name, String interest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.interest = interest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInterest</span><span class="params">(GetSomething&lt;String&gt; get)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get.getThing()+<span class="string">","</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用示例</li>
</ul>
<blockquote>
<p>我这里的业务逻辑是根据输入参数(隐式interest)，计算出一个结果返回出来，并对这个结果执行打印操作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Doctor doctor=<span class="keyword">new</span> Doctor(<span class="string">"baigt"</span>,<span class="string">"java and javascript"</span>);</span><br><span class="line">System.out.println(doctor.getInterest(() -&gt; <span class="string">"Hi"</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到此处，我们已经大概明白lambda表达式的基本用法。但是还会有两个疑问？</p>
</blockquote>
<ul>
<li>上边例子我们自定义了几个函数式接口，那么还有其他常用的函数式接口？</li>
<li>函数式接口不仅可以通过lambda表达式使用，还可以通过方法引用和构造引用来使用。那么这种引用又是怎么回事？</li>
</ul>
<h4 id="常用函数接口"><a href="#常用函数接口" class="headerlink" title="常用函数接口"></a>常用函数接口</h4><blockquote>
<p>我们选中@FunctionInterface注解类，通过Ide的Find Usages功能，会发现在java.util.function包下java8新增了很多类。这里挑几个基础的(其他的基本是功能上的增强或变种)来说。大致上有这么几种。</p>
</blockquote>
<ul>
<li>Consumer</li>
<li>Supplier</li>
<li>Predicate</li>
<li>Function</li>
</ul>
<blockquote>
<p>下边会做一个简单的说明和使用。可能不会细致的去讲每一个Api。旨在让大家快速熟悉使用java8 lambda。</p>
</blockquote>
<h5 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation that accepts a single input argument and returns no</span></span><br><span class="line"><span class="comment"> * result. Unlike most other functional interfaces, &#123;<span class="doctag">@code</span> Consumer&#125; is expected</span></span><br><span class="line"><span class="comment"> * to operate via side-effects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #accept(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the operation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先此接口只有一个抽象方法accept，<strong>该方法接收一个入参，不返回结果</strong>。</p>
</blockquote>
<h5 id="定义使用类"><a href="#定义使用类" class="headerlink" title="定义使用类"></a>定义使用类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doConsumer</span><span class="params">(Consumer consumer,String input)</span> </span>&#123;</span><br><span class="line">    consumer.accept(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用示例1</li>
</ul>
<blockquote>
<p>接收 “something input”输入，并执行打印操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer consumer = input -&gt; System.out.println(input);</span><br><span class="line">doConsumer(consumer,<span class="string">"something input"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用示例2</li>
</ul>
<blockquote>
<p>将两个Consumer操作串连起来，andThen的后执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer consumer = input -&gt; System.out.println(input);</span><br><span class="line">doConsumer(consumer.andThen(input2-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"input2"</span>);</span><br><span class="line">        &#125;),<span class="string">"something input"</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a supplier of results.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is no requirement that a new or distinct result be returned each</span></span><br><span class="line"><span class="comment"> * time the supplier is invoked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #get()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of results supplied by this supplier</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先此接口只有一个抽象方法get，<strong>该方法不接收参数，返回一个T类型的结果</strong>。</p>
</blockquote>
<h5 id="定义使用类-1"><a href="#定义使用类-1" class="headerlink" title="定义使用类"></a>定义使用类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">doSupplier</span><span class="params">(Supplier&lt;T&gt; supplier)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> supplier.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用示例1</li>
</ul>
<blockquote>
<p>不传入参数，生成一个指定类型为String或Integer的对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(doSupplier(() -&gt; <span class="string">"baigt"</span>));</span><br><span class="line">System.out.println(doSupplier(() -&gt; &#123;<span class="keyword">return</span> Integer.valueOf(<span class="string">"10"</span>);&#125;));</span><br></pre></td></tr></table></figure>

<h5 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a predicate (boolean-valued function) of one argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #test(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the predicate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> false&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ANDed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先此接口只有一个抽象方法test，<strong>该方法接受一个T类型的对象，返回一个boolean类型的结果</strong>。</p>
</blockquote>
<h5 id="定义使用类-2"><a href="#定义使用类-2" class="headerlink" title="定义使用类"></a>定义使用类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doPredicate</span><span class="params">(Predicate&lt;String&gt; predicate,String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> predicate.test(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用示例1</li>
</ul>
<blockquote>
<p>根据条件，判断输入对象是否符合过滤规则。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(doPredicate(input -&gt; input.length() &gt; <span class="number">5</span>, <span class="string">"12345"</span>));</span><br><span class="line">System.out.println(doPredicate(((Predicate&lt;String&gt;) (input -&gt; input.length() &gt; <span class="number">5</span>))</span><br><span class="line">        .and(input -&gt; input.equalsIgnoreCase(<span class="string">"12345"</span>)), <span class="string">"12345"</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function to its input, and then applies this function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of input to the &#123;<span class="doctag">@code</span> before&#125; function, and to the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> before the function to apply before this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment">     * function and then applies this function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if before is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #andThen(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #compose(Function)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a function that always returns its input argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input and output objects to the function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function that always returns its input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先此接口只有一个抽象方法apply，<strong>该方法接收一个T类型对象，返回一个R类型的结果。</strong></p>
</blockquote>
<h5 id="定义使用类-3"><a href="#定义使用类-3" class="headerlink" title="定义使用类"></a>定义使用类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">doFunction</span><span class="params">(Function&lt;String,Integer&gt; function,String input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function.apply(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用示例1</li>
</ul>
<blockquote>
<p>接收一个String类型的入参，返回Integer类型的结果。示例中没做具体异常判断。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(doFunction(input -&gt; input.length(), <span class="string">"baigt"</span>));</span><br><span class="line"><span class="comment">// 上述结果为 5</span></span><br><span class="line"> System.out.println(doFunction(((Function&lt;String, Integer&gt;) (input -&gt; input.length())).compose(input -&gt; String.valueOf(input.length() * <span class="number">3</span>)), <span class="string">"baigt"</span>));</span><br><span class="line"><span class="comment">// 上述结果为 2</span></span><br><span class="line"> System.out.println(doFunction(((Function&lt;String, Integer&gt;) (input -&gt; &#123;</span><br><span class="line">     System.out.println(<span class="string">"notcompose:"</span>+input);</span><br><span class="line">     <span class="keyword">return</span> Integer.valueOf(input)+<span class="number">1</span>;</span><br><span class="line"> &#125;)).compose(input -&gt; &#123;</span><br><span class="line">     System.out.println(<span class="string">"compose:"</span>+input);</span><br><span class="line">     <span class="keyword">return</span> String.valueOf(Integer.valueOf(input)*<span class="number">3</span>);</span><br><span class="line"> &#125;), <span class="string">"22"</span>));</span><br><span class="line"> <span class="comment">// 上述结果为 67</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>compose是先执行的部分，上述例子中，是根据输入参数进行进一步的加工，再作为输入参数传递给具体调用者。</p>
</blockquote>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><blockquote>
<p>前边提到了方法引用和构造引用两种，其实构造引用是一种特殊方法引用。具体参照<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener">官方文档说明</a>中“Kinds of Method References”部分。</p>
</blockquote>
<table>
<thead>
<tr>
<th>种类</th>
<th>用例</th>
</tr>
</thead>
<tbody><tr>
<td>类名::静态方法</td>
<td>String::valueOf</td>
</tr>
<tr>
<td>实例对象::实例方法</td>
<td>doctor1::getInterest</td>
</tr>
<tr>
<td>类名::实例方法</td>
<td>String::toUpperCase</td>
</tr>
<tr>
<td>类名::new (构造引用)</td>
<td>String::new</td>
</tr>
</tbody></table>
<h5 id="静态引用"><a href="#静态引用" class="headerlink" title="静态引用"></a>静态引用</h5><ul>
<li>使用类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doStaticReference</span><span class="params">(Function&lt;Integer,String&gt; function, Integer input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function.apply(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doStaticReference(String::valueOf,<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>

<h5 id="实例对象引用实例方法"><a href="#实例对象引用实例方法" class="headerlink" title="实例对象引用实例方法"></a>实例对象引用实例方法</h5><ul>
<li>使用类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Doctor</span></span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   String interest;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Doctor</span><span class="params">(String name, String interest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">       <span class="keyword">this</span>.interest = interest;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getStringInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Doctor doctor1=<span class="keyword">new</span> Doctor(<span class="string">"baigt007"</span>,<span class="string">"java"</span>);</span><br><span class="line">Supplier&lt;String&gt; instance = doctor1::getInterest;</span><br></pre></td></tr></table></figure>

<h5 id="类引用实例方法"><a href="#类引用实例方法" class="headerlink" title="类引用实例方法"></a>类引用实例方法</h5><ul>
<li>使用类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doMethodReference</span><span class="params">(Function&lt;String,String&gt; function, String input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function.apply(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doMethodReference(String::toUpperCase,<span class="string">"baigt"</span>);O</span><br></pre></td></tr></table></figure>

<h5 id="构造引用"><a href="#构造引用" class="headerlink" title="构造引用"></a>构造引用</h5><ul>
<li>示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;String&gt; stringInstance = String::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<p>原文地址：<a href="https://my.oschina.net/lt0314/blog/3144851" target="_blank" rel="noopener">https://my.oschina.net/lt0314/blog/3144851</a></p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>JDK</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>平台迁移与整合那些事儿？</title>
    <url>/2020/01/06/2020/01/%E5%B9%B3%E5%8F%B0%E8%BF%81%E7%A7%BB%E4%B8%8E%E6%95%B4%E5%90%88%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>迁移了一年，这话真的丝毫没有夸张~</p>
<p>1、从2018年底开始从阿里的HSF迁移到SpringCloud，全面拥抱Spring开源框架；</p>
<p>2、然后就是项目组上海、北京、深圳的项目交接，全部由深圳这边来做业务；</p>
<p>3、后面就是全平台的迁移与整合，包括代码、中间件、数据库、网络等；</p>
<p>4、包括中途发布系统迁移了3~4次，网络从阿里云的经典网络迁移到阿里云的VPC网络；</p>
<p>做这一切都是为了（降本增效）：提高我们的对接效率，节约我们的成本，对接的人员更加的专业与熟练。我个人觉得做这些还是挺有意义的，只是要尽快的结束掉。</p>
<h4 id="项目如何迁移？"><a href="#项目如何迁移？" class="headerlink" title="项目如何迁移？"></a>项目如何迁移？</h4><h5 id="如何建设一个标准统一平台？"><a href="#如何建设一个标准统一平台？" class="headerlink" title="如何建设一个标准统一平台？"></a>如何建设一个标准统一平台？</h5><h6 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h6><p>错综复杂的业务以及以前一些”坑爹“的特殊处理，你想实现平台大统一。谁都是知道是一件很不容易的事情。你系统的包容能力、可拓展能力真的要很强。那如何去实现这些呢？毫无疑问：一套给力的配置中心是少不了的？</p>
<p><strong>方案一：采用MySQL + Redis的方式</strong></p>
<p>优点：以MySQL关系型数据库做基础，用Redis作为缓存提高吞吐。数据库中的配置保持着简单明了，只存储关键节点，一般情况就是Yes or No，再就是具体的值，每次变更完后立马刷新到缓存即可。</p>
<p>缺点：Redis的方式只能通过客户端的拉取，每次修改都要伴随着一个人工或者手动触发的动作。</p>
<p><strong>方案二：采用Zookeeper + MySQL的方式</strong></p>
<p>优点：利用Zookeeper的方式存储数据，能够保证高可用性以及消息能主动推送的效果，然后用MySQL来做降级。</p>
<p>缺点：类似Zookeeper、Diamond的配置中心，是失去关系型查询的能力以及要处理好代码与配置的更新先后顺序。</p>
<p><img src="http://static.cyblogs.com/WX20200113-171033.png" alt="http://static.cyblogs.com/WX20200113-171033.png"></p>
<h6 id="系统编排"><a href="#系统编排" class="headerlink" title="系统编排"></a>系统编排</h6><p>业务、原子能力可编排已经成为搭建中台、平台不可缺少的能力？这是更好的复用底层的最好方式。</p>
<p><strong>方式一：责任链编排</strong></p>
<p>一个比较复杂的业务需要通过好几个系统才能完成。比如：一个还款业务需要贷前、贷中业务的支撑才能保证还款业务的正确执行，起码要经过贷后业务、贷中业务、贷前业务、下游系统等子模块的调用才能把还款计划给冲销掉。</p>
<p>贷前业务：<code>Handler4</code></p>
<p>贷中业务：Handler<code>2</code>、<code>Handler3</code></p>
<p>贷后业务：<code>Handler1</code>、<code>Handler5</code></p>
<p>下游系统：<code>Handler6</code></p>
<p>那么该条业务就是根据某个产品独特的业务特性来编排的：<code>Handler1→Handler2→Handler3→Handler4→Handler5→Handler6</code>。</p>
<p><img src="http://static.cyblogs.com/WX20200114-091359.png" alt="http://static.cyblogs.com/WX20200114-091359.png"></p>
<p>优点：从配置上能够很清晰的看出一个业务的逻辑，并且非常的灵活。其中router-convert-in、router-convert-out、handler-convert-in、handler-convert-out就是一层代理，可以在入口以及每一个原子服务的前后都能做一些事情。</p>
<p>缺点：太灵活，导致没有标准，什么都能做。配置量巨大，对于后期的维护不太友好。</p>
<p>方式二：配置中心</p>
<p><img src="http://static.cyblogs.com/WX20200114-092931.png" alt="http://static.cyblogs.com/WX20200114-092931.png"></p>
<p>每个系统的边界是非常清晰的，因为都是接口来提现你的能力。每个服务接口都要自己保证自己的完整性与一致性。至于某一个业务具体走了多少个<code>Handler</code>是要看产品的配置。</p>
<p>优点：系统能力清晰，边界清晰，代码可读性强。配置小，基本就是Yes or No，再就是一些具体的变量值。</p>
<p>缺点：不够灵活，每一次的功能叠加与优化，都需要走发布流程才能完成。</p>
<h6 id="格转功能"><a href="#格转功能" class="headerlink" title="格转功能"></a>格转功能</h6><p>其实格转这个我们在哪儿都需要，有一段时间在Java的MVC模式下，每一层的数据转换差点就怀疑人生了。其实分层或者叫fullstack的思想都是有它的道理的。每个团队都有他特有的约定或者行业约定，只要大家认可就好，在同一个约定下开发才能你快乐我也快乐。</p>
<ul>
<li>Setter 与 Getter </li>
<li>BeanCopy</li>
<li>@Annotation</li>
<li>一些自定义格转框架</li>
</ul>
<p>用格转的时候，应该从方便性、可维护性、性能方面去考虑，就看你侧重与哪一点？</p>
<h5 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h5><h6 id="项目前期分析"><a href="#项目前期分析" class="headerlink" title="项目前期分析"></a>项目前期分析</h6><p>项目迁移最重要的就是一个风险的评估，需要对之前的系统以及新的系统的差异点要非常的清楚，否则可能会出现盲点造成生产故障。数据迁移一般只包括存量的数量，新增的数据将会在系统层面提现。如果遇到数据量大，而且分库分表逻辑不一致的时候，就会出现很多的问题。</p>
<ul>
<li>对于没有数据要按照一定的规则生成</li>
<li>缺少对应关系的需要建设映射关系…等</li>
</ul>
<h6 id="数据量的评估"><a href="#数据量的评估" class="headerlink" title="数据量的评估"></a>数据量的评估</h6><p>对于每一张表的一个条数、物理磁盘空间占用等的评估。对于后面迁移的瓶颈在哪儿有一个大概的评估。</p>
<h6 id="表映射关系"><a href="#表映射关系" class="headerlink" title="表映射关系"></a>表映射关系</h6><ul>
<li>部分字段需要特殊转换</li>
<li>多个表写入一张表</li>
<li>一张表写入多张表</li>
</ul>
<p>这里的细节取决与对于2个系统之间的了解，都要在前期做很细的规划与考量。</p>
<h6 id="迁移框架开发"><a href="#迁移框架开发" class="headerlink" title="迁移框架开发"></a>迁移框架开发</h6><p>对于迁移功能或者框架的要求需要做到如下才行：</p>
<ul>
<li>可回滚：全量回滚，单笔删除</li>
<li>可重试：回滚重试、不回滚重试</li>
<li>可校验：提供校验入口，输出校验结果</li>
<li>时效性：一定的时间内，完成迁移、校验动作</li>
<li>可控制：写入速度控制、可暂停、可强制停止</li>
<li>可视化：进度条、耗时、速率~</li>
</ul>
<p>其中迁移最重要的就是<code>Reader</code>与<code>Writer</code>，但大部分都是在写这里出现了性能问题。达不到迁移时间上的要求导致失败或者特殊处理。</p>
<p>Reader:</p>
<ul>
<li>分页查询，尽量能按照固定顺序来读；</li>
<li>建议好索引，避免出现数据库底层的性能问题，提前分析加上好索引；</li>
<li>部分数据可以加载在内存里里面，在内存里进行包装；</li>
</ul>
<p>Writer：</p>
<ul>
<li>最好是利用并发来写数据，注意好线程安全；</li>
<li>尽量把不同的表数据打散开来，提高数据库的并发；</li>
<li>能批量操作的就批量操作，不要一条条的操作，减少网络的开销；</li>
<li>注意好事物的回滚操作与日志监控</li>
</ul>
<p>业务验证</p>
<ul>
<li>对于迁移的数据可验证，最好能做成自动化的验证功能</li>
<li>对于异常数据把补偿功能提前做好</li>
<li>提前做好回滚的方案</li>
</ul>
<p>指标&amp;异常考虑</p>
<ul>
<li>可回滚：全量回滚，单笔删除  – 支持以物理表维度全量回滚</li>
<li>可重试：回滚重试、不回滚重试  – 支持，建议采用回滚重试</li>
<li>可校验：提供校验入口，输出校验结果  – 支持</li>
<li>时效性：一定的时间内，完成迁移、校验动作</li>
<li>可控制：写入速度控制、可暂停、可强制停止 – 通过写线程、部署服务数量来控制速录， 支持暂停服务 TaskScheduler</li>
<li>可视化：进度条、耗时、速率  – 抽样打印插入耗时， 支持打印进度条、打印内存占用率、cpu等</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>真的没有最厉害的系统，只有最合适的系统。不要过度设计、过度设计、过度设计。每一个设计一定是为了解决某种恶心问题来设计的，它可能解决了最恶心的问题但是也附带了它的问题。首先要去任何架构师的设计，其余的问题就是去耐心解决就好。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码角度剖析 Spring 如何管理 mybatis 事务的？</title>
    <url>/2020/01/02/2020/01/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%89%96%E6%9E%90%20Spring%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%20mybatis%20%E4%BA%8B%E5%8A%A1%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="环境与背景"><a href="#环境与背景" class="headerlink" title="环境与背景"></a>环境与背景</h4><p>Ext1：本文源码解析基于 mybatis-spring-boot-starter 2.1.1，即 mybatis 3.5.3 版本。</p>
<p>Ext2：本文主要是对源码的讲解，着重点会是在源码上。</p>
<p>Ext3：阅读本文前，最好对 mapperProxy、 sqlSession 有一定的了解</p>
<h2 id="一、-XMLMapperBuilder、mapperProxy-与-mapperMethod"><a href="#一、-XMLMapperBuilder、mapperProxy-与-mapperMethod" class="headerlink" title="一、 XMLMapperBuilder、mapperProxy 与 mapperMethod"></a>一、 XMLMapperBuilder、mapperProxy 与 mapperMethod</h2><p><a href="https://my.oschina.net/anur/blog/3147253" target="_blank" rel="noopener">上篇文章</a> 讲了 mapper 文件是怎么解析的，在文章开头提到了 <code>SqlSessionFactory</code> 这个重要的对象，是的就是我们经常需要配置的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//  略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面做了很多自动化的配置，当然我们可以通过重写它来自定义我们自己的 <code>sqlSessionFactory</code>，借用一下上篇文章的图片： <img src="https://oscimg.oschina.net/oscnet/up-34f220d9791cfad54d095f1e49f2e3bcd0b.JPEG" alt="img"></p>
<p>spring 借助 <code>SqlSessionFactoryBean</code> 来创建 <code>sqlSessionFactory</code>，这可以视作是一个典型的建造者模式，来创建 <code>SqlSessionFactory</code>。</p>
<p>上篇文章说到，spring 拿到我们配置的 mapper 路径去扫描我们 mapper.xml 然后进行一个循环进行解析(<a href="https://my.oschina.net/anur/blog/3147253" target="_blank" rel="noopener">上篇文章第二章节：二、SqlSessionFactory 的初始化与 XMLMapperBuilder</a>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 代码位于 org.mybatis.spring.SqlSessionFactoryBean#buildSqlSessionFactory --</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">"Property 'mapperLocations' was specified but matching resources are not found."</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">                targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">            xmlMapperBuilder.parse();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to parse mapping resource: '"</span> + mapperLocation + <span class="string">"'"</span>, e);</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">          &#125;</span><br><span class="line">          LOGGER.debug(() -&gt; <span class="string">"Parsed mapper file: '"</span> + mapperLocation + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">"Property 'mapperLocations' was not specified."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-- 代码位于 org.apache.ibatis.builder.xml.XMLMapperBuilder#parse --</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>)); <span class="comment">// 上篇文章主要说的</span></span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      bindMapperForNamespace();<span class="comment">// 创建mapperProxy的工厂对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-从-xml-到-mapperStatement"><a href="#1-1-从-xml-到-mapperStatement" class="headerlink" title="1.1 从 xml 到 mapperStatement"></a>1.1 从 xml 到 mapperStatement</h3><p>上篇文章实际上就是在讲解 <code>configurationElement(parser.evalNode(&quot;/mapper&quot;));</code> 里面发生的故事，实际上还有后续的步骤，如果对 mybatis 有所了解的，应该知道，mybatis 会为我们的接口创建一个叫做 <code>mapperProxy</code> 的代理对象（<del>划重点</del>），其实就是在这后续的步骤 <code>bindMapperForNamespace();</code> 做的（不尽然，实际上是创建并绑定了 <code>mapperProxyFactory</code>）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0c401779c9959fceed9195106f206cdd03d.JPEG" alt="img"></p>
<p>不贴太多代码，<code>bindMapperForNamespace()</code> 方法里核心做的主要就是调用 <code>configuration.addMapper()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (boundType != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">    <span class="comment">// Spring may not know the real resource name so we set a flag</span></span><br><span class="line">    <span class="comment">// to prevent loading again this resource from the mapper interface</span></span><br><span class="line">    <span class="comment">// look at MapperAnnotationBuilder#loadXmlResource</span></span><br><span class="line">    configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</span><br><span class="line">    configuration.addMapper(boundType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>boundType</code> 就是我们在 mapper 文件里面指定的 <code>namespace</code>，比如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">"com.anur.mybatisdemo.test.TrackerConfigMapper"</span>&gt;</span><br><span class="line">     XXXXXXXXXXXXXXXXXX 里面写的sql语句，resultMap 等等，略</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<p>在 <code>configuration.addMapper()</code> 中调用了 <code>mapperRegistry.addMapper()</code>，看到 <code>knowMappers</code> ，这个就是存储我们生产 <code>MapperProxy</code> 的工厂映射 map，我们稍微再讲，先继续往下看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">      <span class="comment">// It's important that the type is added before the parser is run</span></span><br><span class="line">      <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">      <span class="comment">// mapper parser. If the type is already known, it won't try.</span></span><br><span class="line">      MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">      parser.parse();</span><br><span class="line">      loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-从注解到-mapperStatement"><a href="#1-2-从注解到-mapperStatement" class="headerlink" title="1.2 从注解到 mapperStatement"></a>1.2 从注解到 mapperStatement</h3><p>看到 <code>MapperAnnotationBuilder#parse()</code>，<code>parse()</code> 中主要是对这个接口里面定义的方法做了 <code>parseStatement</code> 这件事</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// issue #237</span></span><br><span class="line">    <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">      parseStatement(method);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">    configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>parseStatement()</code> 就是解析注解语句的地方，</strong> 如果说我们没有写 xml，将语句以注解的形式写在方法上，则会在这里进行语句解析。它和我们上篇文章讲到的解析xml很像，就是拿到一大堆属性，比如 <code>resultMap</code>，<code>keyGenerator</code> 等等，生成一个 <code>MappedStatement</code> 对象，这里就不赘述了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseStatement</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">   Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span><br><span class="line">   LanguageDriver languageDriver = getLanguageDriver(method);</span><br><span class="line">   SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</span><br><span class="line">   <span class="keyword">if</span> (sqlSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 解析注解式的 sql 语句，略</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-如果写了-xml，也写了注解会怎么样（调皮）"><a href="#1-3-如果写了-xml，也写了注解会怎么样（调皮）" class="headerlink" title="1.3 如果写了 xml，也写了注解会怎么样（调皮）"></a>1.3 如果写了 xml，也写了注解会怎么样（调皮）</h3><p>我们知道承载 <code>mapperStatement</code> 的是一个 map 映射，通过我们在上篇文章中反复强调的 <code>id</code> 来作为 key，那么重复添加会出现什么呢？</p>
<p>答案在这里，<code>mybatis</code> 的这个 map 被重写了，同时写这两者的话，会抛出 <code>...already contains value for...</code> 的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 代码位置 org.apache.ibatis.session.Configuration.StrictMap#put --</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(String key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (containsKey(key)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(name + <span class="string">" already contains value for "</span> + key</span><br><span class="line">        + (conflictMessageProducer == <span class="keyword">null</span> ? <span class="string">""</span> : conflictMessageProducer.apply(<span class="keyword">super</span>.get(key), value)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key.contains(<span class="string">"."</span>)) &#123;</span><br><span class="line">    <span class="keyword">final</span> String shortKey = getShortName(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">super</span>.get(shortKey) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">super</span>.put(shortKey, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.put(shortKey, (V) <span class="keyword">new</span> Ambiguity(shortKey));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-回到-MapperProxy"><a href="#1-4-回到-MapperProxy" class="headerlink" title="1.4 回到 MapperProxy"></a>1.4 回到 MapperProxy</h3><h4 id="1-4-1-MapperProxy-的创建"><a href="#1-4-1-MapperProxy-的创建" class="headerlink" title="1.4.1 MapperProxy 的创建"></a>1.4.1 MapperProxy 的创建</h4><p>刚才在1.1中我们提到了，<code>mapperProxy</code>，也就是刚才 <code>org.apache.ibatis.binding.MapperRegistry#addMapper</code> 的代码：<code>knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));</code></p>
<p>看到 <code>MapperProxyFactory</code> 的内部：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 有删减 --</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解JDK动态代理的小伙伴应该很清楚了， <code>newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code> 意为，为接口创建一个实现了 <code>InvocationHandler</code> 的代理对象。我们在调用接口方法的时候，实际上要看代理类是如何实现的。</p>
<p>那么看看 mapperProxy 的内部的 <code>invoke</code> 是如何实现的，这里有三类方法，</p>
<ul>
<li>一种是一些 <code>Object</code> 对象带来的方法，这里不进行代理，直接 <code>invoke</code>，</li>
<li>一种是default方法，一种比较蛋疼的写法，把接口当抽象类写，里面可以放一个default方法写实现，这种代理了也没太大意义</li>
<li>最后一种也就是我们准备代理的方法， 它会为每个非上面两者的方法，懒加载一个 <code>MapperMethod</code> 对象，并调用 <code>MapperMethod#execute</code> 来执行真正的 mybatis 逻辑。</li>
</ul>
<h4 id="1-4-2-MapperMethod-的创建"><a href="#1-4-2-MapperMethod-的创建" class="headerlink" title="1.4.2 MapperMethod 的创建"></a>1.4.2 MapperMethod 的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 有删减 --</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;<span class="comment">// 来自 Object 的方法，比如 toString()</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;<span class="comment">// 静态方法，我们可以直接忽略</span></span><br><span class="line">        <span class="keyword">if</span> (privateLookupInMethod == <span class="keyword">null</span>) &#123; </span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava8(proxy, method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava9(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache.computeIfAbsent(method,</span><br><span class="line">        k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MapperMethod</code> 的逻辑是怎么样的，也很好猜到，它的构造函数中创建了两个对象，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, mapperInterface, method);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>sqlCommand</li>
</ul>
<p><code>sqlCommand</code> 实际上就是从 <code>configuration</code> 里面把它对应的 <code>MappedStatement</code> 取出来，持有它的唯一 <code>id</code> 和执行类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommandType type;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">    MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,</span><br><span class="line">        configuration);</span><br><span class="line">    <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getAnnotation(Flush<span class="class">.<span class="keyword">class</span>) !</span>= <span class="keyword">null</span>) &#123;</span><br><span class="line">        name = <span class="keyword">null</span>;</span><br><span class="line">        type = SqlCommandType.FLUSH;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Invalid bound statement (not found): "</span></span><br><span class="line">            + mapperInterface.getName() + <span class="string">"."</span> + methodName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      name = ms.getId();</span><br><span class="line">      type = ms.getSqlCommandType();</span><br><span class="line">      <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MethodSignature <code>MethodSignature</code> 是针对接口返回值、参数等值的解析，比如我们的 <code>@Param</code> 注解，就是在 <code>new ParamNameResolver(configuration, method);</code> 里面解析的，比较简单，在之前的文章 <a href="https://my.oschina.net/anur/blog/3133753" target="_blank" rel="noopener">简单概括的mybatis sqlSession 源码解析</a> 里也提到过，这里就不多说了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MethodSignature</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">  Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">  <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) resolvedReturnType;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.returnType = method.getReturnType();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.returnsVoid = <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line">  <span class="keyword">this</span>.returnsMany = configuration.getObjectFactory().isCollection(<span class="keyword">this</span>.returnType) || <span class="keyword">this</span>.returnType.isArray();</span><br><span class="line">  <span class="keyword">this</span>.returnsCursor = Cursor<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line">  <span class="keyword">this</span>.returnsOptional = Optional<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line">  <span class="keyword">this</span>.mapKey = getMapKey(method);</span><br><span class="line">  <span class="keyword">this</span>.returnsMap = <span class="keyword">this</span>.mapKey != <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.rowBoundsIndex = getUniqueParamIndex(method, RowBounds<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">this</span>.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">this</span>.paramNameResolver = <span class="keyword">new</span> ParamNameResolver(configuration, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-3-MapperMethod-的执行"><a href="#1-4-3-MapperMethod-的执行" class="headerlink" title="1.4.3 MapperMethod 的执行"></a>1.4.3 MapperMethod 的执行</h4><p><code>mapperMethod</code> 就是 <code>sqlSession</code> 与 <code>mappedStatement</code> 的一个整合。它的执行是一个策略模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">  Object result;</span><br><span class="line">  switch (command.getType()) &#123;</span><br><span class="line">    case INSERT: &#123;</span><br><span class="line">      Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result &#x3D; rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    case UPDATE: &#123;</span><br><span class="line">      Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result &#x3D; rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    case DELETE: &#123;</span><br><span class="line">      Object param &#x3D; method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result &#x3D; rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    case SELECT:</span><br><span class="line">	&#x2F;&#x2F; 略..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体是怎么执行的在文章 <a href="https://my.oschina.net/anur/blog/3133753" target="_blank" rel="noopener">简单概括的mybatis sqlSession 源码解析</a> 提到过，这里也不过多赘述。</p>
<p>这里对 <code>MapperProxy</code> 在初始化与调用过程中的关系做一下罗列：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dd9e420d3e2c2cd1f5b352208e95dce8144.JPEG" alt="img"></p>
<h2 id="二、-下文序言"><a href="#二、-下文序言" class="headerlink" title="二、 下文序言"></a>二、 下文序言</h2><p>上面的 <code>MapperProxy</code> 讲解的比较粗略，因为真的很简单（复杂一点的在 <code>MepperMethod</code> 的策略模式，也就是调用 <code>sqlSession</code> 去执行语句的时候，但是那个本文不会详细说明，后续的文章会解析这部分代码）</p>
<p><strong>本文要讲的是几个在很多文章或者书里都没有提到，或者只是简单提了一下的点：本文将会把 sqlSession、MapperProxy、Spring事务管理几个关联密切的功能点进行总结，比如如下这样的疑问：</strong></p>
<ul>
<li>1、我们知道一个 sqlSession 对应一个数据库连接，在创建 MapperProxy 的时候，又注入了 sqlSession ，难道我们用的一直是同一个 sqlSession？或者难道每次使用不同的数据库连接，会创建不同的 MapperProxy 代理？</li>
<li>2、事务传播等级是怎么实现的，和 sqlSession 有关系吗？</li>
<li>3、代理对象 MapperProxy 是如何和 spring 产生关联的？</li>
</ul>
<h2 id="三、-SqlSession-的初始化及其运作总览"><a href="#三、-SqlSession-的初始化及其运作总览" class="headerlink" title="三、 SqlSession 的初始化及其运作总览"></a>三、 SqlSession 的初始化及其运作总览</h2><p>为了避免有小伙伴对 <code>sqlSession</code> 完全没有概念，这里将接口代码贴出，可以看出 <code>sqlSession</code> 是执行语句的一个入口，同时也提供了事务的一些操作，实际上就是如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSession</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span></span>;</span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span></span>;</span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span>;</span><br><span class="line">  &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">selectMap</span><span class="params">(String statement, String mapKey)</span></span>;</span><br><span class="line">  &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span></span>;</span><br><span class="line">  &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowBounds)</span></span>;</span><br><span class="line">  &lt;T&gt; <span class="function">Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  &lt;T&gt; <span class="function">Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement, Object parameter)</span></span>;</span><br><span class="line">  &lt;T&gt; <span class="function">Cursor&lt;T&gt; <span class="title">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(String statement, Object parameter, ResultHandler handler)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(String statement, ResultHandler handler)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(String statement, Object parameter)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String statement, Object parameter)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(String statement, Object parameter)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> force)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> force)</span></span>;</span><br><span class="line">  <span class="function">List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Configuration <span class="title">getConfiguration</span><span class="params">()</span></span>;</span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-sqlSession-的创建"><a href="#3-1-sqlSession-的创建" class="headerlink" title="3.1 sqlSession 的创建"></a>3.1 sqlSession 的创建</h3><h4 id="3-1-1-Environment-与-Transaction"><a href="#3-1-1-Environment-与-Transaction" class="headerlink" title="3.1.1 Environment 与 Transaction"></a>3.1.1 Environment 与 Transaction</h4><p>首先忘掉 spring 为我们提供的便利，看一下基础的，脱离了 spring 托管的 mybatis 是怎么进行 sql 操作的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">TrackerConfigMapper mapper = sqlSession.getMapper(TrackerConfigMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">TrackerConfigDO one = mapper.getOne(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>SqlSessionFactory</code> 有两个子类实现：<code>DefaultSqlSessionFactory</code> 和 <code>SqlSessionManager</code>，<code>SqlSessionManager</code> 使用动态代理 + 静态代理对 <code>DefaultSqlSessionFactory</code> 进行了代理，不过不用太在意这个 <code>SqlSessionManager</code>，后面会说明原因。</p>
<p>上面不管怎么代理，实际逻辑的执行者都是 <code>DefaultSqlSessionFactory</code>，我们看看它的创建方法，也就是 <code>openSession()</code> 实际执行的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">    <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>environment</code> 可用于数据源切换，那么提到数据源切换，就很容易想到了，连接的相关信息是这货维持的。 所以看到我们的代码：<code>tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</code>， <code>TransactionFactory</code> 有三个实现，它们分别是 <code>JdbcTransactionFactory</code>、<code>ManagedTransactionFactory</code> 和 <code>SpringManagedTransactionFactory</code>。</p>
<p><code>JdbcTransactionFactory</code> 和 <code>ManagedTransactionFactory</code> 最大的区别就在于 <code>ManagedTransactionFactory</code> 实现了空的 commit 与 rollback，源码中这样说道：付与容器来管理 <code>transaction</code> 的生命周期，这个博主不是特别熟悉，因为没这么用过，tomcat、jetty 等容器实现了对 jdbc 的代理。<strong>要注意，不管如何都是使用的 jdbc 这套接口规范进行数据库操作的。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * &#123;@link Transaction&#125; that lets the container manage the full lifecycle of the transaction.</span><br><span class="line"> * Delays connection retrieval until getConnection() is called.</span><br><span class="line"> * Ignores all commit or rollback requests.</span><br><span class="line"> * By default, it closes the connection but can be configured not to do it.</span><br><span class="line"> *</span><br><span class="line"> * @author Clinton Begin</span><br><span class="line"> *</span><br><span class="line"> * @see ManagedTransactionFactory</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<p><code>Transaction</code> 是 mybatis 创建的一个对象，它实际上是对 <code>jdbc</code> <code>connection</code> 对象的一个封装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 代码位于 org.apache.ibatis.transaction.jdbc.JdbcTransaction --</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">    openConnection();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; !connection.getAutoCommit()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">"Committing JDBC Connection ["</span> + connection + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    connection.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (connection != <span class="keyword">null</span> &amp;&amp; !connection.getAutoCommit()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">"Rolling back JDBC Connection ["</span> + connection + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    connection.rollback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-Executor-与-SqlSession"><a href="#3-1-2-Executor-与-SqlSession" class="headerlink" title="3.1.2 Executor 与 SqlSession"></a>3.1.2 Executor 与 SqlSession</h4><p>我们知道 sqlSession 的 四大对象之一，Executor，负责统领全局，从语句获取（从 mappedStatement），到参数拼装（parameterHandler），再到执行语句（statementHandler），最后结果集封装（resultHandler），都是它负责“指挥”的。</p>
<p>我们看到它使用 <code>Transaction</code> 进行初始化，另外的一个参数是它的类型，这里不多说，REUSE 是带语句缓存的，和普通的 SimpleExecutor 没有特别大的区别，BATCH 类型则是通过 jdbc 提供的批量提交来对网络请求进行优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutorType &#123;  SIMPLE, REUSE, BATCH&#125;</span><br></pre></td></tr></table></figure>

<p>最后将持有 <code>Transaction</code> 的 Executor 置入 <code>SqlSession</code> ，完成一个 <code>SqlSession</code> 对象的创建。</p>
<p>可以看到，我们的确是一个<code>SqlSession</code> 对应一个连接(<code>Transaction</code>)，<code>MapperProxy</code> 这个业务接口的动态代理对象又持有一个 <code>SqlSession</code> 对象，那么总不可能一直用同一个连接吧？</p>
<p>当然有疑问是好的，而且通过对 SqlSession 初始化过程的剖析，我们已经完善了我们对 mybatis 的认知：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-977d7780790a5566c67354b4723ed77085c.JPEG" alt="img"></p>
<p>接下来就是来打消这个疑问，<code>MapperProxy</code> 持有的 <code>sqlSession</code> 和 <code>SqlSessionFactory</code> 创建的这个有什么关系？</p>
<h3 id="3-2-SqlSessionTemplate-对-sqlSession-的代理"><a href="#3-2-SqlSessionTemplate-对-sqlSession-的代理" class="headerlink" title="3.2 SqlSessionTemplate 对 sqlSession 的代理"></a>3.2 SqlSessionTemplate 对 sqlSession 的代理</h3><p>实际上答案就在 <code>SqlSessionTemplate</code>，<code>SqlSessionTemplate</code> 是 spring 对 mybatis <code>SqlSessionFactory</code> 的封装，同时，它还是 <code>SqlSession</code> 的代理。</p>
<p><code>SqlSessionTemplate</code> 和 mybatis 提供的 <code>SqlSessionManager</code>( <code>SqlSessionFactory</code> 的另一个实现类，也是<code>DefaultSqlSessionFactory</code> 的代理类，可以细想一下，业务是否共用同一个 <code>sqlSession</code> 还要在业务里面去传递，去控制是不是很麻烦) 是一样的思路，不过 spring 直接代理了 <code>sqlSession</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 代码位于 org.mybatis.spring.SqlSessionTemplate --</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorType executorType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersistenceExceptionTranslator exceptionTranslator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs a Spring managed &#123;<span class="doctag">@code</span> SqlSession&#125; with the given</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> SqlSessionFactory&#125; and &#123;<span class="doctag">@code</span> ExecutorType&#125;.</span></span><br><span class="line"><span class="comment">   * A custom &#123;<span class="doctag">@code</span> SQLExceptionTranslator&#125; can be provided as an</span></span><br><span class="line"><span class="comment">   * argument so any &#123;<span class="doctag">@code</span> PersistenceException&#125; thrown by MyBatis</span></span><br><span class="line"><span class="comment">   * can be custom translated to a &#123;<span class="doctag">@code</span> RuntimeException&#125;</span></span><br><span class="line"><span class="comment">   * The &#123;<span class="doctag">@code</span> SQLExceptionTranslator&#125; can also be null and thus no</span></span><br><span class="line"><span class="comment">   * exception translation will be done and MyBatis exceptions will be</span></span><br><span class="line"><span class="comment">   * thrown</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSessionFactory a factory of SqlSession</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> executorType an executor type on session</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exceptionTranslator a translator of exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="function"><span class="params">      PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sqlSessionFactory, <span class="string">"Property 'sqlSessionFactory' is required"</span>);</span><br><span class="line">    notNull(executorType, <span class="string">"Property 'executorType' is required"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">    <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">    <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(</span><br><span class="line">        SqlSessionFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">        new Class[] &#123; SqlSession.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>还是熟悉的配方，就是 jdk 的动态代理，<code>SqlSessionTemplate</code> 在初始化时创建了一个 <code>SqlSession</code> 代理，也内置了 <code>ExecutorType</code>，<code>SqlSessionFactory</code>等 <code>defaultSqlSession</code> 初始化的必要组件。</p>
<p>想必看到这里，已经有很多小伙伴知道这里是怎么回事了，是的，我们对 <code>SqlSession</code> 的操作都是经由这个代理来完成，代理的内部，实现了真正 <code>SqlSession</code> 的创建与销毁，回滚与提交等，我们先纵览以下它的代理实现。</p>
<h4 id="3-2-1-sqlSession-常规代理流程赏析"><a href="#3-2-1-sqlSession-常规代理流程赏析" class="headerlink" title="3.2.1 sqlSession 常规代理流程赏析"></a>3.2.1 sqlSession 常规代理流程赏析</h4><p>对于这种jdk动态代理，我们看到 <code>SqlSessionInterceptor#invoke</code> 方法就明了了。我们先过一遍常规的流程，也就是没有使用 spring 事务功能支持，执行完 sql 就直接提交事务的常规操作：</p>
<ul>
<li>1、<code>getSqlSession()</code> 创建 <code>sqlSession</code></li>
<li>2、执行 <code>MapperProxy</code>，也就是前面讲了一大堆的，<code>MapperProxy</code> 中，通过 <code>MapperMethod</code> 来调用 <code>sqlSession</code> 和我们生成好的 <code>mappedStatement</code> 操作 sql 语句。</li>
<li>3、提交事务</li>
<li>4、关闭事务</li>
</ul>
<p><strong>注：代码有很大删减</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     SqlSession sqlSession = getSqlSession(</span><br><span class="line">         SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory,</span><br><span class="line">         SqlSessionTemplate.<span class="keyword">this</span>.executorType,</span><br><span class="line">         SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator); <span class="comment">// 创建或者获取真正需要的 SqlSession</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       Object result = method.invoke(sqlSession, args); <span class="comment">// 执行原本想对 SqlSession 做的事情</span></span><br><span class="line">       <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">         <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">         <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">         sqlSession.commit(<span class="keyword">true</span>);<span class="comment">// 如非 spring 管理事务，则直接提交</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">         closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：注释掉的代码在此类型的操作中没有什么意义，<code>getSqlSession()</code> 在这里只是简单通过 <code>sessionFactory</code> 创建了一个 <code>sqlSession</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// SqlSession session = sessionHolder(executorType, holder);</span></span><br><span class="line"> <span class="comment">//  if (session != null) &#123;</span></span><br><span class="line"> <span class="comment">//    return session;</span></span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  LOGGER.debug(() -&gt; <span class="string">"Creating a new SqlSession"</span>);</span><br><span class="line">  session = sessionFactory.openSession(executorType);</span><br><span class="line"> <span class="comment">//  registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span></span><br><span class="line">  <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-sqlSession-借助-TransactionSynchronizationManager-代理流程赏析"><a href="#3-2-2-sqlSession-借助-TransactionSynchronizationManager-代理流程赏析" class="headerlink" title="3.2.2 sqlSession 借助 TransactionSynchronizationManager 代理流程赏析"></a>3.2.2 sqlSession 借助 TransactionSynchronizationManager 代理流程赏析</h4><p>看完前面的实现，有小伙伴会好奇，我的 <a href="https://my.oschina.net/u/3770144" target="_blank" rel="noopener">@Transactional</a> 注解呢？我的事务传播等级呢？</p>
<p>实际上，除去上述常规流程，更多的是要借助 <code>TransactionSynchronizationManager</code> 这个对象来完成，比如刚才步骤一，<code>getSqlSession()</code> 我暂时注释掉的代码里面，有一个很重要的操作：</p>
<p>我们把刚才 <code>getSqlSession()</code> 中注释掉的代码再拿回来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line">SqlSession session = sessionHolder(executorType, holder);</span><br><span class="line"> <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session = sessionFactory.openSession(executorType);</span><br><span class="line">registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"><span class="keyword">return</span> session;</span><br></pre></td></tr></table></figure>

<p>我们可以看到<strong>首先获取一个叫做 <code>SqlSessionHolder</code>的东西</strong>，如果里面没有 <code>sqlSession</code> 则调用 <code>sessionFactory.openSession(executorType);</code> 创建一个，<strong>并把它注册到 TransactionSynchronizationManager</strong>。</p>
<p>sqlSessionHolder 没什么可说的，它就只是个纯粹的容器，里面主要就是装着一个 <code>SqlSession</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlSessionHolder</span><span class="params">(SqlSession sqlSession,</span></span></span><br><span class="line"><span class="function"><span class="params">    ExecutorType executorType,</span></span></span><br><span class="line"><span class="function"><span class="params">    PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  notNull(sqlSession, <span class="string">"SqlSession must not be null"</span>);</span><br><span class="line">  notNull(executorType, <span class="string">"ExecutorType must not be null"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">  <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">  <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说我们只需要把目光焦距在 <code>TransactionSynchronizationManager</code> 就可以了，它的内部持有了很多个元素为 <code>Map</code> 的 <code>ThreadLocal</code>（代码示例中只贴出了 <code>resources</code> 这一个 <code>ThreadLocal</code> ）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(TransactionSynchronizationManager<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">			<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getResource</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">		Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);</span><br><span class="line">		Object value = doGetResource(actualKey);</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Retrieved value ["</span> + value + <span class="string">"] for key ["</span> + actualKey + <span class="string">"] bound to thread ["</span> +</span><br><span class="line">					Thread.currentThread().getName() + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">doGetResource</span><span class="params">(Object actualKey)</span> </span>&#123;</span><br><span class="line">		Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">		<span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Object value = map.get(actualKey);</span><br><span class="line">		<span class="comment">// Transparently remove ResourceHolder that was marked as void...</span></span><br><span class="line">		<span class="keyword">if</span> (value <span class="keyword">instanceof</span> ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123;</span><br><span class="line">			map.remove(actualKey);</span><br><span class="line">			<span class="comment">// Remove entire ThreadLocal if empty...</span></span><br><span class="line">			<span class="keyword">if</span> (map.isEmpty()) &#123;</span><br><span class="line">				resources.remove();</span><br><span class="line">			&#125;</span><br><span class="line">			value = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也就是说，spring 的事务，是借助 <code>TransactionSynchronizationManager</code>+ <code>SqlSessionHolder</code> 对 <code>sqlSession</code> 的控制来实现的。</strong></p>
<p>那么这样就很清晰了，如下总结，也如下图：</p>
<ul>
<li><code>MapperProxy</code> 内置的 <code>sqlSession</code> 是 <code>sqlSessiontemplate</code></li>
<li><code>sqlSessiontemplate</code> 通过持有 <code>SqlSessionFactory</code> 来创建真正的 <code>SqlSession</code></li>
<li><code>TransactionSynchronizationManager</code> + <code>SqlSessionHolder</code> 则扮演着 <code>SqlSession</code> 管理的角色</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-ff27c8e3ab67117b4fdace3523a7dc68dde.JPEG" alt="img"></p>
<h2 id="四、spring-如何管理-sqlSession"><a href="#四、spring-如何管理-sqlSession" class="headerlink" title="四、spring 如何管理 sqlSession"></a>四、spring 如何管理 sqlSession</h2><p>上一个小节只是讲了是什么，没有讲为什么，到了这里如果有好奇宝宝一定会好奇诸如 spring 的一系列事务控制是怎么实现的，当然本文不会讲太多 spring 事务管理相关的太多东西，以后会有后续文章专门剖析事务管理。</p>
<p>我们可以简单看下 <code>TransactionInterceptor</code> ，这是 <code>@Transactional</code> 注解的代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AOP Alliance MethodInterceptor for declarative transaction</span></span><br><span class="line"><span class="comment"> * management using the common Spring transaction infrastructure</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@link</span> org.springframework.transaction.PlatformTransactionManager&#125;/</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.transaction.ReactiveTransactionManager&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Derives from the &#123;<span class="doctag">@link</span> TransactionAspectSupport&#125; class which</span></span><br><span class="line"><span class="comment"> * contains the integration with Spring's underlying transaction API.</span></span><br><span class="line"><span class="comment"> * TransactionInterceptor simply calls the relevant superclass methods</span></span><br><span class="line"><span class="comment"> * such as &#123;<span class="doctag">@link</span> #invokeWithinTransaction&#125; in the correct order.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;TransactionInterceptors are thread-safe.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> TransactionProxyFactoryBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.aop.framework.ProxyFactoryBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.aop.framework.ProxyFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new TransactionInterceptor.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Transaction manager and transaction attributes still need to be set.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setTransactionManager</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setTransactionAttributes(java.util.Properties)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #setTransactionAttributeSource(TransactionAttributeSource)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TransactionInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">		<span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">		<span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">		Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Adapt to TransactionAspectSupport's invokeWithinTransaction...</span></span><br><span class="line">		<span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到它的代理方法 <code>invoke()</code> 的执行逻辑在 <code>invokeWithinTransaction()</code> 里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--代码位于 org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction --</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">		TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">		<span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.reactiveAdapterRegistry != <span class="keyword">null</span> &amp;&amp; tm <span class="keyword">instanceof</span> ReactiveTransactionManager) &#123;</span><br><span class="line">			<span class="comment">// 响应式事务相关</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">		<span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">			<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">			TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">				<span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">				retVal = invocation.proceedWithInvocation();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="comment">// target invocation exception</span></span><br><span class="line">				completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				cleanupTransactionInfo(txInfo);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">				<span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">				TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">				<span class="keyword">if</span> (status != <span class="keyword">null</span> &amp;&amp; txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">					retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			commitTransactionAfterReturning(txInfo);</span><br><span class="line">			<span class="keyword">return</span> retVal;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// CallbackPreferringPlatformTransactionManager 的处理逻辑</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>invokeWithinTransaction()</code> 的代码虽然长，我们还是把它分段来看：</p>
<h3 id="4-1-TransactionDefinition-与-TransactionManager-的创建"><a href="#4-1-TransactionDefinition-与-TransactionManager-的创建" class="headerlink" title="4.1 TransactionDefinition 与 TransactionManager 的创建"></a>4.1 TransactionDefinition 与 TransactionManager 的创建</h3><ul>
<li>第一部分，准备阶段</li>
</ul>
<p>也就是这部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line"><span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line"><span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br></pre></td></tr></table></figure>

<p>获取 <code>TransactionAttribute</code>(<code>TransactionDefinition</code>（底层接口），这里面装载了事务传播等级，隔离级别等属性。 <code>TransactionAttribute</code> 的创建依据配置，或者我们的事务传播等级注解，对什么异常进行回滚等，后续会继续对它的应用做说明，<code>PlatformTransactionManager</code> 则是进行事务管理的主要操作者。</p>
<h3 id="4-2-获取-TransactionInfo"><a href="#4-2-获取-TransactionInfo" class="headerlink" title="4.2 获取 TransactionInfo"></a>4.2 获取 TransactionInfo</h3><ul>
<li>第二部分，事务开启或者获取与准备，也就是我们执行逻辑的第一行代码 <code>createTransactionIfNecessary()</code>（是不是和前面说到的 SqlSession的创建或者获取很像？）</li>
</ul>
<p>我们可以看到 <code>createTransactionIfNecessary()</code> 的实现就做了两件事，其一是获取一个叫做 <code>TransactionStatus</code> 的东西，另外则是调用 <code>prepareTransactionInfo()</code>，获取一个 <code>TransactionInfo</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">	TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">--代码位于 org.springframework.transaction.interceptor.TransactionAspectSupport#createTransactionIfNecessary --</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		TransactionStatus status = tm.getTransaction(txAttr);</span><br><span class="line">		<span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>先看看第一件事，也就是获取 <code>TransactionStatus</code>，它保存了事务的 <code>savePoint</code> ，是否新事物等。删减掉一些判断方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">	TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"></span><br><span class="line">	Object transaction = doGetTransaction();</span><br><span class="line">	<span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">		<span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">		<span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">	&#125;</span><br><span class="line">               <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">			def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">			def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					def, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			doBegin(transaction, def);</span><br><span class="line">			prepareSynchronization(status, def);</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">			resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Create "empty" transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">		<span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">			logger.warn(<span class="string">"Custom isolation level specified but no actual transaction initiated; "</span> +</span><br><span class="line">					<span class="string">"isolation level will effectively be ignored: "</span> + def);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		<span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，但是不急，我们可以简单看出它分为两个部分：</p>
<ul>
<li>第一部分是获取事务 <code>doGetTransaction()</code></li>
<li>第二部分则是判断是否新事物，<ul>
<li>如果不是新事物，则执行 <code>handleExistingTransaction</code>，</li>
<li>如果是新事物<ul>
<li>则 <code>TransactionDefinition.PROPAGATION_REQUIRED</code>、<code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>、<code>TransactionDefinition.PROPAGATION_NESTED</code> 是一种逻辑</li>
<li>其余是另一种逻辑，信息量有点大，但是慢慢来：</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-2-1-doGetTransaction"><a href="#4-2-1-doGetTransaction" class="headerlink" title="4.2.1 doGetTransaction"></a>4.2.1 doGetTransaction</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DataSourceTransactionObject txObject = <span class="keyword">new</span> DataSourceTransactionObject();</span><br><span class="line">	txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">	ConnectionHolder conHolder =</span><br><span class="line">			(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());</span><br><span class="line">	txObject.setConnectionHolder(conHolder, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doGetTransaction</code> 获取我们的事务对象，这里也使用了 <code>TransactionSynchronizationManager</code>（前面说到的 <code>SqlSession</code> 的管理类），事务对象会尝试获取本事务所使用的连接对象，这个和事务传播等级有关，先立个 flag。</p>
<p>我们可以看到这里面主要逻辑就是去获取 <code>ConnectionHolder</code>，实际上很简单，只要能获取到，就是已经存在的事务，获取不到（或者事务已经关闭）就是新事物。</p>
<h4 id="4-2-2-新事物的处理之创建一个真正的事务对象"><a href="#4-2-2-新事物的处理之创建一个真正的事务对象" class="headerlink" title="4.2.2 新事物的处理之创建一个真正的事务对象"></a>4.2.2 新事物的处理之创建一个真正的事务对象</h4><p>如果说前面无法从 <code>TransactionSynchronizationManager</code> 获取到 <code>conHolder</code>，或者说，我们的线程中并没有 <code>ConnectionHolder</code> 那么将会进入此分支，此分支的支持的三个事务传播等级 <code>TransactionDefinition.PROPAGATION_REQUIRED</code>、<code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>、<code>TransactionDefinition.PROPAGATION_NESTED</code> 都是需要创建新事务的，所以它们在同一个分支里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">		def, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">doBegin(transaction, def);</span><br><span class="line">prepareSynchronization(status, def);</span><br><span class="line"><span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure>

<p><code>SuspendedResourcesHolder</code> 与事务的挂起相关，<code>doBegin()</code> 则是对连接对象 <code>connection</code> 的获取和配置，<code>prepareSynchronization()</code> 则是对新事物的一些初始化操作。我们一点点看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation sets the isolation level but ignores the timeout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">	DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">	Connection con = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">				txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">			Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Acquired Connection ["</span> + newCon + <span class="string">"] for JDBC transaction"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">		con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">		Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">		txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">		txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,</span></span><br><span class="line">		<span class="comment">// so we don't want to do it unnecessarily (for example if we've explicitly</span></span><br><span class="line">		<span class="comment">// configured the connection pool to set it already).</span></span><br><span class="line">		<span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">			txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Switching JDBC Connection ["</span> + con + <span class="string">"] to manual commit"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		prepareTransactionalConnection(con, definition);</span><br><span class="line">		txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Bind the connection holder to the thread.</span></span><br><span class="line">		<span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">			TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>ConnectionHolder</code> 的创建和连接的打开就是在这里进行的，创建后，设置其隔离级别，取消 <code>connection</code> 的自动提交，将提交操作纳入到 spring 管理，并且将其存到 <code>TransactionSynchronizationManager</code> 使得 <code>4.2.1 提到的 doGetTransaction()</code> 可以拿到此 <code>ConnectionHolder</code>。</p>
<hr>
<p>做完连接的获取与配置后，下一步就是对事物的一些初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize transaction synchronization as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareSynchronization</span><span class="params">(DefaultTransactionStatus status, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">		TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());</span><br><span class="line">		TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(</span><br><span class="line">				definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?</span><br><span class="line">						definition.getIsolationLevel() : <span class="keyword">null</span>);</span><br><span class="line">		TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());</span><br><span class="line">		TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());</span><br><span class="line">		TransactionSynchronizationManager.initSynchronization();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码都是代码字面意义的简单设置，就不赘述了。</p>
<h4 id="4-2-3-新事物的处理之创建一个虚假的事务对象"><a href="#4-2-3-新事物的处理之创建一个虚假的事务对象" class="headerlink" title="4.2.3 新事物的处理之创建一个虚假的事务对象"></a>4.2.3 新事物的处理之创建一个虚假的事务对象</h4><p>刚才讲的是 “无法从 <code>TransactionSynchronizationManager</code> 获取到 <code>conHolder</code>”，并且属于一些需要创建新事物的传播等级的情况。</p>
<p>如果说方才没有事务，也不需要创建新的事务，则会进入此分支，创建一个空的 <code>TransactionStatus</code>，内部的事务对象为空，代码很简单就不贴了，有兴趣可以去看看 <code>org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction</code> 的最后一个分支。</p>
<h4 id="4-2-4-事务嵌套"><a href="#4-2-4-事务嵌套" class="headerlink" title="4.2.4 事务嵌套"></a>4.2.4 事务嵌套</h4><p>刚才说的都是无法获取到 <code>conHolder</code> 的情况，如果获取到了，则又是另一套代码了，<code>handleExistingTransaction</code> 很长，它的第一个部分是对传播等级的控制，有兴趣的小伙伴可以去看看源码，我这里只挑一个简单的传播等级 <code>PROPAGATION_NESTED_NEW</code> 做说明（其他的会在专门的事务一期做讲解）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 代码位于 org.springframework.transaction.support.AbstractPlatformTransactionManager#handleExistingTransaction --</span><br><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">handleExistingTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">			<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Suspending current transaction, creating new transaction with name ["</span> +</span><br><span class="line">						definition.getName() + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">				DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">						definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">				doBegin(transaction, definition);</span><br><span class="line">				prepareSynchronization(status, definition);</span><br><span class="line">				<span class="keyword">return</span> status;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">				resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">				<span class="keyword">throw</span> beginEx;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	... 略</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现和 <code>4.2.2 新事物的处理</code> 代码是一样的，唯一的区别就是此 <code>TransactionStatus</code> 对象会真正内嵌一个事务挂起对象 <code>SuspendedResourcesHolder</code>。</p>
<h3 id="4-3-封装-TransactionInfo"><a href="#4-3-封装-TransactionInfo" class="headerlink" title="4.3 封装 TransactionInfo"></a>4.3 封装 TransactionInfo</h3><p>拿到 <code>TransactionStatus</code> 之后， <code>prepareTransactionInfo()</code> 里简单的将刚才那些 <code>PlatformTransactionManager</code>、<code>TransactionAttribute</code>、<code>TransactionStatus</code> 包装成一个 <code>TransactionInfo</code> 对象，并将其保存在 <code>ThreadLocal</code> 中，这个 <code>bindToThread()</code> 还会将当前已经持有的 <code>TransactionInfo</code> 对象暂存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">prepareTransactionInfo</span><span class="params">(@Nullable PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable TransactionAttribute txAttr, String joinpointIdentification,</span></span></span><br><span class="line"><span class="function"><span class="params">			@Nullable TransactionStatus status)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		TransactionInfo txInfo = <span class="keyword">new</span> TransactionInfo(tm, txAttr, joinpointIdentification);</span><br><span class="line">		<span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// The transaction manager will flag an error if an incompatible tx already exists.</span></span><br><span class="line">			txInfo.newTransactionStatus(status);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// We always bind the TransactionInfo to the thread, even if we didn't create</span></span><br><span class="line">		<span class="comment">// a new transaction here. This guarantees that the TransactionInfo stack</span></span><br><span class="line">		<span class="comment">// will be managed correctly even if no transaction was created by this aspect.</span></span><br><span class="line">		txInfo.bindToThread();</span><br><span class="line">		<span class="keyword">return</span> txInfo;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>到这里思路就很清晰了，代理为我们做的事情就是生成了一个叫做 <code>TransactionInfo</code> 的东西，里面的 <code>TransactionManager</code> 可以使得 spring 去对最底层的 <code>connection</code> 对象做一些回滚，提交操作。<code>TransactionStatus</code> 则保存挂起的事务的信息，以及当前事务的一些状态，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9b2466bcb2a3fc033a0e41e795226313e83.JPEG" alt="img"></p>
<h4 id="4-4-纵览流程"><a href="#4-4-纵览流程" class="headerlink" title="4.4 纵览流程"></a>4.4 纵览流程</h4><p>让我们回到第四节开头的那段很长的代码，到这里是不是很明了了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">	TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">	<span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">	PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">	<span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">		<span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">		TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">		Object retVal;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">			<span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">			retVal = invocation.proceedWithInvocation();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// target invocation exception</span></span><br><span class="line">			completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			cleanupTransactionInfo(txInfo);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">			<span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">			TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">			<span class="keyword">if</span> (status != <span class="keyword">null</span> &amp;&amp; txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">				retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		commitTransactionAfterReturning(txInfo);</span><br><span class="line">		<span class="keyword">return</span> retVal;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1、获取 TransactionInfo</li>
<li>2、执行切面</li>
<li>3、将之前挂起的 <code>TransactionInfo</code> 找回：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindToThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Expose current TransactionStatus, preserving any existing TransactionStatus</span></span><br><span class="line">	<span class="comment">// for restoration after this transaction is complete.</span></span><br><span class="line">	<span class="keyword">this</span>.oldTransactionInfo = transactionInfoHolder.get();</span><br><span class="line">	transactionInfoHolder.set(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreThreadLocalStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Use stack to restore old transaction TransactionInfo.</span></span><br><span class="line">	<span class="comment">// Will be null if none was set.</span></span><br><span class="line">	transactionInfoHolder.set(<span class="keyword">this</span>.oldTransactionInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4、如果需要，则提交当前事务</li>
<li>5、返回切面值</li>
</ul>
<h4 id="4-5-最后一块拼图，spring-如何与-sqlSession-产生关联："><a href="#4-5-最后一块拼图，spring-如何与-sqlSession-产生关联：" class="headerlink" title="4.5 最后一块拼图，spring 如何与 sqlSession 产生关联："></a>4.5 最后一块拼图，spring 如何与 sqlSession 产生关联：</h4><p>我们在第三章讲到，mybatis有一个叫做 <code>defualtSqlSessionFactory</code> 的类，负责创建 <code>sqlSession</code>，但是它和 spring 又是怎么产生关联的呢？</p>
<p>答案就在于，spring 实现了自己的 <code>TransactionFactory</code>，以及自己的 <code>Transaction</code> 对象 <code>SpringManagedTransaction</code> 。回顾一下 <code>SqlSession</code> 的创建过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">    <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下 <code>SpringManagedTransaction</code> 是如何管理 <code>connection</code>的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.connection = DataSourceUtils.getConnection(<span class="keyword">this</span>.dataSource);</span><br><span class="line">  <span class="keyword">this</span>.autoCommit = <span class="keyword">this</span>.connection.getAutoCommit();</span><br><span class="line">  <span class="keyword">this</span>.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(<span class="keyword">this</span>.connection, <span class="keyword">this</span>.dataSource);</span><br><span class="line"></span><br><span class="line">  LOGGER.debug(() -&gt; <span class="string">"JDBC Connection ["</span> + <span class="keyword">this</span>.connection + <span class="string">"] will"</span></span><br><span class="line">      + (<span class="keyword">this</span>.isConnectionTransactional ? <span class="string">" "</span> : <span class="string">" not "</span>) + <span class="string">"be managed by Spring"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DataSourceUtils.getConnection(this.dataSource);</code> 划重点，里面的实现不用我多说了，我们可以看到熟悉的身影，也就是 <code>ConnectionHolder</code>，连接是从这里(优先)拿的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);</span><br><span class="line"><span class="keyword">if</span> (conHolder != <span class="keyword">null</span> &amp;&amp; (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) &#123;</span><br><span class="line">	conHolder.requested();</span><br><span class="line">	<span class="keyword">if</span> (!conHolder.hasConnection()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Fetching resumed JDBC Connection from DataSource"</span>);</span><br><span class="line">		conHolder.setConnection(fetchConnection(dataSource));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> conHolder.getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新整套体系图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-81228c6c6e264f6b6d58b4fad12565d62ec.JPEG" alt="img"></p>
<p>我们整体简单过一次：</p>
<ul>
<li>mybatis 启动时根据xml、注解创建了 <code>mapperedStatement</code>，用于sql执行，创建了 <code>SqlSessionFactory</code> 用于创建 <code>SqlSession</code> 对象。</li>
<li>mybatis 启动时创建了 <code>MapperProxyFactory</code> 用于创建接口的代理对象 <code>MapperProxy</code></li>
<li>在创建 <code>MapperProxy</code> 时，spring 为其注入了一个 <code>sqlSession</code> 用于 sql执行，但是这个 <code>sqlSession</code> 是一个代理对象，叫做 <code>sqlSessionTemplate</code>，它会自动选择我们该使用哪个 <code>sqlSession</code> 去执行</li>
<li>在执行时，spring 切面在执行事务之前，会创建一个叫做 <code>TransactionInfo</code> 的对象，此对象会根据事务传播等级来控制是否创建新连接，是否挂起上一个连接，将信息保存在 <code>TransactionSynchronizationManager</code></li>
<li>到了真正需要创建或者获取 <code>sqlSession</code> 时，spring 重写的 <code>TransactionFactory</code> 会优先去 <code>TransactionSynchronizationManager</code> 中拿连接对象。</li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>高效开发 Dubbo？用 Spring Boot 可得劲！</title>
    <url>/2020/01/03/2020/01/%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%20Dubbo%EF%BC%9F%E7%94%A8%20Spring%20Boot%20%E5%8F%AF%E5%BE%97%E5%8A%B2%EF%BC%81/</url>
    <content><![CDATA[<p>不仅简化了 Dubbo 基于 xml 配置的方式，也提高了日常开发效率，甚至提升了工作幸福感。</p>
<p>为了节省亲爱的读者您的时间，请根据以下2点提示来阅读本文，以提高您的阅读收获效率哦。</p>
<ul>
<li>如果您只有简单的 Java 基础和 Maven 经验，而不熟悉 Dubbo，本文档将帮助您从零开始使用 Spring Boot 开发 Dubbo 服务，并使用 EDAS 服务注册中心实现服务注册与发现。</li>
<li>如果您熟悉 Dubbo，可以选择性地阅读相关章节。</li>
</ul>
<h4 id="为什么使用-Spring-Boot-开发-Dubbo-应用"><a href="#为什么使用-Spring-Boot-开发-Dubbo-应用" class="headerlink" title="为什么使用 Spring Boot 开发 Dubbo 应用"></a>为什么使用 Spring Boot 开发 Dubbo 应用</h4><p>Spring Boot 使用极简的一些配置，就能快速搭建一个基于 Spring 的应用，提高的日常的开发效率。因此，如果您使用 Spring Boot 来开发基于 Dubbo 的应用，简化了 Bubbo 基于 xml 配置的方式，提高了日常开发效率，提升了工作幸福感。</p>
<h4 id="为什么使用-EDAS-服务注册中心"><a href="#为什么使用-EDAS-服务注册中心" class="headerlink" title="为什么使用 EDAS 服务注册中心"></a>为什么使用 EDAS 服务注册中心</h4><p>EDAS 服务注册中心实现了 Dubbo 所提供的 SPI 标准的<a href="http://dubbo.apache.org/zh-cn/docs/dev/impls/registry.html?spm=a2c4g.11186623.2.13.41344822aqNoSX" target="_blank" rel="noopener">注册中心扩展</a>，能够完整地支持 Dubbo 服务注册、<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html?spm=a2c4g.11186623.2.14.41344822aqNoSX" target="_blank" rel="noopener">路由规则</a>、<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/config-rule.html?spm=a2c4g.11186623.2.15.41344822aqNoSX" target="_blank" rel="noopener">配置规则功能</a>。</p>
<p>EDAS 服务注册中心能够完全代替 ZooKeeper 和 Redis，作为您 Dubbo 服务的注册中心。同时，与 ZooKeeper 和 Redis 相比，还具有以下优势：</p>
<ul>
<li>EDAS 服务注册中心为共享组件，节省了您运维、部署 ZooKeeper 等组件的机器成本。</li>
<li>EDAS 服务注册中心在通信过程中增加了鉴权加密功能，为您的服务注册链路进行了安全加固。</li>
<li>EDAS 服务注册中心与 EDAS 其他组件紧密结合，为您提供一整套的微服务解决方案。</li>
</ul>
<h4 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h4><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><ul>
<li>下载、启动及配置轻量级配置中心。</li>
</ul>
<p>为了便于本地开发，EDAS 提供了一个包含了 EDAS 服务注册中心基本功能的轻量级配置中心。基于轻量级配置中心开发的应用无需修改任何代码和配置就可以部署到云端的 EDAS 中。</p>
<p>请您参考 <a href="https://help.aliyun.com/document_detail/44163.html?spm=a2c4g.11186623.2.17.4fa073571VPegl" target="_blank" rel="noopener">配置轻量级配置中心</a> 进行下载、启动及配置。推荐使用最新版本。</p>
<ul>
<li>下载 <a href="http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.0/binaries/apache-maven-3.6.0-bin.tar.gz?spm=a2c4g.11186623.2.18.4fa073571VPegl&file=apache-maven-3.6.0-bin.tar.gz" target="_blank" rel="noopener">Maven</a> 并设置环境变量（本地已安装的可略过）。</li>
</ul>
<h5 id="创建服务提供者"><a href="#创建服务提供者" class="headerlink" title="创建服务提供者"></a>创建服务提供者</h5><p>1、创建一个 Spring Boot 工程，命名为 spring-boot-dubbo-provider。</p>
<p>这里我们以 Spring Boot 2.0.6.RELEASE 为例，在 pom.xml 文件中加入如下内容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.edas<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>edas-dubbo-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果您需要选择使用 Spring Boot 1.x 的版本，请使用 Spring Boot 1.5.x 版本，对应的 com.alibaba.boot:dubbo-spring-boot-starter 版本为 0.1.0。</p>
<p><strong>说明：</strong> Spring Boot 1.x 版本的生命周期即将在 2019 年 8 月 结束，推荐使用新版本开发您的应用。</p>
<p>2、开发 Dubbo 服务提供者</p>
<p>2.1、Dubbo 中服务都是以接口的形式提供的。因此需要开发一个接口，例如这里的 <strong>IHelloService</strong>，接口里有若干个可被调用的方法，例如这里的 <strong>SayHello</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.edas.boot;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.2、在服务提供方，需要实现所有以接口形式暴露的服务接口。例如这里实现 <strong>IHelloService</strong> 接口的类为 <strong>HelloServiceImpl</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.edas.boot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Service</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="string">"Hello, "</span> + name + <span class="string">" (from Dubbo with Spring Boot)"</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> 这里的 Service 注解式 Dubbo 提供的一个注解类，类的全名称为：<strong>com.alibaba.dubbo.config.annotation.Service</strong> 。</p>
<p>2.3、配置 Dubbo 服务。在 application.properties/application.yaml 配置文件中新增以下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Base packages to scan Dubbo Components (e.g @Service , @Reference)</span></span><br><span class="line"><span class="meta">dubbo.scan.basePackages</span>=<span class="string">com.alibaba.edas.boot</span></span><br><span class="line"><span class="meta">dubbo.application.name</span>=<span class="string">dubbo-provider-demo</span></span><br><span class="line"><span class="meta">dubbo.registry.address</span>=<span class="string">edas://127.0.0.1:8080</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>     </p>
<ul>
<li>以上三个配置没有默认值，必须要给出具体的配置。</li>
<li>dubbo.scan.basePackages 的值是开发的代码中含有 com.alibaba.dubbo.config.annotation.Service 和  com.alibaba.dubbo.config.annotation.Reference 注解所在的包。多个包之间用逗号隔开。</li>
<li>dubbo.registry.address 的值前缀必须是一个 <strong>edas://</strong> 开头，后面的ip地址和端口指的是轻量版配置中心</li>
</ul>
<p>3、开发并启动 Spring Boot 入口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.edas.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(DubboProvider<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、登录轻量版配置中心控制台 <a href="http://127.0.0.1:8080，在左侧导航栏中单击服务列表/">http://127.0.0.1:8080，在左侧导航栏中单击服务列表</a> ，查看提供者列表。可以看到服务提供者里已经包含了 com.alibaba.edas.IHelloService，且可以查询该服务的服务分组和提供者 IP。</p>
<h4 id="创建服务消费者"><a href="#创建服务消费者" class="headerlink" title="创建服务消费者"></a>创建服务消费者</h4><p>1、创建一个 Spring Boot 工程，命名为 spring-boot-dubbo-consumer。</p>
<p>这里我们以 Spring Boot 2.0.6.RELEASE 为例，在 pom.xml 文件中加入如下内容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.edas<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>edas-dubbo-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果您需要选择使用 Spring Boot 1.x 的版本，请使用 Spring Boot 1.5.x 版本，对应的 com.alibaba.boot:dubbo-spring-boot-starter 版本为 0.1.0。</p>
<p><strong>说明：</strong> Spring Boot 1.x 版本的生命周期即将在 2019 年 8 月 结束，推荐使用新版本开发您的应用。</p>
<p>2、开发 Dubbo 消费者</p>
<p>2.1、在服务消费方，需要引入所有以接口形式暴露的服务接口。例如这里 <strong>IHelloService</strong> 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.edas.boot;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">	    <span class="function">String <span class="title">sayHello</span><span class="params">(String str)</span></span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.2、Dubbo 服务调用。例如需要在 Controller 中调用一次远程 Dubbo 服务，开发的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.edas.boot;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> IHelloService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sayHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：这里的 Reference 注解是 com.alibaba.dubbo.config.annotation.Reference 。</p>
<p>2.3、配置 Dubbo 服务。在 application.properties/application.yaml 配置文件中新增以下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">dubbo.application.name</span>=<span class="string">dubbo-consumer-demo</span></span><br><span class="line"><span class="meta">dubbo.registry.address</span>=<span class="string">edas://127.0.0.1:8080</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> </p>
<ul>
<li>以上两个配置没有默认值，必须要给出具体的配置。</li>
<li>dubbo.registry.address 的值前缀必须是一个 <strong>edas://</strong> 开头，后面的ip地址和端口指的是轻量版配置中心</li>
</ul>
<p>3、开发并启动 Spring Boot 入口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.edas.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(DubboConsumer<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录轻量版配置中心控制台 <a href="http://127.0.0.1:8080，在左侧导航栏中单击/">http://127.0.0.1:8080，在左侧导航栏中单击</a> 服务列表 ，再在服务列表页面选择 调用者列表 ，可以看到包含了 com.alibaba.edas.IHelloService，且可以查看该服务的服务分组和调用者 IP。</p>
<h4 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h4><ul>
<li>本地结果验证</li>
</ul>
<blockquote>
<p>curl <a href="http://localhost:17080/sayHello/EDAS" target="_blank" rel="noopener">http://localhost:17080/sayHello/EDAS</a></p>
</blockquote>
<blockquote>
<p>Hello, EDAS (from Dubbo with Spring Boot)</p>
</blockquote>
<ul>
<li>EDAS 部署结果验证</li>
</ul>
<blockquote>
<p>curl <a href="http://localhost:8080/sayHello/EDAS" target="_blank" rel="noopener">http://localhost:8080/sayHello/EDAS</a></p>
</blockquote>
<blockquote>
<p>Hello, EDAS (from Dubbo with Spring Boot)</p>
</blockquote>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Dubbo</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>字节码增强技术探索</title>
    <url>/2020/01/08/2020/01/%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h4 id="1-字节码"><a href="#1-字节码" class="headerlink" title="1.字节码"></a>1.字节码</h4><h5 id="1-1-什么是字节码？"><a href="#1-1-什么是字节码？" class="headerlink" title="1.1 什么是字节码？"></a>1.1 什么是字节码？</h5><p>Java之所以可以“一次编译，到处运行”，一是因为JVM针对各种操作系统、平台都进行了定制，二是因为无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供JVM使用。因此，也可以看出字节码对于Java生态的重要性。之所以被称之为字节码，是因为字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单位进行读取。在Java中一般是用javac命令编译源代码为字节码文件，一个.java文件从编译到运行的示例如图1所示。</p>
<p><img src="https://p0.meituan.net/travelcube/110b593ecf53866e0dec8df3618b0443257977.png" alt="图1 Java运行示意图"></p>
<p>图1 Java运行示意图</p>
<p>对于开发人员，了解字节码可以更准确、直观地理解Java语言中更深层次的东西，比如通过字节码，可以很直观地看到Volatile关键字如何在字节码上生效。另外，字节码增强技术在Spring AOP、各种ORM框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益。除此之外，由于JVM规范的存在，只要最终可以生成符合规范的字节码就可以在JVM上运行，因此这就给了各种运行在JVM上的语言（如Scala、Groovy、Kotlin）一种契机，可以扩展Java所没有的特性或者实现各种语法糖。理解字节码后再学习这些语言，可以“逆流而上”，从字节码视角看它的设计思路，学习起来也“易如反掌”。</p>
<p>本文重点着眼于字节码增强技术，从字节码开始逐层向上，由JVM字节码操作集合到Java中操作字节码的框架，再到我们熟悉的各类框架原理及应用，也都会一一进行介绍。</p>
<h5 id="1-2-字节码结构"><a href="#1-2-字节码结构" class="headerlink" title="1.2 字节码结构"></a>1.2 字节码结构</h5><p>.java文件通过javac编译后将得到一个.class文件，比如编写一个简单的ByteCodeDemo类，如下图2的左侧部分：</p>
<p><img src="https://p0.meituan.net/travelcube/de80a67bdb1c0a47d6adb3a0420a826d1235757.png" alt="图2 示例代码（左侧）及对应的字节码（右侧）"></p>
<p>图2 示例代码（左侧）及对应的字节码（右侧）</p>
<p>编译后生成ByteCodeDemo.class文件，打开后是一堆十六进制数，按字节为单位进行分割后展示如图2右侧部分所示。上文提及过，JVM对于字节码是有规范要求的，那么看似杂乱的十六进制符合什么结构呢？JVM规范要求每一个字节码文件都要由十部分按照固定的顺序组成，整体结构如图3所示。接下来我们将一一介绍这十部分：</p>
<p><img src="https://p0.meituan.net/travelcube/393097261d80d730f434561157e219c657820.png" alt="图3 JVM规定的字节码结构"></p>
<p>图3 JVM规定的字节码结构</p>
<p>（1） 魔数（Magic Number）</p>
<p>所有的.class文件的前四个字节都是魔数，魔数的固定值为：0xCAFEBABE。魔数放在文件开头，JVM可以根据文件的开头来判断这个文件是否可能是一个.class文件，如果是，才会继续进行之后的操作。</p>
<blockquote>
<p>有趣的是，魔数的固定值是Java之父James Gosling制定的，为CafeBabe（咖啡宝贝），而Java的图标为一杯咖啡。</p>
</blockquote>
<p>（2） 版本号</p>
<p>版本号为魔数之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。上图2中版本号为“00 00 00 34”，次版本号转化为十进制为0，主版本号转化为十进制为52，在Oracle官网中查询序号52对应的主版本号为1.8，所以编译该文件的Java版本号为1.8.0。</p>
<p>（3） 常量池（Constant Pool）</p>
<p>紧接着主版本号之后的字节为常量池入口。常量池中存储两类常量：字面量与符号引用。字面量为代码中声明为Final的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体上分为两部分：常量池计数器以及常量池数据区，如下图4所示。</p>
<p><img src="https://p0.meituan.net/travelcube/ac90457d635b90e2c08bf7659b0b7dfd50229.png" alt="图4 常量池的结构"></p>
<p>图4 常量池的结构</p>
<ul>
<li>常量池计数器（constant_pool_count）：由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。图2中示例代码的字节码前10个字节如下图5所示，将十六进制的24转化为十进制值为36，排除掉下标“0”，也就是说，这个类文件中共有35个常量。</li>
</ul>
<p><img src="https://p0.meituan.net/travelcube/ed119aae2b6bdacde724db6489e3600550525.png" alt="图5 前十个字节及含义"></p>
<p>图5 前十个字节及含义</p>
<ul>
<li>常量池数据区：数据区是由（constant_pool_count-1）个cp_info结构组成，一个cp_info结构对应一个常量。在字节码中共有14种类型的cp_info（如下图6所示），每种类型的结构都是固定的。</li>
</ul>
<p><img src="https://p0.meituan.net/travelcube/f5bdc7e8203ec666a531fcd19cdbcddc519208.png" alt="图6 各类型的cp_info"></p>
<p>图6 各类型的cp_info</p>
<p>具体以CONSTANT_utf8_info为例，它的结构如下图7左侧所示。首先一个字节“tag”，它的值取自上图6中对应项的Tag，由于它的类型是utf8_info，所以值为“01”。接下来两个字节标识该字符串的长度Length，然后Length个字节为这个字符串具体的值。从图2中的字节码摘取一个cp_info结构，如下图7右侧所示。将它翻译过来后，其含义为：该常量类型为utf8字符串，长度为一字节，数据为“a”。</p>
<p><img src="https://p1.meituan.net/travelcube/a230e57d6737ff00b1fa38d5265255db301604.png" alt="图7 CONSTANT_utf8_info的结构（左）及示例（右）"></p>
<p>图7 CONSTANT_utf8_info的结构（左）及示例（右）</p>
<p>其他类型的cp_info结构在本文不再赘述，整体结构大同小异，都是先通过Tag来标识类型，然后后续n个字节来描述长度和（或）数据。先知其所以然，以后可以通过javap -verbose ByteCodeDemo命令，查看JVM反编译后的完整常量池，如下图8所示。可以看到反编译结果将每一个cp_info结构的类型和值都很明确地呈现了出来。</p>
<p><img src="https://p0.meituan.net/travelcube/5a0e4dd2f0476a0e1521737d19b3c803448375.png" alt="图8 常量池反编译结果"></p>
<p>图8 常量池反编译结果</p>
<p>（4） 访问标志</p>
<p>常量池结束之后的两个字节，描述该Class是类还是接口，以及是否被Public、Abstract、Final等修饰符修饰。JVM规范规定了如下图9的访问标志（Access_Flag）。需要注意的是，JVM并没有穷举所有的访问标志，而是使用按位或操作来进行描述的，比如某个类的修饰符为Public Final，则对应的访问修饰符的值为ACC_PUBLIC | ACC_FINAL，即0x0001 | 0x0010=0x0011。</p>
<p><img src="https://p0.meituan.net/travelcube/7a750dfc34fa8f54f45c261bc8dd67f4222300.png" alt="图9 访问标志"></p>
<p>图9 访问标志</p>
<p>（5） 当前类名</p>
<p>访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。</p>
<p>（6） 父类名称</p>
<p>当前类名后的两个字节，描述父类的全限定名，同上，保存的也是常量池中的索引值。</p>
<p>（7） 接口信息</p>
<p>父类名称后为两字节的接口计数器，描述了该类或父类实现的接口数量。紧接着的n个字节是所有接口名称的字符串常量的索引值。</p>
<p>（8） 字段表</p>
<p>字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。字段表也分为两部分，第一部分为两个字节，描述字段个数；第二部分是每个字段的详细信息fields_info。字段表结构如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/0f795d2b2b28ce96b5963efb2e564e5a197874.png" alt="图10 字段表结构"></p>
<p>图10 字段表结构</p>
<p>以图2中字节码的字段表为例，如下图11所示。其中字段的访问标志查图9，0002对应为Private。通过索引下标在图8中常量池分别得到字段名为“a”，描述符为“I”（代表int）。综上，就可以唯一确定出一个类中声明的变量private int a。</p>
<p><img src="https://p0.meituan.net/travelcube/bd2b14ec23771a8f6a20699d1295dec6129370.png" alt="图11 字段表示例"></p>
<p>图11 字段表示例</p>
<p>（9）方法表</p>
<p>字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数；第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性，如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/d84d5397da84005d9e21d5289afa29e755614.png" alt="图12 方法表结构"></p>
<p>图12 方法表结构</p>
<p>方法的权限修饰符依然可以通过图9的值查询得到，方法名和方法的描述符都是常量池中的索引值，可以通过索引值在常量池中找到。而“方法的属性”这一部分较为复杂，直接借助javap -verbose将其反编译为人可以读懂的信息进行解读，如图13所示。可以看到属性中包括以下三个部分：</p>
<ul>
<li>“Code区”：源代码对应的JVM指令操作码，在进行字节码增强时重点操作的就是“Code区”这一部分。</li>
<li>“LineNumberTable”：行号表，将Code区的操作码和源代码中的行号对应，Debug时会起到作用（源代码走一行，需要走多少个JVM指令操作码）。</li>
<li>“LocalVariableTable”：本地变量表，包含This和局部变量，之所以可以在每一个方法内部都可以调用This，是因为JVM将This作为每一个方法的第一个参数隐式进行传入。当然，这是针对非Static方法而言。</li>
</ul>
<p><img src="https://p0.meituan.net/travelcube/27b4609c522ee39916f14ee3f510af8a296734.png" alt="图13 反编译后的方法表"></p>
<p>图13 反编译后的方法表</p>
<p>（10）附加属性表</p>
<p>字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息。</p>
<h5 id="1-3-字节码操作集合"><a href="#1-3-字节码操作集合" class="headerlink" title="1.3 字节码操作集合"></a>1.3 字节码操作集合</h5><p>在上图13中，Code区的红色编号0～17，就是.java中的方法源代码编译后让JVM真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码与助记符的对应关系，以及每一个操作码的用处可以查看Oracle官方文档进行了解，在需要用到时进行查阅即可。比如上图中第一个助记符为iconst_2，对应到图2中的字节码为0x05，用处是将int值2压入操作数栈中。以此类推，对0~17的助记符理解后，就是完整的add()方法的实现。</p>
<h5 id="1-4-操作数栈和字节码"><a href="#1-4-操作数栈和字节码" class="headerlink" title="1.4 操作数栈和字节码"></a>1.4 操作数栈和字节码</h5><p>JVM的指令集是基于栈而不是寄存器，基于栈可以具备很好的跨平台性（因为寄存器指令集往往和硬件挂钩），但缺点在于，要完成同样的操作，基于栈的实现需要更多指令才能完成（因为栈只是一个FILO结构，需要频繁压栈出栈）。另外，由于栈是在内存实现的，而寄存器是在CPU的高速缓存区，相较而言，基于栈的速度要慢很多，这也是为了跨平台性而做出的牺牲。</p>
<p>我们在上文所说的操作码或者操作集合，其实控制的就是这个JVM的操作数栈。为了更直观地感受操作码是如何控制操作数栈的，以及理解常量池、变量表的作用，将add()方法的对操作数栈的操作制作为GIF，如下图14所示，图中仅截取了常量池中被引用的部分，以指令iconst_2开始到ireturn结束，与图13中Code区0~17的指令一一对应：</p>
<p><img src="https://p1.meituan.net/travelcube/ac42012daa48396d66eda1e9adcdb8c5624301.gif" alt="图14 控制操作数栈示意图"></p>
<p>图14 控制操作数栈示意图</p>
<h5 id="1-5-查看字节码工具"><a href="#1-5-查看字节码工具" class="headerlink" title="1.5 查看字节码工具"></a>1.5 查看字节码工具</h5><p>如果每次查看反编译后的字节码都使用javap命令的话，好非常繁琐。这里推荐一个Idea插件：<a href="https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer" target="_blank" rel="noopener">jclasslib</a>。使用效果如图15所示，代码编译后在菜单栏”View”中选择”Show Bytecode With jclasslib”，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息。</p>
<p><img src="https://p0.meituan.net/travelcube/1983db2e05eab90be4a101033e54825292211.png" alt="图15 jclasslib查看字节码"></p>
<p>图15 jclasslib查看字节码</p>
<h4 id="2-字节码增强"><a href="#2-字节码增强" class="headerlink" title="2. 字节码增强"></a>2. 字节码增强</h4><p>在上文中，着重介绍了字节码的结构，这为我们了解字节码增强技术的实现打下了基础。字节码增强技术就是一类对现有字节码进行修改或者动态生成全新字节码文件的技术。接下来，我们将从最直接操纵字节码的实现方式开始深入进行剖析。</p>
<p><img src="https://p0.meituan.net/travelcube/12e1964581f38f04488dfc6d2f84f003110966.png" alt="图16 字节码增强技术"></p>
<p>图16 字节码增强技术</p>
<h5 id="2-1-ASM"><a href="#2-1-ASM" class="headerlink" title="2.1 ASM"></a>2.1 ASM</h5><p>对于需要手动操纵字节码的需求，可以使用ASM，它可以直接生产 .class字节码文件，也可以在类被加载入JVM之前动态修改类行为（如下图17所示）。ASM的应用场景有AOP（Cglib就是基于ASM）、热部署、修改其他jar包中的类等。当然，涉及到如此底层的步骤，实现起来也比较麻烦。接下来，本文将介绍ASM的两种API，并用ASM来实现一个比较粗糙的AOP。但在此之前，为了让大家更快地理解ASM的处理流程，强烈建议读者先对<a href="https://en.wikipedia.org/wiki/Visitor_pattern" target="_blank" rel="noopener">访问者模式</a>进行了解。简单来说，访问者模式主要用于修改或操作一些数据结构比较稳定的数据，而通过第一章，我们知道字节码文件的结构是由JVM固定的，所以很适合利用访问者模式对字节码文件进行修改。</p>
<p><img src="https://p0.meituan.net/travelcube/3c40b90c6d92499ad4c708162095fe3029983.png" alt="图17 ASM修改字节码"></p>
<p>图17 ASM修改字节码</p>
<h5 id="2-1-1-ASM-API"><a href="#2-1-1-ASM-API" class="headerlink" title="2.1.1 ASM API"></a>2.1.1 ASM API</h5><h6 id="2-1-1-1-核心API"><a href="#2-1-1-1-核心API" class="headerlink" title="2.1.1.1 核心API"></a>2.1.1.1 核心API</h6><p>ASM Core API可以类比解析XML文件中的SAX方式，不需要把这个类的整个结构读取进来，就可以用流式的方法来处理字节码文件。好处是非常节约内存，但是编程难度较大。然而出于性能考虑，一般情况下编程都使用Core API。在Core API中有以下几个关键类：</p>
<ul>
<li>ClassReader：用于读取已经编译好的.class文件。</li>
<li>ClassWriter：用于重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</li>
<li>各种Visitor类：如上所述，CoreAPI根据字节码从上到下依次处理，对于字节码文件中不同的区域有不同的Visitor，比如用于访问方法的MethodVisitor、用于访问类变量的FieldVisitor、用于访问注解的AnnotationVisitor等。为了实现AOP，重点要使用的是MethodVisitor。</li>
</ul>
<h6 id="2-1-1-2-树形API"><a href="#2-1-1-2-树形API" class="headerlink" title="2.1.1.2 树形API"></a>2.1.1.2 树形API</h6><p>ASM Tree API可以类比解析XML文件中的DOM方式，把整个类的结构读取到内存中，缺点是消耗内存多，但是编程比较简单。TreeApi不同于CoreAPI，TreeAPI通过各种Node类来映射字节码的各个区域，类比DOM节点，就可以很好地理解这种编程方式。</p>
<h5 id="2-1-2-直接利用ASM实现AOP"><a href="#2-1-2-直接利用ASM实现AOP" class="headerlink" title="2.1.2 直接利用ASM实现AOP"></a>2.1.2 直接利用ASM实现AOP</h5><p>利用ASM的CoreAPI来增强类。这里不纠结于AOP的专业名词如切片、通知，只实现在方法调用前、后增加逻辑，通俗易懂且方便理解。首先定义需要被增强的Base类：其中只包含一个process()方法，方法内输出一行“process”。增强后，我们期望的是，方法执行前输出“start”，之后输出”end”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"process"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了利用ASM实现AOP，需要定义两个类：一个是MyClassVisitor类，用于对字节码的visit以及修改；另一个是Generator类，在这个类中定义ClassReader和ClassWriter，其中的逻辑是，classReader读取字节码，然后交给MyClassVisitor类处理，处理完成后由ClassWriter写字节码并将旧的字节码替换掉。Generator类较简单，我们先看一下它的实现，如下所示，然后重点解释MyClassVisitor类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassReader;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//读取</span></span><br><span class="line">        ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">"meituan/bytecode/asm/Base"</span>);</span><br><span class="line">        ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">        ClassVisitor classVisitor = <span class="keyword">new</span> MyClassVisitor(classWriter);</span><br><span class="line">        classReader.accept(classVisitor, ClassReader.SKIP_DEBUG);</span><br><span class="line">        <span class="keyword">byte</span>[] data = classWriter.toByteArray();</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"operation-server/target/classes/meituan/bytecode/asm/Base.class"</span>);</span><br><span class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        fout.write(data);</span><br><span class="line">        fout.close();</span><br><span class="line">        System.out.println(<span class="string">"now generator cc success!!!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyClassVisitor继承自ClassVisitor，用于对字节码的观察。它还包含一个内部类MyMethodVisitor，继承自MethodVisitor用于对类内方法的观察，它的整体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.objectweb.asm.ClassVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.MethodVisitor;</span><br><span class="line"><span class="keyword">import</span> org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassVisitor</span><span class="params">(ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(ASM5, cv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">                      String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        cv.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        MethodVisitor mv = cv.visitMethod(access, name, desc, signature,</span><br><span class="line">                exceptions);</span><br><span class="line">        <span class="comment">//Base类中有两个方法：无参构造以及process方法，这里不增强构造方法</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">"&lt;init&gt;"</span>) &amp;&amp; mv != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mv = <span class="keyword">new</span> MyMethodVisitor(mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyMethodVisitor</span><span class="params">(MethodVisitor mv)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Opcodes.ASM5, mv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.visitCode();</span><br><span class="line">            mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">            mv.visitLdcInsn(<span class="string">"start"</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)</span><br><span class="line">                    || opcode == Opcodes.ATHROW) &#123;</span><br><span class="line">                <span class="comment">//方法在返回之前，打印"end"</span></span><br><span class="line">                mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line">                mv.visitLdcInsn(<span class="string">"end"</span>);</span><br><span class="line">                mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mv.visitInsn(opcode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这个类就可以实现对字节码的修改。详细解读其中的代码，对字节码做修改的步骤是：</p>
<ul>
<li>首先通过MyClassVisitor类中的visitMethod方法，判断当前字节码读到哪一个方法了。跳过构造方法 `` 后，将需要被增强的方法交给内部类MyMethodVisitor来进行处理。</li>
<li>接下来，进入内部类MyMethodVisitor中的visitCode方法，它会在ASM开始访问某一个方法的Code区时被调用，重写visitCode方法，将AOP中的前置逻辑就放在这里。</li>
<li>MyMethodVisitor继续读取字节码指令，每当ASM访问到无参数指令时，都会调用MyMethodVisitor中的visitInsn方法。我们判断了当前指令是否为无参数的“return”指令，如果是就在它的前面添加一些指令，也就是将AOP的后置逻辑放在该方法中。</li>
<li>综上，重写MyMethodVisitor中的两个方法，就可以实现AOP了，而重写方法时就需要用ASM的写法，手动写入或者修改字节码。通过调用methodVisitor的visitXXXXInsn()方法就可以实现字节码的插入，XXXX对应相应的操作码助记符类型，比如mv.visitLdcInsn(“end”)对应的操作码就是ldc “end”，即将字符串“end”压入栈。</li>
</ul>
<p>完成这两个visitor类后，运行Generator中的main方法完成对Base类的字节码增强，增强后的结果可以在编译后的target文件夹中找到Base.class文件进行查看，可以看到反编译后的代码已经改变了（如图18左侧所示）。然后写一个测试类MyTest，在其中new Base()，并调用base.process()方法，可以看到下图右侧所示的AOP实现效果：</p>
<p><img src="https://p0.meituan.net/travelcube/885844f5bb478418a7a7faaceaec619a104853.png" alt="图18 ASM实现AOP的效果"></p>
<p>图18 ASM实现AOP的效果</p>
<h5 id="2-1-3-ASM工具"><a href="#2-1-3-ASM工具" class="headerlink" title="2.1.3 ASM工具"></a>2.1.3 ASM工具</h5><p>利用ASM手写字节码时，需要利用一系列visitXXXXInsn()方法来写对应的助记符，所以需要先将每一行源代码转化为一个个的助记符，然后通过ASM的语法转换为visitXXXXInsn()这种写法。第一步将源码转化为助记符就已经够麻烦了，不熟悉字节码操作集合的话，需要我们将代码编译后再反编译，才能得到源代码对应的助记符。第二步利用ASM写字节码时，如何传参也很令人头疼。ASM社区也知道这两个问题，所以提供了工具<a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline" target="_blank" rel="noopener">ASM ByteCode Outline</a>。</p>
<p>安装后，右键选择“Show Bytecode Outline”，在新标签页中选择“ASMified”这个tab，如图19所示，就可以看到这个类中的代码对应的ASM写法了。图中上下两个红框分别对应AOP中的前置逻辑于后置逻辑，将这两块直接复制到visitor中的visitMethod()以及visitInsn()方法中，就可以了。</p>
<p><img src="https://p0.meituan.net/travelcube/e7234eba0f40030de07189f2014d87f9224042.png" alt="图19 ASM Bytecode Outline"></p>
<p>图19 ASM Bytecode Outline</p>
<h5 id="2-2-Javassist"><a href="#2-2-Javassist" class="headerlink" title="2.2 Javassist"></a>2.2 Javassist</h5><p>ASM是在指令层次上操作字节码的，阅读上文后，我们的直观感受是在指令层次上操作字节码的框架实现起来比较晦涩。故除此之外，我们再简单介绍另外一类框架：强调源代码层次操作字节码的框架Javassist。</p>
<p>利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。其中最重要的是ClassPool、CtClass、CtMethod、CtField这四个类：</p>
<ul>
<li>CtClass（compile-time class）：编译时类信息，它是一个class文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个CtClass对象，用来表示这个类文件。</li>
<li>ClassPool：从开发视角来看，ClassPool是一张保存CtClass信息的HashTable，key为类名，value为类名对应的CtClass对象。当我们需要对某个类进行修改时，就是通过pool.getCtClass(“className”)方法从pool中获取到相应的CtClass。</li>
<li>CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。</li>
</ul>
<p>了解这四个类后，我们可以写一个小Demo来展示Javassist简单、快速的特点。我们依然是对Base中的process()方法做增强，在方法调用前后分别输出”start”和”end”，实现代码如下。我们需要做的就是从pool中获取到相应的CtClass对象和其中的方法，然后执行method.insertBefore和insertAfter方法，参数为要插入的Java代码，再以字符串的形式传入即可，实现起来也极为简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.meituan.mtrace.agent.javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException, IllegalAccessException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        ClassPool cp = ClassPool.getDefault();</span><br><span class="line">        CtClass cc = cp.get(<span class="string">"meituan.bytecode.javassist.Base"</span>);</span><br><span class="line">        CtMethod m = cc.getDeclaredMethod(<span class="string">"process"</span>);</span><br><span class="line">        m.insertBefore(<span class="string">"&#123; System.out.println(\"start\"); &#125;"</span>);</span><br><span class="line">        m.insertAfter(<span class="string">"&#123; System.out.println(\"end\"); &#125;"</span>);</span><br><span class="line">        Class c = cc.toClass();</span><br><span class="line">        cc.writeFile(<span class="string">"/Users/zen/projects"</span>);</span><br><span class="line">        Base h = (Base)c.newInstance();</span><br><span class="line">        h.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-运行时类的重载"><a href="#3-运行时类的重载" class="headerlink" title="3. 运行时类的重载"></a>3. 运行时类的重载</h4><h5 id="3-1-问题引出"><a href="#3-1-问题引出" class="headerlink" title="3.1 问题引出"></a>3.1 问题引出</h5><p>上一章重点介绍了两种不同类型的字节码操作框架，且都利用它们实现了较为粗糙的AOP。其实，为了方便大家理解字节码增强技术，在上文中我们避重就轻将ASM实现AOP的过程分为了两个main方法：第一个是利用MyClassVisitor对已编译好的class文件进行修改，第二个是new对象并调用。这期间并不涉及到JVM运行时对类的重加载，而是在第一个main方法中，通过ASM对已编译类的字节码进行替换，在第二个main方法中，直接使用已替换好的新类信息。另外在Javassist的实现中，我们也只加载了一次Base类，也不涉及到运行时重加载类。</p>
<p>如果我们在一个JVM中，先加载了一个类，然后又对其进行字节码增强并重新加载会发生什么呢？模拟这种情况，只需要我们在上文中Javassist的Demo中main()方法的第一行添加Base b=new Base()，即在增强前就先让JVM加载Base类，然后在执行到c.toClass()方法时会抛出错误，如下图20所示。跟进c.toClass()方法中，我们会发现它是在最后调用了ClassLoader的native方法defineClass()时报错。也就是说，JVM是不允许在运行时动态重载一个类的。</p>
<p><img src="https://p0.meituan.net/travelcube/de7c8af6c1b6e0f6ebbc08a512a9cb88271265.png" alt="图20 运行时重复load类的错误信息"></p>
<p>图20 运行时重复load类的错误信息</p>
<p>显然，如果只能在类加载前对类进行强化，那字节码增强技术的使用场景就变得很窄了。我们期望的效果是：在一个持续运行并已经加载了所有类的JVM中，还能利用字节码增强技术对其中的类行为做替换并重新加载。为了模拟这种情况，我们将Base类做改写，在其中编写main方法，每五秒调用一次process()方法，在process()方法中输出一行“process”。</p>
<p>我们的目的就是，在JVM运行中的时候，将process()方法做替换，在其前后分别打印“start”和“end”。也就是在运行中时，每五秒打印的内容由”process”变为打印”start process end”。那如何解决JVM不允许运行时重加载类信息的问题呢？为了达到这个目的，我们接下来一一来介绍需要借助的Java类库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">        String s = name.split(<span class="string">"@"</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//打印当前Pid</span></span><br><span class="line">        System.out.println(<span class="string">"pid:"</span>+s);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            process();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"process"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-Instrument"><a href="#3-2-Instrument" class="headerlink" title="3.2 Instrument"></a>3.2 Instrument</h5><p>instrument是JVM提供的一个可以修改已加载类的类库，专门为Java语言编写的插桩服务提供支持。它需要依赖JVMTI的Attach API机制实现，JVMTI这一部分，我们将在下一小节进行介绍。在JDK 1.6以前，instrument只能在JVM刚启动开始加载类时生效，而在JDK 1.6之后，instrument支持了在运行时对类定义的修改。要使用instrument的类修改功能，我们需要实现它提供的ClassFileTransformer接口，定义一个类文件转换器。接口中的transform()方法会在类文件被加载时调用，而在transform方法里，我们可以利用上文中的ASM或Javassist对传入的字节码进行改写或替换，生成新的字节码数组后返回。</p>
<p>我们定义一个实现了ClassFileTransformer接口的类TestTransformer，依然在其中利用Javassist对Base类中的process()方法进行增强，在前后分别打印“start”和“end”，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Transforming "</span> + className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPool cp = ClassPool.getDefault();</span><br><span class="line">            CtClass cc = cp.get(<span class="string">"meituan.bytecode.jvmti.Base"</span>);</span><br><span class="line">            CtMethod m = cc.getDeclaredMethod(<span class="string">"process"</span>);</span><br><span class="line">            m.insertBefore(<span class="string">"&#123; System.out.println(\"start\"); &#125;"</span>);</span><br><span class="line">            m.insertAfter(<span class="string">"&#123; System.out.println(\"end\"); &#125;"</span>);</span><br><span class="line">            <span class="keyword">return</span> cc.toBytecode();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有了Transformer，那么它要如何注入到正在运行的JVM呢？还需要定义一个Agent，借助Agent的能力将Instrument注入到JVM中。我们将在下一小节介绍Agent，现在要介绍的是Agent中用到的另一个类Instrumentation。在JDK 1.6之后，Instrumentation可以做启动后的Instrument、本地代码（Native Code）的Instrument，以及动态改变Classpath等等。我们可以向Instrumentation中添加上文中定义的Transformer，并指定要被重加载的类，代码如下所示。这样，当Agent被Attach到一个JVM中时，就会执行类字节码替换并重载入JVM的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAgent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定我们自己定义的Transformer，在其中利用Javassist做字节码替换</span></span><br><span class="line">        inst.addTransformer(<span class="keyword">new</span> TestTransformer(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//重定义类并载入新的字节码</span></span><br><span class="line">            inst.retransformClasses(Base<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(<span class="string">"Agent Load Done."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"agent load failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-JVMTI-amp-Agent-amp-Attach-API"><a href="#3-3-JVMTI-amp-Agent-amp-Attach-API" class="headerlink" title="3.3 JVMTI &amp; Agent &amp; Attach API"></a>3.3 JVMTI &amp; Agent &amp; Attach API</h5><p>上一小节中，我们给出了Agent类的代码，追根溯源需要先介绍JPDA（Java Platform Debugger Architecture）。如果JVM启动时开启了JPDA，那么类是允许被重新加载的。在这种情况下，已被加载的旧版本类信息可以被卸载，然后重新加载新版本的类。正如JDPA名称中的Debugger，JDPA其实是一套用于调试Java程序的标准，任何JDK都必须实现该标准。</p>
<p>JPDA定义了一整套完整的体系，它将调试体系分为三部分，并规定了三者之间的通信接口。三部分由低到高分别是Java 虚拟机工具接口（JVMTI），Java 调试协议（JDWP）以及 Java 调试接口（JDI），三者之间的关系如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/16655ee86f5ca48c33a894d15146cef2115190.png" alt="图21 JPDA"></p>
<p>图21 JPDA</p>
<p>现在回到正题，我们可以借助JVMTI的一部分能力，帮助动态重载类信息。JVM TI（JVM TOOL INTERFACE，JVM工具接口）是JVM提供的一套对JVM进行操作的工具接口。通过JVMTI，可以实现对JVM的多种操作，它通过接口注册各种事件勾子，在JVM事件触发时，同时触发预定义的勾子，以实现对各个JVM事件的响应，事件包括类文件加载、异常产生与捕获、线程启动和结束、进入和退出临界区、成员变量修改、GC开始和结束、方法调用进入和退出、临界区竞争与等待、VM启动与退出等等。</p>
<p>而Agent就是JVMTI的一种实现，Agent有两种启动方式，一是随Java进程启动而启动，经常见到的java -agentlib就是这种方式；二是运行时载入，通过attach API，将模块（jar包）动态地Attach到指定进程id的Java进程内。</p>
<p>Attach API 的作用是提供JVM进程间通信的能力，比如说我们为了让另外一个JVM进程把线上服务的线程Dump出来，会运行jstack或jmap的进程，并传递pid的参数，告诉它要对哪个进程进行线程Dump，这就是Attach API做的事情。在下面，我们将通过Attach API的loadAgent()方法，将打包好的Agent jar包动态Attach到目标JVM上。具体实现起来的步骤如下：</p>
<ul>
<li>定义Agent，并在其中实现AgentMain方法，如上一小节中定义的代码块7中的TestAgent类；</li>
<li>然后将TestAgent类打成一个包含MANIFEST.MF的jar包，其中MANIFEST.MF文件中将Agent-Class属性指定为TestAgent的全限定名，如下图所示；</li>
</ul>
<p><img src="https://p0.meituan.net/travelcube/40245adc76d037352a11aea7bf73ed2c36124.png" alt="图22 Manifest.mf"></p>
<p>图22 Manifest.mf</p>
<ul>
<li>最后利用Attach API，将我们打包好的jar包Attach到指定的JVM pid上，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException </span>&#123;</span><br><span class="line">        <span class="comment">// 传入目标 JVM pid</span></span><br><span class="line">        VirtualMachine vm = VirtualMachine.attach(<span class="string">"39333"</span>);</span><br><span class="line">        vm.loadAgent(<span class="string">"/Users/zen/operation_server_jar/operation-server.jar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于在MANIFEST.MF中指定了Agent-Class，所以在Attach后，目标JVM在运行时会走到TestAgent类中定义的agentmain()方法，而在这个方法中，我们利用Instrumentation，将指定类的字节码通过定义的类转化器TestTransformer做了Base类的字节码替换（通过javassist），并完成了类的重新加载。由此，我们达成了“在JVM运行时，改变类的字节码并重新载入类信息”的目的。</li>
</ul>
<p>以下为运行时重新载入类的效果：先运行Base中的main()方法，启动一个JVM，可以在控制台看到每隔五秒输出一次”process”。接着执行Attacher中的main()方法，并将上一个JVM的pid传入。此时回到上一个main()方法的控制台，可以看到现在每隔五秒输出”process”前后会分别输出”start”和”end”，也就是说完成了运行时的字节码增强，并重新载入了这个类。</p>
<p><img src="https://p0.meituan.net/travelcube/740a913e621fba61728bd5641e5ebfef56980.png" alt="图23 运行时重载入类的效果"></p>
<p>图23 运行时重载入类的效果</p>
<h5 id="3-4-使用场景"><a href="#3-4-使用场景" class="headerlink" title="3.4 使用场景"></a>3.4 使用场景</h5><p>至此，字节码增强技术的可使用范围就不再局限于JVM加载类前了。通过上述几个类库，我们可以在运行时对JVM中的类进行修改并重载了。通过这种手段，可以做的事情就变得很多了：</p>
<ul>
<li>热部署：不部署服务而对线上服务做修改，可以做打点、增加日志等操作。</li>
<li>Mock：测试时候对某些服务做Mock。</li>
<li>性能诊断工具：比如bTrace就是利用Instrument，实现无侵入地跟踪一个正在运行的JVM，监控到类和方法级别的状态信息。</li>
</ul>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>字节码增强技术相当于是一把打开运行时JVM的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪JVM运行中程序的状态。此外，我们平时使用的动态代理、AOP也与字节码增强密切相关，它们实质上还是利用各种手段生成符合规范的字节码文件。综上所述，掌握字节码增强后可以高效地定位并快速修复一些棘手的问题（如线上性能问题、方法出现不可控的出入参需要紧急加日志等问题），也可以在开发中减少冗余代码，大大提高开发效率。</p>
<h4 id="5-参考文献"><a href="#5-参考文献" class="headerlink" title="5. 参考文献"></a>5. 参考文献</h4><ul>
<li>《ASM4-Guide》</li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">Oracle:The class File Format</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Oracle:The Java Virtual Machine Instruction Set</a></li>
<li><a href="http://www.javassist.org/tutorial/tutorial.html" target="_blank" rel="noopener">javassist tutorial</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html" target="_blank" rel="noopener">JVM Tool Interface - Version 1.2</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>字节码</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList与CopyOnWriteArrayList常见操作与问题</title>
    <url>/2020/02/14/2020/02/ArrayList%E4%B8%8ECopyOnWriteArrayList%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="ArrayList循环遍历并删除元素的常见陷阱"><a href="#ArrayList循环遍历并删除元素的常见陷阱" class="headerlink" title="ArrayList循环遍历并删除元素的常见陷阱"></a>ArrayList循环遍历并删除元素的常见陷阱</h4><p>在工作和学习中，经常碰到删除ArrayList里面的某个元素，看似一个很简单的问题，却很容易出bug。不妨把这个问题当做一道面试题目，我想一定能难道不少的人。今天就给大家说一下在ArrayList循环遍历并删除元素的问题。首先请看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListRemove</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　ArrayList&lt;String&gt;list=newArrayList&lt;String&gt;();</span><br><span class="line">　　　　list.add(<span class="string">"a"</span>);</span><br><span class="line">　　　　list.add(<span class="string">"b"</span>);</span><br><span class="line">　　　　list.add(<span class="string">"b"</span>);</span><br><span class="line">　　　　list.add(<span class="string">"c"</span>);</span><br><span class="line">　　　　list.add(<span class="string">"c"</span>);</span><br><span class="line">　　　　list.add(<span class="string">"c"</span>);</span><br><span class="line">　　　　remove(list);</span><br><span class="line">　　　　<span class="keyword">for</span>(Strings:list)</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　System.out.println(<span class="string">"element : "</span>+s);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　<span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要想删除list的b字符，有下面两种常见的错误例子：</p>
<p>错误写法实例一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(inti=<span class="number">0</span>;i&lt;list.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Strings=list.get(i);</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">"b"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误的原因：这种最普通的循环写法执行后会发现第二个“b”的字符串没有删掉。</p>
<p>错误写法实例二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Strings:list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">"b"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误的原因：这种for-each写法会报出著名的并发修改异常：java.util.ConcurrentModificationException。</p>
<p>先解释一下实例一的错误原因。翻开JDK的ArrayList源码，先看下ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是入参不同，这里看的是入参为Object的remove方法）是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Objecto)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(intindex=<span class="number">0</span>;index&lt;size;index++)</span><br><span class="line">            <span class="keyword">if</span>(elementData[index]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(intindex=<span class="number">0</span>;index&lt;size;index++)</span><br><span class="line">                <span class="keyword">if</span>(o.equals(elementData[index]))&#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下程序的执行路径会走到else路径下最终调用faseRemove方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        intnumMoved=size-index-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numMoved&gt;<span class="number">0</span>)             </span><br><span class="line">        　　System.arraycopy(elementData,index+<span class="number">1</span>,elementData,index,numMoved);</span><br><span class="line">        elementData[--size]=<span class="keyword">null</span>;<span class="comment">// Let gc do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到会执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。针对错误写法一，在遍历第一个字符串b时因为符合删除条件，所以将该元素从数组中删除，并且将后一个元素移动（也就是第二个字符串b）至当前位置，导致下一次循环遍历时后一个字符串b并没有遍历到，所以无法删除。针对这种情况可以倒序删除的方式来避免：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(inti=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Strings=list.get(i);</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">"b"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组倒序遍历时即使发生元素删除也不影响后序元素遍历。</p>
<p>接着解释一下实例二的错误原因。错误二产生的原因却是foreach写法是对实际的Iterable、hasNext、next方法的简写，问题同样处在上文的fastRemove方法中，可以看到第一行把modCount变量的值加一，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            E next = get(cursor);</span><br><span class="line">            lastRet = cursor++;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行checkForComodification方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会做迭代器内部修改次数检查，因为上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。要避免这种情况的出现则在使用迭代器迭代时（显示或for-each的隐式）不要使用ArrayList的remove，改为用Iterator的remove即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            String s = it.next();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">"b"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>Doug Lea 大师就为我们提供 CopyOnWriteArrayList 容器可以保证线程安全，保证读读之间在任何时候都不会被阻塞，CopyOnWriteArrayList 也被广泛应用于很多业务场景之中，CopyOnWriteArrayList 值得被我们好好认识一番。</p>
<h5 id="CopyOnWrite的设计思想"><a href="#CopyOnWrite的设计思想" class="headerlink" title="CopyOnWrite的设计思想"></a>CopyOnWrite的设计思想</h5><p>如果简单的使用读写锁的话，在写锁被获取之后，读写线程被阻塞，只有当写锁被释放后读线程才有机会获取到锁从而读到最新的数据，站在<strong>读线程的角度来看，即读线程任何时候都是获取到最新的数据，满足数据实时性</strong>。既然我们说到要进行优化，必然有 trade-off,我们就可以<strong>牺牲数据实时性满足数据的最终一致性即可</strong>。而 CopyOnWriteArrayList 就是通过 Copy-On-Write(COW)，即写时复制的思想来通过延时更新的策略来实现数据的最终一致性，并且能够保证读线程间不阻塞。</p>
<p>COW 通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对 CopyOnWrite 容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，放弃数据实时性达到数据的最终一致性。</p>
<h5 id="CopyOnWriteArrayList-的实现原理"><a href="#CopyOnWriteArrayList-的实现原理" class="headerlink" title="CopyOnWriteArrayList 的实现原理"></a>CopyOnWriteArrayList 的实现原理</h5><p>现在我们来通过看源码的方式来理解 CopyOnWriteArrayList，实际上 CopyOnWriteArrayList 内部维护的就是一个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<p>并且该数组引用是被 volatile 修饰，注意这里<strong>仅仅是修饰的是数组引用</strong>，其中另有玄机，稍后揭晓。关于 volatile 很重要的一条性质是它能够够保证可见性，关于 volatile 的详细讲解可以看<a href="https://juejin.im/post/5ae9b41b518825670b33e6c4" target="_blank" rel="noopener">这篇文章</a>。对 list 来说，我们自然而然最关心的就是读写的时候，分别为 get 和 add 方法的实现。</p>
<h5 id="get-方法实现原理"><a href="#get-方法实现原理" class="headerlink" title="get 方法实现原理"></a>get 方法实现原理</h5><p>get 方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来 get 方法实现非常简单，几乎就是一个“单线程”程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有 CAS 操作等等，原因是，所有的读线程只是会读取数据容器中的数据，并不会进行修改。</p>
<h5 id="add-方法实现原理"><a href="#add-方法实现原理" class="headerlink" title="add 方法实现原理"></a>add 方法实现原理</h5><p>再来看下如何进行添加数据的？add 方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	<span class="comment">//1. 使用Lock,保证写线程在同一时刻只有一个</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//2. 获取旧数组引用</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">		<span class="comment">//3. 创建新的数组，并将旧数组的数据复制到新数组中</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//4. 往新数组中添加新的数据</span></span><br><span class="line">		newElements[len] = e;</span><br><span class="line">		<span class="comment">//5. 将旧数组引用指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add 方法的逻辑也比较容易理解，请看上面的注释。需要注意这么几点：</p>
<ol>
<li>采用 ReentrantLock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份被复制的数据；</li>
<li>前面说过数组引用是 volatile 修饰的，因此将旧的数组引用指向新的数组，根据 volatile 的 happens-before 规则，写线程对数组引用的修改对读线程是可见的。</li>
<li>由于在写数据的时候，是在新的数组中插入数据的，从而保证读写实在两个不同的数据容器中进行操作。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们知道 COW 和读写锁都是通过读写分离的思想实现的，但两者还是有些不同，可以进行比较：</p>
<blockquote>
<p><strong>COW vs 读写锁</strong></p>
</blockquote>
<p>相同点：1. 两者都是通过读写分离的思想实现；2.读线程间是互不阻塞的</p>
<p>不同点：<strong>对读线程而言，为了实现数据实时性，在写锁被获取后，读线程会等待或者当读锁被获取后，写线程会等待，从而解决“脏读”等问题。也就是说如果使用读写锁依然会出现读线程阻塞等待的情况。而 COW 则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延时感知的，因此读线程不会存在等待的情况</strong>。</p>
<p>对这一点从文字上还是很难理解，我们来通过 debug 看一下，add 方法核心代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.Object[] elements = getArray();</span><br><span class="line"><span class="number">2</span>.<span class="keyword">int</span> len = elements.length;</span><br><span class="line"><span class="number">3</span>.Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"><span class="number">4</span>.newElements[len] = e;</span><br><span class="line"><span class="number">5</span>.setArray(newElements);</span><br></pre></td></tr></table></figure>

<p>假设 COW 的变化如下图所示：</p>
<p><img src="http://static.cyblogs.com/QQ20200216-233236@2x.jpg" alt="http://static.cyblogs.com/QQ20200216-233236@2x.jpg"></p>
<p>数组中已有数据 1,2,3，现在写线程想往数组中添加数据 4，我们在第 5 行处打上断点，让写线程暂停。读线程依然会“不受影响”的能从数组中读取数据，可是还是只能读到 1,2,3。<strong>如果读线程能够立即读到新添加的数据的话就叫做能保证数据实时性</strong>。当对第 5 行的断点放开后，读线程才能感知到数据变化，读到完整的数据 1,2,3,4，而保证<strong>数据最终一致性</strong>，尽管有可能中间间隔了好几秒才感知到。</p>
<p>这里还有这样一个问题： <strong>为什么需要复制呢？ 如果将 array 数组设定为 volitile 的， 对 volatile 变量写 happens-before 读，读线程不是能够感知到 volatile 变量的变化</strong>。</p>
<p>原因是，这里 volatile 的修饰的<strong>仅仅</strong>只是<strong>数组引用</strong>，<strong>数组中的元素的修改是不能保证可见性的</strong>。因此 COW 采用的是新旧两个数据容器，通过第 5 行代码将数组引用指向新的数组。</p>
<p>这也是为什么 concurrentHashMap 只具有弱一致性的原因，关于 concurrentHashMap 的弱一致性可以<a href="http://ifeve.com/volatile-array-visiblity/294529737/" target="_blank" rel="noopener">看这篇文章</a>。</p>
<blockquote>
<p><strong>COW 的缺点</strong></p>
</blockquote>
<p>CopyOnWrite 容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<ol>
<li><strong>内存占用问题</strong>：因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对 象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对 象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比 如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 minor GC 和 major GC。</li>
<li><strong>数据一致性问题</strong>：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="https://juejin.im/post/5aeeb55f5188256715478c21" target="_blank" rel="noopener">https://juejin.im/post/5aeeb55f5188256715478c21</a></li>
<li><a href="https://www.cnblogs.com/huangjinyong/p/9455163.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangjinyong/p/9455163.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS原理分析及ABA问题详解</title>
    <url>/2020/02/15/2020/02/CAS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8AABA%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h4><p><code>CAS</code>即<code>Compare And Swap</code>的缩写，翻译成中文就是<strong>比较并交换</strong>，其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新，也就是CAS是<strong>原子性</strong>的操作(读和写两者同时具有原子性)，其实现方式是通过借助<code>C/C++</code>调用CPU指令完成的，所以效率很高。<br><code>CAS</code>的原理很简单，这里使用一段<code>Java</code>代码来描述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        如果内存中的值value和期望值expect一样 则将值更新为新值update</span></span><br><span class="line">    <span class="keyword">if</span> (value == expect) &#123;</span><br><span class="line">        value = update;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致过程是将内存中的值、我们的期望值、新值交给CPU进行运算，如果内存中的值和我们的期望值相同则将值更新为新值，否则不做任何操作。这个过程是在CPU中完成的，这里不好描述CPU的工作过程，就拿Java代码来描述了。 </p>
<h4 id="Unsafe源码分析"><a href="#Unsafe源码分析" class="headerlink" title="Unsafe源码分析"></a>Unsafe源码分析</h4><p>Java是在<code>Unsafe(sun.misc.Unsafe)</code>类实现<code>CAS</code>的操作，而我们知道Java是无法直接访问操作系统底层的API的(原因是Java的跨平台性限制了Java不能和操作系统耦合)，所以Java并没有在<code>Unsafe</code>类直接实现<code>CAS</code>的操作，而是通过<strong>JDI(Java Native Interface)</strong>本地调用<code>C/C++</code>语言来实现<code>CAS</code>操作的。<br><code>Unsafe</code>有很多个<code>CAS</code>操作的相关方法，这里举例几个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们拿<code>public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</code>进行分析，这个方法是比较内存中的一个值(整型)和我们的期望值(var4)是否一样，如果一样则将内存中的这个值更新为<code>var5</code>，参数中的<code>var1</code>是值所在的对象，<code>var2</code>是值在对象(var1)中的内存偏移量，<strong>参数var1和参数var2是为了定位出值所在内存的地址</strong>。<br><img src="http://static.cyblogs.com/e0e01e43ly1g11dbvrjwoj21ay0bujtl.jpg" alt="http://static.cyblogs.com/e0e01e43ly1g11dbvrjwoj21ay0bujtl.jpg"><br><strong>Unsafe.java在这里发挥的作用有：</strong></p>
<ol>
<li>将对象引用、值在对象中的偏移量、期望的值和欲更新的新值传递给<code>Unsafe.cpp</code></li>
<li>如果值更新成功则返回<code>true</code>给开发者，没有更新则返回<code>false</code></li>
</ol>
<p><strong>Unsafe.cpp在这里发挥的作用有：</strong></p>
<ol>
<li>接受从<code>Unsafe</code>传递过来的对象引用、偏移量、期望的值和欲更新的新值，根据对象引用和偏移量<strong>计算出值的地址</strong>，然后将值的地址、期望的值、欲更新的新值传递给CPU</li>
<li>如果值更新成功则返回<code>true</code>给<code>Unsafe.java</code>，没有更新则返回<code>false</code></li>
</ol>
<p><strong>CPU在这里发挥的作用：</strong></p>
<ol>
<li>接受从<code>Unsafe.cpp</code>传递过来的地址、期望的值和欲更新的新值，执行指令<code>cmpxchg</code>，比较地址中的值是否和期望的值一样，一样则将值更新为新的值，不一样则不做任何操作</li>
<li>将操作结果返回给<code>Unsafe.cpp</code></li>
</ol>
<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><p><code>CAS</code>虽然高效的实现了原子性操作，但是也存在一些缺点，主要表现在以下三个方面。</p>
<h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>在多线程场景下<code>CAS</code>会出现<code>ABA</code>问题，关于ABA问题这里简单科普下，例如有2个线程同时对同一个值(初始值为A)进行CAS操作，这三个线程如下 </p>
<ol>
<li>线程1，期望值为A，欲更新的值为B</li>
<li>线程2，期望值为A，欲更新的值为B</li>
</ol>
<p>线程<code>1</code>抢先获得CPU时间片，而线程<code>2</code>因为其他原因阻塞了，线程<code>1</code>取值与期望的A值比较，发现相等然后将值更新为B，然后这个时候<strong>出现了线程<code>3</code>，期望值为B，欲更新的值为A</strong>，线程3取值与期望的值B比较，发现相等则将值更新为A，此时线程<code>2</code>从阻塞中恢复，并且获得了CPU时间片，这时候线程<code>2</code>取值与期望的值A比较，发现相等则将值更新为B，虽然线程<code>2</code>也完成了操作，但是线程<code>2</code>并不知道值已经经过了<code>A-&gt;B-&gt;A</code>的变化过程。 </p>
<p><strong><code>ABA</code>问题带来的危害</strong>：<br>小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50<br>线程1（提款机）：获取当前值100，期望更新为50，<br>线程2（提款机）：获取当前值100，期望更新为50，<br>线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50<br>线程3（默认）：获取当前值50，期望更新为100，<br>这时候线程3成功执行，余额变为100，<br>线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！<br>此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的成功提交。</p>
<p><strong>解决方法</strong>：<br>在变量前面加上版本号，每次变量更新的时候变量的<strong>版本号都<code>+1</code></strong>，即<code>A-&gt;B-&gt;A</code>就变成了<code>1A-&gt;2B-&gt;3A</code>。</p>
<h5 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h5><p>如果<code>CAS</code>操作失败，就需要循环进行<code>CAS</code>操作(循环同时将期望值更新为最新的)，如果长时间都不成功的话，那么会造成CPU极大的开销。</p>
<blockquote>
<p>这种循环也称为自旋</p>
</blockquote>
<p><strong>解决方法</strong>：<br>限制自旋次数，防止进入死循环。</p>
<h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p><code>CAS</code>的原子操作只能针对一个共享变量。</p>
<p><strong>解决方法</strong>：<br>如果需要对多个共享变量进行操作，可以使用加锁方式(悲观锁)保证原子性，或者可以把多个共享变量合并成一个共享变量进行<code>CAS</code>操作。</p>
<h4 id="CAS的应用"><a href="#CAS的应用" class="headerlink" title="CAS的应用"></a>CAS的应用</h4><p>我们知道<code>CAS</code>操作并不会锁住共享变量，也就是一种<strong>非阻塞</strong>的同步机制，<code>CAS</code>就是乐观锁的实现。</p>
<ol>
<li>乐观锁<br><strong>乐观锁</strong>总是假设最好的情况，每次去操作数据都认为不会被别的线程修改数据，<strong>所以在每次操作数据的时候都不会给数据加锁</strong>，即在线程对数据进行操作的时候，<strong>别的线程不会阻塞</strong>仍然可以对数据进行操作，只有在需要更新数据的时候才会去判断数据是否被别的线程修改过，如果数据被修改过则会拒绝操作并且返回错误信息给用户。</li>
<li>悲观锁<br><strong>悲观锁</strong>总是假设最坏的情况，每次去操作数据时候都认为会被的线程修改数据，<strong>所以在每次操作数据的时候都会给数据加锁</strong>，让别的线程无法操作这个数据，别的线程会一直阻塞直到获取到这个数据的锁。这样的话就会影响效率，比如当有个线程发生一个很耗时的操作的时候，别的线程只是想获取这个数据的值而已都要等待很久。</li>
</ol>
<p><code>Java</code>利用<code>CAS</code>的乐观锁、原子性的特性高效解决了多线程的安全性问题，例如JDK1.8中的集合类<code>ConcurrentHashMap</code>、关键字<code>volatile</code>、<code>ReentrantLock</code>等。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li>原文地址：<a href="https://ddnd.cn/2019/03/13/java-cas/" target="_blank" rel="noopener">https://ddnd.cn/2019/03/13/java-cas/</a></li>
<li><a href="https://zl198751.iteye.com/blog/1848575" target="_blank" rel="noopener">https://zl198751.iteye.com/blog/1848575</a></li>
<li><a href="http://objcoding.com/2018/11/29/cas" target="_blank" rel="noopener">http://objcoding.com/2018/11/29/cas</a></li>
<li><a href="https://segmentfault.com/a/1190000014858404#articleHeader3" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014858404#articleHeader3</a></li>
<li><a href="https://www.zhihu.com/question/23281499" target="_blank" rel="noopener">https://www.zhihu.com/question/23281499</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU Cache与高性能编程</title>
    <url>/2020/02/16/2020/02/CPU%20Cache%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="认识CPU-Cache"><a href="#认识CPU-Cache" class="headerlink" title="认识CPU Cache"></a>认识CPU Cache</h4><h5 id="CPU-Cache概述"><a href="#CPU-Cache概述" class="headerlink" title="CPU Cache概述"></a>CPU Cache概述</h5><p>随着CPU的频率不断提升，而内存的访问速度却没有质的突破，为了弥补访问内存的速度慢，充分发挥CPU的计算资源，提高CPU整体吞吐量，在CPU与内存之间引入了一级Cache。随着热点数据体积越来越大，一级Cache L1已经不满足发展的要求，引入了二级Cache L2，三级Cache L3。（注：若无特别说明，本文的Cache指CPU Cache，高速缓存）CPU Cache在存储器层次结构中的示意如下图：</p>
<p><img src="http://static.cyblogs.com/20161111081230139.png" alt="http://static.cyblogs.com/20161111081230139.png"></p>
<p>计算机早已进入多核时代，软件也越来越多的支持多核运行。一个处理器对应一个物理插槽，多处理器间通过QPI总线相连。一个处理器包含多个核，一个处理器间的多核共享L3 Cache。一个核包含寄存器、L1 Cache、L2 Cache，下图是Intel Sandy Bridge CPU架构，一个典型的NUMA多处理器结构：</p>
<p><img src="http://static.cyblogs.com/20161111081336921.png" alt="http://static.cyblogs.com/20161111081336921.png"></p>
<p>作为程序员，需要理解计算机存储器层次结构，它对应用程序的性能有巨大的影响。如果需要的程序是在CPU寄存器中的，指令执行时1个周期内就能访问到他们。如果在CPU Cache中，需要1<del>30个周期；如果在主存中，需要50</del>200个周期；在磁盘上，大概需要几千万个周期。充分利用它的结构和机制，可以有效的提高程序的性能。</p>
<p>以我们常见的X86芯片为例，Cache的结构下图所示：整个Cache被分为S个组，每个组是又由E行个最小的存储单元——Cache Line所组成，而一个Cache Line中有B（B=64）个字节用来存储数据，即每个Cache Line能存储64个字节的数据，每个Cache Line又额外包含一个有效位(valid bit)、t个标记位(tag bit)，其中valid bit用来表示该缓存行是否有效；tag bit用来协助寻址，唯一标识存储在CacheLine中的块；而Cache Line里的64个字节其实是对应内存地址中的数据拷贝。根据Cache的结构题，我们可以推算出每一级Cache的大小为B×E×S。</p>
<p><img src="http://static.cyblogs.com/20161111081422178.png" alt="http://static.cyblogs.com/20161111081422178.png"></p>
<p>那么如何查看自己电脑CPU的Cache信息呢？</p>
<p>在windows下查看方式有多种方式，其中最直观的是，通过安装CPU-Z软件，直接显示Cache信息，如下图：</p>
<p><img src="http://static.cyblogs.com/20161111081516632.png" alt="http://static.cyblogs.com/20161111081516632.png"></p>
<p>此外，Windows下还有两种方法：</p>
<p>①Windows API调用GetLogicalProcessorInfo。<br>②通过命令行系统内部工具CoreInfo。</p>
<p>如果是Linux系统， 可以使用下面的命令查看Cache信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /sys/devices/system/cpu/cpu0/cache/index0</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/20161111081643978.png" alt="http://static.cyblogs.com/20161111081643978.png"></p>
<p>还有lscpu等命令也可以查看相关信息,如果是Mac系统，可以用sysctl machdep.cpu 命令查看cpu信息。</p>
<p>如果我们用Java编程，还可以通过CacheSize API方式来获取Cache信息， CacheSize是一个谷歌的小项目，java语言通过它可以进行访问本机Cache的信息。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CacheNotFoundException </span>&#123;</span><br><span class="line">    CacheInfo info = CacheInfo.getInstance(); </span><br><span class="line">    CacheLevelInfo l1Datainf = info.getCacheInformation(CacheLevel.L1, CacheType.DATA_CACHE);</span><br><span class="line">    System.out.println(<span class="string">"第一级数据缓存信息："</span>+l1Datainf.toString());</span><br><span class="line">		CacheLevelInfo l1Instrinf = info.getCacheInformation(CacheLevel.L1, CacheType.INSTRUCTION_CACHE);</span><br><span class="line">    System.out.println(<span class="string">"第一级指令缓存信息："</span>+l1Instrinf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一级数据缓存信息：CacheLevelInfo [cacheLevel=L1, cacheType=DATA_CACHE, cacheSets=<span class="number">64</span>, cacheCoherencyLineSize=<span class="number">64</span>, cachePhysicalLinePartitions=<span class="number">1</span>, cacheWaysOfAssociativity=<span class="number">8</span>, isFullyAssociative=<span class="keyword">false</span>, isSelfInitializing=<span class="keyword">true</span>, totalSizeInBytes=<span class="number">32768</span>]</span><br><span class="line"></span><br><span class="line">第一级指令缓存信息：CacheLevelInfo [cacheLevel=L1, cacheType=INSTRUCTION_CACHE, cacheSets=<span class="number">64</span>, cacheCoherencyLineSize=<span class="number">64</span>, cachePhysicalLinePartitions=<span class="number">1</span>, cacheWaysOfAssociativity=<span class="number">8</span>, isFullyAssociative=<span class="keyword">false</span>, isSelfInitializing=<span class="keyword">true</span>, totalSizeInBytes=<span class="number">32768</span>]</span><br><span class="line">还可以查询L2、L3级缓存的信息，这里不做示例。从打印的信息和CPU-Z显示的信息可以看出，本机的Cache信息是一致的，L1数据/指令缓存大小都为：C=B×E×S=<span class="number">64</span>×<span class="number">8</span>×<span class="number">64</span>=<span class="number">32768</span>字节=<span class="number">32</span>KB。</span><br></pre></td></tr></table></figure>

<h4 id="Cache-Line伪共享及解决方案"><a href="#Cache-Line伪共享及解决方案" class="headerlink" title="Cache Line伪共享及解决方案"></a>Cache Line伪共享及解决方案</h4><h5 id="Cache-Line伪共享分析"><a href="#Cache-Line伪共享分析" class="headerlink" title="Cache Line伪共享分析"></a>Cache Line伪共享分析</h5><p>说伪共享前，先看看Cache Line 在java编程中使用的场景。如果CPU访问的内存数据不在Cache中（一级、二级、三级），这就产生了Cache Line miss问题，此时CPU不得不发出新的加载指令，从内存中获取数据。通过前面对Cache存储层次的理解，我们知道一旦CPU要从内存中访问数据就会产生一个较大的时延，程序性能显著降低，所谓远水救不了近火。为此我们不得不提高Cache命中率，也就是充分发挥局部性原理。</p>
<p>局部性包括时间局部性、空间局部性。时间局部性：对于同一数据可能被多次使用，自第一次加载到Cache Line后，后面的访问就可以多次从Cache Line中命中，从而提高读取速度（而不是从下层缓存读取）。空间局部性：一个Cache Line有64字节块，我们可以充分利用一次加载64字节的空间，把程序后续会访问的数据，一次性全部加载进来，从而提高Cache Line命中率（而不是重新去寻址读取）。</p>
<p>看个例子：内存地址是连续的数组（利用空间局部性），能一次被L1缓存加载完成。</p>
<p>如下代码，长度为16的row和column数组，在Cache Line 64字节数据块上内存地址是连续的，能被一次加载到Cache Line中，所以在访问数组时，Cache Line命中率高，性能发挥到极致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span>[] row, <span class="keyword">int</span>[] column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ ) &#123;</span><br><span class="line">        sum += row[i] * column[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>而上面例子中变量i则体现了时间局部性，i作为计数器被频繁操作，一直存放在寄存器中，每次从寄存器访问，而不是从主存甚至磁盘访问。虽然连续紧凑的内存分配带来高性能，但并不代表它一直都能带来高性能。如果把它放在多线程中将会发生什么呢？如图：</p>
<p><img src="http://static.cyblogs.com/20161111081903485.png" alt="http://static.cyblogs.com/20161111081903485.png"></p>
<p>数据X、Y、Z被加载到同一Cache Line中，线程A在Core1修改X，线程B在Core2上修改Y。根据MESI大法，假设是Core1是第一个发起操作的CPU核，Core1上的L1 Cache Line由S（共享）状态变成M（修改，脏数据）状态，然后告知其他的CPU核，图例则是Core2，引用同一地址的Cache Line已经无效了；当Core2发起写操作时，首先导致Core1将X写回主存，Cache Line状态由M变为I（无效），而后才是Core2从主存重新读取该地址内容，Cache Line状态由I变成E（独占），最后进行修改Y操作， Cache Line从E变成M。可见多个线程操作在同一Cache Line上的不同数据，相互竞争同一Cache Line，导致线程彼此牵制影响，变成了串行程序，降低了并发性。此时我们则需要将共享在多线程间的数据进行隔离，使他们不在同一个Cache Line上，从而提升多线程的性能。</p>
<h5 id="Cache-Line伪共享处理方案"><a href="#Cache-Line伪共享处理方案" class="headerlink" title="Cache Line伪共享处理方案"></a>Cache Line伪共享处理方案</h5><p>处理伪共享的两种方式：</p>
<p>增大数组元素的间隔使得不同线程存取的元素位于不同的cache line上。典型的空间换时间。（Linux cache机制与之相关）<br>在每个线程中创建全局数组各个元素的本地拷贝，然后结束后再写回全局数组。<br>在Java类中，最优化的设计是考虑清楚哪些变量是不变的，哪些是经常变化的，哪些变化是完全相互独立的，哪些属性一起变化。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> modifyTime;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>假如业务场景中，上述的类满足以下几个特点：</p>
<p>当value变量改变时，modifyTime肯定会改变<br>createTime变量和key变量在创建后，就不会再变化。<br>flag也经常会变化，不过与modifyTime和value变量毫无关联。<br>当上面的对象需要由多个线程同时的访问时，从Cache角度来说，就会有一些有趣的问题。当我们没有加任何措施时，Data对象所有的变量极有可能被加载在L1缓存的一行Cache Line中。在高并发访问下，会出现这种问题：</p>
<p><img src="http://static.cyblogs.com/20161111082043281.png" alt="http://static.cyblogs.com/20161111082043281.png"></p>
<p>如上图所示，每次value变更时，根据MESI协议，对象其他CPU上相关的Cache Line全部被设置为失效。其他的处理器想要访问未变化的数据(key 和 createTime)时，必须从内存中重新拉取数据，增大了数据访问的开销。</p>
<p>Padding 方式<br>正确的方式应该将该对象属性分组，将一起变化的放在一组，与其他属性无关的属性放到一组，将不变的属性放到一组。这样当每次对象变化时，不会带动所有的属性重新加载缓存，提升了读取效率。在JDK1.8以前，我们一般是在属性间增加长整型变量来分隔每一组属性。被操作的每一组属性占的字节数加上前后填充属性所占的字节数，不小于一个cache line的字节数就可以达到要求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataPadding</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a1,a2,a3,a4,a5,a6,a7,a8;<span class="comment">//防止与前一个对象产生伪共享</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">long</span> modifyTime;</span><br><span class="line">    <span class="keyword">long</span> b1,b2,b3,b4,b5,b6,b7,b8;<span class="comment">//防止不相关变量伪共享;</span></span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">long</span> c1,c2,c3,c4,c5,c6,c7,c8;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line">    <span class="keyword">long</span> d1,d2,d3,d4,d5,d6,d7,d8;<span class="comment">//防止与下一个对象产生伪共享</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过填充变量，使不相关的变量分开</p>
<h5 id="Contended注解方式"><a href="#Contended注解方式" class="headerlink" title="Contended注解方式"></a>Contended注解方式</h5><p>在JDK1.8中，新增了一种注解@sun.misc.Contended，来使各个变量在Cache line中分隔开。注意，jvm需要添加参数-XX:-RestrictContended才能开启此功能<br>用时，可以在类前或属性前加上此注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类前加上代表整个类的每个变量都会在单独的cache line中</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"restriction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContendedData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">long</span> modifyTime;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line">&#125;</span><br><span class="line">或者这种：</span><br><span class="line"><span class="comment">// 属性前加上时需要加上组标签</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"restriction"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContendedGroupData</span> </span>&#123;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"group1"</span>)</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"group1"</span>)</span><br><span class="line">    <span class="keyword">long</span> modifyTime;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"group2"</span>)</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"group3"</span>)</span><br><span class="line">    <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="meta">@sun</span>.misc.Contended(<span class="string">"group3"</span>)</span><br><span class="line">    <span class="keyword">char</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>采取上述措施图示：</p>
<p><img src="http://static.cyblogs.com/20161111082403755.png" alt="http://static.cyblogs.com/20161111082403755.png"></p>
<p>JDK1.8 ConcurrentHashMap的处理<br>java.util.concurrent.ConcurrentHashMap在这个如雷贯耳的Map中，有一个很基本的操作问题，在并发条件下进行++操作。因为++这个操作并不是原子的，而且在连续的Atomic中，很容易产生伪共享（false sharing）。所以在其内部有专门的数据结构来保存long型的数据:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（openjdk\jdk\src\share\classes\java\util\concurrent\ConcurrentHashMap.java line:<span class="number">2506</span>）：</span><br><span class="line"><span class="comment">/* ---------------- Counter support -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到该类中，是通过@sun.misc.Contended达到防止false sharing的目的</p>
<h5 id="JDK1-8-Thread-的处理"><a href="#JDK1-8-Thread-的处理" class="headerlink" title="JDK1.8 Thread 的处理"></a>JDK1.8 Thread 的处理</h5><p>java.lang.Thread在java中，生成随机数是和线程有着关联。而且在很多情况下，多线程下产生随机数的操作是很常见的，JDK为了确保产生随机数的操作不会产生false sharing ,把产生随机数的三个相关值设为独占cache line。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（openjdk\jdk\src\share\classes\java\lang\Thread.java line:<span class="number">2023</span>）</span><br><span class="line"><span class="comment">// The following three initially uninitialized fields are exclusively</span></span><br><span class="line"><span class="comment">// managed by class java.util.concurrent.ThreadLocalRandom. These</span></span><br><span class="line"><span class="comment">// fields are used to build the high-performance PRNGs in the</span></span><br><span class="line"><span class="comment">// concurrent code, and we can not risk accidental false sharing.</span></span><br><span class="line"><span class="comment">// Hence, the fields are isolated with @Contended.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The current seed for a ThreadLocalRandom */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">long</span> threadLocalRandomSeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">int</span> threadLocalRandomProbe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">int</span> threadLocalRandomSecondarySeed;</span><br></pre></td></tr></table></figure>
<h4 id="Java中对Cache-line经典设计"><a href="#Java中对Cache-line经典设计" class="headerlink" title="Java中对Cache line经典设计"></a>Java中对Cache line经典设计</h4><h5 id="Disruptor框架"><a href="#Disruptor框架" class="headerlink" title="Disruptor框架"></a>Disruptor框架</h5><h6 id="认识Disruptor"><a href="#认识Disruptor" class="headerlink" title="认识Disruptor"></a>认识Disruptor</h6><p>LMAX是在英国注册并受到FCA监管的外汇黄金交易所。也是欧洲第一家也是唯一一家采用多边交易设施Multilateral Trading Facility（MTF）拥有交易所牌照和经纪商牌照的欧洲顶级金融公司。LMAX的零售金融交易平台，是建立在JVM平台上，核心是一个业务逻辑处理器，它能够在一个线程里每秒处理6百万订单。业务逻辑处理器的核心就是Disruptor（注，本文Disruptor基于当前最新3.3.6版本），这是一个Java实现的并发组件，能够在无锁的情况下实现网络的Queue并发操作，它确保任何数据只由一个线程拥有以进行写访问，从而消除写争用的设计， 这种设计被称作“破坏者”，也是这样命名这个框架的。</p>
<p>Disruptor是一个线程内通信框架，用于线程里共享数据。与LinkedBlockingQueue类似，提供了一个高速的生产者消费者模型，广泛用于批量IO读写，在硬盘读写相关的程序中应用的十分广泛，Apache旗下的HBase、Hive、Storm等框架都有在使用Disruptor。LMAX 创建Disruptor作为可靠消息架构的一部分，并将它设计成一种在不同组件中共享数据非常快的方法。Disruptor运行大致流程入下图：</p>
<p><img src="http://static.cyblogs.com/20161111082723254.png" alt="http://static.cyblogs.com/20161111082723254.png"></p>
<p>图中左侧（Input Disruptor部分）可以看作多生产者单消费者模式。外部多个线程作为多生产者并发请求业务逻辑处理器（Business Logic Processor），这些请求的信息经过Receiver存放在粉红色的圆环中，业务处理器则作为消费者从圆环中取得数据进行处理。右侧（Output Disruptor部分）则可看作单生产者多消费者模式。业务逻辑处理器作为单生产者，发布数据到粉红色圆环中，Publisher作为多个消费者接受业务逻辑处理器的结果。这里两处地方的数据共享都是通过那个粉红色的圆环，它就是Disruptor的核心设计RingBuffer。</p>
<h6 id="Disruptor特点"><a href="#Disruptor特点" class="headerlink" title="Disruptor特点"></a>Disruptor特点</h6><p>1、无锁机制。<br>2、没有CAS操作，避免了内存屏障指令的耗时。<br>3、避开了Cache line伪共享的问题，也是Disruptor部分主要关注的主题。</p>
<h5 id="Disruptor对伪共享的处理"><a href="#Disruptor对伪共享的处理" class="headerlink" title="Disruptor对伪共享的处理"></a>Disruptor对伪共享的处理</h5><h6 id="RingBuffer类"><a href="#RingBuffer类" class="headerlink" title="RingBuffer类"></a>RingBuffer类</h6><p>RingBuffer类（即上节中粉红色的圆环）的类关系图如下：</p>
<p><img src="http://static.cyblogs.com/20161111082805708.png" alt="http://static.cyblogs.com/20161111082805708.png"></p>
<p>通过源码分析，RingBuffer的父类，RingBufferFields采用数组来实现存放线程间的共享数据。下图，第57行，entries数组。</p>
<p><img src="http://static.cyblogs.com/20161111082838223.png" alt="http://static.cyblogs.com/20161111082838223.png"></p>
<p>前面分析过数组比链表、树更具有缓存友好性，此处不做细表。不使用LinkedBlockingQueue队列，是基于无锁机制的考虑。详细分析可参考，并发编程网的翻译。这里我们主要分析RingBuffer的继承关系中的填充，解决缓存伪共享问题。如下图：</p>
<p><img src="http://static.cyblogs.com/20161111082919849.png" alt="http://static.cyblogs.com/20161111082919849.png"></p>
<p><img src="http://static.cyblogs.com/20161111082958287.png" alt="http://static.cyblogs.com/20161111082958287.png"></p>
<p>依据JVM对象继承关系中父类属性与子类属性，内存地址连续排列布局，RingBufferPad的protected long p1,p2,p3,p4,p5,p6,p7;作为缓存前置填充，RingBuffer中的protected long p1,p2,p3,p4,p5,p6,p7;作为缓存后置填充。这样任意线程访问RingBuffer时，RingBuffer放在父类RingBufferFields的属性，都是独占一行Cache line不会产生伪共享问题。如图，RingBuffer的操作字段在RingBufferFields中，使用rbf标识：</p>
<p><img src="http://static.cyblogs.com/20161111083200062.png" alt="http://static.cyblogs.com/20161111083200062.png"></p>
<p>按照一行缓存64字节计算，前后填充56字节（7个long），中间大于等于8字节的内容都能独占一行Cache line，此处rbf是大于8字节的。</p>
<h6 id="Sequence类"><a href="#Sequence类" class="headerlink" title="Sequence类"></a>Sequence类</h6><p>Sequence类用来跟踪RingBuffer和事件处理器的增长步数，支持多个并发操作包括CAS指令和写指令。同时使用了Padding方式来实现，如下为其类结构图及Padding的类。</p>
<p>Sequence里在volatile long value前后放置了7个long padding，来解决伪共享的问题。示意如图，此处Value等于8字节：</p>
<p>也许读者应该会认为这里的图示比上面RingBuffer的图示更好理解，这里的操作属性只有一个value，两个图相互结合就更能理解了。</p>
<h6 id="Sequencer的实现"><a href="#Sequencer的实现" class="headerlink" title="Sequencer的实现"></a>Sequencer的实现</h6><p>在RingBuffer构造函数里面存在一个Sequencer接口，用来遍历数据，在生产者和消费者之间传递数据。Sequencer有两个实现类，单生产者模式的实现SingleProducerSequencer与多生产者模式的实现MultiProducerSequencer。它们的类结构如图：</p>
<p>单生产者是在Cache line中使用padding方式实现，源码如下：</p>
<p><img src="http://static.cyblogs.com/20161111084637099.png" alt="http://static.cyblogs.com/20161111084637099.png"></p>
<p>多生产者则是使用 sun.misc.Unsafe来实现的。如下图：</p>
<p><img src="http://static.cyblogs.com/20161111084621458.png" alt="http://static.cyblogs.com/20161111084621458.png"></p>
<h4 id="总结与使用示例"><a href="#总结与使用示例" class="headerlink" title="总结与使用示例"></a>总结与使用示例</h4><p>可见padding方式在Disruptor中是处理伪共享常见的方式，JDK1.8的@Contended很好的解决了这个问题，不知道Disruptor后面的版本是否会考虑使用它。</p>
<p>Disruptor使用示例代码参考地址。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>7个示例科普CPU Cache：<a href="http://coolshell.cn/articles/10249.html" target="_blank" rel="noopener">http://coolshell.cn/articles/10249.html</a><br>Linux Cache 机制：<a href="http://www.cnblogs.com/liloke/archive/2011/11/20/2255737.html" target="_blank" rel="noopener">http://www.cnblogs.com/liloke/archive/2011/11/20/2255737.html</a><br>《深入理解计算机系统》：第六章部分<br>Disruptor官方文档：<a href="https://github.com/LMAX-Exchange/disruptor/tree/master/docs" target="_blank" rel="noopener">https://github.com/LMAX-Exchange/disruptor/tree/master/docs</a><br>Disruptor并发编程网文档翻译：<a href="http://ifeve.com/disruptor/" target="_blank" rel="noopener">http://ifeve.com/disruptor/</a></p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>CPU</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU的缓存L1、L2、L3与缓存行填充</title>
    <url>/2020/02/17/2020/02/CPU%E7%9A%84%E7%BC%93%E5%AD%98L1%E3%80%81L2%E3%80%81L3%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C%E5%A1%AB%E5%85%85/</url>
    <content><![CDATA[<p><code>L1，L2，L3</code> 指的都是<code>CPU</code>的缓存，他们比内存快，但是很昂贵，所以用作缓存，<code>CPU</code>查找数据的时候首先在L1，然后看<code>L2</code>，如果还没有，就到内存查找一些服务器还有<code>L3 Cache</code>，目的也是提高速度。</p>
<p>高速缓冲存储器<code>Cache</code>是位于<code>CPU</code>与内存之间的临时存储器，它的容量比内存小但交换速度快。在<code>Cache</code>中的数据是内存中的一小部分，但这一小部分是短时间内<code>CPU</code>即将访问的，当<code>CPU</code>调用大量数据时，就可避开内存直接从<code>Cache</code>中调用，从而加快读取速度。由此可见，在<code>CPU</code>中加入<code>Cache</code>是一种高效的解决方案，这样整个内存储器<code>（Cache+内存）</code>就变成了既有<code>Cache</code>的高速度，又有内存的大容量的存储系统了。<code>Cache</code>对<code>CPU</code>的性能影响很大，主要是因为<code>CPU</code>的数据交换顺序和<code>CPU</code>与<code>Cache</code>间的带宽引起的。</p>
<p><img src="http://static.cyblogs.com/20161111081230139.png" alt="http://static.cyblogs.com/20161111081230139.png"></p>
<h4 id="高速缓存的工作原理"><a href="#高速缓存的工作原理" class="headerlink" title="高速缓存的工作原理"></a>高速缓存的工作原理</h4><h5 id="1．-读取顺序"><a href="#1．-读取顺序" class="headerlink" title="1． 读取顺序"></a>1． 读取顺序</h5><p><code>CPU</code>要读取一个数据时，首先从<code>Cache</code>中查找，如果找到就立即读取并送给<code>CPU</code>处理；如果没有找到，就用相对慢的速度从内存中读取并送给<code>CPU</code>处理，同时把这个数据所在的数据块调入<code>Cache</code>中，可以使得以后对整块数据的读取都从<code>Cache</code>中进行，不必再调用内存。</p>
<p>正是这样的读取机制使<code>CPU</code>读取<code>Cache</code>的命中率非常高（大多数<code>CPU</code>可达90%左右），也就是说<code>CPU</code>下一次要读取的数据90%都在<code>Cache</code>中，只有大约10%需要从内存读取。这大大节省了<code>CPU</code>直接读取内存的时间，也使<code>CPU</code>读取数据时基本无需等待。总的来说，<code>CPU</code>读取数据的顺序是先Cache后内存。</p>
<h5 id="2．-缓存分类"><a href="#2．-缓存分类" class="headerlink" title="2． 缓存分类"></a>2． 缓存分类</h5><p>前面是把<code>Cache</code>作为一个整体来考虑的，现在要分类分析了。<code>Intel</code>从<code>Pentium</code>开始将<code>Cache</code>分开，通常分为<code>一级高速缓存L1</code>和<code>二级高速缓存L2</code>。</p>
<p>在以往的观念中，<code>L1 Cache</code>是集成在<code>CPU</code>中的，被称为片内<code>Cache</code>。在<code>L1</code>中还分数据<code>Cache（I-Cache）</code>和指令<code>Cache（D-Cache）</code>。它们分别用来存放数据和执行这些数据的指令，而且两个<code>Cache</code>可以同时被<code>CPU</code>访问，减少了争用Cache所造成的冲突，提高了处理器效能。</p>
<p><img src="http://static.cyblogs.com/20161111081336921.png" alt="http://static.cyblogs.com/20161111081336921.png"></p>
<p>在P4处理器中使用了一种先进的一级指令Cache——动态跟踪缓存。它直接和执行单元及动态跟踪引擎相连，通过动态跟踪引擎可以很快地找到所执行的指令，并且将指令的顺序存储在追踪缓存里，这样就减少了主执行循环的解码周期，提高了处理器的运算效率。</p>
<p>以前的<code>L2 Cache</code>没集成在<code>CPU</code>中，而在主板上或与<code>CPU</code>集成在同一块电路板上，因此也被称为<code>片外Cache</code>。但从PⅢ开始，由于工艺的提高<code>L2 Cache</code>被集成在<code>CPU</code>内核中，以相同于主频的速度工作，结束了<code>L2 Cache</code>与CPU大差距分频的历史，使<code>L2 Cache</code>与<code>L1 Cache</code>在性能上平等，得到更高的传输速度。<code>L2Cache</code>只存储数据，因此不分数据<code>Cache</code>和指令<code>Cache</code>。在<code>CPU</code>核心不变化的情况下，增加<code>L2 Cache</code>的容量能使性能提升，同一核心的<code>CPU</code>高低端之分往往也是在<code>L2 Cache</code>上做手脚，可见<code>L2 Cache</code>的重要性。现在<code>CPU</code>的<code>L1 Cache</code>与<code>L2 Cache</code>惟一区别在于读取顺序。</p>
<h5 id="3．-读取命中率"><a href="#3．-读取命中率" class="headerlink" title="3． 读取命中率"></a>3． 读取命中率</h5><p><code>CPU</code>在<code>Cache</code>中找到有用的数据被称为命中，当<code>Cache</code>中没有<code>CPU</code>所需的数据时（这时称为未命中），<code>CPU</code>才访问内存。从理论上讲，在一颗拥有2级<code>Cache</code>的<code>CPU</code>中，读取<code>L1 Cache</code>的命中率为<code>80%</code>。也就是说<code>CPU</code>从<code>L1 Cache</code>中找到的有用数据占数据总量的80%，剩下的20%从<code>L2 Cache</code>读取。由于不能准确预测将要执行的数据，读取L2的命中率也在80%左右（从L2读到有用的数据占总数据的16%）。那么还有的数据就不得不从内存调用，但这已经是一个相当小的比例了。在一些高端领域的<code>CPU</code>（像<code>Intel</code>的<code>Itanium</code>）中，我们常听到<code>L3 Cache</code>，它是为读取<code>L2 Cache</code>后未命中的数据设计的—种<code>Cache</code>，在拥有<code>L3 Cache</code>的<code>CPU</code>中，只有约5%的数据需要从内存中调用，这进一步提高了<code>CPU</code>的效率。</p>
<p>为了保证<code>CPU</code>访问时有较高的命中率，<code>Cache</code>中的内容应该按一定的算法替换。一种较常用的算法是“最近最少使用算法”（<code>LRU算法</code>），它是将最近一段时间内最少被访问过的行淘汰出局。因此需要为每行设置一个计数器，<code>LRU</code>算法是把命中行的计数器清零，其他各行计数器加1。当需要替换时淘汰行计数器计数值最大的数据行出局。这是一种高效、科学的算法，其计数器清零过程可以把一些频繁调用后再不需要的数据淘汰出<code>Cache</code>，提高<code>Cache</code>的利用率。</p>
<h4 id="缓存行填充"><a href="#缓存行填充" class="headerlink" title="缓存行填充"></a>缓存行填充</h4><p><code>CPU</code>访问内存时，并不是逐个字节访问，而是以字长为单位访问。比如32位的<code>CPU</code>，字长为4字节，那么<code>CPU</code>访问内存的单位也是4字节。</p>
<p>这么设计的目的，是减少<code>CPU</code>访问内存的次数，加大<code>CPU</code>访问内存的吞吐量。比如同样读取8个字节的数据，一次读取4个字节那么只需要读取2次。</p>
<p>我们来看看，编写程序时，变量在内存中是否按内存对齐的差异。有2个变量<code>word1、word2</code>：</p>
<p>图如下：</p>
<p><img src="http://static.cyblogs.com/WX20200211-152201@2x.png" alt="http://static.cyblogs.com/WX20200211-152201@2x.png"></p>
<p>我们假设<code>CPU</code>以<code>4字节</code>为单位读取内存。如果变量在内存中的布局按4字节对齐，那么读取a变量只需要读取一次内存，即<code>word1</code>；读取b变量也只需要读取一次内存，即<code>word2</code>。</p>
<p>而如果变量不做内存对齐，那么读取a变量也只需要读取一次内存，即<code>word1</code>；但是读取b变量时，由于b变量跨越了2个<code>word</code>，所以需要读取两次内存，分别读取<code>word1</code>和<code>word2</code>的值，然后将<code>word1</code>偏移取后3个字节，<code>word2</code>偏移取前1个字节，最后将它们做或操作，拼接得到b变量的值。</p>
<p>显然，内存对齐在某些情况下可以减少读取内存的次数以及一些运算，性能更高。</p>
<p>另外，由于内存对齐保证了读取b变量是单次操作，在多核环境下，原子性更容易保证。</p>
<p>但是内存对齐提升性能的同时，也需要付出相应的代价。由于变量与变量之间增加了填充，并没有存储真实有效的数据，所以占用的内存会更大。这也是一个典型的空间换时间的应用场景。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="https://blog.csdn.net/karamos/article/details/80126704" target="_blank" rel="noopener">https://blog.csdn.net/karamos/article/details/80126704</a></li>
<li><a href="https://pengrl.com/p/20020/" target="_blank" rel="noopener">https://pengrl.com/p/20020/</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>CPU</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>Double浮点数运算为啥会丢失精度？</title>
    <url>/2020/02/18/2020/02/Double%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%BA%E5%95%A5%E4%BC%9A%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6%EF%BC%9F/</url>
    <content><![CDATA[<p>作者：王念博客</p>
<p>来源：<a href="https://my.oschina.net/wangnian/blog/3064886" target="_blank" rel="noopener">https://my.oschina.net/wangnian/blog/3064886</a></p>
<p>前言：在工作中，谈到有小数点的加减乘除都会想到用BigDecimal来解决，但是有很多人对于<code>double</code>或者<code>float</code>为啥会丢失精度一脸茫然。还有<code>BigDecimal</code>是怎么解决的？话不多说，我们开始。</p>
<h4 id="浮点数是啥？"><a href="#浮点数是啥？" class="headerlink" title="浮点数是啥？"></a>浮点数是啥？</h4><p> 浮点数是计算机用来表示小数的一种数据类型，采用科学计数法。在java中，double是双精度，64位，浮点数，默认是0.0d。float是单精度，32位.浮点数，默认是0.0f；</p>
<p> 在内存中存储</p>
<p><img src="https://oscimg.oschina.net/oscnet/ac189484da6532ca2c14a25665bc97072b9.jpg" alt="img"></p>
<p>float   符号位(1bit)  指数(8 bit)   尾数(23 bit)<br>double  符号位(1bit) 指数(11 bit)  尾数(52 bit)</p>
<p>float在内存中指数是8bit，由于阶码实际存储的是指数的移码，假设指数的真值是e,阶码为E，则有E=e+(2^n-1 -1)。其中 2^n-1 -1是IEEE754标准规定的指数偏移量，根据这个公式我们可以得到 2^8 -1=127。于是，float的指数范围为-128  +127，而double的指数范围为-1024 +1023。其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。</p>
<p>float的范围为-2^128 ~ +2^127，也即-3.40E+38 ~ +3.40E+38；<br>double的范围为-2^1024 ~ +2^1023，也即-1.79E+308 ~ +1.79E+308</p>
<h4 id="走进失真之科学计数法"><a href="#走进失真之科学计数法" class="headerlink" title="走进失真之科学计数法"></a>走进失真之科学计数法</h4><p> 我们先说说科学计数法，科学计数法是一种简化计数的方法，用来近似表示一个极大或极小且位数较多的数，对于位数较小的数值，科学计数法没有什么优势，但对于位数较多的数值其计数方法的优势就非常明显了。例如：光的速速是300000000米/秒，全世界人口数大约是6100000000。类似光的速度和世界人口数这样大数值的数，读、写都很不方便，所以光的速度可以写成3<em>10^8，全世界人口数可以写成6.1</em>10^9。所以计算器用科学计数法表示光速是3E8，世界人口数大约是6.1E9。</p>
<p>我们小时候玩计算器喜欢疯狂的累加或者累减，到最后计算器就会显示下图。这个就是科学计数法显示的结果 </p>
<p><img src="https://oscimg.oschina.net/oscnet/c3bf5d2b1869e6754caa30e4f11c02a81cb.jpg" alt="img"></p>
<p>那图中真实的值是 -4.86*10^11=-486000000000。十进制科学计数法要求有效数字的整数部分必须在【1，9】区间内。</p>
<h4 id="走进失真之精度"><a href="#走进失真之精度" class="headerlink" title="走进失真之精度"></a>走进失真之精度</h4><p>计算机在处理数据都涉及到数据的转换和各种复杂运算，比如，不同单位换算，不同进制（如二进制十进制）换算等，很多除法运算不能除尽，比如10÷3=3.3333…..无穷无尽，而精度是有限的，3.3333333x3并不等于10，经过复杂的处理后得到的十进制数据并不精确，精度越高越精确。float和double的精度是由尾数的位数来决定的,其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。float：2^23 = 8388608，一共七位，由于最左为1的一位省略了，这意味着最多能表示8位数： 2<em>8388608 = 16777216 。有8位有效数字，但绝对能保证的为7位，也即*</em>float的精度为7<del>8位有效数字<strong>；double：2^52 = 4503599627370496，一共16位，同理，</strong>double的精度为16</del>17位*。</p>
<p><img src="https://oscimg.oschina.net/oscnet/731e52b8ffaa28fdf67b3e97b0c18969d2f.jpg" alt="img"></p>
<p>当到达一定值自动开始使用科学计数法，并保留相关精度的有效数字，所以结果是个近似数,并且指数为整数。在十进制中小数有些是无法完整用二进制表示的。所以只能用有限位来表示，从而在存储时可能就会有误差。对于十进制的小数转换成二进制采用乘2取整法进行计算，取掉整数部分后，剩下的小数继续乘以2,直到小数部分全为0。</p>
<p>如遇到 </p>
<p><img src="https://oscimg.oschina.net/oscnet/ea0a68703cbec84b967ed448a06acf9415a.jpg" alt="img"></p>
<p>输出是 0.19999999999999998</p>
<p>double类型 0.3-0.1的情况。需要将0.3转成二进制在运算</p>
<p>0.3 * 2 = 0.6 =&gt; .0 (.6)取0剩0.6<br>0.6 * 2 = 1.2 =&gt; .01 (.2)取1剩0.2<br>0.2 * 2 = 0.4 =&gt; .010 (.4)取0剩0.4<br>0.4 * 2 = 0.8 =&gt; .0100 (.8) 取0剩0.8<br>0.8 * 2 = 1.6 =&gt; .01001 (.6)取1剩0.6<br>………….</p>
<p><img src="https://oscimg.oschina.net/oscnet/91e5aa515fd1299d321d85b838adbddd484.jpg" alt="img"></p>
<p> 看完上面，大概清楚了为啥浮点数会有精度问题。简单来说float和double类型主要是为了科学计算和工程计算而设计，他们执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近和计算而精心设计的。然而，他们并没有提供完全精确的结果，所以不应该被用于精确的结果的场合。浮点数达到一定大的数会自动使用科学计数法，这样的表示只是近似真实数而不等于真实数。当十进制小数位转换二进制的时候也会出现无限循环或者超过浮点数尾数的长度。</p>
<h4 id="那我们怎么用BigDecimal来解决？"><a href="#那我们怎么用BigDecimal来解决？" class="headerlink" title="那我们怎么用BigDecimal来解决？"></a>那我们怎么用BigDecimal来解决？</h4><p>大家看下面的两个输出</p>
<p><img src="https://oscimg.oschina.net/oscnet/4dad3f8db2d9a65b3091fdbb50465a274d1.jpg" alt="img"></p>
<p>输出结果：</p>
<p>0.299999999999999988897769753748434595763683319091796875<br>0.3</p>
<p>图上阿里的代码约束插件已经标注警告，让我使用<code>String</code>参数的构造方法创建<code>BigDecimal</code>。因为<code>double</code>不能精确地表示为0.3（任何有限长度的二进制），构造方法传递的值也是不完全等于0.3。<strong>大家在使用BigDecimal的时候一定要用String参数的构造方法来创建</strong>。说到这里，是木有还有好奇的宝宝有疑问，<code>BigDecimal</code>的原理是啥？为啥它就没有问题呢？其实原理很简单，<code>BigDecimal</code>是不可变的，可以用来表示任意精度的带符号十进制数。<code>double</code>之所以会出问题，是因为小数点转二进制丢失精度。<strong>BigDecimal在处理的时候把十进制小数扩大N倍让它在整数上进行计算，并保留相应的精度信息。</strong>至于<code>BigDecimal</code>是怎么保存的可以翻阅一下源代码。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Double</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap JDK 1.8 后它改了什么？</title>
    <url>/2020/02/21/2020/02/HashMap%20JDK%201.8%20%E5%90%8E%E5%AE%83%E6%94%B9%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>推荐一个咕泡学院的视频资源：链接:<a href="https://pan.baidu.com/s/1SmSzrmfgbm6XgKZO7utKWg" target="_blank" rel="noopener">https://pan.baidu.com/s/1SmSzrmfgbm6XgKZO7utKWg</a>  密码:e54x</p>
<p>先回答一下之前发布的《使用HashMap的时候小心点》同学不补充的问题，说最好说下HashMap在JDK8下是怎么解决死循环的问题的。</p>
<p>链表部分对应上面 transfer 的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">  Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      next = e.next;</span><br><span class="line">      <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">              loHead = e;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              loTail.next = e;</span><br><span class="line">          loTail = e;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">              hiHead = e;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              hiTail.next = e;</span><br><span class="line">          hiTail = e;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">      loTail.next = <span class="keyword">null</span>;</span><br><span class="line">      newTab[j] = loHead;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">      hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">      newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于扩容是按两倍进行扩，即 N 扩为 N + N，因此就会存在低位部分 0 - (N-1)，以及高位部分 N - (2N-1)， 所以这里分为 loHead (low Head) 和 hiHead (high head)。</p>
<p>通过上面的分析，不难发现循环的产生是因为新链表的顺序跟旧的链表是完全相反的，所以只要保证建新链时还是按照原来的顺序的话就不会产生循环。</p>
<p>JDK8是用 <code>head</code> 和 <code>tail</code> 来保证链表的顺序和之前一样，这样就不会产生循环引用。</p>
<h4 id="传统-HashMap-的缺点"><a href="#传统-HashMap-的缺点" class="headerlink" title="传统 HashMap 的缺点"></a>传统 HashMap 的缺点</h4><p>JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。</p>
<p>当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。</p>
<p>针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。</p>
<h4 id="新增的数据结构-–-红黑树"><a href="#新增的数据结构-–-红黑树" class="headerlink" title="新增的数据结构 – 红黑树"></a>新增的数据结构 – 红黑树</h4><p><img src="http://static.cyblogs.com/adc0e45d0065227fa3b6f01acad60528.png" alt="http://static.cyblogs.com/adc0e45d0065227fa3b6f01acad60528.png"></p>
<p>JDK 1.8 中 HashMap 中除了链表节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//哈希值，就是位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">//指向下一个几点的指针</span></span><br><span class="line">    Node next;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有另外一种节点：TreeNode，它是 1.8 新增的，属于数据结构中的 <strong>红黑树</strong>（不了解红黑树的同学可以 <a href="http://blog.csdn.net/u011240877/article/details/53329023" target="_blank" rel="noopener">点击这里了解红黑树</a>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">    TreeNode parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到就是个红黑树节点，有父亲、左右孩子、前一个元素的节点，还有个颜色值。</p>
<p>另外由于它继承自 LinkedHashMap.Entry ，而 LinkedHashMap.Entry 继承自 HashMap.Node ，因此还有额外的 6 个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承 LinkedHashMap.Entry 的</span></span><br><span class="line">Entry before, after;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap.Node 的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node next;</span><br></pre></td></tr></table></figure>

<h4 id="红黑树的三个关键参数"><a href="#红黑树的三个关键参数" class="headerlink" title="红黑树的三个关键参数"></a>红黑树的三个关键参数</h4><p>HashMap 中有三个关于红黑树的关键参数:</p>
<ul>
<li>TREEIFY_THRESHOLD</li>
<li>UNTREEIFY_THRESHOLD</li>
<li>MIN_TREEIFY_CAPACITY</li>
</ul>
<p>值及作用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个桶的树化阈值</span></span><br><span class="line"><span class="comment">//当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点</span></span><br><span class="line"><span class="comment">//这个值必须为 8，要不然频繁转换效率也不高</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个树的链表还原阈值</span></span><br><span class="line"><span class="comment">//当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构</span></span><br><span class="line"><span class="comment">//这个值应该比上面那个小，至少为 6，避免频繁转换</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表的最小树形化容量</span></span><br><span class="line"><span class="comment">//当哈希表中的容量大于这个值时，表中的桶才能进行树形化</span></span><br><span class="line"><span class="comment">//否则桶内元素太多时会扩容，而不是树形化</span></span><br><span class="line"><span class="comment">//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<h4 id="新增的操作：桶的树形化-treeifyBin"><a href="#新增的操作：桶的树形化-treeifyBin" class="headerlink" title="新增的操作：桶的树形化 treeifyBin()"></a>新增的操作：桶的树形化 treeifyBin()</h4><p>在<a href="http://lib.csdn.net/base/17" target="_blank" rel="noopener">Java</a> 8 中，如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8 )，就使用红黑树来替换链表，从而提高速度。</p>
<p>这个替换的方法叫 treeifyBin() 即树形化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将桶内所有的 链表节点 替换成 红黑树节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node e;</span><br><span class="line">    <span class="comment">//如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)，就去新建/扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果哈希表中的元素个数超过了 树形化阈值，进行树形化</span></span><br><span class="line">        <span class="comment">// e 是哈希表中指定位置桶里的链表节点，从第一个开始</span></span><br><span class="line">        TreeNode hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>; <span class="comment">//红黑树的头、尾节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//新建一个树形节点，内容和当前链表节点 e 一致</span></span><br><span class="line">            TreeNode p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>) <span class="comment">//确定树头节点</span></span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);  </span><br><span class="line">        <span class="comment">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">replacementTreeNode</span><span class="params">(Node p, Node next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述操作做了这些事:</p>
<ul>
<li>根据哈希表中元素个数确定是扩容还是树形化</li>
<li>如果是树形化<ul>
<li>遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</li>
<li>然后让桶第一个元素指向新建的树头结点，替换桶的链表内容为树形内容</li>
</ul>
</li>
</ul>
<p>但是我们发现，之前的操作并没有设置红黑树的颜色值，现在得到的只能算是个二叉树。在 最后调用树形节点 hd.treeify(tab) 方法进行塑造红黑树，来看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//头回进入循环，确定头结点，为黑色</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//后面进入循环走的逻辑，x 指向树中的某个节点</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//又一个循环，从根节点开始，遍历所有节点跟当前节点 x 比较，调整位置，有点像冒泡排序</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;        <span class="comment">//这个 dir </span></span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)  <span class="comment">//当比较节点的哈希值比 x 大时， dir 为 -1</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)  <span class="comment">//哈希值比 x 小时 dir 为 1</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 如果比较节点的哈希值、 x </span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//把 当前节点变成 x 的父亲</span></span><br><span class="line">                    <span class="comment">//如果当前比较节点的哈希值比 x 大，x 就是左孩子，否则 x 是右孩子 </span></span><br><span class="line">                TreeNode xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，将二叉树变为红黑树时，需要保证有序。这里有个双重循环，拿树中的所有节点和当前节点的哈希值进行对比(如果哈希值相等，就对比键，这里不用完全有序），然后根据比较结果确定在树种的位置。</p>
<h4 id="新增的操作：-红黑树中添加元素-putTreeVal"><a href="#新增的操作：-红黑树中添加元素-putTreeVal" class="headerlink" title="新增的操作： 红黑树中添加元素 putTreeVal()"></a>新增的操作： 红黑树中添加元素 putTreeVal()</h4><p>上面介绍了如何把一个桶中的链表结构变成红黑树结构。</p>
<p>在添加时，如果一个桶中已经是红黑树结构，就要调用红黑树的添加元素方法 putTreeVal()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode <span class="title">putTreeVal</span><span class="params">(HashMap map, Node[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//每次添加元素时，从根节点遍历，对比哈希值</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))  </span><br><span class="line">        <span class="comment">//如果当前节点的哈希值、键和要添加的都一致，就返回当前节点（奇怪，不对比值吗？）</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前节点和要添加的节点哈希值相等，但是两个节点的键不是一个类，只好去挨个对比左右孩子 </span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="comment">//如果从 ch 所在子树中可以找到要添加的节点，就直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//哈希值相等，但键无法比较，只好通过特殊的方法给个结果</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//经过前面的计算，得到了当前节点和要插入节点的一个大小关系</span></span><br><span class="line">        <span class="comment">//要插入的节点比当前节点小就插到左子树，大就插到右子树</span></span><br><span class="line">        TreeNode xp = p;</span><br><span class="line">     <span class="comment">//这里有个判断，如果当前节点还没有左孩子或者右孩子时才能插入，否则就进入下一轮循环 </span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node xpn = xp.next;</span><br><span class="line">            TreeNode x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode)xpn).prev = x;</span><br><span class="line">            <span class="comment">//红黑树中，插入元素后必要的平衡调整操作</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法用于 a 和 b 哈希值相同但是无法比较时，直接根据两个引用的地址进行比较</span></span><br><span class="line"><span class="comment">//这里源码注释也说了，这个树里不要求完全有序，只要插入时使用相同的规则保持平衡即可</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">             -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以知道，HashMap 中往红黑树中添加一个新节点 n 时，有以下操作：</p>
<ul>
<li>从根节点开始遍历当前红黑树中的元素 p，对比 n 和 p 的哈希值；</li>
<li>如果哈希值相等并且键也相等，就判断为已经有这个元素（这里不清楚为什么不对比值）；</li>
<li>如果哈希值就通过其他信息，比如引用地址来给个大概比较结果，这里可以看到红黑树的比较并不是很准确，注释里也说了，只是保证个相对平衡即可；</li>
<li>最后得到哈希值比较结果后，如果当前节点 p 还没有左孩子或者右孩子时才能插入，否则就进入下一轮循环;</li>
<li>插入元素后还需要进行红黑树例行的平衡调整，还有确保根节点的领先地位。</li>
</ul>
<h4 id="新增的操作：-红黑树中查找元素-getTreeNode"><a href="#新增的操作：-红黑树中查找元素-getTreeNode" class="headerlink" title="新增的操作： 红黑树中查找元素 getTreeNode()"></a>新增的操作： 红黑树中查找元素 getTreeNode()</h4><p>HashMap 的查找方法是 get():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它通过计算指定 key 的哈希值后，调用内部方法 getNode()；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node[] tab; Node first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 getNode() 方法就是根据哈希表元素个数与哈希值求模（<code>使用的公式是 (n - 1) &amp;hash</code>）得到 key 所在的桶的头结点，如果头节点恰好是红黑树节点，就调用红黑树节点的 getTreeNode() 方法，否则就遍历链表节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getTreeNode 方法使通过调用树形节点的 find() 方法进行查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从根节点根据 哈希值和 key 进行查找</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class kc)</span> </span>&#123;</span><br><span class="line">    TreeNode p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于之前添加时已经保证这个树是有序的，因此查找时基本就是折半查找，效率很高。</p>
<p>这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断 key 是否相等，相等就直接返回（也没有判断值哎）；不相等就从子树中递归查找。</p>
<h4 id="新增的操作：-树形结构修剪-split"><a href="#新增的操作：-树形结构修剪-split" class="headerlink" title="新增的操作： 树形结构修剪 split()"></a>新增的操作： 树形结构修剪 split()</h4><p>HashMap 中， resize() 方法的作用就是初始化或者扩容哈希表。当扩容时，如果当前桶中元素结构是红黑树，并且元素个数小于链表还原阈值 UNTREEIFY_THRESHOLD （默认为 6），就会把桶中的树形结构缩小或者直接还原（切分）为链表结构，调用的就是 split():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数介绍</span></span><br><span class="line"><span class="comment">//tab 表示保存桶头结点的哈希表</span></span><br><span class="line"><span class="comment">//index 表示从哪个位置开始修剪</span></span><br><span class="line"><span class="comment">//bit 要修剪的位数（哈希值）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap map, Node[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果当前节点哈希值的最后一位等于要修剪的 bit 值</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//就把当前节点放到 lXXX 树中</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            <span class="comment">//然后 loTail 记录 e</span></span><br><span class="line">            loTail = e;</span><br><span class="line">            <span class="comment">//记录 lXXX 树的节点数量</span></span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">//如果当前节点哈希值最后一位不是要修剪的</span></span><br><span class="line">                <span class="comment">//就把当前节点放到 hXXX 树中</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            <span class="comment">//记录 hXXX 树的节点数量</span></span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果 lXXX 树的数量小于 6，就把 lXXX 树的枝枝叶叶都置为空，变成一个单节点</span></span><br><span class="line">        <span class="comment">//然后让这个桶中，要还原索引位置开始往后的结点都变成还原成链表的 lXXX 节点</span></span><br><span class="line">        <span class="comment">//这一段元素以后就是一个链表结构</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则让索引位置的结点指向 lXXX 树，这个树被修剪过，元素少了</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//同理，让 指定位置 index + bit 之后的元素</span></span><br><span class="line">        <span class="comment">//指向 hXXX 还原成链表或者修剪过的树</span></span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看到，HashMap 扩容时对红黑树节点的修剪主要分两部分，先分类、再根据元素个数决定是还原成链表还是精简一下元素仍保留红黑树结构。</p>
<p>1.分类</p>
<p>指定位置、指定范围，让指定位置中的元素 <code>（hash &amp; bit) == 0</code> 的，放到 lXXX 树中，不相等的放到 hXXX 树中。</p>
<p>2.根据元素个数决定处理情况</p>
<p>符合要求的元素（即 lXXX 树），在元素个数小于 6 时还原成链表，最后让哈希表中修剪的痛 tab[index] 指向 lXXX 树；在元素个数大于 6 时，还是用红黑树，只不过是修剪了下枝叶；</p>
<p>不符合要求的元素（即 hXXX 树）也是一样的操作，只不过最后它是放在了修剪范围外 tab[index + bit]。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JDK 1.8 以后哈希表的 添加、删除、查找、扩容方法都增加了一种 节点为 TreeNode 的情况：</p>
<ul>
<li>添加时，当桶中链表个数超过 8 时会转换成红黑树；</li>
<li>删除、扩容时，如果桶中结构为红黑树，并且树中元素个数太少的话，会进行修剪或者直接还原成链表结构；</li>
<li>查找时即使哈希函数不优，大量元素集中在一个桶中，由于有红黑树结构，性能也不会差。</li>
</ul>
<p>(图片来自：<a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">tech.meituan.com/java-hashma…</a>)</p>
<p><img src="https://user-gold-cdn.xitu.io/2016/11/29/f4b4ce0080649808815e6979d55b2915" alt="shixinzhang"></p>
<p>这篇文章根据源码分析了 HashMap 在 JDK 1.8 里新增的 TreeNode 的一些关键方法，可以看到，1.8 以后的 HashMap 结合了哈希表和红黑树的优点，不仅快速，而且在极端情况也能保证性能，设计者苦心孤诣可见一斑，写到这里不禁仰天长叹：什么时候我才能写出这么 NB 的代码啊！！！</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://cloud.tencent.com/developer/article/1120823" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1120823</a></li>
<li><a href="https://juejin.im/entry/5839ad0661ff4b007ec7cc7a" target="_blank" rel="noopener">https://juejin.im/entry/5839ad0661ff4b007ec7cc7a</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hash算法和一致性Hash算法</title>
    <url>/2020/02/20/2020/02/Hash%E7%AE%97%E6%B3%95%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h4><p><code>Hash</code>算法在路由算法应用中，为了保证数据均匀的分布，例如有<code>3</code>个桶，分别是<code>0</code>号桶，<code>1</code>号桶和<code>2</code>号桶；现在有<code>12</code>个球，怎么样才能让<code>12</code>个球平均分布到<code>3</code>个桶中呢？使用<code>Hash</code>算法的做法是，将<code>12</code>个球从<code>0</code>开始编号，得到这样的一个序列：<code>0，1，2，3，4，5，6，7，8，9，10，11</code>。将这个序列中的每个值模3，不管数字是什么，得到的结果都是<code>0,1,2</code>，不会超过<code>3</code>，将结果为<code>0</code>的数字放入<code>0</code>号桶，结果为<code>1</code>的数子放入<code>1</code>号桶，结果为<code>2</code>的数字放入2号桶，12个球就均匀的分布到<code>3</code>个桶中，<code>0,3,6,9,12</code>号球放入<code>0</code>号桶，<code>1,4,7,10</code>号球放入<code>1</code>号桶，<code>2,5,8,11</code>号球放入<code>2</code>号桶。</p>
<h4 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h4><p>一致性<code>Hash</code>算法在<code>1997</code>年由麻省理工学院提出的一种分布式哈希<code>（DHT）</code>实现算法，设计目标是为了解决因特网中的热点<code>（Hot Spot）</code>问题，初衷和<code>CARP</code>十分相似。一致性<code>Hash</code>修正了<code>CARP</code>使用的简单哈希算法带来的问题，使得分布式哈希<code>（DHT）</code>可以在<code>P2P</code>环境中真正得到应用。</p>
<p>一致性<code>Hash</code>算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对<code>2^32</code>取模，什么意思呢？简单来说，一致性<code>Hash</code>算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为<code>0-2^32-1</code>（即哈希值是一个32位无符号整形）。整个空间按<strong>顺时针方向组织</strong>，圆环的正上方的点代表<code>0，0</code>点右侧的第一个点代表<code>1</code>，以此类推，<code>2、3、4、5、6</code>……直到<code>2^32-1</code>，也就是说<code>0</code>点左侧的第一个点代表<code>2^32-1</code>， <code>0</code>和<code>2^32-1</code>在零点中方向重合，我们把这个由<code>2^32</code>个点组成的圆环称为<strong>Hash环</strong>。</p>
<p><img src="http://static.cyblogs.com/hash%E7%AE%97%E6%B3%95001.png" alt="http://static.cyblogs.com/hash算法001.png"></p>
<h5 id="特性定义"><a href="#特性定义" class="headerlink" title="特性定义"></a>特性定义</h5><p>一致性<code>Hash</code>算法提出了在动态变化的<code>Cache</code>环境中，判定哈希算法好坏的四个定义：</p>
<p><strong>1、平衡性（Balance）：</strong>平衡性是指哈希的结果能够尽可能分布在所有的缓冲<code>(Cache)</code>中去，这样可以使得所有的缓冲空间得到利用。很多哈希算法都能够满足这一条件。</p>
<p><strong>2、单调性（Monotonicity）：</strong>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应该能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会映射到旧的缓冲集合中的其他缓冲区。</p>
<p><strong>3、分散性（Spread）：</strong>在分布式环境中，终端有可能看不到所有的缓冲，而只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上去，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应该能够尽量避免不一致的情况发生，也就是尽量降低分散性。</p>
<p><strong>4、负载（Load）：</strong>负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射到不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
<p>下一步将各个服务器使用Hash进行一个哈希，具体可以选择<strong>服务器的IP或主机名</strong>作为<strong>关键字</strong>进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下： </p>
<img src="http://static.cyblogs.com/hash算法002.png" alt="http://static.cyblogs.com/hash算法002.png"/>

<p>接下来使用如下算法定位数据访问到相应服务器：将数据<code>key</code>使用相同的函数<code>Hash</code>计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p>
<p>例如我们有<code>Object A</code>、<code>Object B</code>、<code>Object C</code>、<code>Object D</code>四个数据对象，经过哈希计算后，在环空间上的位置如下： </p>
<img src="http://static.cyblogs.com/hash算法003.png" alt="http://static.cyblogs.com/hash算法003.png"/>

<p>根据一致性<code>Hash</code>算法，数据<code>A</code>会被定为到<code>Node A</code>上，<code>B</code>被定为到<code>Node B</code>上，<code>C</code>被定为到<code>Node C</code>上，<code>D</code>被定为到<code>Node D</code>上。</p>
<h5 id="容错和可扩展"><a href="#容错和可扩展" class="headerlink" title="容错和可扩展"></a>容错和可扩展</h5><p>现假设<code>Node C</code>不幸宕机，可以看到此时对象<code>A、B、D</code>不会受到影响，只有<code>C</code>对象被重定位到<code>Node D</code>。一般的，在一致性<code>Hash</code>算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：</p>
<img src="http://static.cyblogs.com/hash算法004.png" alt="http://static.cyblogs.com/hash算法004.png" />

<p>下面考虑另外一种情况，如果在系统中增加一台服务器<code>Node X</code>，如下图所示：</p>
<img src="http://static.cyblogs.com/hash算法005.png" alt="http://static.cyblogs.com/hash算法005.png" />

<p>此时对象<code>Object A、B、D</code>不受影响，只有对象<code>C</code>需要重定位到新的<code>Node X</code> ！一般的，在一致性<code>Hash</code>算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
<p>综上所述，一致性<code>Hash</code>算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<h5 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h5><p>一致性<code>Hash</code>算法在<strong>服务节点太少时</strong>，容易因为节点分部不均匀而造成<strong>数据倾斜</strong>（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下： </p>
<p><img src="http://static.cyblogs.com/hash%E7%AE%97%E6%B3%95006.png" alt="http://static.cyblogs.com/hash算法006.png"></p>
<p>此时必然造成大量数据集中到<code>Node A</code>上，而只有极少量会定位到<code>Node B</code>上。为了解决这种数据倾斜问题，一致性<code>Hash</code>算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在<code>服务器IP</code>或<code>主机名</code>的后面增加编号来实现。</p>
<p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “<code>Node A#1</code>”、“<code>Node A#2</code>”、“<code>Node A#3</code>”、“<code>Node B#1</code>”、“<code>Node B#2</code>”、“<code>Node B#3</code>”的哈希值，于是形成六个虚拟节点： </p>
<img src="http://static.cyblogs.com/hash算法007.png" alt="http://static.cyblogs.com/hash算法007.png" />

<p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“<code>Node A#1</code>”、“<code>Node A#2</code>”、“<code>Node A#3”</code>三个虚拟节点的数据均定位到<code>Node A</code>上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为<code>32</code>甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Hash算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo负载均衡：一致性Hash的实现分析</title>
    <url>/2020/02/19/2020/02/Dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>作者：FserSuN</p>
<p>来源：<a href="https://blog.csdn.net/Revivedsun/article/details/71022871" target="_blank" rel="noopener">https://blog.csdn.net/Revivedsun/article/details/71022871</a></p>
<p>LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，以分摊压力。Dubbo中LoadBalance结构如下图。</p>
<p><img src="http://static.cyblogs.com/20170430135402902.jpeg" alt="http://static.cyblogs.com/20170430135402902.jpeg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.alibaba.dubbo.rpc.cluster.LoadBalance </span><br><span class="line">接口提供了</span><br><span class="line">&lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>; </span><br><span class="line">通过该方法，进行结点选择。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.alibaba.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance </span><br><span class="line">实现了一些公共方法，并定义抽象方法</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>; </span><br><span class="line">该方法由具体的负载均衡实现类去实现。</span><br></pre></td></tr></table></figure>

<h4 id="一致性哈希负载均衡配置"><a href="#一致性哈希负载均衡配置" class="headerlink" title="一致性哈希负载均衡配置"></a>一致性哈希负载均衡配置</h4><p>具体的负载均衡实现类包括4种。分别是随机、轮训、最少活跃、一致性Hash<br>一致性哈希负载均衡配置</p>
<p>配置如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"consistenthash"</span> /&gt;</span></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"consistenthash"</span> /&gt;</span></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"consistenthash"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"consistenthash"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span></span></span><br></pre></td></tr></table></figure>


<p>一致性Hash负载均衡涉及到两个主要的配置参数为hash.arguments 与hash.nodes。</p>
<p>hash.arguments ： 当进行调用时候根据调用方法的哪几个参数生成key，并根据key来通过一致性hash算法来选择调用结点。例如调用方法invoke(String s1,String s2); 若hash.arguments为1(默认值)，则仅取invoke的参数1（s1）来生成hashCode。</p>
<p>hash.nodes： 为结点的副本数。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">缺省只对第一个参数Hash，如果要修改，请配置</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"hash.arguments"</span> <span class="attr">value</span>=<span class="string">"0,1"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">缺省用160份虚拟节点，如果要修改，请配置</span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"hash.nodes"</span> <span class="attr">value</span>=<span class="string">"320"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Dubbo中一致性Hash的实现分析"><a href="#Dubbo中一致性Hash的实现分析" class="headerlink" title="Dubbo中一致性Hash的实现分析"></a>Dubbo中一致性Hash的实现分析</h4><p>dubbo的一致性哈希通过ConsistentHashLoadBalance类来实现。</p>
<p>ConsistentHashLoadBalance内部定义ConsistentHashSelector类，最终通过该类进行结点选择。ConsistentHashLoadBalance实现的doSelect方法来利用所创建的ConsistentHashSelector对象选择结点。</p>
<p>doSelect的实现如下。当调用该方法时，如果选择器不存在则去创建。随后通过ConsistentHashSelector的select方法选择结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取调用方法名</span></span><br><span class="line">    String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + invocation.getMethodName();</span><br><span class="line">    <span class="comment">// 生成调用列表hashCode</span></span><br><span class="line">    <span class="keyword">int</span> identityHashCode = System.identityHashCode(invokers);</span><br><span class="line">    <span class="comment">// 以调用方法名为key,获取一致性hash选择器</span></span><br><span class="line">    ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">    <span class="comment">// 若不存在则创建新的选择器</span></span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.getIdentityHashCode() != identityHashCode) &#123;</span><br><span class="line">        <span class="comment">// 创建ConsistentHashSelector时会生成所有虚拟结点</span></span><br><span class="line">        selectors.put(key, <span class="keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, invocation.getMethodName(), identityHashCode));</span><br><span class="line">        <span class="comment">// 获取选择器</span></span><br><span class="line">        selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择结点</span></span><br><span class="line">    <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConsistentHashSelector在构造函数内部会创建replicaNumber个虚拟结点，并将这些虚拟结点存储于TreeMap。随后根据调用方法的参数来生成key，并在TreeMap中选择一个结点进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers; <span class="comment">// 虚拟结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>                       replicaNumber;   <span class="comment">// 副本数 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>                       identityHashCode;<span class="comment">// hashCode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[]                     argumentIndex;   <span class="comment">// 参数索引数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsistentHashSelector</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="keyword">int</span> identityHashCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建TreeMap 来保存结点</span></span><br><span class="line">        <span class="keyword">this</span>.virtualInvokers = <span class="keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">        <span class="comment">// 生成调用结点HashCode</span></span><br><span class="line">        <span class="keyword">this</span>.identityHashCode = System.identityHashCode(invokers);</span><br><span class="line">        <span class="comment">// 获取Url </span></span><br><span class="line">        <span class="comment">// dubbo://169.254.90.37:20880/service.DemoService?anyhost=true&amp;application=srcAnalysisClient&amp;check=false&amp;dubbo=2.8.4&amp;generic=false&amp;interface=service.DemoService&amp;loadbalance=consistenthash&amp;methods=sayHello,retMap&amp;pid=14648&amp;sayHello.timeout=20000&amp;side=consumer&amp;timestamp=1493522325563</span></span><br><span class="line">        URL url = invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line">        <span class="comment">// 获取所配置的结点数，如没有设置则使用默认值160</span></span><br><span class="line">        <span class="keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, <span class="string">"hash.nodes"</span>, <span class="number">160</span>);</span><br><span class="line">        <span class="comment">// 获取需要进行hash的参数数组索引，默认对第一个参数进行hash</span></span><br><span class="line">        String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, <span class="string">"hash.arguments"</span>, <span class="string">"0"</span>));</span><br><span class="line">        argumentIndex = <span class="keyword">new</span> <span class="keyword">int</span>[index.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i ++) &#123;</span><br><span class="line">            argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建虚拟结点</span></span><br><span class="line">        <span class="comment">// 对每个invoker生成replicaNumber个虚拟结点，并存放于TreeMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 根据md5算法为每4个结点生成一个消息摘要，摘要长为16字节128位。</span></span><br><span class="line">                <span class="keyword">byte</span>[] digest = md5(invoker.getUrl().toFullString() + i);</span><br><span class="line">                <span class="comment">// 随后将128位分为4部分，0-31,32-63,64-95,95-128，并生成4个32位数，存于long中，long的高32位都为0</span></span><br><span class="line">                <span class="comment">// 并作为虚拟结点的key。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line">                    virtualInvokers.put(m, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIdentityHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> identityHashCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据调用参数来生成Key</span></span><br><span class="line">        String key = toKey(invocation.getArguments());</span><br><span class="line">        <span class="comment">// 根据这个参数生成消息摘要</span></span><br><span class="line">        <span class="keyword">byte</span>[] digest = md5(key);</span><br><span class="line">        <span class="comment">//调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode</span></span><br><span class="line">        <span class="comment">//调用sekectForKey方法选择结点。</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = sekectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toKey</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 由于hash.arguments没有进行配置，因为只取方法的第1个参数作为key</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : argumentIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                buf.append(args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据hashCode选择结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">sekectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">        Invoker&lt;T&gt; invoker;</span><br><span class="line">        Long key = hash;</span><br><span class="line">        <span class="comment">// 若HashCode直接与某个虚拟结点的key一样，则直接返回该结点</span></span><br><span class="line">        <span class="keyword">if</span> (!virtualInvokers.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 若不一致，找到一个最小上届的key所对应的结点。</span></span><br><span class="line">            SortedMap&lt;Long, Invoker&lt;T&gt;&gt; tailMap = virtualInvokers.tailMap(key);</span><br><span class="line">            <span class="comment">// 若存在则返回，例如hashCode落在图中[1]的位置</span></span><br><span class="line">            <span class="comment">// 若不存在，例如hashCode落在[2]的位置，那么选择treeMap中第一个结点</span></span><br><span class="line">            <span class="comment">// 使用TreeMap的firstKey方法，来选择最小上界。</span></span><br><span class="line">            <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">                key = virtualInvokers.firstKey();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                key = tailMap.firstKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        invoker = virtualInvokers.get(key);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(<span class="keyword">byte</span>[] digest, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="keyword">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="keyword">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) </span><br><span class="line">                | (digest[<span class="number">0</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>)) </span><br><span class="line">                &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] md5(String value) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bytes = value.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中 hash(byte[] digest, int number)方法用来生成hashCode。该函数将生成的结果转换为long类，这是因为生成的结果是一个32位数，若用int保存可能会产生负数。而一致性hash生成的逻辑环其hashCode的范围是在 0 - MAX_VALUE之间。因此为正整数，所以这里要强制转换为long类型，避免出现负数。</p>
<p>进行结点选择的方法为select,最后通过sekectForKey方法来选择结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据调用参数来生成Key</span></span><br><span class="line">    String key = toKey(invocation.getArguments());</span><br><span class="line">    <span class="comment">// 根据这个参数生成消息摘要</span></span><br><span class="line">    <span class="keyword">byte</span>[] digest = md5(key);</span><br><span class="line">    <span class="comment">//调用hash(digest, 0)，将消息摘要转换为hashCode，这里仅取0-31位来生成HashCode</span></span><br><span class="line">    <span class="comment">//调用sekectForKey方法选择结点。</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = sekectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sekectForKey方法的实现如下。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">sekectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">     Invoker&lt;T&gt; invoker;</span><br><span class="line">     Long key = hash;</span><br><span class="line">     <span class="comment">// 若HashCode直接与某个虚拟结点的key一样，则直接返回该结点</span></span><br><span class="line">     <span class="keyword">if</span> (!virtualInvokers.containsKey(key)) &#123;</span><br><span class="line">         <span class="comment">// 若不在，找到一个最小上届的key所对应的结点。</span></span><br><span class="line">         SortedMap&lt;Long, Invoker&lt;T&gt;&gt; tailMap = virtualInvokers.tailMap(key);</span><br><span class="line">         <span class="comment">// 若存在则返回，例如hashCode落在图中[1]的位置</span></span><br><span class="line">         <span class="comment">// 若不存在，例如hashCode落在[2]的位置，那么选择treeMap中第一个结点</span></span><br><span class="line">         <span class="comment">// 使用TreeMap的firstKey方法，来选择最小上界。</span></span><br><span class="line">         <span class="keyword">if</span> (tailMap.isEmpty()) &#123;</span><br><span class="line">             key = virtualInvokers.firstKey();</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						 key = tailMap.firstKey();</span><br><span class="line">				 &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    invoker = virtualInvokers.get(key);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行选择时候若HashCode直接与某个虚拟结点的key一样，则直接返回该结点，例如hashCode落在某个结点上(圆圈所表示)。若不在，找到一个最小上届的key所对应的结点。例如进行选择时的key落在图中1所标注的位置。由于利用TreeMap存储，key所落在的位置可能无法找到最小上界，例如图中2所标注的位置。那么需要返回TreeMap中的最小值（构成逻辑环状结构，找不到，则返回最开头的结点）。</p>
<p><img src="http://static.cyblogs.com/20170430142247665.png" alt="http://static.cyblogs.com/20170430142247665.png"></p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用的 select、poll、epoll详解</title>
    <url>/2020/02/22/2020/02/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%20select%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>前几篇文章讲述了IO的几种模式及netty的基本概念，netty基于多路复用模型下的reactor模式，对 大量连接、单个处理短且快 的场景很适用 。</p>
<p>那在往底层思考，linux对于IO又是如何处理的呢？</p>
<h4 id="C10K-问题"><a href="#C10K-问题" class="headerlink" title="C10K 问题"></a>C10K 问题</h4><p><a href="http://www.52im.net/thread-566-1-1.html" target="_blank" rel="noopener">http://www.52im.net/thread-566-1-1.html</a></p>
<p>最初的服务器都是基于进程/线程模型的，新到来一个TCP连接，就需要分配1个进程（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。如果是C10K就要创建1万个进程，那么单机而言操作系统是无法承受的（往往出现效率低下甚至完全瘫痪）。如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大。基于上述考虑，如何突破单机性能局限，是高性能网络编程所必须要直面的问题。这些局限和问题最早被<code>Dan Kegel</code> 进行了归纳和总结，并首次成系统地分析和提出解决方案，后来这种普遍的网络现象和技术局限都被大家称为 <code>C10K</code> 问题。</p>
<p>C10K 问题的最大特点是：<strong>设计不够良好的程序，其性能和连接数及机器性能的关系往往是非线性的</strong>。</p>
<p>举个例子：如果没有考虑过 C10K 问题，一个经典的基于 select 的程序能在旧服务器上很好处理 1000 并发的吞吐量，它在 2 倍性能新服务器上往往处理不了并发 2000 的吞吐量。这是因为在策略不当时，大量操作的消耗和当前连接数 n 成线性相关。会导致单个任务的资源消耗和当前连接数的关系会是 O(n)。而服务程序需要同时对数以万计的socket 进行 I/O 处理，积累下来的资源消耗会相当可观，这显然会导致系统吞吐量不能和机器性能匹配。</p>
<p>以上这就是典型的C10K问题在技术层面的表现。C10K问题本质上是操作系统的问题。对于Web1.0/2.0时代的操作系统而言， 传统的同步阻塞I/O模型都是一样的，处理的方式都是requests per second，并发10K和100的区别关键在于CPU。创建的进程线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞）， 进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质！<br>可见，解决C10K问题的关键就是尽可能减少这些CPU等核心计算资源消耗，从而榨干单台服务器的性能，突破C10K问题所描述的瓶颈。</p>
<h4 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h4><h5 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h5><p>现在操作系统都是采用虚拟存储器，那么<strong>对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）</strong>。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为<strong>内核空间</strong>，一部分为<strong>用户空间</strong>。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<p><strong>处在内核空间称为内核态，用户空间称为用户态！ 内核的权限远大于用户空间权限，硬件、IO等等系统操作只能通过内核调用！</strong></p>
<h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。</p>
<h5 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h5><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态， <strong>此时是不占用CPU资源的</strong>。</p>
<h5 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h5><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。<strong>I/O的socket操作也是一种文件描述符fd</strong>。<br>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是<strong>文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统</strong>。</p>
<h5 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h5><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的<strong>页缓存</strong>（ page cache ）中，也就是说，<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</strong></p>
<p><strong>缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</strong></p>
<h4 id="I-O-多路复用之select、poll、epoll详解"><a href="#I-O-多路复用之select、poll、epoll详解" class="headerlink" title="I/O 多路复用之select、poll、epoll详解"></a>I/O 多路复用之select、poll、epoll详解</h4><blockquote>
<p>详细部分可以参阅：<br><a href="https://segmentfault.com/a/1190000003063859；" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859；</a><br><a href="https://blog.csdn.net/wxy941011/article/details/80274233" target="_blank" rel="noopener">https://blog.csdn.net/wxy941011/article/details/80274233</a></p>
</blockquote>
<p>select，poll，epoll都是IO多路复用的机制。<strong>一个进程可以监视多个描述符，</strong>一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。 本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>Netty与redis(单线程的下的I/O多路复用) 使用epoll模式。</p>
<h5 id="select-poll的几大缺点"><a href="#select-poll的几大缺点" class="headerlink" title="select/poll的几大缺点"></a>select/poll的几大缺点</h5><ol>
<li><p>select的本质是采用32个整数的32位，即32*32= 1024来标识，fd值为1-1024。</p>
<p>（总结： 句柄上限 + 重复初始化 + 逐个排查所有文件句柄状态效率不高）</p>
<ol>
<li>当fd的值超过1024限制时，就必须修改FD_SETSIZE（管理的句柄上限）的大小，这个时候就可以标识32*max值范围的fd。</li>
<li>在使用上，因为只有一个字段记录关注和发生事件，每次调用之前要重新初始化 fd_set 结构体。</li>
<li>select的触发方式是<strong>水平触发</strong>，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</li>
</ol>
</li>
<li><p>poll主要解决 select 的前两个问题，但还是得逐个排查所有文件句柄状态效率不高：</p>
<ol>
<li>通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制。</li>
<li>pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。</li>
</ol>
</li>
<li><p><strong>select/poll 将这个fd列表维持在用户态, 每次调用时都需要把fd集合从用户态拷贝到内核态, 并在内核中遍历传递进来的所有fd； 返回的的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件</strong></p>
</li>
</ol>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p>epoll是poll的一种优化，<strong>在内核中维持了fd的列表，只遍历发生事件的fd集合</strong>。<br>与poll/select不同，epoll不再是一个单独的系统调用，而是由epoll_create/epoll_ctl/epoll_wait三个系统调用组成，epoll在2.6以后的内核才支持。</p>
<p>综合的来说：</p>
<p>epoll在<strong>内核</strong>中申请一个简易的文件系统，把原先的select/poll调用分成了3个部分。连接的套接字（socket句柄）是采用红黑树的结构存储在内核cache中的，并给内核中断处理程序注册一个回调函数，告诉内核：如果这个句柄的中断到了，就把它放到准备就绪list链表里。当有事件准备就绪时，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了(epoll的基础是回调)。当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可；有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。</p>
<p>1）调用<strong>epoll_create</strong>建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源， 创建了红黑树和就绪链表)<br>2）调用<strong>epoll_ctl</strong>向epoll对象中添加这100万个连接的套接字 （如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据）<br>3）调用<strong>epoll_wait</strong>收集发生的事件的连接 （立刻返回准备就绪链表里的数据）</p>
<h5 id="两种模式LT和ET"><a href="#两种模式LT和ET" class="headerlink" title="两种模式LT和ET"></a>两种模式LT和ET</h5><p>ET是<strong>边缘触发</strong>，LT是<strong>水平触发</strong>，一个表示只有在变化的边际触发，一个表示在某个阶段都会触发。</p>
<p>当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回这个句柄。（从上面这段，可以看出，LT还有个回放的过程，低效了）</p>
<h4 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h4><p>eg.有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。处理的流越多，每一次无差别轮询时间就越长!</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://my.oschina.net/u/3434392/blog/3029255" target="_blank" rel="noopener">https://my.oschina.net/u/3434392/blog/3029255</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM深入理解-垃圾回收</title>
    <url>/2020/02/26/2020/02/JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近线上出现了JVM 频繁FGC的问题，查询了很多GC相关的资料，做了一些整理翻译。文章比较长可以收藏后慢慢阅读。</p>
<h4 id="一、什么是垃圾回收？-Garbage-Collection"><a href="#一、什么是垃圾回收？-Garbage-Collection" class="headerlink" title="一、什么是垃圾回收？(Garbage Collection)"></a>一、什么是垃圾回收？(Garbage Collection)</h4><p>一个垃圾回收器有一下三个职责</p>
<ul>
<li>分配内存</li>
<li>确保有引用的对象能够在内存中保留。</li>
<li>能够在正在执行的代码环境中回收已经死亡对象的内存。</li>
</ul>
<p>这里提到的<code>有引用</code>是指存活的对象,后面会提到一些算法用来判断对象是否存活。不在有引用的对象将被认为是死亡的，也就是常说的垃圾<code>garbage</code>。找到并释放这些垃圾对象占用的空间的过程就被称作是垃圾回收<code>garbage collection</code>。</p>
<p>垃圾回收可以解决很多内存分配的问题，但并不意味这全部。 比如：你可以不断地创建对象并保持对它们的引用直到没有可用的内存分配。垃圾回收本身就是一项非常复杂和消耗资源的过程。</p>
<h4 id="二、理想的垃圾收集器需要哪些特性？"><a href="#二、理想的垃圾收集器需要哪些特性？" class="headerlink" title="二、理想的垃圾收集器需要哪些特性？"></a>二、理想的垃圾收集器需要哪些特性？</h4><ol>
<li>垃圾收集器必须是安全和全面的。这就意味着，存活的对象绝对不能被释放，相反垃圾对象在很少的垃圾回收循环里必须被回收。</li>
<li>垃圾回收必须是高效的，不允许出现正在运行的程序长时间暂停。</li>
<li>内存碎片整理，垃圾被收集以后内存会存在很多不连续的内存碎片，可能导致大对象无法分配到足够连续的内存。</li>
<li>扩展性，在多处理器系统、多线程应用中，内存分配和垃圾收集不能成为性能瓶颈。</li>
</ol>
<h4 id="三、设计选择"><a href="#三、设计选择" class="headerlink" title="三、设计选择"></a>三、设计选择</h4><p>在设计一款垃圾收集器时，有一些选择可供选择：</p>
<ul>
<li>串行 vs 并行</li>
</ul>
<p>串行收集，即使在多cpu环境中也是单线程处理垃圾收集工作。当使用并行收集时，垃圾收集任务就会被分为几子任务由不同的线程的执行，不仅仅是在多CPU环境中使用，在单核的系统中也可以使用，只是收集效果可能比使用串行效率还低。所以再单核的环境下尽量使用串行收集。</p>
<ul>
<li>并发 vs 暂停（stop-the-word）</li>
</ul>
<p>并发是指垃圾收集线程和应用线程同时执行，并发和<code>stop-the-word</code>并不是互斥的，在一个执行一次垃圾收集的过程中两种情况都可能存在。例如<code>CMS</code>、<code>G1</code>垃圾搜集器。并发式GC会并发执行其垃圾收集任务，但是，可能也会有一些步骤需要以<code>stop-the-world</code>方法执行，导致应用程序暂停。与并发式<code>GC</code>相比，<code>Stop-the-world</code>式的GC更简单.</p>
<ul>
<li>整理 vs 不整理 vs 复制</li>
</ul>
<p>这个描述的主要是垃圾被收集以后，对内存碎片的处理方式。</p>
<p>整理、不整理，垃圾回收以后是否将存活的对象统一移动到一个地方。整理后的内存空间方便后续的对象分配内存，但是更消耗资源和时间，而不整理效率更高存在内存碎片的风险。</p>
<p>复制，首先将内存分割成两块一样大小的区域，垃圾收集后会将存活的对象拷贝到另一块不同的内存区域。这样做的好处是，拷贝后，源内存区域可以作为一块空的、立即可用的区域对待，方便后续的内存分配，但是这种方法的缺点是需要用额外的时间、空间来拷贝对象。</p>
<h4 id="四、对象是否存活？"><a href="#四、对象是否存活？" class="headerlink" title="四、对象是否存活？"></a>四、对象是否存活？</h4><p><code>JVM</code>要对回收一个对象必须知道这个对象是否存活，即是否有有效的引用？介绍几种判断对象是否死亡的算法。</p>
<ol>
<li><p>引用计数法 给对象添加一个引用计数器，每次引用到它时引用计数器加一，当引用失效时引用计时器减一。当引用计数器为0时即表示当前对象可以被回收。 这个算法实现简单、判定效率也很高，但是无法处理循环引用的问题，即 A 对象引用了 B， B 对象也引用了 A，那么A、B都有引用，他们的应用计数都为一，但实际他们是可以被回收的。</p>
</li>
<li><p>可达性分析算法 算法规定了一些称为<code>GC Root</code>的根对象，当对象没有引用链到达这些<code>GC Root</code>时就被判定为可回收的对象。</p>
<p><img src="http://static.cyblogs.com/WX20200131-153715@2x.png" alt="http://static.cyblogs.com/WX20200131-153715@2x.png"></p>
</li>
</ol>
<h4 id="五、分代收集算法"><a href="#五、分代收集算法" class="headerlink" title="五、分代收集算法"></a>五、分代收集算法</h4><p>当使用称为分代收集的技术时，内存将被分为不同的几代，即，会将对象按其年龄分别存储在不同的对象池中。例如，目前最广泛使用的是分代是将对象分为年轻代对象和老年代对象。</p>
<p>在分代内存管理中，使用不同算法对不同代的对象执行垃圾收集的工作，每种算法都是基于对某代对象的特性进行优化的。考虑到应用程序可以是用包括Java在内的不同的程序语言编写，分代垃圾收集使用了称为 弱代理论（weak generational hypothesis）的方法，具体描述如下：</p>
<p>大多数分配了内存的对象并不会存活太长时间，在处于年轻代时就会死掉； 很少有对象会从老年代变成年轻代。 年轻代对象的垃圾收集相对频繁一些，同时会也更有效率，更快一些，因为年轻代对象所占用的内存通常较小，也比较容易确定哪些对象是已经无法再被引用的。</p>
<p>当某些对象经过几次年轻代垃圾收集后依然存活，则这些对象会被 提升（promoted）到老年代。典型情况下，老年代所占用的内存会比年轻代大，而且还会随时渐渐慢慢增大。这样的结果是，对老年代的垃圾收集就不能频繁进行，而且执行时间也会长很多。</p>
<p><img src="http://static.cyblogs.com/WX20200131-153928@2x.png" alt="http://static.cyblogs.com/WX20200131-153928@2x.png"></p>
<p>选择年轻代的垃圾收集算法时会更看重执行速度，因为年轻代的垃圾收集工作会频繁执行。另一方面，管理老年代的算法则更注重空间效率，因为老年代会占用堆中的大部分空间，这要求算法必须要处理好垃圾收集的工作，尽量降低堆中的垃圾内存的密度。</p>
<h4 id="六、HotSpot-分代收集"><a href="#六、HotSpot-分代收集" class="headerlink" title="六、HotSpot 分代收集"></a>六、HotSpot 分代收集</h4><p>主要介绍几种常见的垃圾收集器<code>串行收集器（Serial Collector）</code>、<code>并行垃圾收集器（Parallel Collector）</code>、<code>并行整理收集器（Parallel Compacting Collector）</code>、<code>并发标记清理垃圾收集器（Concurrent Mark-Sweep，CMS）</code>、<code>Garbage-First (G1)</code> 图中有连线的表示可以组合使用。</p>
<p><img src="http://static.cyblogs.com/WX20200131-154328@2x.png" alt="http://static.cyblogs.com/WX20200131-154328@2x.png"></p>
<h5 id="6-1-HotSpot中的代的划分"><a href="#6-1-HotSpot中的代的划分" class="headerlink" title="6.1 HotSpot中的代的划分"></a>6.1 HotSpot中的代的划分</h5><p>在Java HotSpot虚拟机中，内存被分为3代：年轻代、老年代和永生代(java8已经取消永久代)。大多数对象最初都是分配在年轻代内存中的，年轻代中对象经过几次垃圾收集后还存活的，会被转到老年代。一些体积比较大的对象在创建的时候可能就会在老年代中。 在年轻代中包含三个分区，一个 Eden区和两个 Survivor区(FROM、TO)，如图所示。大部分对象最初是分配在Eden区中的（但是，如前面所述，一些较大的对象可能会直接分配在老年代中）。Survivor始终保持一个区域为空，当经过一定次数（<code>-XX:MaxTenuringThreshold=n</code>来指定默认值为15）的年轻代GC后依然存活的对象可以被晋升到老年代。</p>
<p><img src="http://static.cyblogs.com/WX20200131-154416@2x.png" alt="http://static.cyblogs.com/WX20200131-154416@2x.png"></p>
<h5 id="6-2-垃圾收集分类"><a href="#6-2-垃圾收集分类" class="headerlink" title="6.2 垃圾收集分类"></a>6.2 垃圾收集分类</h5><p>当年轻代被填满时，开始执行年轻代的垃圾收集（<code>minor collection</code>）。当老年代被填满时，也会执行老年代垃圾收集（<code>full GC</code>，<code>major collection</code>），一般来说，年轻代GC会先执行，执行多次young GC 会触发<code>FGC</code>，当然这不是绝对的，因为大对象会直接分配到老年代，当老年代的分配的内存不足时就可能触发频繁的<code>FGC</code>。目前除了<code>CMS</code>收集器外，在执行<code>FGC</code>的时候都会对整个堆进行垃圾收集。</p>
<h5 id="6-3-串行收集器（Serial-Collector）"><a href="#6-3-串行收集器（Serial-Collector）" class="headerlink" title="6.3 串行收集器（Serial Collector）"></a>6.3 串行收集器（Serial Collector）</h5><p>使用串行收集器，年轻代和老年代的垃圾收集工作会串行完成（在单一CPU系统上），这时是stop-the-world模式的。即，当执行垃圾收集工作时，应用程序必须停止运行。</p>
<h6 id="6-3-1-使用串行收集器的年轻代垃圾收集"><a href="#6-3-1-使用串行收集器的年轻代垃圾收集" class="headerlink" title="6.3.1 使用串行收集器的年轻代垃圾收集"></a>6.3.1 使用串行收集器的年轻代垃圾收集</h6><p>图3展示了使用串行收集器的年轻代垃圾收集的执行过程。<code>Eden</code>和<code>Survivor FROM</code>区存活的对象会被拷贝到初始为空的另一个Survivor区（图中标识为To的区）中，这其中，那些体积过大以至于<code>Survivor</code>区装不下的对象会被直接拷贝到老年代中。相对于已经被拷贝到To区的对象，源<code>Survivor</code>区（图中标识为From的区）中的存活对象仍然比较年轻，而被拷贝到老年代中对象则相对年纪大一些。</p>
<p><img src="http://static.cyblogs.com/WX20200131-154513@2x.png" alt="http://static.cyblogs.com/WX20200131-154513@2x.png"></p>
<p>在年轻代垃圾收集完成后，Eden区和From区会被清空，只有To区会继续持有存活的对象。此时，From区和To区在逻辑上交换，To区变成From区，原From区变成To区，如图4所示。</p>
<p><img src="http://static.cyblogs.com/WX20200131-154558@2x.png" alt="http://static.cyblogs.com/WX20200131-154558@2x.png"></p>
<h6 id="6-3-2-使用串行收集器的老年代垃圾收集"><a href="#6-3-2-使用串行收集器的老年代垃圾收集" class="headerlink" title="6.3.2 使用串行收集器的老年代垃圾收集"></a>6.3.2 使用串行收集器的老年代垃圾收集</h6><p>对于串行收集器，老年代和永生代会在进行垃圾收集时使用标记-清理-整理（Mark-Sweep-Compact）算法。在标记阶段，收集器会标识哪些对象是live状态的。清理阶段会跨代清理，标识垃圾对象。然后，收集器执行整理（sliding compaction），将存活对象移动到老年代内存空间的起始部分（永生代中情况于此类似），这样在老年代内存空间的尾部会产生一个大的连续空间。如图5所示。这种整理可以使用碰撞指针完成。</p>
<p><img src="http://static.cyblogs.com/WX20200131-154708@2x.png" alt="http://static.cyblogs.com/WX20200131-154708@2x.png"></p>
<h6 id="6-3-3-什么时候使用串行垃圾收集器"><a href="#6-3-3-什么时候使用串行垃圾收集器" class="headerlink" title="6.3.3 什么时候使用串行垃圾收集器"></a>6.3.3 什么时候使用串行垃圾收集器</h6><p>大多数运行在客户机上的应用程序会选择使用并行垃圾收集器，因为这些应用程序对低暂停时间并没有较高的要求。对于当今的硬件来说，串行垃圾收集器已经可以有效的管理许多具有64M堆的重要应用程序，并且执行一次完整垃圾收集也不会超过半秒钟。</p>
<h6 id="6-3-4-选择串行垃圾收集器"><a href="#6-3-4-选择串行垃圾收集器" class="headerlink" title="6.3.4 选择串行垃圾收集器"></a>6.3.4 选择串行垃圾收集器</h6><p>在J2SE 5.0的发行版中，在非服务器类使用的机器上，默认选择的是串行垃圾收集器。在其他类型使用的机器上，可以通过添加参数 -XX:+UseSerialGC来显式的使用串行垃圾收集器。</p>
<h5 id="6-4-并行垃圾收集器（Parallel-Collector）"><a href="#6-4-并行垃圾收集器（Parallel-Collector）" class="headerlink" title="6.4 并行垃圾收集器（Parallel Collector）"></a>6.4 并行垃圾收集器（Parallel Collector）</h5><p>当前，很多的Java应用程序都跑在具有较大物理内存和多CPU的机器上。并行垃圾收集器，也称为吞吐量垃圾收集器，被用于垃圾收集工作。该收集器可以充分的利用多CPU的特点，避免一个CPU执行垃圾收集，其他CPU空闲的状态发生。</p>
<h6 id="6-4-1-使用并行垃圾收集器的年轻代垃圾收集"><a href="#6-4-1-使用并行垃圾收集器的年轻代垃圾收集" class="headerlink" title="6.4.1 使用并行垃圾收集器的年轻代垃圾收集"></a>6.4.1 使用并行垃圾收集器的年轻代垃圾收集</h6><p>这里，对年轻代的并行垃圾收集使用的串行垃圾收集算法的并行版本。它仍然会stop-the-world，拷贝对象，但执行垃圾收集时是使用多CPU并行进行的，减少了垃圾收集的时间损耗，提高了应用程序的吞吐量。图6展示了串行垃圾收集器和并行垃圾收集器对年轻代进行垃圾收集时的区别。</p>
<p><img src="http://static.cyblogs.com/WX20200131-154849@2x.png" alt="http://static.cyblogs.com/WX20200131-154849@2x.png"></p>
<h6 id="6-4-2-使用并行垃圾收集器的老年代垃圾收集"><a href="#6-4-2-使用并行垃圾收集器的老年代垃圾收集" class="headerlink" title="6.4.2 使用并行垃圾收集器的老年代垃圾收集"></a>6.4.2 使用并行垃圾收集器的老年代垃圾收集</h6><p>老年代中的并行垃圾收集使用了与串行垃圾收集器相同的串行 标记-清理-整理（mark-sweep-compact）算法。</p>
<h6 id="6-4-3-什么时候使用并行垃圾收集器"><a href="#6-4-3-什么时候使用并行垃圾收集器" class="headerlink" title="6.4.3 什么时候使用并行垃圾收集器"></a>6.4.3 什么时候使用并行垃圾收集器</h6><p>当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，使用并行垃圾收集器会有较好的效果，因为虽不频繁，但可能时间会很长的老年代垃圾收集仍然会发生。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序更适合使用并行垃圾收集。</p>
<p>可能你会想用并行整理垃圾收集器（会在下一节介绍）来替代并行收集器，因为前者对所有代执行垃圾收集，而后者指对年轻代执行垃圾收集。</p>
<h6 id="6-4-4-选择并行垃圾收集器"><a href="#6-4-4-选择并行垃圾收集器" class="headerlink" title="6.4.4 选择并行垃圾收集器"></a>6.4.4 选择并行垃圾收集器</h6><p>在J2SE 5.0的发行版中，若应用程序是运行在服务器类的机器上，则会默认使用并行垃圾收集器。在其他机器上，可以通过 -XX:+UseParallelGC参数来显式启用并行垃圾收集器。</p>
<h5 id="6-5-并行整理整理收集器（Parallel-Compacting-Collector）"><a href="#6-5-并行整理整理收集器（Parallel-Compacting-Collector）" class="headerlink" title="6.5 并行整理整理收集器（Parallel Compacting Collector）"></a>6.5 并行整理整理收集器（Parallel Compacting Collector）</h5><p>并行整理垃圾收集器是在J2SE 5.0 update 6中被引入的，其与并行垃圾收集器的区别在于，并行整理垃圾收集器使用了新的算法对老年代进行垃圾收集。注意，最终，并行整理垃圾收集器会取代并行垃圾收集器。</p>
<h6 id="6-5-1-使用并行整理垃圾收集器的年轻代垃圾收集"><a href="#6-5-1-使用并行整理垃圾收集器的年轻代垃圾收集" class="headerlink" title="6.5.1 使用并行整理垃圾收集器的年轻代垃圾收集"></a>6.5.1 使用并行整理垃圾收集器的年轻代垃圾收集</h6><p>年轻代中，并行整理垃圾收集器使用了与并行垃圾收集器相同的垃圾收集算法。</p>
<h6 id="6-5-2-使用并行整理垃圾收集器的老年代垃圾收集"><a href="#6-5-2-使用并行整理垃圾收集器的老年代垃圾收集" class="headerlink" title="6.5.2 使用并行整理垃圾收集器的老年代垃圾收集"></a>6.5.2 使用并行整理垃圾收集器的老年代垃圾收集</h6><p>当使用并行整理垃圾收集时，老年代和永生代会使用<code>stop-the-world</code>的方式执行垃圾收集，大多数的并行模式都会使用移动整理（sliding compaction）。垃圾收集分为三个阶段。首先，将每一个代从逻辑上分为固定大小的区域。</p>
<p>在 标记阶段（mark phase），应用程序代码可以直接到达的live对象的初始集合会被划分到各个垃圾收集线程中，然后，所有的live对象会被并行标记。若一个对象被标记为live，则会更新该对象所在的区域中与该对象的大小和位置相关的数据。</p>
<p>在 总结阶段（summary phase）会对区域，而非单独的对象进行操作。由于之前的垃圾收集执行了整理，每一代的左侧部分的对象密度会较高，包含了大部分live对象。这些对象密度较高的区域被恢复为可用后，就不值得再花时间去整理了。所以，在总结阶段要做的第一件事是从最左端对象开始检查每个区域的live对象密度，直到找到了一个恢复其本区域和恢复其右侧的空间的开销都比较小时停止。找到的区域的左侧所有区域被称为dense prefix，不会再有对象被移动到这些区域里了。这个区域后侧的区域会被整理，清除所有已死的空间（清理垃圾对象占用的空间）。总结阶段会计算并保存每个整理后的区域中对象的新地址。注意，在当前实现中，总结阶段是串行的；当然总结阶段也可以实现为并行的，但相对于性能总结阶段的并行不及标记整理阶段来得重要。</p>
<p>在 整理阶段（compaction phase），垃圾收集线程使用总结阶段收集到的数据决定哪些区域课余填充数据，然后各个线程独立的将数据拷贝到这些区域中。这样就产生了一个底端对象密度大，连一端是一个很大的空区域块的堆。</p>
<h6 id="6-5-3-什么时候使用并行整理垃圾收集器"><a href="#6-5-3-什么时候使用并行整理垃圾收集器" class="headerlink" title="6.5.3 什么时候使用并行整理垃圾收集器"></a>6.5.3 什么时候使用并行整理垃圾收集器</h6><p>相对于并行垃圾收集器，使用并行整理垃圾收集器对那些运行在多CPU的应用程序更有好处。此外，老年代垃圾收集的并行操作可以减少应用程序的暂停时间，对于那些对暂停时间有较高要求的应用程序来说，并行整理垃圾程序比并行垃圾收集更加适用。并行整理垃圾收集程序可能并不适用于那些与其他很多应用程序并存于一台机器的应用程序上，这种情况下，没有一个应用程序可以独占所有的CPU。在这样的机器上，需要考虑减少执行垃圾收集的线程数（使用-XX:ParallelGCThreads=n命令行选项），或者使用另一种垃圾收集器。</p>
<h6 id="5-5-4-选择并行整理垃圾收集选项"><a href="#5-5-4-选择并行整理垃圾收集选项" class="headerlink" title="5.5.4 选择并行整理垃圾收集选项"></a>5.5.4 选择并行整理垃圾收集选项</h6><p>若你想使用并行整理垃圾收集器，你必须显式指定-XX:+UseParallelOldGC命令行选项。</p>
<h5 id="6-6-并发标记清理（Concurrent-Mark-Sweep，CMS）垃圾收集器"><a href="#6-6-并发标记清理（Concurrent-Mark-Sweep，CMS）垃圾收集器" class="headerlink" title="6.6 并发标记清理（Concurrent Mark-Sweep，CMS）垃圾收集器"></a>6.6 并发标记清理（Concurrent Mark-Sweep，CMS）垃圾收集器</h5><p>对于很多应用程序来说，点到点的吞吐量并不如快速响应来的重要。典型情况下，年轻代的垃圾收集并不会引起较长时间的暂停。但是，老年代的垃圾收集，虽不频繁，却可能引起长时间的暂停，特别是使用了较大的堆的时候。为了应付这种情况，HotSpot JVM使用了CMS垃圾收集器，也称为低延迟（low-latency）垃圾收集器。</p>
<h6 id="6-6-1-使用CMS垃圾收集器的年轻代垃圾收集"><a href="#6-6-1-使用CMS垃圾收集器的年轻代垃圾收集" class="headerlink" title="6.6.1 使用CMS垃圾收集器的年轻代垃圾收集"></a>6.6.1 使用CMS垃圾收集器的年轻代垃圾收集</h6><p>CMS垃圾收集器只对老年代进行收集，年轻代实际默认使用<code>ParNewGC</code>（一种年轻代的并行垃圾收集器）收集。</p>
<h6 id="6-6-2-使用CMS垃圾收集器的老年代垃圾收集"><a href="#6-6-2-使用CMS垃圾收集器的老年代垃圾收集" class="headerlink" title="6.6.2 使用CMS垃圾收集器的老年代垃圾收集"></a>6.6.2 使用CMS垃圾收集器的老年代垃圾收集</h6><p>大部分老年代的垃圾收集使用了<code>CMS</code>垃圾收集器，垃圾收集工作是与应用程序的执行并发进行的。</p>
<table>
<thead>
<tr>
<th>过程</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>初始标记</td>
<td>标记老年代的存活对象，也可能包括年轻代的存活对象。暂停应用线程<code>stop-the world</code></td>
</tr>
<tr>
<td>并发标记</td>
<td>和应用程序一起执行，标记应用程序运行过程中产生的存活的对象。</td>
</tr>
<tr>
<td>重标记</td>
<td>标记由于应用程序更新导致遗漏的对象，暂停应用线程<code>stop-the world</code></td>
</tr>
<tr>
<td>并发清理</td>
<td>清理没有被标记的对象，不会进行内存整理，可能导致内存碎片问题。</td>
</tr>
<tr>
<td>复位</td>
<td>清理数据等待下一次收集执行。</td>
</tr>
</tbody></table>
<p>图7展示了使用串行化的标记清理垃圾收集器和使用CMS垃圾收集器对老年代进行垃圾收集的区别。</p>
<p><img src="http://static.cyblogs.com/WX20200131-155134@2x.png" alt="http://static.cyblogs.com/WX20200131-155134@2x.png"></p>
<p>不进行内存空间整理节省了时间，但是可用空间不再是连续的了，垃圾收集也不能简单的使用指针指向下一次可用来为对象分配内存的地址了。相反，这种情况下，需要使用可用空间列表。即，会创建一个指向未分配区域的列表，每次为对象分配内存时，会从列表中找到一个合适大小的内存区域来为新对象分配内存。这样做的结果是，老年代上的内存的分配比简单实用碰撞指针分配内存消耗大。这也会增加年轻代垃圾收集的额外负担，因为老年代中的大部分对象是在新生代垃圾收集的时候从新生代提升为老年代的。</p>
<p><strong>使用CMS垃圾收集器的另一个缺点是它所需要的对空间比其他垃圾收集器大</strong>。在标记阶段，应用程序可以继续运行，可以继续分配内存，潜在的可能会持续的增大老年代的内存使用。此外，尽管垃圾收集器保证会在标记阶段标记出所有的live对象，但是在此阶段中，某些对象可能会变成垃圾对象，这些对象不会被回收，直到下一次垃圾收集执行。这些对象成为 浮动垃圾对象（floating garbage）。</p>
<p>最后，由于没有使用整理，会造成内存碎片的产生。为了解决这个问题，CMS垃圾收集器会跟踪常用对象的大小，预估可能的内存需要，可能会差分或合并内存块来满足需要。</p>
<p>与其他的垃圾收集器不同，当老年代被填满后，CMS垃圾收集器并不会对老年代进行垃圾收集。相反，它会在老年代被填满之前就执行垃圾收集工作。否则这就与串行或并行垃圾收集器一样会造成应用程序长时间地暂停。为了避免这种情况，CMS垃圾收集器会基于统计数字来来定执行垃圾收集工作的时间，这个统计数字涵盖了前几次垃圾收集的执行时间和老年代中新增内存分配的速率。当老年代中内存占用率超过了称为初始占用率的阀值后，会启动CMS垃圾收集器进行垃圾收集。初始占用率可以通过命令行选项<code>-XX:CMSInitiatingOccupancyFraction=n</code>进行设置，其中n是老年代占用率的百分比的值，默认为68。</p>
<p>总体来看，与平行垃圾收集器相比，CMS减少了执行老年代垃圾收集时应用暂停的时间，但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量而且需要占用更大的堆空间。</p>
<h4 id="七、G1-收集器"><a href="#七、G1-收集器" class="headerlink" title="七、G1 收集器"></a>七、G1 收集器</h4><p>G1最为新一代的垃圾回收器，设计之初就是为了取代<code>CMS</code>的。具备以下优点：</p>
<ul>
<li>并发执行垃圾收集</li>
<li>很短的时间进行内存整理</li>
<li>GC的暂停时间可控</li>
<li>不需要牺牲吞吐量</li>
<li>不需要占用额外的java堆空间 什么需要使用G1收集器呢？</li>
<li>频繁的FGC</li>
<li>对象分配率或提升的速率差异很大。</li>
<li>无法接受过长的GC暂停和内存整理时间</li>
</ul>
<p>G1收集器和之前垃圾收集器拥有完全不同的内存结构，虽然从逻辑上也存在年轻代、老年代，但是物理空间上不在连续而是散列在内存中的一个个<code>regions</code>。内存空间分割成很多个相互独立的空间，被乘称作<code>regions</code>。当<code>jvm</code>启动时<code>regins</code>的大小就被确定了。jvm会创建大概2000个regions,每个region的大小在1M~32M之间。内存结构如下图：</p>
<p><img src="http://static.cyblogs.com/WX20200131-155507@2x.png" alt="http://static.cyblogs.com/WX20200131-155507@2x.png"></p>
<h5 id="7-1-使用G1进行年轻代收集"><a href="#7-1-使用G1进行年轻代收集" class="headerlink" title="7.1 使用G1进行年轻代收集"></a>7.1 使用G1进行年轻代收集</h5><p>当年轻代GC被触发时，Eden中存活的对象将会被复制或者移动<code>evacuated</code>到幸存区的<code>regions</code>，在幸存复制的次数到达阈值的存活对象将会晋升到老年区。这个过程也是一个Stop-the-world 暂停。eden和survivor的大小将会在下一次年轻代GC前重新计算。</p>
<p><img src="http://static.cyblogs.com/WX20200131-155627@2x.png" alt="http://static.cyblogs.com/WX20200131-155627@2x.png"></p>
<p>总而言之，G1在年轻代的手机行为包括以下几点：</p>
<ul>
<li><p>1、内存被分割成相互独立的大小相等的regions。 </p>
</li>
<li><p>2、年轻代散列在整个内存空间中，这样做的好处是当需要重新分配年轻代大小时会非常方便。 </p>
</li>
<li><p>3、stop-the-word 暂停所有线程。</p>
</li>
<li><p>4、实际上也是并行回收算法，多线程并行收集。 </p>
</li>
<li><p>5、存活的对象将被复制到新的 survivor或老年代 regions。</p>
</li>
</ul>
<h5 id="7-2-使用G1进行老年代收集"><a href="#7-2-使用G1进行老年代收集" class="headerlink" title="7.2 使用G1进行老年代收集"></a>7.2 使用G1进行老年代收集</h5><table>
<thead>
<tr>
<th>过程</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>初始标记</td>
<td><code>stop-the world</code> 通常伴随在年轻代GC后面，标记有被老年代对象关联的幸存区 regions</td>
</tr>
<tr>
<td>扫描根 Regions</td>
<td>和应用线程并发执行，扫描幸存区regions</td>
</tr>
<tr>
<td>并发标记</td>
<td>并发标记整个堆存活的对象</td>
</tr>
<tr>
<td>重标记</td>
<td>完成整个堆的存活对象标记，使用<code>snapshot-at-the-beginning (SATB)</code>算法标记存活对象，该算法比CMS中使用的更快。<code>stop-the-word</code></td>
</tr>
<tr>
<td>并行清理</td>
<td>并行清理死亡的的对象，返回空的regoins到可用列表。</td>
</tr>
<tr>
<td>复制</td>
<td>复制存活的对象到新的regions,<code>This can be done with young generation regions which are logged as [GC pause (young)]. Or both young and old generation regions which are logged as [GC Pause (mixed)].</code></td>
</tr>
</tbody></table>
<h5 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h5><p>1、不要指定年轻代大小 <code>-Xmn</code>,G1每次垃圾收集结束后都会从新计算并设置年轻代的大小，将会影响全局的暂停时间 2、响应时间配置 <code>-XX:MaxGCPauseMillis=</code> 3、如何解决清理 or 复制失败问题，通过增加<code>-XX:G1ReservePercent=n</code>配置预留空间的大小，防止<code>Evacuation Failure</code>,默认值是10.也可以使用<code>-XX:ConcGCThreads=n</code>增加并发标记的线程数来解决</p>
<h4 id="八、相关命令"><a href="#八、相关命令" class="headerlink" title="八、相关命令"></a>八、相关命令</h4><p>选择垃圾回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UseSerialGC            串行垃圾收集器</span><br><span class="line">-XX:+UseParallelGC          并行垃圾收集器</span><br><span class="line">-XX:+UseParallelOldGC       并行整理垃圾收集器</span><br><span class="line">-XX:+UseConcMarkSweepGC	    并发标记清理（CMS）垃圾收集年轻代默认使用-XX:+ParNewGC</span><br><span class="line">-XX:+UserG1GC</span><br></pre></td></tr></table></figure>

<p>查看垃圾收集日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGC                </span><br><span class="line">-XX:+PrintGCDetails     </span><br><span class="line">-XX:+PrintGCTimeStamps</span><br></pre></td></tr></table></figure>

<p>对大小配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmsn                           堆最小值</span><br><span class="line">-Xmxn                           堆最大值</span><br><span class="line">-Xmn                            年轻代大小</span><br><span class="line">-XX:NewRatio=n	                年清代比例 Client_JVM=<span class="number">2</span> Server_JVM=<span class="number">8</span>     </span><br><span class="line">-XX:SurvivorRatio=n	            幸存去比例</span><br><span class="line">-XX:MaxPermSize=n               依赖于不同平台的实现永生代的最大值(java <span class="number">8</span> 以后启用)。</span><br></pre></td></tr></table></figure>

<p>G1可用的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+UseG1GC	Use the Garbage First (G1) Collector</span><br><span class="line">-XX:MaxGCPauseMillis&#x3D;n	Sets a target for the maximum GC pause time. This is a soft goal, and the JVM will make its best effort to achieve it.</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent&#x3D;n	Percentage of the (entire) heap occupancy to start a concurrent GC cycle. It is used by GCs that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (e.g., G1). A value of 0 denotes &#39;do constant GC cycles&#39;. The default value is 45.</span><br><span class="line">-XX:NewRatio&#x3D;n	Ratio of new&#x2F;old generation sizes. The default value is 2.</span><br><span class="line">-XX:SurvivorRatio&#x3D;n	Ratio of eden&#x2F;survivor space size. The default value is 8.</span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;n	Maximum value for tenuring threshold. The default value is 15.</span><br><span class="line">-XX:ParallelGCThreads&#x3D;n	Sets the number of threads used during parallel phases of the garbage collectors. The default value varies with the platform on which the JVM is running.</span><br><span class="line">-XX:ConcGCThreads&#x3D;n	Number of threads concurrent garbage collectors will use. The default value varies with the platform on which the JVM is running.</span><br><span class="line">-XX:G1ReservePercent&#x3D;n	Sets the amount of heap that is reserved as a false ceiling to reduce the possibility of promotion failure. The default value is 10.</span><br><span class="line">-XX:G1HeapRegionSize&#x3D;n</span><br></pre></td></tr></table></figure>

<h4 id="九、参考"><a href="#九、参考" class="headerlink" title="九、参考"></a>九、参考</h4><ul>
<li><p><a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html" target="_blank" rel="noopener">Getting Started with the G1 Garbage Collector</a></p>
</li>
<li><p><a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="noopener">Memory Management in the Java HotSpot™ Virtual Machine</a></p>
</li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM深入理解-内存物理结构&amp;类加载</title>
    <url>/2020/02/27/2020/02/JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E5%86%85%E5%AD%98%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84&amp;%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>对于JVM这块儿的知识，我估计大部分的都是只有在需要面试的时候才会拿出来复习一下，然后就又放下来。也是因为这块儿是<code>Java</code>最底层的部分，非常难懂。其实如果真的说认真、细心的去撸一下，了解透彻，应该就不会那么容易忘记。</p>
<p>今天的主要目的也是根据<code>Oracle</code>的官方文档来一步一步的理解与学习，并且用用一些<code>demo</code>来验证理论。</p>
<h5 id="Java虚拟机内存结构"><a href="#Java虚拟机内存结构" class="headerlink" title="Java虚拟机内存结构"></a>Java虚拟机内存结构</h5><p>我们先来看一下<code>JVM</code>一个大概的物理结构图（请注意，不叫内存模型）：</p>
<p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20191121231823.png" alt="http://static.cyblogs.com/QQ截图20191121231823.png"></p>
<h6 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h6><p>我们首先看一下官方地址对于运行时数据区域的一个划分：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">2.5. Run-Time Data Areas</a></p>
<ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.1" target="_blank" rel="noopener">2.5.1. The <code>pc</code> Register</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.2" target="_blank" rel="noopener">2.5.2. Java Virtual Machine Stacks</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.3" target="_blank" rel="noopener">2.5.3. Heap</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener">2.5.4. Method Area</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.5" target="_blank" rel="noopener">2.5.5. Run-Time Constant Pool</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.6" target="_blank" rel="noopener">2.5.6. Native Method Stacks</a></li>
</ul>
<h6 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h6><p>堆存放：对象、数组 （官方证明： The heap is the run-time data area from which memory for all class instances and arrays is allocated. ）</p>
<h6 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h6><p>方法区存放：静态成员变量、常量、类的信息、常量池 （官方证明： It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener">§2.9</a>) used in class and instance initialization and interface initialization.）</p>
<h6 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h6><p>然后我们看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"this is a methd"</span>);</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"this is b methd"</span>);</span><br><span class="line">    c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"this is c methd"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单画一个方法压栈与出栈的过程：</p>
<p><img src="http://static.cyblogs.com/WX20200130-133454@2x.png" alt="http://static.cyblogs.com/WX20200130-133454@2x.png"></p>
<p>其实在这就可以看到，因为有相互调用的情况，这里利用栈的原理（FILO=frist in last out）。</p>
<ul>
<li>先<code>a()</code>入栈发现调用了<code>b()</code>，<code>b()</code>入栈发现调用<code>c()</code>；</li>
<li><code>c()</code>执行完毕出栈，然后<code>b()</code>出栈，最后<code>c()</code>方法出栈；</li>
</ul>
<p>如果一直压栈的话，如果是无穷的递归会怎么办？所以栈是需要规定深度的，对应的就是栈的大小-Xss来控制的，如果是超过大小是会<code>OOM</code>的。</p>
<blockquote>
<p>The following exceptional conditions are associated with native method stacks:</p>
<ul>
<li>If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a <code>StackOverflowError</code>.</li>
<li>If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available, or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</li>
</ul>
</blockquote>
<h6 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h6><p>执行本地方法，<code>native</code>方法属于C的方法。 （官方证明：An implementation of the Java Virtual Machine may use conventional stacks, colloquially called “C stacks,” to support <code>native</code> methods (methods written in a language other than the Java programming language).）</p>
<h6 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h6><p>因为在多线程的情况下，CPU通过轮询来去提高执行效率，线程之间会进行切换。如果从离开到下一次再进来，一定要知道上一次的一个状态。所以它应该是来干这件事情的。</p>
<p>（官方证明：The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own <code>pc</code> (program counter) register. ）</p>
<h5 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h5><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。</p>
<p><img src="http://static.cyblogs.com/WX20200130-123334@2x.png" alt="http://static.cyblogs.com/WX20200130-123334@2x.png"></p>
<h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li><p>1、通过一个类的全限定名来获取其定义的二进制字节流。</p>
</li>
<li><p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
</li>
</ul>
<p>注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。这里也就是Java的开放之处，给程序员更多的选择。</p>
<p>说到加载，不得不提到类加载器，下面就具体讲述下类加载器。</p>
<p>类加载器虽然只用于实现类的加载动作，但它在<code>Java</code>程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就<code>Java</code>虚拟机中的唯一性，也就是说，即使两个类来源于同一个<code>Class</code>文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的<code>Class</code>对象的<code>equals()、isAssignableFrom()、isInstance()</code>等方法的返回结果，也包括了使用<code>instanceof</code>关键字对对象所属关系的判定结果。</p>
<p><img src="http://static.cyblogs.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.jpg" alt="http://static.cyblogs.com/类加载器.jpg"></p>
<ul>
<li>启动类加载器：<code>Bootstrap ClassLoader</code>，它负责加载存放在<code>JDK\jre\lib</code>(JDK代表<code>JDK</code>的安装目录，下同)下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如<code>rt.jar</code>，所有的java.*开头的类均被<code>Bootstrap ClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。</li>
<li>扩展类加载器：<code>Extension ClassLoader</code>，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器：<code>Application ClassLoader</code>，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（<code>ClassPath</code>）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。</p>
<h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p>
<ul>
<li>文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li>
<li>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</li>
<li>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li>
<li>符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</li>
</ul>
<h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h6><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li>
</ul>
<h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。这里需要对编译后的字节码文件结构有一个深入了解才能明白。</p>
<p>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。</p>
<p>直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</p>
<p>1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p>
<p>2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下：</p>
<p>本类 → 接口 → 父接口 → …→ 父类 → 祖父类→… 我们看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/1/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 11:40 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了super类静态语句块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.vernon.test.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/1/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 11:40 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了super类静态语句块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.vernon.test.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/1/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 11:44 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了子类静态语句块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.vernon.test.classloader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/1/30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 11:27 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:62747', transport: 'socket'</span><br><span class="line">执行了super类静态语句块</span><br><span class="line">执行了父类静态语句块</span><br><span class="line">33</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:62747', transport: 'socket'</span><br></pre></td></tr></table></figure>

<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<br>   这里简单说明下<code>&lt;clinit&gt;()</code>方法的执行规则:<br>    1、<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。<br>    2、<code>&lt;clinit&gt;()</code>方法与实例构造器<code>&lt;init&gt;()</code>方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此，在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是<code>java.lang.Object。</code><br>    3、<code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。<br>    4、接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成<code>&lt;clinit&gt;()</code>方法。但是接口鱼类不同的是：执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。<br>    5、虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>类加载这块儿部分其实是非常重要的知识点，它让我们了解到Java的开放、包容以及一个类是如何被加载、被分配的。其中这也是为什么说Java是一次编译，到底执行的原因，其中包含了字节码部分，还有如何做一些字节码增强的技术，后续还有对于GC部分的知识。总之，越往基础越是重要！</p>
<h5 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h5><ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/</a></li>
<li><a href="https://juejin.im/post/5a810b0e5188257a5c606a85" target="_blank" rel="noopener">https://juejin.im/post/5a810b0e5188257a5c606a85</a></li>
<li><a href="https://blog.csdn.net/ns_code/article/details/17881581" target="_blank" rel="noopener">https://blog.csdn.net/ns_code/article/details/17881581</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序员必须要了解的类Unsafe</title>
    <url>/2020/02/24/2020/02/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BBUnsafe/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Java是一个安全的编程语言，它能最大程度的防止程序员犯一些低级的错误（大部分是和内存管理有关的）。但凡是不是绝对的，使用Unsafe程序员就可以操作内存，因此可能带来一个安全隐患。</p>
<p>这篇文章是就快速学习下<code>sun.misc.Unsafe</code>的公共API和一些有趣的使用例子。</p>
<h4 id="Unsafe-实例化"><a href="#Unsafe-实例化" class="headerlink" title="Unsafe 实例化"></a>Unsafe 实例化</h4><p>在使用Unsafe之前我们需要先实例化它。但我们不能通过像<code>Unsafe unsafe = new Unsafe()</code>这种简单的方式来实现Unsafe的实例化，这是由于Unsafe的构造方法是私有的。Unsafe有一个静态的getUnsafe()方法，但是如果天真的以为调用该方法就可以的话，那你将遇到一个<code>SecurityException</code>异常，这是由于该方法只能在被信任的代码中调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class cc = sun.reflect.Reflection.getCallerClass(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (cc.getClassLoader() != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那Java是如何判断我们的代码是否是受信的呢？它就是通过判断加载我们代码的类加载器是否是根类加载器。</p>
<p>我们可是通过这种方法将我们自己的代码变为受信的，使用jvm参数<code>bootclasspath</code>。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xbootclasspath:/usr/jdk1<span class="number">.7</span><span class="number">.0</span>/jre/lib/rt.jar:. com.mishadoff.magic.UnsafeClient</span><br></pre></td></tr></table></figure>

<p><strong>但这种方式太难了</strong></p>
<p>Unsafe类内部有一个名为<code>theUnsafe</code>的私有实例变量，我们可以通过反射来获取该实例变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 忽略你的IDE提示. 例如, eclipse可能会报这样的错误”Access restriction…” 单如果你运行你的代码，会发现一切正常。如果还是还是提示错误，你可以通过如下的方式关闭该错误提示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Preferences -&gt; Java -&gt; Compiler -&gt; Errors/Warnings -&gt;</span><br><span class="line">Deprecated and restricted API -&gt; Forbidden reference -&gt; Warning</span><br></pre></td></tr></table></figure>

<h4 id="Unsafe-API"><a href="#Unsafe-API" class="headerlink" title="Unsafe API"></a>Unsafe API</h4><p>类 <a href="http://www.docjar.com/docs/api/sun/misc/Unsafe.html" target="_blank" rel="noopener">sun.misc.Unsafe</a> 由150个方法组成。事实上这些方法只有几组是非常重要的用来操作不同的对象。下面我们就来看下这些方法中的一部分。</p>
<ol>
<li><strong>Info</strong> 仅仅是返回一个低级别的内存相关的信息<ul>
<li>addressSize</li>
<li>pageSize</li>
</ul>
</li>
<li><strong>Objects</strong>. 提供操作对象和对象字段的方法<ul>
<li>allocateInstance</li>
<li>objectFieldOffset</li>
</ul>
</li>
<li><strong>Classes</strong>. 提供针对类和类的静态字段操作的方法<ul>
<li>staticFieldOffset</li>
<li>defineClass</li>
<li>defineAnonymousClass</li>
<li>ensureClassInitialized</li>
</ul>
</li>
<li><strong>Arrays</strong>. 数组操作<ul>
<li>arrayBaseOffset</li>
<li>arrayIndexScale</li>
</ul>
</li>
<li>Synchronization. 低级别的同步原语<ul>
<li>monitorEnter</li>
<li>tryMonitorEnter</li>
<li>monitorExit</li>
<li>compareAndSwapInt</li>
<li>putOrderedInt</li>
</ul>
</li>
<li>Memory. 直接访问内存的方法<ul>
<li>allocateMemory</li>
<li>copyMemory</li>
<li>freeMemory</li>
<li>getAddress</li>
<li>getInt</li>
<li>putInt</li>
</ul>
</li>
</ol>
<h4 id="有趣的使用case"><a href="#有趣的使用case" class="headerlink" title="有趣的使用case"></a>有趣的使用case</h4><h5 id="跳过构造初始化"><a href="#跳过构造初始化" class="headerlink" title="跳过构造初始化"></a>跳过构造初始化</h5><p>allocateInstance方法可能是有用的,当你需要在构造函数中跳过对象初始化阶段或绕过安全检查又或者你想要实例化哪些没有提供公共构造函数的类时就可以使用该方法。考虑下面的类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> a; <span class="comment">// not initialized value</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">1</span>; <span class="comment">// initialization</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">a</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过构造函数，反射，Unsafe分别来实例化该类结果是不同的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A o1 = <span class="keyword">new</span> A(); <span class="comment">// constructor</span></span><br><span class="line">o1.a(); <span class="comment">// prints 1</span></span><br><span class="line"></span><br><span class="line">A o2 = A<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>; <span class="comment">// reflection</span></span><br><span class="line">o2.a(); <span class="comment">// prints 1</span></span><br><span class="line"></span><br><span class="line">A o3 = (A) unsafe.allocateInstance(A<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">// unsafe</span></span><br><span class="line">o3.a(); <span class="comment">// prints 0</span></span><br></pre></td></tr></table></figure>

<p>思考一下这些确保对<a href="http://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">Singletons</a>模式的影响。</p>
<h5 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h5><p>对C程序员来说这中情况是很常见的。</p>
<p>思考一下一些简单的类是如何坚持访问规则的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Guard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ACCESS_ALLOWED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">giveAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">42</span> == ACCESS_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码是非常安全的,调用giveAccess()检查访问规则。不幸的是对所有的客户端代码,它总是返回false。只有特权用户在某种程度上可以改变ACCESS_ALLOWED常量并且获得访问权限。</p>
<p>事实上,这不是真的。这是证明它的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Guard guard = <span class="keyword">new</span> Guard();</span><br><span class="line">guard.giveAccess();   <span class="comment">// false, no access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bypass</span></span><br><span class="line">Unsafe unsafe = getUnsafe();</span><br><span class="line">Field f = guard.getClass().getDeclaredField(<span class="string">"ACCESS_ALLOWED"</span>);</span><br><span class="line">unsafe.putInt(guard, unsafe.objectFieldOffset(f), <span class="number">42</span>); <span class="comment">// memory corruption</span></span><br><span class="line"></span><br><span class="line">guard.giveAccess(); <span class="comment">// true, access granted</span></span><br></pre></td></tr></table></figure>

<p>现在所有的客户端都没有访问限制了。</p>
<p>事实上同样的功能也可以通过反射来实现。但有趣的是, 通过上面的方式我们修改任何对象，即使我们没有持有对象的引用。</p>
<p>举个例子, 在内存中有另外的一个Guard对象，并且地址紧挨着当前对象的地址，我们就可以通过下面的代码来修改该对象的<code>ACCESS_ALLOWED</code>字段的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">unsafe.putInt(guard, <span class="number">16</span> + unsafe.objectFieldOffset(f), <span class="number">42</span>); <span class="comment">// memory corruption</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，我们没有使用任何指向该对象的引用，16是Guard对象在32位架构上的大小。我们也可以通过<code>sizeOf</code>方法来计算Guard对象的大小。</p>
<h5 id="sizeOf"><a href="#sizeOf" class="headerlink" title="sizeOf"></a>sizeOf</h5><p>使用<code>objectFieldOffset</code>方法我们可以实现C风格的sizeof方法。下面的方法实现返回对象的表面上的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Unsafe u = getUnsafe();</span><br><span class="line">    HashSet&lt;Field&gt; fields = <span class="keyword">new</span> HashSet&lt;Field&gt;();</span><br><span class="line">    Class c = o.getClass();</span><br><span class="line">    <span class="keyword">while</span> (c != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Field f : c.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((f.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                fields.add(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c = c.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get offset</span></span><br><span class="line">    <span class="keyword">long</span> maxSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        <span class="keyword">long</span> offset = u.objectFieldOffset(f);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; maxSize) &#123;</span><br><span class="line">            maxSize = offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((maxSize/<span class="number">8</span>) + <span class="number">1</span>) * <span class="number">8</span>;   <span class="comment">// padding</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法逻辑如下：收集所有包括父类在内的非静态字段，获得每个字段的偏移量，发现最大并添加填充。也许,我错过了一些东西，但是概念是明确的。</p>
<p>更简单的sizeof方法实现逻辑是：我们只读取该对象对应的class对象中关于大小的字段值。在<code>JVM 1.7 32 位</code>版本上该表示大小的字段偏移量是12。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUnsafe().getAddress(</span><br><span class="line">        normalize(getUnsafe().getInt(object, <span class="number">4L</span>)) + <span class="number">12L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>normalize</code>是一个将有符号的int类型转为无符号的long类型的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">normalize</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value &gt;= <span class="number">0</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">return</span> (~<span class="number">0L</span> &gt;&gt;&gt; <span class="number">32</span>) &amp; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太棒了,这个方法返回的结果和我们之前的sizeof函数是相同的。</p>
<p>but it requires specifyng agent option in your JVM.</p>
<p>事实上，对于合适的，安全的，准确的sizeof函数最好使用<code>java.lang.instrument</code>包，但它需要特殊的JVM参数。</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>在实现了计算对象浅层大小的基础上，我们可以非常容易的添加对象的拷贝方法。标准的办法需要修改我们的代码和Cloneable。或者你可以实现自定义的对象拷贝函数，但它不会变为通用的函数。</p>
<p>浅拷贝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">shallowCopy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> size = sizeOf(obj);</span><br><span class="line">    <span class="keyword">long</span> start = toAddress(obj);</span><br><span class="line">    <span class="keyword">long</span> address = getUnsafe().allocateMemory(size);</span><br><span class="line">    getUnsafe().copyMemory(start, address, size);</span><br><span class="line">    <span class="keyword">return</span> fromAddress(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>toAddress</code> 和 <code>fromAddress</code> 将对象转为它在内存中的地址或者从指定的地址内容转为对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">toAddress</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Object[] array = <span class="keyword">new</span> Object[] &#123;obj&#125;;</span><br><span class="line">    <span class="keyword">long</span> baseOffset = getUnsafe().arrayBaseOffset(Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> normalize(getUnsafe().getInt(array, baseOffset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">fromAddress</span><span class="params">(<span class="keyword">long</span> address)</span> </span>&#123;</span><br><span class="line">    Object[] array = <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>&#125;;</span><br><span class="line">    <span class="keyword">long</span> baseOffset = getUnsafe().arrayBaseOffset(Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    getUnsafe().putLong(array, baseOffset, address);</span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该拷贝函数可以用来拷贝任何类型的对象，因为对象的大小是动态计算的。</p>
<p><strong>注意</strong> 在完成拷贝动作后你需要将拷贝对象的类型强转为目标类型。</p>
<h5 id="隐藏密码"><a href="#隐藏密码" class="headerlink" title="隐藏密码"></a>隐藏密码</h5><p>在Unsafe的直接内存访问方法使用case中有一个非常有趣的用法就是删除内存中不想要的对象。</p>
<p>大多数获取用户密码的API方法的返回值不是byte[]就是char[]，这是为什么呢？</p>
<p>这完全是出于安全原因, 因为我们可以在不需要它们的时候将数组元素置为失效。如果我们获取的密码是字符串类型，则密码字符串是作为一个对象保存在内存中的。要将该密码字符串置为无效，我们只能讲字符串引用职位null，但是该字符串的内容任然存在内存直到GC回收该对象后。</p>
<p>这个技巧在内存创建一个假的大小相同字符串对象来替换原来的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String password = <span class="keyword">new</span> String(<span class="string">"l00k@myHor$e"</span>);</span><br><span class="line">String fake = <span class="keyword">new</span> String(password.replaceAll(<span class="string">"."</span>, <span class="string">"?"</span>));</span><br><span class="line">System.out.println(password); <span class="comment">// l00k@myHor$e</span></span><br><span class="line">System.out.println(fake); <span class="comment">// ????????????</span></span><br><span class="line"></span><br><span class="line">getUnsafe().copyMemory(</span><br><span class="line">          fake, <span class="number">0L</span>, <span class="keyword">null</span>, toAddress(password), sizeOf(password));</span><br><span class="line"></span><br><span class="line">System.out.println(password); <span class="comment">// ????????????</span></span><br><span class="line">System.out.println(fake); <span class="comment">// ????????????</span></span><br></pre></td></tr></table></figure>

<p>感觉安全了吗？</p>
<p>其实该方法不是真的安全。想要真的安全我们可以通过反射API将字符串对象中的字符数组<code>value</code>字段的值修改为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field stringValue = String.class.getDeclaredField("value");</span><br><span class="line">stringValue.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">char</span>[] mem = (<span class="keyword">char</span>[]) stringValue.get(password);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; mem.length; i++) &#123;</span><br><span class="line">  mem[i] = <span class="string">'?'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>在Java中本来是没有多重集成的。除非我们可以将任意的类型转为我们想要的任意类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> intClassAddress = normalize(getUnsafe().getInt(<span class="keyword">new</span> Integer(<span class="number">0</span>), <span class="number">4L</span>));</span><br><span class="line"><span class="keyword">long</span> strClassAddress = normalize(getUnsafe().getInt(<span class="string">""</span>, <span class="number">4L</span>));</span><br><span class="line">getUnsafe().putAddress(intClassAddress + <span class="number">36</span>, strClassAddress);</span><br></pre></td></tr></table></figure>

<p>这段代码将String类添加到Integer的超类集合中,所以我们的强转代码是没有运行时异常的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(String) (Object) (<span class="keyword">new</span> Integer(<span class="number">666</span>))</span><br></pre></td></tr></table></figure>

<p>有个问题是我们需要先将要转的对象转为Object，然后再转为我们想要的类型。这是为了欺骗编译器。</p>
<h4 id="动态类"><a href="#动态类" class="headerlink" title="动态类"></a>动态类</h4><p>We can create classes in runtime, for example from compiled .class file. To perform that read class contents to byte array and pass it properly to defineClass method.</p>
<p>我们可以在运行时创建类, 例如通过一个编译好的class文件。将class文件的内容读入到字节数组中然后将该数组传递到合适的<code>defineClass</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] classContents = getClassContent();</span><br><span class="line">Class c = getUnsafe().defineClass(</span><br><span class="line">              <span class="keyword">null</span>, classContents, <span class="number">0</span>, classContents.length);</span><br><span class="line">    c.getMethod(<span class="string">"a"</span>).invoke(c.newInstance(), <span class="keyword">null</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>读取class文件内如的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getClassContent() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">"/home/mishadoff/tmp/A.class"</span>);</span><br><span class="line">    FileInputStream input = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">    <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">    input.read(content);</span><br><span class="line">    input.close();</span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方式是非常有用的，如果你确实需要在运行时动态的创建类。比如生产代理类或切面类。</p>
<h4 id="抛出一个异常"><a href="#抛出一个异常" class="headerlink" title="抛出一个异常"></a>抛出一个异常</h4><p>不喜欢受检异常？这不是问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getUnsafe().throwException(<span class="keyword">new</span> IOException());</span><br></pre></td></tr></table></figure>

<p>该方法抛出一个受检异常，但是你的代码不需要强制捕获该异常就像运行时异常一样。</p>
<h4 id="快速序列化"><a href="#快速序列化" class="headerlink" title="快速序列化"></a>快速序列化</h4><p>这种使用方式更实用。</p>
<p>每个人都知道java标准的序列化的功能速度很慢而且它还需要类拥有公有的构造函数。</p>
<p>外部序列化是更好的方式，但是需要定义针对待序列化类的schema。</p>
<p>非常流行的高性能序列化库，像<a href="http://code.google.com/p/kryo/" target="_blank" rel="noopener">kryo</a>是有使用限制的，比如在内存缺乏的环境就不合适。</p>
<p>但通过使用Unsafe类我们可以非常简单的实现完整的序列化功能。</p>
<p><strong>序列化</strong>：</p>
<ul>
<li>通过反射定义类的序列化。 这个可以只做一次。</li>
<li>通过Unsafe的<code>getLong</code>, <code>getInt</code>, <code>getObject</code>等方法获取字段真实的值。</li>
<li>添加可以恢复该对象的标识符。</li>
<li>将这些数据写入到输出</li>
</ul>
<p>当然也可以使用压缩来节省空间。</p>
<p><strong>反序列化</strong>:</p>
<ul>
<li>创建一个序列化类的实例，可以通过方法<code>allocateInstance</code>。因为该方法不需要任何构造方法。</li>
<li>创建schama, 和序列化类似</li>
<li>从文件或输入读取或有的字段</li>
<li>使用 <code>Unsafe</code> 的 <code>putLong</code>, <code>putInt</code>, <code>putObject</code>等方法来填充对象。</li>
</ul>
<p>Actually, there are much more details in correct inplementation, but intuition is clear.</p>
<p>事实上要正确实现序列化和反序列化需要注意很多细节，但是思路是清晰的。</p>
<p>这种序列化方式是非常快的。</p>
<p>顺便说一句，在 <code>kryo</code> 有许多使用<code>Unsafe</code>的尝试 <a href="http://code.google.com/p/kryo/issues/detail?id=75" target="_blank" rel="noopener">http://code.google.com/p/kryo/issues/detail?id=75</a></p>
<h4 id="大数组"><a href="#大数组" class="headerlink" title="大数组"></a>大数组</h4><p>如你所知Java数组长度的最大值是<code>Integer.MAX_VALUE</code>。使用直接内存分配我们可以创建非常大的数组，该数组的大小只受限于堆的大小。</p>
<p>这里有一个<code>SuperArray</code>的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> BYTE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperArray</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        address = getUnsafe().allocateMemory(size * BYTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> i, <span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line">        getUnsafe().putByte(address + i * BYTE, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">long</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getUnsafe().getByte(address + idx * BYTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> SUPER_SIZE = (<span class="keyword">long</span>)Integer.MAX_VALUE * <span class="number">2</span>;</span><br><span class="line">SuperArray array = <span class="keyword">new</span> SuperArray(SUPER_SIZE);</span><br><span class="line">System.out.println(<span class="string">"Array size:"</span> + array.size()); <span class="comment">// 4294967294</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    array.set((<span class="keyword">long</span>)Integer.MAX_VALUE + i, (<span class="keyword">byte</span>)<span class="number">3</span>);</span><br><span class="line">    sum += array.get((<span class="keyword">long</span>)Integer.MAX_VALUE + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Sum of 100 elements:"</span> + sum);  <span class="comment">// 300</span></span><br></pre></td></tr></table></figure>

<p>事实上该技术使用了非堆内存<code>off-heap memory</code>，在 <code>java.nio</code> 包中也有使用。</p>
<p>通过这种方式分配的内存不在堆上，并且不受GC管理。因此需要小心使用<code>Unsafe.freeMemory()</code>。该方法不会做任何边界检查，因此任何不合法的访问可能就会导致JVM奔溃。</p>
<p>这种使用方式对于数学计算是非常有用的，因为代码可以操作非常大的数据数组。 同样的编写实时程序的程序员对此也非常感兴趣，因为不受GC限制，就不会因为GC导致非常大的停顿。</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>关于并发编程使用Unsafe的只言片语。<code>compareAndSwap</code> 方法是原子的，可以用来实现高性能的无锁化数据结构。</p>
<p>举个例子，多个线程并发的更新共享的对象这种场景：</p>
<p>首先我们定义一个简单的接口 <code>Counter</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义工作线程 <code>CounterClient</code>, 它会使用 <code>Counter</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterClient</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Counter c;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterClient</span><span class="params">(Counter c, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            c.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> NUM_OF_THREADS = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> NUM_OF_INCREMENTS = <span class="number">100000</span>;</span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(NUM_OF_THREADS);</span><br><span class="line">Counter counter = ... <span class="comment">// creating instance of specific counter</span></span><br><span class="line"><span class="keyword">long</span> before = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_OF_THREADS; i++) &#123;</span><br><span class="line">    service.submit(<span class="keyword">new</span> CounterClient(counter, NUM_OF_INCREMENTS));</span><br><span class="line">&#125;</span><br><span class="line">service.shutdown();</span><br><span class="line">service.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"><span class="keyword">long</span> after = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"Counter result: "</span> + c.getCounter());</span><br><span class="line">System.out.println(<span class="string">"Time passed in ms:"</span> + (after - before));</span><br></pre></td></tr></table></figure>

<p>第一个实现-没有同步的计数器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StupidCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter result: <span class="number">99542945</span></span><br><span class="line">Time passed in ms: <span class="number">679</span></span><br></pre></td></tr></table></figure>

<p>速度很多，但是没有对所有的线程进行协调所以结果是错误的。第二个版本，使用Java常见的同步方式来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">10136</span></span><br></pre></td></tr></table></figure>

<p>彻底的同步当然会导致正确的结果。但是花费的时间令人沮丧。让我们试试 <code>ReentrantReadWriteLock</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> WriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock().writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        counter++;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">8065</span></span><br></pre></td></tr></table></figure>

<p>结果依然是正确的，时间也短。那使用原子的类呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    AtomicLong counter = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">6552</span></span><br></pre></td></tr></table></figure>

<p>使用<code>AtomicCounter</code>的效果更好一点。最后我们试试<code>Unsafe</code>的原子方法<code>compareAndSwapLong</code>看看是不是更进一步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CASCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CASCounter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        unsafe = getUnsafe();</span><br><span class="line">        offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField("counter"));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> before = counter;</span><br><span class="line">        <span class="keyword">while</span> (!unsafe.compareAndSwapLong(<span class="keyword">this</span>, offset, before, before + <span class="number">1</span>)) &#123;</span><br><span class="line">            before = counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Counter result: <span class="number">100000000</span></span><br><span class="line">Time passed in ms: <span class="number">6454</span></span><br></pre></td></tr></table></figure>

<p>开起来和使用原子类是一样的效果，难道原子类使用了<code>Unsafe</code>？答案是YES。</p>
<p>事实上该例子非常简单但表现出了<code>Unsafe</code>的强大功能。</p>
<p>就像前面提到的 <code>CAS</code>原语可以用来实现高效的无锁数据结构。实现的原理很简单：</p>
<ul>
<li>拥有一个状态</li>
<li>创建一个它的副本</li>
<li>修改该副本</li>
<li>执行 CAS 操作</li>
<li>如果失败就重复执行</li>
</ul>
<p>事实上，在真实的环境它的实现难度超过你的想象，这其中有需要类似ABA，指令重排序这样的问题。</p>
<p>如果你确实对此感兴趣，你可以参考关于无锁HashMap的精彩演示。</p>
<h4 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h4><p>Documentation for park method from Unsafe class contains longest English sentence I’ve ever seen:</p>
<blockquote>
<p>Block current thread, returning when a balancing unpark occurs, or a balancing unpark has already occurred, or the thread is interrupted, or, if not absolute and time is not zero, the given time nanoseconds have elapsed, or if absolute, the given deadline in milliseconds since Epoch has passed, or spuriously (i.e., returning for no “reason”). Note: This operation is in the Unsafe class only because unpark is, so it would be strange to place it elsewhere.</p>
</blockquote>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>尽管Unsafe有这么多有用的应用，但是尽力不要使用。当然了使用JDK中利用了Unsafe实现的类是可以的。或者你对你代码功力非常自信。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><p><a href="https://leokongwq.github.io/2016/12/31/java-magic-unsafe.html" target="_blank" rel="noopener">https://leokongwq.github.io/2016/12/31/java-magic-unsafe.html</a></p>
</li>
<li><p><a href="https://dzone.com/articles/understanding-sunmiscunsafe" target="_blank" rel="noopener">https://dzone.com/articles/understanding-sunmiscunsafe</a></p>
</li>
<li><p><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html</a></p>
</li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>我们如何看SpringBoot的源代码</title>
    <url>/2020/02/23/2020/02/Java%20volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h4 id="Volatile简介"><a href="#Volatile简介" class="headerlink" title="Volatile简介"></a>Volatile简介</h4><p><code>volatile</code>被称为<strong>轻量级的synchronized</strong>，运行时开销比<code>synchronized</code>更小，在多线程并发编程中发挥着<strong>同步共享变量</strong>、<strong>禁止处理器重排序</strong>的重要作用。建议在学习<code>volatie</code>之前，先看一下Java内存模型<a href="https://ddnd.cn/2019/03/11/java-memory-model/" target="_blank" rel="noopener">《什么是Java内存模型？》</a>，因为<code>volatile</code>和Java内存模型有着莫大的关系。</p>
<h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>在学习<code>volatie</code>之前，需要补充下Java内存模型的相关(JMM)知识，我们知道Java线程的所有操作都是在工作区进行的，那么工作区和主存之间的变量是怎么进行交互的呢，可以用下面的图来表示。</p>
<p><img src="http://static.cyblogs.com/e0e01e43ly1g186enjfwfj20k80degmr.jpg" alt="http://static.cyblogs.com/e0e01e43ly1g186enjfwfj20k80degmr.jpg"><br>Java通过几种原子操作完成<strong>工作区内存</strong>和<strong>主存</strong>的交互</p>
<ol>
<li>lock：作用于主存，把变量标识为线程独占状态。</li>
<li>unlock：作用于主存，解除变量的独占状态。</li>
<li>read：作用于主存，把一个变量的值通过主存传输到线程的工作区内存。</li>
<li>load：作用于工作区内存，把<code>read</code>操作传过来的变量值储存到工作区内存的变量副本中。</li>
<li>use：作用于工作内存，把工作区内存的变量副本传给执行引擎。</li>
<li>assign：作用于工作区内存，把从执行引擎传过来的值赋值给工作区内存的变量副本。</li>
<li>store：作用于工作区内存，把工作区内存的变量副本传给主存。</li>
<li>write：作用于主存，把<code>store</code>操作传过来的值赋值给主存变量。</li>
</ol>
<p><strong>这<code>8</code>个操作每个操作都是原子性的，但是几个操作连着一起就不是原子性了！</strong></p>
<h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><p>上面介绍了Java模型的<code>8</code>个操作，那么这<code>8</code>个操作和<code>volatile</code>又有着什么关系呢。</p>
<h5 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a>volatile的可见性</h5><p>什么是<strong>可见性</strong>，用一个例子来解释，先看一段代码，加入线程<code>1</code>先执行，线程<code>2</code>再执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">    <span class="keyword">do</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>线程<code>1</code>执行后会进入到一个死循环中，当线程<code>2</code>执行后，线程<code>1</code>的死循环就一定会马上结束吗？答案是不一定，因为线程<code>2</code>执行完<code>stop = true</code>后，并不会马上将变量<code>stop</code>的值<code>true</code>写回主存中，也就是上图中的<code>assign</code>执行完成之后，<code>store</code>和<code>write</code>并不会随着执行，<strong>线程<code>1</code>没有立即将修改后的变量的值更新到主存中</strong>，即使线程<code>2</code>及时将变量<code>stop</code>的值写回主存中了，<strong>线程<code>1</code>也没有了解到变量<code>stop</code>的值已被修改而去主存中重新获取</strong>，也就是线程<code>1</code>的<code>load</code>、<code>read</code>操作并不会马上执行造成线程<code>1</code>的工作区内存中的变量副本不是最新的。这两个原因造成了线程<code>1</code>的死循环也就不会马上结束。<br>那么如何避免上诉的问题呢？我们可以使用<code>volatile</code>关键字修饰变量<code>stop</code>，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">    <span class="keyword">do</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>这样线程<code>1</code>每次读取变量<code>stop</code>的时候都会先去主存中获取变量<code>stop</code>最新的值，线程<code>2</code>每次修改变量<code>stop</code>的值之后都会马上将变量的值写回主存中，这样也就不会出现上述的问题了。</p>
<p>那么关键字<code>volatie</code>是如何做到的呢？<code>volatie</code>规定了上述<code>8</code>个操作的规则</p>
<ol>
<li>只有当线程对变量执行的<strong>前一个操作</strong>是<code>load</code>时，线程才能对变量执行<code>use</code>操作；只有线程的后一个操作是<code>use</code>时，线程才能对变量执行<code>load</code>操作。即规定了<code>use</code>、<code>load</code>、<code>read</code>三个操作之间的约束关系，<strong>规定这三个操作必须连续的出现，保证了线程每次读取变量的值前都必须去主存获取最新的值</strong>。</li>
<li>只有当前程对变量执行的<strong>前一个操作</strong>是<code>assign</code>时，线程才能对变量执行<code>store</code>操作；只有线程的后一个操作是<code>store</code>时，线程才能对变量执行<code>assign</code>操作，即规定了<code>assign</code>、<code>store</code>、<code>write</code>三个操作之间的约束关系，<strong>规定了这三个操作必须连续的出现，保证线程每次修改变量后都必须将变量的值写回主存</strong>。</li>
</ol>
<p><code>volatile</code>的这两个规则，也正是保证了<strong>共享变量的可见性</strong>。</p>
<h5 id="volatile的有序性"><a href="#volatile的有序性" class="headerlink" title="volatile的有序性"></a>volatile的有序性</h5><p>有序性即程序执行的顺序按照代码的先后顺序执行，Java内存模型(JMM)允许编译器和处理器对指令进行重排序，但是规定了<code>as-if-serial</code>语义，即保证<strong>单线程</strong>情况下不管怎么重排序，程序的结果不能改变，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;  <span class="comment">//A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1</span>;     <span class="comment">//B</span></span><br><span class="line"><span class="keyword">double</span> s = pi * r * r; <span class="comment">//C</span></span><br></pre></td></tr></table></figure>

<p>上面的代码可能按照<code>A-&gt;B-&gt;C</code>顺序执行，也有可能按照<code>B-&gt;A-&gt;C</code>顺序执行，这两种顺序都不会影响程序的结果。但是不会以<code>C-&gt;A(B)-&gt;B(A)</code>的顺序去执行，因为<code>C</code>语句是依赖于<code>A</code>和<code>B</code>的，如果按照这样的顺序去执行就不能保证结果不变了(违背了<code>as-if-serial</code>)。</p>
<p>上面介绍的是单线程的执行，不管指令怎么重排序都不会影响结果，但是在多线程下就会出现问题了。<br>下面看个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">r = <span class="number">10</span>; <span class="comment">//A</span></span><br><span class="line">start = <span class="keyword">true</span>; <span class="comment">//B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">if</span> (start) &#123;  <span class="comment">//C</span></span><br><span class="line">    s = pi * r * r;  <span class="comment">//D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程<code>1</code>和线程<code>2</code>同时执行，线程<code>1</code>的<code>A</code>和<code>B</code>的执行顺序可能是<code>A-&gt;B</code>或者<code>B-&gt;A</code>(因为A和B之间没有依赖关系，可以指令重排序)。如果线程<code>1</code>按照<code>A-&gt;B</code>的顺序执行，那么线程<code>2</code>执行后的结果s就是我们想要的正确结果，如果线程<code>1</code>按照<code>B-&gt;A</code>的顺序执行，那么线程<code>2</code>执行后的结果s可能就不是我们想要的结果了，因为线程<code>1</code>将变量<code>stop</code>的值修改为<code>true</code>后，线程<code>2</code>马上获取到<code>stop</code>为<code>true</code>然后执行<code>C</code>语句，然后执行<code>D</code>语句即<code>s = 3.14 * 0 * 0</code>，然后线程<code>1</code>再执行<code>B</code>语句，那么结果就是有问题了。</p>
<p>那么为了解决这个问题，我们可以在变量<code>true</code>加上关键字<code>volatile</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1</span></span><br><span class="line">r = <span class="number">10</span>; <span class="comment">//A</span></span><br><span class="line">start = <span class="keyword">true</span>; <span class="comment">//B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="keyword">if</span> (start) &#123;  <span class="comment">//C</span></span><br><span class="line">    s = pi * r * r;  <span class="comment">//D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样线程<code>1</code>的执行顺序就只能是<code>A-&gt;B</code>了，因为关键字<strong>发挥了禁止处理器指令重排序的作用</strong>，所以线程<code>2</code>的执行结果就不会有问题了。</p>
<p>那么<code>volatile</code>是怎么实现禁止处理器重排序的呢？<br><strong>编译器会在编译生成字节码的时候，在加有<code>volatile</code>关键字的变量的指令进行插入内存屏障来禁止特定类型的处理器重排序</strong><br>我们先看<strong>内存屏障</strong>有哪些及发挥的作用<br><img src="http://static.cyblogs.com/e0e01e43ly1g191y6o3paj21620f5qd7.jpg" alt="http://static.cyblogs.com/e0e01e43ly1g191y6o3paj21620f5qd7.jpg"></p>
<ol>
<li><code>StoreStore</code>屏障：禁止屏障上面变量的写和下面所有进行写的变量进行处理器重排序。</li>
<li><code>StoreLoad</code>屏障：禁止屏障上面变量的写和下面所有进行读的变量进行处理器重排序。</li>
<li><code>LoadLoad</code>屏障：禁止屏障上面变量的读和下面所有进行读的变量进行处理器重排序。</li>
<li><code>LoadStore</code>屏障：禁止屏障上面变量的读和下面所有进行写的变量进行处理器重排序。</li>
</ol>
<p>再看<code>volatile</code>是怎么插入屏障的</p>
<ol>
<li>在每个<code>volatile</code>变量的写<strong>前面</strong>插入一个<code>StoreStore</code>屏障。</li>
<li>在每个<code>volatile</code>变量的写<strong>后面</strong>插入一个<code>StoreLoad</code>屏障。</li>
<li>在每个<code>volatile</code>变量的读<strong>后面</strong>插入一个<code>LoadLoad</code>屏障。</li>
<li>在每个<code>volatile</code>变量的读<strong>后面</strong>插入一个<code>LoadStore</code>屏障。</li>
</ol>
<blockquote>
<p>注意：写操作是在<code>volatile</code><strong>前后</strong>插入一个内存屏障，而读操作是在<strong>后面</strong>插入两个内存屏障。</p>
</blockquote>
<p><img src="http://static.cyblogs.com/e0e01e43ly1g186ext5z1j20h809vjsv.jpg" alt="http://static.cyblogs.com/e0e01e43ly1g186ext5z1j20h809vjsv.jpg"></p>
<p><strong><code>volatile</code>变量通过插入内存屏障禁止了处理器重排序，从而解决了多线程环境下处理器重排序的问题</strong>。</p>
<h5 id="volatile有没有原子性？"><a href="#volatile有没有原子性？" class="headerlink" title="volatile有没有原子性？"></a>volatile有没有原子性？</h5><p>上面分别介绍了<code>volatile</code>的可见性和有序性，那么<code>volatile</code>有原子性吗？我们先看一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们开启<code>10</code>个线程对<code>volatile</code>变量进行自增操作，每个线程对<code>volatile</code>变量执行<code>1000</code>次自增操作，那结果变量<code>inc</code>会是<code>10000</code>吗？答案是，变量<code>inc</code>的值基本都是小于<code>10000</code>。<br>可能你会有疑问，<code>volatile</code>变量<code>inc</code>不是保证了共享变量的可见性了吗，每次线程读取到的都是最新的值，是的没错，<strong>但是线程每次将值写回主存的时候并不能保证主存中的值没有被其他的线程修过过</strong>。</p>
<p><img src="http://static.cyblogs.com/WX20200212-225100@2x.png" alt="http://static.cyblogs.com/WX20200212-225100@2x.png"></p>
<p>如果所示：线程<code>1</code>在主存中获取了<code>i</code>的最新值(i=1)，线程<code>2</code>也在主存中获取了<code>i</code>的最新值(i=1，注意这时候线程<code>1</code>并未对变量<code>i</code>进行修改，所以<code>i</code>的值还是<code>1</code>)），然后线程<code>2</code>将i自增后写回主存，这时候主存中<code>i=2</code>，到这里还没有问题，然后线程<code>1</code>又对i进行了自增写回了主存，这时候主存中<code>i=2</code>，也就是对i做了2次自增操作，结果i的结果只自增了1，问题就出来了这里。</p>
<p>为什么会有这个问题呢，前面我们提到了Java内存模型和主存之间交互的<code>8</code>个操作都是原子性的，但是他们的操作连在一起就不是原子性了，而<code>volatile</code>关键字也只是保证了<code>use</code>、<code>load</code>、<code>read</code>三个操作连在一起时候的原子性，还有<code>assign</code>、<code>store</code>、<code>write</code>这三个操作连在一起时候的原子性，也就是<code>volatile</code>关键字<strong>保证了变量读操作的原子性和写操作的原子性，而变量的自增过程需要对变量进行读和写两个过程，而这两个过程连在一起就不是原子性操作了。</strong></p>
<p>所以说<code>volatile</code>变量对于变量的单独写操作/读操作是保证了原子性的，而常说的原子性包括读写操作连在一起，所以说对于<code>volatile</code>不保证原子性的。那么如何解决上面程序的问题呢？只能给<code>increase</code>方法加锁，让在多线程情况下只有一个线程能执行<code>increase</code>方法，也就是保证了一个线程对变量的读写是原子性的。<strong>当然还有个更优的方案，就是利用读写都为原子性的<code>CAS</code>，利用<code>CAS</code>对<code>volatile</code>进行操作，既解决了<code>volatile</code>不保证原子性的问题，同时消耗也没加锁的方式大</strong></p>
<h5 id="volatile和CAS"><a href="#volatile和CAS" class="headerlink" title="volatile和CAS"></a>volatile和CAS</h5><p>学完<code>volatile</code>之后，是不是觉得<code>volatile</code>和<code>CAS</code>有种似曾相识的感觉？那它们之间有什么关系或者区别呢。</p>
<ol>
<li><code>volatile</code>只能保证共享变量的读和写操作单个操作的原子性，而<code>CAS</code>保证了共享变量的读和写两个操作一起的原子性(即CAS是原子性操作的)。</li>
<li><code>volatile</code>的实现基于<code>JMM</code>，而<code>CAS</code>的实现基于硬件。</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://ddnd.cn/2019/03/19/java-volatile" target="_blank" rel="noopener">https://ddnd.cn/2019/03/19/java-volatile</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java深拷贝和浅拷贝</title>
    <url>/2020/02/25/2020/02/Java%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h4 id="对象拷贝有哪些"><a href="#对象拷贝有哪些" class="headerlink" title="对象拷贝有哪些"></a>对象拷贝有哪些</h4><p>对象拷贝(Object Copy)就是将一个对象的属性拷贝到另一个有着相同类类型的对象中去。在程序中拷贝对象是很常见的，主要是为了在新的上下文环境中复用对象的部分或全部数据。</p>
<p>Java中有三种类型的对象拷贝：</p>
<ul>
<li>浅拷贝(Shallow Copy)</li>
<li>深拷贝(Deep Copy)</li>
<li>延迟拷贝(Lazy Copy)</li>
</ul>
<h4 id="理解浅拷贝"><a href="#理解浅拷贝" class="headerlink" title="理解浅拷贝"></a>理解浅拷贝</h4><h5 id="什么是浅拷贝？"><a href="#什么是浅拷贝？" class="headerlink" title="什么是浅拷贝？"></a>什么是浅拷贝？</h5><ul>
<li><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</p>
<ul>
<li><p>如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
</li>
<li><p><img src="http://static.cyblogs.com/QQ20200226-210909@2x.jpg" alt="http://static.cyblogs.com/QQ20200226-210909@2x.jpg"></p>
</li>
<li><p>在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj”（引用ContainedObject类型的对象）。当对SourceObject做浅拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及仍指向refObj本身的引用。由于”field1”是基本类型，所以只是将它的值拷贝给”field2”，但是由于”refObj”是一个引用类型, 所以CopiedObject指向”refObj”相同的地址。因此对SourceObject中的”refObj”所做的任何改变都会影响到CopiedObject。</p>
</li>
</ul>
</li>
</ul>
<h5 id="如何实现浅拷贝"><a href="#如何实现浅拷贝" class="headerlink" title="如何实现浅拷贝"></a>如何实现浅拷贝</h5><p>下面来看一看实现浅拷贝的一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> String name; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 对象引用 </span></span><br><span class="line">   <span class="keyword">private</span> Subject subj; </span><br><span class="line">   <span class="keyword">private</span> String name; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s, String sub)</span> </span>&#123; </span><br><span class="line">      name = s; </span><br><span class="line">      subj = <span class="keyword">new</span> Subject(sub); </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubj</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> subj; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> name; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">      name = s; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    *  重写clone()方法 </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="comment">//浅拷贝 </span></span><br><span class="line">      <span class="keyword">try</span> &#123; </span><br><span class="line">         <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">super</span>.clone(); </span><br><span class="line">      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123; </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">      &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyDemoMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原始对象</span></span><br><span class="line">        Student stud = <span class="keyword">new</span> Student(<span class="string">"杨充"</span>, <span class="string">"潇湘剑雨"</span>);</span><br><span class="line">        System.out.println(<span class="string">"原始对象: "</span> + stud.getName() + <span class="string">" - "</span> + stud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拷贝对象</span></span><br><span class="line">        Student clonedStud = (Student) stud.clone();</span><br><span class="line">        System.out.println(<span class="string">"拷贝对象: "</span> + clonedStud.getName() + <span class="string">" - "</span> + clonedStud.getSubj().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始对象和拷贝对象是否一样：</span></span><br><span class="line">        System.out.println(<span class="string">"原始对象和拷贝对象是否一样: "</span> + (stud == clonedStud));</span><br><span class="line">        <span class="comment">// 原始对象和拷贝对象的name属性是否一样</span></span><br><span class="line">        System.out.println(<span class="string">"原始对象和拷贝对象的name属性是否一样: "</span> + (stud.getName() == clonedStud.getName()));</span><br><span class="line">        <span class="comment">// 原始对象和拷贝对象的subj属性是否一样</span></span><br><span class="line">        System.out.println(<span class="string">"原始对象和拷贝对象的subj属性是否一样: "</span> + (stud.getSubj() == clonedStud.getSubj()));</span><br><span class="line"></span><br><span class="line">        stud.setName(<span class="string">"小杨逗比"</span>);</span><br><span class="line">        stud.getSubj().setName(<span class="string">"潇湘剑雨大侠"</span>);</span><br><span class="line">        System.out.println(<span class="string">"更新后的原始对象: "</span> + stud.getName() + <span class="string">" - "</span> + stud.getSubj().getName());</span><br><span class="line">        System.out.println(<span class="string">"更新原始对象后的克隆对象: "</span> + clonedStud.getName() + <span class="string">" - "</span> + clonedStud.getSubj().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:57836', transport: 'socket'</span><br><span class="line">原始对象: 杨充 - 潇湘剑雨</span><br><span class="line">拷贝对象: 杨充 - 潇湘剑雨</span><br><span class="line">原始对象和拷贝对象是否一样: false</span><br><span class="line">原始对象和拷贝对象的name属性是否一样: true</span><br><span class="line">原始对象和拷贝对象的subj属性是否一样: true</span><br><span class="line">更新后的原始对象: 小杨逗比 - 潇湘剑雨大侠</span><br><span class="line">更新原始对象后的克隆对象: 杨充 - 潇湘剑雨大侠</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:57836', transport: 'socket'</span><br></pre></td></tr></table></figure>

<p>可以得出的结论</p>
<ul>
<li>在这个例子中，让要拷贝的类Student实现了Clonable接口并重写Object类的clone()方法，然后在方法内部调用super.clone()方法。从输出结果中我们可以看到，对原始对象stud的”name”属性所做的改变并没有影响到拷贝对象clonedStud，但是对引用对象subj的”name”属性所做的改变影响到了拷贝对象clonedStud。</li>
</ul>
<h4 id="理解深拷贝"><a href="#理解深拷贝" class="headerlink" title="理解深拷贝"></a>理解深拷贝</h4><h5 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h5><ul>
<li>深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。<ul>
<li><img src="http://static.cyblogs.com/QQ20200226-212333@2x.jpg" alt="http://static.cyblogs.com/QQ20200226-212333@2x.jpg"></li>
<li>在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj1”（引用ContainedObject类型的对象）。当对SourceObject做深拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及包含”refObj1”拷贝值的引用类型属性”refObj2” 。因此对SourceObject中的”refObj”所做的任何改变都不会影响到CopiedObject</li>
</ul>
</li>
</ul>
<h5 id="实现深拷贝案例"><a href="#实现深拷贝案例" class="headerlink" title="实现深拷贝案例"></a>实现深拷贝案例</h5><p>下面是实现深拷贝的一个例子。只是在浅拷贝的例子上做了一点小改动，Subject 和CopyTest 类都没有变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepStudent</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对象引用 </span></span><br><span class="line">    <span class="keyword">private</span> Subject subj;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepStudent</span><span class="params">(String s, String sub)</span> </span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">        subj = <span class="keyword">new</span> Subject(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写clone()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立</span></span><br><span class="line">        DeepStudent s = <span class="keyword">new</span> DeepStudent(name, subj.getName());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:60802', transport: 'socket'</span><br><span class="line">原始对象: 杨充 - 潇湘剑雨</span><br><span class="line">拷贝对象: 杨充 - 潇湘剑雨</span><br><span class="line">原始对象和拷贝对象是否一样: false</span><br><span class="line">原始对象和拷贝对象的name属性是否一样: true</span><br><span class="line">原始对象和拷贝对象的subj属性是否一样: true</span><br><span class="line">更新后的原始对象: 小杨逗比 - 潇湘剑雨大侠</span><br><span class="line">更新原始对象后的克隆对象: 杨充 - 潇湘剑雨大侠</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:60802', transport: 'socket'</span><br></pre></td></tr></table></figure>

<p>得出的结论</p>
<ul>
<li>很容易发现clone()方法中的一点变化。因为它是深拷贝，所以你需要创建拷贝类的一个对象。因为在Student类中有对象引用，所以需要在Student类中实现Cloneable接口并且重写clone方法。</li>
</ul>
<h4 id="序列化进行拷贝"><a href="#序列化进行拷贝" class="headerlink" title="序列化进行拷贝"></a>序列化进行拷贝</h4><h5 id="序列化属于深拷贝"><a href="#序列化属于深拷贝" class="headerlink" title="序列化属于深拷贝"></a>序列化属于深拷贝</h5><p>可能你会问，序列化是属于那种类型拷贝？答案是：通过序列化来实现深拷贝。可以思考一下，为何序列化对象要用深拷贝而不是用浅拷贝呢？</p>
<h5 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h5><p>可以序列化是干什么的?它将整个对象图写入到一个持久化存储文件中并且当需要的时候把它读取回来, 这意味着当你需要把它读取回来时你需要整个对象图的一个拷贝。这就是当你深拷贝一个对象时真正需要的东西。请注意，当你通过序列化进行深拷贝时，必须确保对象图中所有类都是可序列化的。</p>
<h5 id="序列化案例"><a href="#序列化案例" class="headerlink" title="序列化案例"></a>序列化案例</h5><p>看一下下面案例，很简单，只需要实现Serializable这个接口。Android中还可以实现Parcelable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColoredCircle</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> x; </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> y; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ColoredCircle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">      <span class="keyword">this</span>.x = x; </span><br><span class="line">      <span class="keyword">this</span>.y = y; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> x; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">      <span class="keyword">this</span>.x = x; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> y; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">      <span class="keyword">this</span>.y = y; </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"x="</span> + x + <span class="string">", y="</span> + y; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DouBi</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8752043194511106066L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DouBi</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyDemoMain3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建原始的可序列化对象</span></span><br><span class="line">            DouBi c1 = <span class="keyword">new</span> DouBi(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">"原始的对象 = "</span> + c1);</span><br><span class="line">            DouBi c2 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 通过序列化实现深拷贝</span></span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            <span class="comment">// 序列化以及传递这个对象</span></span><br><span class="line">            oos.writeObject(c1);</span><br><span class="line">            oos.flush();</span><br><span class="line">            ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">            <span class="comment">// 返回新的对象</span></span><br><span class="line">            c2 = (DouBi) ois.readObject();</span><br><span class="line">            <span class="comment">// 校验内容是否相同</span></span><br><span class="line">            System.out.println(<span class="string">"复制后的对象   = "</span> + c2);</span><br><span class="line">            <span class="comment">// 改变原始对象的内容</span></span><br><span class="line">            c1.setX(<span class="number">200</span>);</span><br><span class="line">            c1.setY(<span class="number">200</span>);</span><br><span class="line">            <span class="comment">// 查看每一个现在的内容</span></span><br><span class="line">            System.out.println(<span class="string">"查看原始的对象 = "</span> + c1);</span><br><span class="line">            System.out.println(<span class="string">"查看复制的对象 = "</span> + c2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception in main = "</span> + e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:62095', transport: 'socket'</span><br><span class="line">原始的对象 = com.vernon.test.copy.DouBi@1134affc</span><br><span class="line">复制后的对象   = com.vernon.test.copy.DouBi@1b604f19</span><br><span class="line">查看原始的对象 = com.vernon.test.copy.DouBi@1134affc</span><br><span class="line">查看复制的对象 = com.vernon.test.copy.DouBi@1b604f19</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:62095', transport: 'socket'</span><br></pre></td></tr></table></figure>

<p>注意：需要做以下几件事儿:</p>
<ul>
<li><p>确保对象图中的所有类都是可序列化的</p>
</li>
<li><p>创建输入输出流</p>
</li>
<li><p>使用这个输入输出流来创建对象输入和对象输出流</p>
</li>
<li><p>将你想要拷贝的对象传递给对象输出流</p>
</li>
<li><p>从对象输入流中读取新的对象并且转换回你所发送的对象的类</p>
</li>
<li><p>得出的结论</p>
<ul>
<li>在这个例子中，创建了一个DouBi对象c1然后将它序列化 (将它写到ByteArrayOutputStream中). 然后我反序列化这个序列化后的对象并将它保存到c2中。随后我修改了原始对象c1。然后结果如你所见，c1不同于c2，对c1所做的任何修改都不会影响c2。</li>
<li>注意，序列化这种方式有其自身的限制和问题：因为无法序列化transient变量, 使用这种方法将无法拷贝transient变量。再就是性能问题。创建一个socket, 序列化一个对象, 通过socket传输它, 然后反序列化它，这个过程与调用已有对象的方法相比是很慢的。所以在性能上会有天壤之别。如果性能对你的代码来说是至关重要的，建议不要使用这种方式。它比通过实现Clonable接口这种方式来进行深拷贝几乎多花100倍的时间。</li>
</ul>
</li>
</ul>
<h4 id="延迟拷贝"><a href="#延迟拷贝" class="headerlink" title="延迟拷贝"></a>延迟拷贝</h4><ul>
<li>延迟拷贝是浅拷贝和深拷贝的一个组合，实际上很少会使用。这个以前几乎都没听说过，后来看书才知道有这么一种拷贝！</li>
<li>当最开始拷贝一个对象时，会使用速度较快的浅拷贝，还会使用一个计数器来记录有多少对象共享这个数据。当程序想要修改原始的对象时，它会决定数据是否被共享（通过检查计数器）并根据需要进行深拷贝。</li>
<li>延迟拷贝从外面看起来就是深拷贝，但是只要有可能它就会利用浅拷贝的速度。当原始对象中的引用不经常改变的时候可以使用延迟拷贝。由于存在计数器，效率下降很高，但只是常量级的开销。而且, 在某些情况下, 循环引用会导致一些问题。</li>
</ul>
<h4 id="如何选择拷贝方式"><a href="#如何选择拷贝方式" class="headerlink" title="如何选择拷贝方式"></a>如何选择拷贝方式</h4><ul>
<li>如果对象的属性全是基本类型的，那么可以使用浅拷贝。</li>
<li>如果对象有引用属性，那就要基于具体的需求来选择浅拷贝还是深拷贝。</li>
<li>意思是如果对象引用任何时候都不会被改变，那么没必要使用深拷贝，只需要使用浅拷贝就行了。如果对象引用经常改变，那么就要使用深拷贝。没有一成不变的规则，一切都取决于具体需求。</li>
</ul>
<h4 id="数组的拷贝"><a href="#数组的拷贝" class="headerlink" title="数组的拷贝"></a>数组的拷贝</h4><ul>
<li>数组除了默认实现了clone()方法之外，还提供了Arrays.copyOf方法用于拷贝，这两者都是浅拷贝。</li>
</ul>
<h5 id="基本数据类型数组"><a href="#基本数据类型数组" class="headerlink" title="基本数据类型数组"></a>基本数据类型数组</h5><p>如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] lNumbers1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span>[] rNumbers1 = Arrays.copyOf(lNumbers1, lNumbers1.length);</span><br><span class="line">    rNumbers1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> first = lNumbers1[<span class="number">0</span>] == rNumbers1[<span class="number">0</span>];</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"lNumbers2[0]="</span> + lNumbers1[<span class="number">0</span>] + <span class="string">",rNumbers2[0]="</span> + rNumbers1[<span class="number">0</span>]+<span class="string">"---"</span>+first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] lNumbers3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span>[] rNumbers3 = lNumbers3.clone();</span><br><span class="line">    rNumbers3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> second = lNumbers3[<span class="number">0</span>] == rNumbers3[<span class="number">0</span>];</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"lNumbers3[0]="</span> + lNumbers3[<span class="number">0</span>] + <span class="string">",rNumbers3[0]="</span> + rNumbers3[<span class="number">0</span>]+<span class="string">"---"</span>+second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">09.907</span> <span class="number">30316</span>-<span class="number">30316</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers2[<span class="number">0</span>]=<span class="number">0</span>,rNumbers2[<span class="number">0</span>]=<span class="number">1</span>---<span class="keyword">false</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">09.907</span> <span class="number">30316</span>-<span class="number">30316</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers3[<span class="number">0</span>]=<span class="number">0</span>,rNumbers3[<span class="number">0</span>]=<span class="number">1</span>---<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h4 id="引用数据类型数组"><a href="#引用数据类型数组" class="headerlink" title="引用数据类型数组"></a>引用数据类型数组</h4><p>如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    People[] lNumbers1 = <span class="keyword">new</span> People[<span class="number">5</span>];</span><br><span class="line">    lNumbers1[<span class="number">0</span>] = <span class="keyword">new</span> People();</span><br><span class="line">    People[] rNumbers1 = lNumbers1;</span><br><span class="line">    <span class="keyword">boolean</span> first = lNumbers1[<span class="number">0</span>].equals(rNumbers1[<span class="number">0</span>]);</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"lNumbers1[0]="</span> + lNumbers1[<span class="number">0</span>] + <span class="string">",rNumbers1[0]="</span> + rNumbers1[<span class="number">0</span>]+<span class="string">"--"</span>+first);</span><br><span class="line"></span><br><span class="line">    People[] lNumbers2 = <span class="keyword">new</span> People[<span class="number">5</span>];</span><br><span class="line">    lNumbers2[<span class="number">0</span>] = <span class="keyword">new</span> People();</span><br><span class="line">    People[] rNumbers2 = Arrays.copyOf(lNumbers2, lNumbers2.length);</span><br><span class="line">    <span class="keyword">boolean</span> second = lNumbers2[<span class="number">0</span>].equals(rNumbers2[<span class="number">0</span>]);</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"lNumbers2[0]="</span> + lNumbers2[<span class="number">0</span>] + <span class="string">",rNumbers2[0]="</span> + rNumbers2[<span class="number">0</span>]+<span class="string">"--"</span>+second);</span><br><span class="line"></span><br><span class="line">    People[] lNumbers3 = <span class="keyword">new</span> People[<span class="number">5</span>];</span><br><span class="line">    lNumbers3[<span class="number">0</span>] = <span class="keyword">new</span> People();</span><br><span class="line">    People[] rNumbers3 = lNumbers3.clone();</span><br><span class="line">    <span class="keyword">boolean</span> third = lNumbers3[<span class="number">0</span>].equals(rNumbers3[<span class="number">0</span>]);</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"lNumbers3[0]="</span> + lNumbers3[<span class="number">0</span>] + <span class="string">",rNumbers3[0]="</span> + rNumbers3[<span class="number">0</span>]+<span class="string">"--"</span>+third);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Holder holder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> holderValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">17.054</span> <span class="number">31093</span>-<span class="number">31093</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers1[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People@<span class="number">46</span>a2c18,rNumbers1[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People@<span class="number">46</span>a2c18--<span class="keyword">true</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">17.054</span> <span class="number">31093</span>-<span class="number">31093</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers2[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People<span class="meta">@d</span>344671,rNumbers2[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People<span class="meta">@d</span>344671--<span class="keyword">true</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">03</span>-<span class="number">25</span> <span class="number">14</span>:<span class="number">53</span>:<span class="number">17.054</span> <span class="number">31093</span>-<span class="number">31093</span>/org.yczbj.ycrefreshview D/小杨逗比: lNumbers3[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People@<span class="number">91e9</span>c56,rNumbers3[<span class="number">0</span>]=org.yczbj.ycrefreshview.MainActivity$People@<span class="number">91e9</span>c56--<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h4 id="集合的拷贝"><a href="#集合的拷贝" class="headerlink" title="集合的拷贝"></a>集合的拷贝</h4><ul>
<li>集合的拷贝也是我们平时经常会遇到的，一般情况下，我们都是用浅拷贝来实现，即通过构造函数或者clone方法。</li>
</ul>
<h5 id="集合浅拷贝"><a href="#集合浅拷贝" class="headerlink" title="集合浅拷贝"></a>集合浅拷贝</h5><p>构造函数和 clone() 默认都是浅拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;People&gt; lPeoples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    People people1 = <span class="keyword">new</span> People();</span><br><span class="line">    lPeoples.add(people1);</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"lPeoples[0]="</span> + lPeoples.get(<span class="number">0</span>));</span><br><span class="line">    ArrayList&lt;People&gt; rPeoples = (ArrayList&lt;People&gt;) lPeoples.clone();</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"rPeoples[0]="</span> + rPeoples.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">boolean</span> b = lPeoples.get(<span class="number">0</span>).equals(rPeoples.get(<span class="number">0</span>));</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"比较两个对象"</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Holder holder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            People people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">            people.holder = (People.Holder) <span class="keyword">this</span>.holder.clone();</span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> holderValue;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-03-25 14:56:56.931 31454-31454&#x2F;org.yczbj.ycrefreshview D&#x2F;小杨逗比: lPeoples[0]&#x3D;org.yczbj.ycrefreshview.MainActivity$People@46a2c18</span><br><span class="line">2019-03-25 14:56:56.931 31454-31454&#x2F;org.yczbj.ycrefreshview D&#x2F;小杨逗比: rPeoples[0]&#x3D;org.yczbj.ycrefreshview.MainActivity$People@46a2c18</span><br><span class="line">2019-03-25 14:56:56.931 31454-31454&#x2F;org.yczbj.ycrefreshview D&#x2F;小杨逗比: 比较两个对象true</span><br></pre></td></tr></table></figure>

<h5 id="集合深拷贝"><a href="#集合深拷贝" class="headerlink" title="集合深拷贝"></a>集合深拷贝</h5><p>在某些特殊情况下，如果需要实现集合的深拷贝，那就要创建一个新的集合，然后通过深拷贝原先集合中的每个元素，将这些元素加入到新的集合当中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;People&gt; lPeoples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    People people1 = <span class="keyword">new</span> People();</span><br><span class="line">    people1.holder = <span class="keyword">new</span> People.Holder();</span><br><span class="line">    lPeoples.add(people1);</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"lPeoples[0]="</span> + lPeoples.get(<span class="number">0</span>));</span><br><span class="line">    ArrayList&lt;People&gt; rPeoples = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (People people : lPeoples) &#123;</span><br><span class="line">        rPeoples.add((People) people.clone());</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"rPeoples[0]="</span> + rPeoples.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">boolean</span> b = lPeoples.get(<span class="number">0</span>).equals(rPeoples.get(<span class="number">0</span>));</span><br><span class="line">    Log.d(<span class="string">"小杨逗比"</span>, <span class="string">"比较两个对象"</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    Holder holder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            People people = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">            people.holder = (People.Holder) <span class="keyword">this</span>.holder.clone();</span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> holderValue;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-03-25 15:00:54.610 31670-31670/org.yczbj.ycrefreshview D/小杨逗比: lPeoples[0]=org.yczbj.ycrefreshview.MainActivity$People@46a2c18</span><br><span class="line">2019-03-25 15:00:54.610 31670-31670/org.yczbj.ycrefreshview D/小杨逗比: rPeoples[0]=org.yczbj.ycrefreshview.MainActivity$People@d344671</span><br><span class="line">2019-03-25 15:00:54.610 31670-31670/org.yczbj.ycrefreshview D/小杨逗比: 比较两个对象false</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://juejin.im/post/5c988a7ef265da6116246d11" target="_blank" rel="noopener">https://juejin.im/post/5c988a7ef265da6116246d11</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka设计解析-Kafka High Availability</title>
    <url>/2020/02/28/2020/02/Kafka%E8%AE%BE%E8%AE%A1%E8%A7%A3%E6%9E%90-Kafka%20High%20Availability/</url>
    <content><![CDATA[<h4 id="1-Kafka简介"><a href="#1-Kafka简介" class="headerlink" title="1. Kafka简介"></a>1. Kafka简介</h4><p>Kafka是一种分布式的，基于发布/订阅的消息系统。主要设计目标如下：</p>
<ol>
<li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输</li>
<li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输</li>
<li>同时支持离线数据处理和实时数据处理</li>
<li>Scale out：支持在线水平扩展</li>
</ol>
<h4 id="2-Kafka架构"><a href="#2-Kafka架构" class="headerlink" title="2. Kafka架构"></a>2. Kafka架构</h4><p><strong>Broker</strong>：Kafka集群包含一个或多个服务器，这种服务器被称为broker</p>
<p><strong>Topic</strong>：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>
<p><strong>Partition</strong>：Parition是物理上的概念，每个Topic包含一个或多个Partition.</p>
<p><strong>Producer</strong>：负责发布消息到Kafka broker</p>
<p><strong>Consumer</strong>：消息消费者，向Kafka broker读取消息的客户端。</p>
<p><strong>Consumer Group</strong>：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>
<h4 id="3-Kafka拓扑结构"><a href="#3-Kafka拓扑结构" class="headerlink" title="3. Kafka拓扑结构"></a>3. Kafka拓扑结构</h4><p><img src="http://static.cyblogs.com/KafkaArchitecture.png" alt="http://static.cyblogs.com/KafkaArchitecture.png"></p>
<p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个<a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper</a>集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。 </p>
<h4 id="4-Delivery-Guarantee"><a href="#4-Delivery-Guarantee" class="headerlink" title="4. Delivery Guarantee"></a>4. Delivery Guarantee</h4><p>　　有这么几种可能的delivery guarantee：</p>
<ul>
<li><code>At most once</code> 消息可能会丢，但绝不会重复传输</li>
<li><code>At least one</code> 消息绝不会丢，但可能会重复传输</li>
<li><code>Exactly once</code> 每条消息肯定会被传输一次且仅传输一次，很多时候这是用户所想要的。</li>
</ul>
<h4 id="5-Kafka-HA设计解析"><a href="#5-Kafka-HA设计解析" class="headerlink" title="5. Kafka HA设计解析"></a>5. Kafka HA设计解析</h4><h5 id="5-1-Replica复制算法"><a href="#5-1-Replica复制算法" class="headerlink" title="5.1 Replica复制算法"></a>5.1 Replica复制算法</h5><p>​    为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。一个典型的部署方式是一个Topic的Partition数量大于Broker的数量。同时为了提高Kafka的容错能力，也需要将同一个Partition的Replica尽量分散到不同的机器。实际上，如果所有的Replica都在同一个Broker上，那一旦该Broker宕机，该Partition的所有Replica都无法工作，也就达不到HA的效果。同时，如果某个Broker宕机了，需要保证它上面的负载可以被均匀的分配到其它幸存的所有Broker上。</p>
<ol>
<li>将所有Broker（假设共n个Broker）和待分配的Partition排序</li>
<li>将第i个Partition分配到第（i mod n）个Broker上</li>
<li>将第i个Partition的第j个Replica分配到第（(i + j) mod n）个Broker上</li>
</ol>
<h5 id="5-2-Broker活着的判定"><a href="#5-2-Broker活着的判定" class="headerlink" title="5.2 Broker活着的判定"></a>5.2 Broker活着的判定</h5><p>kafka判定broker是否活着，通过以下2个方式：</p>
<ol>
<li>和zk的session没有断（通过心跳来维系）</li>
<li>follower能及时将leader消息复制过来，不能落后太多（例如默认lag超过4000就会踢出ISR）</li>
</ol>
<h5 id="5-3-所有Replica都不工作的情况"><a href="#5-3-所有Replica都不工作的情况" class="headerlink" title="5.3 所有Replica都不工作的情况"></a>5.3 所有Replica都不工作的情况</h5><p>如果所有副本都出问题，一般有两种选择：</p>
<ol>
<li>等待ISR中的任一个Replica“活”过来，并且选它作为Leader（一致性好，但是可用性差）</li>
<li>选择第一个“活”过来的Replica（不一定是ISR中的）作为Leader（一致性差，但是可用性相比第一种方式好）</li>
</ol>
<h5 id="5-4-Propagate消息"><a href="#5-4-Propagate消息" class="headerlink" title="5.4 Propagate消息"></a>5.4 Propagate消息</h5><p>​        Producer在发布消息到某个Partition时，先通过 Metadata （通过 Broker 获取并且缓存在 Producer 内） 找到该 Partition 的Leader，然后无论该Topic的Replication Factor为多少（也即该Partition有多少个Replica），Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。<br>为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费。但考虑到这种场景非常少见，可以认为这种方式在性能和数据持久化上做了一个比较好的平衡。</p>
<h5 id="5-5-ACK前需要保证有多少个备份"><a href="#5-5-ACK前需要保证有多少个备份" class="headerlink" title="5.5 ACK前需要保证有多少个备份"></a>5.5 ACK前需要保证有多少个备份</h5><p>​        和大部分分布式系统一样，Kafka处理失败需要明确定义一个Broker是否“活着”。对于Kafka而言，Kafka存活包含两个条件，一是它必须维护与Zookeeper的session(这个通过Zookeeper的Heartbeat机制来实现)。二是Follower必须能够及时将Leader的消息复制过来，不能“落后太多”。<br>　　Leader会跟踪与其保持同步的Replica列表，该列表称为ISR（即in-sync Replica）。如果一个Follower宕机，或者落后太多，Leader将把它从ISR中移除。这里所描述的“落后太多”指Follower复制的消息落后于Leader后的条数超过预定值（该值可在$KAFKA_HOME/config/server.properties中通过<code>replica.lag.max.messages</code>配置，其默认值是4000）或者Follower超过一定时间（该值可在$KAFKA_HOME/config/server.properties中通过<code>replica.lag.time.max.ms</code>来配置，其默认值是10000）未向Leader发送fetch请求。。<br>　　Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率（高吞吐率是Kafka非常重要的一个特性）。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下如果Follower都复制完都落后于Leader，而如果Leader突然宕机，则会丢失数据。而Kafka的这种使用ISR的方式则很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，这样极大的提高复制性能（批量写磁盘），极大减少了Follower与Leader的差距。</p>
<h4 id="6-分区Leader选举方法"><a href="#6-分区Leader选举方法" class="headerlink" title="6. 分区Leader选举方法"></a>6. 分区Leader选举方法</h4><p>一般比较容易想到的一个方法是：所有Follower都在Zookeeper上设置一个Watch，一旦Leader宕机，其对应的ephemeral znode会自动删除，此时所有Follower都尝试创建该节点，而创建成功者（Zookeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。</p>
<p>该方法会存在3个问题：</p>
<ol>
<li>split-brain 这是由Zookeeper的特性引起的，虽然Zookeeper能保证所有Watch按顺序触发，但并不能保证同一时刻所有Replica“看”到的状态是一样的，这就可能造成不同Replica的响应不一致</li>
<li>herd effect 如果宕机的那个Broker上的Partition比较多，会造成多个Watch被触发，造成集群内大量的调整</li>
<li>Zookeeper负载过重 每个Replica都要为此在Zookeeper上注册一个Watch，当集群规模增加到几千个Partition时Zookeeper负载会过重。</li>
</ol>
<p>改进的方法——所有broker中选出一个controller，所有Partition的Leader选举都由controller决定。controller会将Leader的改变直接通过RPC的方式（比Zookeeper Queue的方式更高效）通知需为此作出响应的Broker。同时controller也负责增删Topic以及Replica的重新分配。</p>
<h4 id="7-各组件Failover过程"><a href="#7-各组件Failover过程" class="headerlink" title="7. 各组件Failover过程"></a>7. 各组件Failover过程</h4><h5 id="Broker-failover过程"><a href="#Broker-failover过程" class="headerlink" title="Broker failover过程"></a>Broker failover过程</h5><ol>
<li>Controller在Zookeeper注册Watch，一旦有Broker宕机（这是用宕机代表任何让系统认为其die的情景，包括但不限于机器断电，网络不可用，GC导致的Stop The World，进程crash等），其在Zookeeper对应的znode会自动被删除，Zookeeper会fire Controller注册的watch，Controller读取最新的幸存的Broker</li>
<li>Controller决定set_p，该集合包含了宕机的所有Broker上的所有Partition</li>
<li>对set_p中的每一个Partition</li>
</ol>
<p>　　3.1 从/brokers/topics/[topic]/partitions/[partition]/state读取该Partition当前的ISR　　</p>
<p>​        3.2 决定该Partition的新Leader。如果当前ISR中有至少一个Replica还幸存，则选择其中一个作为新Leader，新的ISR则包含当前ISR中所有幸存的Replica。否则选择该Partition中任意一个幸存的Replica作为新的Leader以及ISR（该场景下可能会有潜在的数据丢失）。如果该Partition的所有Replica都宕机了，则将新的Leader设置为-1。　　</p>
<p>3.3 将新的Leader，ISR和新的leader_epoch及controller_epoch写入/brokers/topics/[topic]/partitions/[partition]/state。注意，该操作只有其version在3.1至3.3的过程中无变化时才会执行，否则跳转到3.1</p>
<ol>
<li>直接通过RPC向set_p相关的Broker发送LeaderAndISRRequest命令。Controller可以在一个RPC操作中发送多个命令从而提高效率。</li>
</ol>
<p>　　Broker failover顺序图如下所示。</p>
<p><img src="http://static.cyblogs.com/kafka_broker_failover.png" alt="http://static.cyblogs.com/kafka_broker_failover.png"></p>
<h5 id="Controller-failure过程"><a href="#Controller-failure过程" class="headerlink" title="Controller failure过程"></a>Controller failure过程</h5><ol>
<li>Controller在Zookeeper的<code>/brokers/ids</code>节点上注册Watch。一旦有Broker宕机（本文用宕机代表任何让Kafka认为其Broker die的情景，包括但不限于机器断电，网络不可用，GC导致的Stop The World，进程crash等），其在Zookeeper对应的Znode会自动被删除，Zookeeper会fire Controller注册的Watch，Controller即可获取最新的幸存的Broker列表。</li>
<li>Controller决定set_p，该集合包含了宕机的所有Broker上的所有Partition。</li>
<li>对set_p中的每一个Partition：<br>　　3.1 从<code>/brokers/topics/[topic]/partitions/[partition]/state</code>读取该Partition当前的ISR。<br>   　　3.2 决定该Partition的新Leader。如果当前ISR中有至少一个Replica还幸存，则选择其中一个作为新Leader，新的ISR则包含当前ISR中所有幸存的Replica。否则选择该Partition中任意一个幸存的Replica作为新的Leader以及ISR（该场景下可能会有潜在的数据丢失）。如果该Partition的所有Replica都宕机了，则将新的Leader设置为-1。<br>   　　3.3 将新的Leader，ISR和新的<code>leader_epoch</code>及<code>controller_epoch</code>写入<code>/brokers/topics/[topic]/partitions/[partition]/state</code>。注意，该操作只有Controller版本在3.1至3.3的过程中无变化时才会执行，否则跳转到3.1。</li>
<li>直接通过RPC向set_p相关的Broker发送LeaderAndISRRequest命令。Controller可以在一个RPC操作中发送多个命令从而提高效率。<br>　　Broker failover顺序图如下所示。</li>
</ol>
<p><img src="http://static.cyblogs.com/kafka_broker_failover.png" alt="http://static.cyblogs.com/kafka_broker_failover.png"></p>
<h4 id="Partition重新分配"><a href="#Partition重新分配" class="headerlink" title="Partition重新分配"></a>Partition重新分配</h4><p>管理工具发出重新分配Partition请求后，会将相应信息写到<code>/admin/reassign_partitions</code>上，而该操作会触发ReassignedPartitionsIsrChangeListener，从而通过执行回调函数KafkaController.onPartitionReassignment来完成以下操作：</p>
<ol>
<li>将Zookeeper中的AR（Current Assigned Replicas）更新为OAR（Original list of replicas for partition） + RAR（Reassigned replicas）。</li>
<li>强制更新Zookeeper中的leader epoch，向AR中的每个Replica发送LeaderAndIsrRequest。</li>
<li>将RAR - OAR中的Replica设置为NewReplica状态。</li>
<li>等待直到RAR中所有的Replica都与其Leader同步。</li>
<li>将RAR中所有的Replica都设置为OnlineReplica状态。</li>
<li>将Cache中的AR设置为RAR。</li>
<li>若Leader不在RAR中，则从RAR中重新选举出一个新的Leader并发送LeaderAndIsrRequest。若新的Leader不是从RAR中选举而出，则还要增加Zookeeper中的leader epoch。</li>
<li>将OAR - RAR中的所有Replica设置为OfflineReplica状态，该过程包含两部分。第一，将Zookeeper上ISR中的OAR - RAR移除并向Leader发送LeaderAndIsrRequest从而通知这些Replica已经从ISR中移除；第二，向OAR - RAR中的Replica发送StopReplicaRequest从而停止不再分配给该Partition的Replica。</li>
<li>将OAR - RAR中的所有Replica设置为NonExistentReplica状态从而将其从磁盘上删除。</li>
<li>将Zookeeper中的AR设置为RAR。</li>
<li>删除<code>/admin/reassign_partition</code>。</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="http://www.jasongj.com/2015/04/24/KafkaColumn2/" target="_blank" rel="noopener">http://www.jasongj.com/2015/04/24/KafkaColumn2/</a></li>
<li><a href="http://www.jasongj.com/2015/06/08/KafkaColumn3/" target="_blank" rel="noopener">http://www.jasongj.com/2015/06/08/KafkaColumn3/</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Refresh方法到底干了啥？</title>
    <url>/2020/02/28/2020/02/Refresh%E6%96%B9%E6%B3%95%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<p>作者：吃饭睡觉撸代码</p>
<p>来源：<a href="https://fangjian0423.github.io/2017/05/10/springboot-context-refresh/" target="_blank" rel="noopener">https://fangjian0423.github.io/2017/05/10/springboot-context-refresh/</a></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Spring容器创建之后，会调用它的refresh方法，refresh的时候会做很多事情：比如完成配置类的解析、各种BeanFactoryPostProcessor和BeanPostProcessor的注册、国际化配置的初始化、web内置容器的构造等等。</p>
<p>我们来分析一下这个refresh过程。</p>
<p>还是以web程序为例，那么对应的Spring容器为AnnotationConfigEmbeddedWebApplicationContext。它的refresh方法调用了父类AbstractApplicationContext的refresh方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="comment">// refresh过程只能一个线程处理，不允许并发执行</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    prepareRefresh();</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line">      initMessageSource();</span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line">      onRefresh();</span><br><span class="line">      registerListeners();</span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">            <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prepareRefresh方法"><a href="#prepareRefresh方法" class="headerlink" title="prepareRefresh方法"></a>prepareRefresh方法</h4><p>表示在真正做refresh操作之前需要准备做的事情：</p>
<ol>
<li>设置Spring容器的启动时间，撤销关闭状态，开启活跃状态。</li>
<li>初始化属性源信息(Property)</li>
<li>验证环境信息里一些必须存在的属性</li>
</ol>
<h4 id="prepareBeanFactory方法"><a href="#prepareBeanFactory方法" class="headerlink" title="prepareBeanFactory方法"></a>prepareBeanFactory方法</h4><p>从Spring容器获取BeanFactory(Spring Bean容器)并进行相关的设置为后续的使用做准备：</p>
<ol>
<li>设置classloader(用于加载bean)，设置表达式解析器(解析bean定义中的一些表达式)，添加属性编辑注册器(注册属性编辑器)</li>
<li>添加ApplicationContextAwareProcessor这个BeanPostProcessor。取消ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、EnvironmentAware这5个接口的自动注入。因为ApplicationContextAwareProcessor把这5个接口的实现工作做了</li>
<li>设置特殊的类型对应的bean。BeanFactory对应刚刚获取的BeanFactory；ResourceLoader、ApplicationEventPublisher、ApplicationContext这3个接口对应的bean都设置为当前的Spring容器</li>
<li>注入一些其它信息的bean，比如environment、systemProperties等</li>
</ol>
<h4 id="postProcessBeanFactory方法"><a href="#postProcessBeanFactory方法" class="headerlink" title="postProcessBeanFactory方法"></a>postProcessBeanFactory方法</h4><p>BeanFactory设置之后再进行后续的一些BeanFactory操作。</p>
<p>不同的Spring容器做不同的操作。比如GenericWebApplicationContext容器会在BeanFactory中添加ServletContextAwareProcessor用于处理ServletContextAware类型的bean初始化的时候调用setServletContext或者setServletConfig方法(跟ApplicationContextAwareProcessor原理一样)。</p>
<p>AnnotationConfigEmbeddedWebApplicationContext对应的postProcessBeanFactory方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用父类EmbeddedWebApplicationContext的实现</span></span><br><span class="line">  <span class="keyword">super</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">  <span class="comment">// 查看basePackages属性，如果设置了会使用ClassPathBeanDefinitionScanner去扫描basePackages包下的bean并注册</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.basePackages != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.basePackages.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.scanner.scan(<span class="keyword">this</span>.basePackages);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看annotatedClasses属性，如果设置了会使用AnnotatedBeanDefinitionReader去注册这些bean</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.annotatedClasses != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.annotatedClasses.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.reader.register(<span class="keyword">this</span>.annotatedClasses);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类EmbeddedWebApplicationContext的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  beanFactory.addBeanPostProcessor(</span><br><span class="line">      <span class="keyword">new</span> WebApplicationContextServletContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ServletContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="invokeBeanFactoryPostProcessors方法"><a href="#invokeBeanFactoryPostProcessors方法" class="headerlink" title="invokeBeanFactoryPostProcessors方法"></a>invokeBeanFactoryPostProcessors方法</h4><p>在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。</p>
<p>介绍两个接口：</p>
<ol>
<li>BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理</li>
<li>BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理</li>
</ol>
<p>基于web程序的Spring容器AnnotationConfigEmbeddedWebApplicationContext构造的时候，会初始化内部属性AnnotatedBeanDefinitionReader reader，这个reader构造的时候会在BeanFactory中注册一些post processor，包括BeanPostProcessor和BeanFactoryPostProcessor(比如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure>

<p>invokeBeanFactoryPostProcessors方法处理BeanFactoryPostProcessor的逻辑如下：</p>
<p>从Spring容器中找出BeanDefinitionRegistryPostProcessor类型的bean(这些processor是在容器刚创建的时候通过构造AnnotatedBeanDefinitionReader的时候注册到容器中的)，然后按照优先级分别执行，优先级的逻辑如下：</p>
<ol>
<li>实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor先全部找出来，然后排序后依次执行</li>
<li>实现Ordered接口的BeanDefinitionRegistryPostProcessor找出来，然后排序后依次执行</li>
<li>没有实现PriorityOrdered和Ordered接口的BeanDefinitionRegistryPostProcessor找出来执行并依次执行</li>
</ol>
<p>接下来从Spring容器内查找BeanFactoryPostProcessor接口的实现类，然后执行(如果processor已经执行过，则忽略)，这里的查找规则跟上面查找BeanDefinitionRegistryPostProcessor一样，先找PriorityOrdered，然后是Ordered，最后是两者都没。</p>
<p>这里需要说明的是ConfigurationClassPostProcessor这个processor是优先级最高的被执行的processor(实现了PriorityOrdered接口)。这个ConfigurationClassPostProcessor会去BeanFactory中找出所有有@Configuration注解的bean，然后使用ConfigurationClassParser去解析这个类。ConfigurationClassParser内部有个Map&lt;ConfigurationClass, ConfigurationClass&gt;类型的configurationClasses属性用于保存解析的类，ConfigurationClass是一个对要解析的配置类的封装，内部存储了配置类的注解信息、被@Bean注解修饰的方法、@ImportResource注解修饰的信息、ImportBeanDefinitionRegistrar等都存储在这个封装类中。</p>
<p>这里ConfigurationClassPostProcessor最先被处理还有另外一个原因是如果程序中有自定义的BeanFactoryPostProcessor，那么这个PostProcessor首先得通过ConfigurationClassPostProcessor被解析出来，然后才能被Spring容器找到并执行。(ConfigurationClassPostProcessor不先执行的话，这个Processor是不会被解析的，不会被解析的话也就不会执行了)。</p>
<p>在我们的程序中，只有主类RefreshContextApplication有@Configuration注解(@SpringBootApplication注解带有@Configuration注解)，所以这个配置类会被ConfigurationClassParser解析。解析过程如下：</p>
<ol>
<li>处理@PropertySources注解：进行一些配置信息的解析</li>
<li>处理@ComponentScan注解：使用ComponentScanAnnotationParser扫描basePackage下的需要解析的类(@SpringBootApplication注解也包括了@ComponentScan注解，只不过basePackages是空的，空的话会去获取当前@Configuration修饰的类所在的包)，并注册到BeanFactory中(这个时候bean并没有进行实例化，而是进行了注册。具体的实例化在finishBeanFactoryInitialization方法中执行)。对于扫描出来的类，递归解析</li>
<li>处理@Import注解：先递归找出所有的注解，然后再过滤出只有@Import注解的类，得到@Import注解的值。比如查找@SpringBootApplication注解的@Import注解数据的话，首先发现@SpringBootApplication不是一个@Import注解，然后递归调用修饰了@SpringBootApplication的注解，发现有个@EnableAutoConfiguration注解，再次递归发现被@Import(EnableAutoConfigurationImportSelector.class)修饰，还有@AutoConfigurationPackage注解修饰，再次递归@AutoConfigurationPackage注解，发现被@Import(AutoConfigurationPackages.Registrar.class)注解修饰，所以@SpringBootApplication注解对应的@Import注解有2个，分别是@Import(AutoConfigurationPackages.Registrar.class)和@Import(EnableAutoConfigurationImportSelector.class)。找出所有的@Import注解之后，开始处理逻辑：<ol>
<li>遍历这些@Import注解内部的属性类集合</li>
<li>如果这个类是个ImportSelector接口的实现类，实例化这个ImportSelector，如果这个类也是DeferredImportSelector接口的实现类，那么加入ConfigurationClassParser的deferredImportSelectors属性中让第6步处理。否则调用ImportSelector的selectImports方法得到需要Import的类，然后对这些类递归做@Import注解的处理</li>
<li>如果这个类是ImportBeanDefinitionRegistrar接口的实现类，设置到配置类的importBeanDefinitionRegistrars属性中</li>
<li>其它情况下把这个类入队到ConfigurationClassParser的importStack(队列)属性中，然后把这个类当成是@Configuration注解修饰的类递归重头开始解析这个类</li>
</ol>
</li>
<li>处理@ImportResource注解：获取@ImportResource注解的locations属性，得到资源文件的地址信息。然后遍历这些资源文件并把它们添加到配置类的importedResources属性中</li>
<li>处理@Bean注解：获取被@Bean注解修饰的方法，然后添加到配置类的beanMethods属性中</li>
<li>处理DeferredImportSelector：处理第3步@Import注解产生的DeferredImportSelector，进行selectImports方法的调用找出需要import的类，然后再调用第3步相同的处理逻辑处理</li>
</ol>
<p>这里@SpringBootApplication注解被@EnableAutoConfiguration修饰，@EnableAutoConfiguration注解被@Import(EnableAutoConfigurationImportSelector.class)修饰，所以在第3步会找出这个@Import修饰的类EnableAutoConfigurationImportSelector，这个类刚好实现了DeferredImportSelector接口，接着就会在第6步被执行。第6步selectImport得到的类就是自动化配置类。</p>
<p>EnableAutoConfigurationImportSelector的selectImport方法会在spring.factories文件中找出key为EnableAutoConfiguration对应的值，有81个，这81个就是所谓的自动化配置类(XXXAutoConfiguration)。</p>
<p>ConfigurationClassParser解析完成之后，被解析出来的类会放到configurationClasses属性中。然后使用ConfigurationClassBeanDefinitionReader去解析这些类。</p>
<p>这个时候这些bean只是被加载到了Spring容器中。下面这段代码是ConfigurationClassBeanDefinitionReader的解析bean过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</span><br><span class="line">  TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</span><br><span class="line">  <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">    <span class="comment">// 对每一个配置类，调用loadBeanDefinitionsForConfigurationClass方法</span></span><br><span class="line">    loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(ConfigurationClass configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用条件注解判断是否需要跳过这个配置类</span></span><br><span class="line">  <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">    <span class="comment">// 跳过配置类的话在Spring容器中移除bean的注册</span></span><br><span class="line">    String beanName = configClass.getBeanName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.importRegistry.removeImportingClassFor(configClass.getMetadata().getClassName());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">    <span class="comment">// 如果自身是被@Import注释所import的，注册自己</span></span><br><span class="line">    registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册方法中被@Bean注解修饰的bean</span></span><br><span class="line">  <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">    loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册@ImportResource注解注释的资源文件中的bean</span></span><br><span class="line">  loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">  <span class="comment">// 注册@Import注解中的ImportBeanDefinitionRegistrar接口的registerBeanDefinitions</span></span><br><span class="line">  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeBeanFactoryPostProcessors方法总结来说就是从Spring容器中找出BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor接口的实现类并按照一定的规则顺序进行执行。 其中ConfigurationClassPostProcessor这个BeanDefinitionRegistryPostProcessor优先级最高，它会对项目中的@Configuration注解修饰的类(@Component、@ComponentScan、@Import、@ImportResource修饰的类也会被处理)进行解析，解析完成之后把这些bean注册到BeanFactory中。需要注意的是这个时候注册进来的bean还没有实例化。</p>
<p>下面这图就是对ConfigurationClassPostProcessor后置器的总结：</p>
<p><a href="https://raw.githubusercontent.com/fangjian0423/blogimages/master/images/configuration-annotation-process.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/fangjian0423/blogimages/master/images/configuration-annotation-process.png" alt="img"></a></p>
<h4 id="registerBeanPostProcessors方法"><a href="#registerBeanPostProcessors方法" class="headerlink" title="registerBeanPostProcessors方法"></a>registerBeanPostProcessors方法</h4><p>从Spring容器中找出的BeanPostProcessor接口的bean，并设置到BeanFactory的属性中。之后bean被实例化的时候会调用这个BeanPostProcessor。</p>
<p>该方法委托给了PostProcessorRegistrationDelegate类的registerBeanPostProcessors方法执行。这里的过程跟invokeBeanFactoryPostProcessors类似：</p>
<ol>
<li>先找出实现了PriorityOrdered接口的BeanPostProcessor并排序后加到BeanFactory的BeanPostProcessor集合中</li>
<li>找出实现了Ordered接口的BeanPostProcessor并排序后加到BeanFactory的BeanPostProcessor集合中</li>
<li>没有实现PriorityOrdered和Ordered接口的BeanPostProcessor加到BeanFactory的BeanPostProcessor集合中</li>
</ol>
<p>这些已经存在的BeanPostProcessor在postProcessBeanFactory方法中已经说明，都是由AnnotationConfigUtils的registerAnnotationConfigProcessors方法注册的。这些BeanPostProcessor包括有AutowiredAnnotationBeanPostProcessor(处理被@Autowired注解修饰的bean并注入)、RequiredAnnotationBeanPostProcessor(处理被@Required注解修饰的方法)、CommonAnnotationBeanPostProcessor(处理@PreDestroy、@PostConstruct、@Resource等多个注解的作用)等。</p>
<p>如果是自定义的BeanPostProcessor，已经被ConfigurationClassPostProcessor注册到容器内。</p>
<p>这些BeanPostProcessor会在这个方法内被实例化(通过调用BeanFactory的getBean方法，如果没有找到实例化的类，就会去实例化)。</p>
<h4 id="initMessageSource方法"><a href="#initMessageSource方法" class="headerlink" title="initMessageSource方法"></a>initMessageSource方法</h4><p>在Spring容器中初始化一些国际化相关的属性。</p>
<h4 id="initApplicationEventMulticaster方法"><a href="#initApplicationEventMulticaster方法" class="headerlink" title="initApplicationEventMulticaster方法"></a>initApplicationEventMulticaster方法</h4><p>在Spring容器中初始化事件广播器，事件广播器用于事件的发布。</p>
<p>在<a href="http://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/" target="_blank" rel="noopener">SpringBoot源码分析之SpringBoot的启动过程</a>中分析过，EventPublishingRunListener这个SpringApplicationRunListener会监听事件，其中发生contextPrepared事件的时候EventPublishingRunListener会把事件广播器注入到BeanFactory中。</p>
<p>所以initApplicationEventMulticaster不再需要再次注册，只需要拿出BeanFactory中的事件广播器然后设置到Spring容器的属性中即可。如果没有使用SpringBoot的话，Spring容器得需要自己初始化事件广播器。</p>
<h4 id="onRefresh方法"><a href="#onRefresh方法" class="headerlink" title="onRefresh方法"></a>onRefresh方法</h4><p>一个模板方法，不同的Spring容器做不同的事情。</p>
<p>比如web程序的容器AnnotationConfigEmbeddedWebApplicationContext中会调用createEmbeddedServletContainer方法去创建内置的Servlet容器。</p>
<p>目前SpringBoot只支持3种内置的Servlet容器：</p>
<ol>
<li>Tomcat</li>
<li>Jetty</li>
<li>Undertow</li>
</ol>
<h4 id="registerListeners方法"><a href="#registerListeners方法" class="headerlink" title="registerListeners方法"></a>registerListeners方法</h4><p>把Spring容器内的时间监听器和BeanFactory中的时间监听器都添加的事件广播器中。</p>
<p>然后如果存在early event的话，广播出去。</p>
<h4 id="finishBeanFactoryInitialization方法"><a href="#finishBeanFactoryInitialization方法" class="headerlink" title="finishBeanFactoryInitialization方法"></a>finishBeanFactoryInitialization方法</h4><p>实例化BeanFactory中已经被注册但是未实例化的所有实例(懒加载的不需要实例化)。</p>
<p>比如invokeBeanFactoryPostProcessors方法中根据各种注解解析出来的类，在这个时候都会被初始化。</p>
<p>实例化的过程各种BeanPostProcessor开始起作用。</p>
<h4 id="finishRefresh方法"><a href="#finishRefresh方法" class="headerlink" title="finishRefresh方法"></a>finishRefresh方法</h4><p>refresh做完之后需要做的其他事情。</p>
<ol>
<li>初始化生命周期处理器，并设置到Spring容器中(LifecycleProcessor)</li>
<li>调用生命周期处理器的onRefresh方法，这个方法会找出Spring容器中实现了SmartLifecycle接口的类并进行start方法的调用</li>
<li>发布ContextRefreshedEvent事件告知对应的ApplicationListener进行响应的操作</li>
<li>调用LiveBeansView的registerApplicationContext方法：如果设置了JMX相关的属性，则就调用该方法</li>
<li>发布EmbeddedServletContainerInitializedEvent事件告知对应的ApplicationListener进行响应的操作</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Spring容器的refresh过程就是上述11个方法的介绍。内容还是非常多的，本文也只是说了个大概，像bean的实例化过程没有具体去分析，这方面的内容以后会看情况去做分析。</p>
<p>这篇文章也是为之后的文章比如内置Servlet容器的创建启动、条件注解的使用等打下基础。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty 系列之 Netty 高性能之道</title>
    <url>/2020/02/28/2020/02/Netty%20%E7%B3%BB%E5%88%97%E4%B9%8B%20Netty%20%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-惊人的性能数据"><a href="#1-1-惊人的性能数据" class="headerlink" title="1.1. 惊人的性能数据"></a>1.1. 惊人的性能数据</h3><p>最近一个圈内朋友通过私信告诉我，通过使用 Netty4 + Thrift 压缩二进制编解码技术，他们实现了 10W TPS（1K 的复杂 POJO 对象）的跨节点远程服务调用。相比于传统基于 Java 序列化 +BIO（同步阻塞 IO）的通信框架，性能提升了 8 倍多。</p>
<p>事实上，我对这个数据并不感到惊讶，根据我 5 年多的 NIO 编程经验，通过选择合适的 NIO 框架，加上高性能的压缩二进制编解码技术，精心的设计 Reactor 线程模型，达到上述性能指标是完全有可能的。</p>
<p>下面我们就一起来看下 Netty 是如何支持 10W TPS 的跨节点远程服务调用的，在正式开始讲解之前，我们先简单介绍下 Netty。</p>
<h3 id="1-2-Netty-基础入门"><a href="#1-2-Netty-基础入门" class="headerlink" title="1.2. Netty 基础入门"></a>1.2. Netty 基础入门</h3><p>Netty 是一个高性能、异步事件驱动的 NIO 框架，它提供了对 TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的，通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。</p>
<p>作为当前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于 Netty 的 NIO 框架构建。</p>
<h2 id="2-Netty-高性能之道"><a href="#2-Netty-高性能之道" class="headerlink" title="2. Netty 高性能之道"></a>2. Netty 高性能之道</h2><h3 id="2-1-RPC-调用的性能模型分析"><a href="#2-1-RPC-调用的性能模型分析" class="headerlink" title="2.1. RPC 调用的性能模型分析"></a>2.1. RPC 调用的性能模型分析</h3><h4 id="2-1-1-传统-RPC-调用性能差的三宗罪"><a href="#2-1-1-传统-RPC-调用性能差的三宗罪" class="headerlink" title="2.1.1. 传统 RPC 调用性能差的三宗罪"></a><strong>2.1.1.</strong> 传统 RPC 调用性能差的三宗罪</h4><p>网络传输方式问题：传统的 RPC 框架或者基于 RMI 等方式的远程服务（过程）调用采用了同步阻塞 IO，当客户端的并发压力或者网络时延增大之后，同步阻塞 IO 会由于频繁的 wait 导致 IO 线程经常性的阻塞，由于线程无法高效的工作，IO 处理能力自然下降。</p>
<p>下面，我们通过 BIO 通信模型图看下 BIO 通信的弊端：</p>
<p><img src="http://static.cyblogs.com/8ca1bcf701494b7fe2751cf65686f6b0.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-1 BIO 通信模型图</p>
<p>采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，接收到客户端连接之后为客户端连接创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。该架构最大的问题就是不具备弹性伸缩能力，当并发访问量增加后，服务端的线程个数和并发访问数成线性正比，由于线程是 JAVA 虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能急剧下降，随着并发量的继续增加，可能会发生句柄溢出、线程堆栈溢出等问题，并导致服务器最终宕机。</p>
<p>序列化方式问题：Java 序列化存在如下几个典型问题：</p>
<p>1) Java 序列化机制是 Java 内部的一种对象编解码技术，无法跨语言使用；例如对于异构系统之间的对接，Java 序列化后的码流需要能够通过其它语言反序列化成原始对象（副本），目前很难支持；</p>
<p>2) 相比于其它开源的序列化框架，Java 序列化后的码流太大，无论是网络传输还是持久化到磁盘，都会导致额外的资源占用；</p>
<p>3) 序列化性能差（CPU 资源占用高）。</p>
<p>线程模型问题：由于采用同步阻塞 IO，这会导致每个 TCP 连接都占用 1 个线程，由于线程资源是 JVM 虚拟机非常宝贵的资源，当 IO 读写阻塞导致线程无法及时释放时，会导致系统性能急剧下降，严重的甚至会导致虚拟机无法创建新的线程。</p>
<h4 id="2-1-2-高性能的三个主题"><a href="#2-1-2-高性能的三个主题" class="headerlink" title="2.1.2. 高性能的三个主题"></a>2.1.2. 高性能的三个主题</h4><p>1) 传输：用什么样的通道将数据发送给对方，BIO、NIO 或者 AIO，IO 模型在很大程度上决定了框架的性能。</p>
<p>2) 协议：采用什么样的通信协议，HTTP 或者内部私有协议。协议的选择不同，性能模型也不同。相比于公有协议，内部私有协议的性能通常可以被设计的更优。</p>
<p>3) 线程：数据报如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，Reactor 线程模型的不同，对性能的影响也非常大。</p>
<p><img src="http://static.cyblogs.com/ca8d3401818a753f5e4db89f5ccf208b.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-2 RPC 调用性能三要素</p>
<h3 id="2-2-Netty-高性能之道"><a href="#2-2-Netty-高性能之道" class="headerlink" title="2.2. Netty 高性能之道"></a>2.2. Netty 高性能之道</h3><h4 id="2-2-1-异步非阻塞通信"><a href="#2-2-1-异步非阻塞通信" class="headerlink" title="2.2.1. 异步非阻塞通信"></a>2.2.1. 异步非阻塞通信</h4><p>在 IO 编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者 IO 多路复用技术进行处理。IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程 / 多进程模型比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。</p>
<p>JDK1.4 提供了对非阻塞 IO（NIO）的支持，JDK1.5_update10 版本使用 epoll 替代了传统的 select/poll，极大的提升了 NIO 通信的性能。</p>
<p>JDK NIO 通信模型如下所示：</p>
<p><img src="http://static.cyblogs.com/cd19b81ba8b3ce114cc8346f877c8d36.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-3 NIO 的多路复用模型图</p>
<p>与 Socket 类和 ServerSocket 类相对应，NIO 也提供了 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现。这两种新增的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单，但是性能和可靠性都不好，非阻塞模式正好相反。开发人员一般可以根据自己的需要来选择合适的模式，一般来说，低负载、低并发的应用程序可以选择同步阻塞 IO 以降低编程复杂度。但是对于高负载、高并发的网络应用，需要使用 NIO 的非阻塞模式进行开发。</p>
<p>Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下：</p>
<p><img src="http://static.cyblogs.com/f93b86a561ec3b494e021251b1cd2997.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-3 NIO 服务端通信序列图</p>
<p>客户端通信序列图如下：</p>
<p><img src="http://static.cyblogs.com/38d04bb5c140733668fccdd7a2e63955.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-4 NIO 客户端通信序列图</p>
<p>Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。另外，由于 Netty 采用了异步通信模式，一个 IO 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>
<h4 id="2-2-2-零拷贝"><a href="#2-2-2-零拷贝" class="headerlink" title="2.2.2. 零拷贝"></a>2.2.2. 零拷贝</h4><p>很多用户都听说过 Netty 具有“零拷贝”功能，但是具体体现在哪里又说不清楚，本小节就详细对 Netty 的“零拷贝”功能进行讲解。</p>
<p>Netty 的“零拷贝”主要体现在如下三个方面：</p>
<p>1) Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p>
<p>2) Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</p>
<p>3) Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p>
<p>下面，我们对上述三种“零拷贝”进行说明，先看 Netty 接收 Buffer 的创建：</p>
<p><img src="http://static.cyblogs.com/d8a16823a5388d5294854b56e924c6a9.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-5 异步消息读取“零拷贝”</p>
<p>每循环读取一次消息，就通过 ByteBufAllocator 的 ioBuffer 方法获取 ByteBuf 对象，下面继续看它的接口定义：</p>
<p><img src="http://static.cyblogs.com/02bad615aad4f63a9c320a2cd1a48c56.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-6 ByteBufAllocator 通过 ioBuffer 分配堆外内存</p>
<p>当进行 Socket IO 读写的时候，为了避免从堆内存拷贝一份副本到直接内存，Netty 的 ByteBuf 分配器直接创建非堆内存避免缓冲区的二次拷贝，通过“零拷贝”来提升读写性能。</p>
<p>下面我们继续看第二种“零拷贝”的实现 CompositeByteBuf，它对外将多个 ByteBuf 封装成一个 ByteBuf，对外提供统一封装后的 ByteBuf 接口，它的类定义如下：</p>
<p><img src="http://static.cyblogs.com/2d1991a4e16f7e80228ea2631e867ad0.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-7 CompositeByteBuf 类继承关系</p>
<p>通过继承关系我们可以看出 CompositeByteBuf 实际就是个 ByteBuf 的包装器，它将多个 ByteBuf 组合成一个集合，然后对外提供统一的 ByteBuf 接口，相关定义如下：</p>
<p><img src="http://static.cyblogs.com/06a1cd492e7c498b05fe1425f497cefe.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-8 CompositeByteBuf 类定义</p>
<p>添加 ByteBuf，不需要做内存拷贝，相关代码如下：</p>
<p><img src="http://static.cyblogs.com/bf2a7f95922a4d60c595619f83219a4e.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-9 新增 ByteBuf 的“零拷贝”</p>
<p>最后，我们看下文件传输的“零拷贝”：</p>
<p><img src="http://static.cyblogs.com/9be2e987db0dda83da570c667d927047.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-10 文件传输“零拷贝”</p>
<p>Netty 文件传输 DefaultFileRegion 通过 transferTo 方法将文件发送到目标 Channel 中，下面重点看 FileChannel 的 transferTo 方法，它的 API DOC 说明如下：</p>
<p><img src="http://static.cyblogs.com/4efc573ec343f5ae4947aa5d729294c3.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-11 文件传输 “零拷贝”</p>
<p>对于很多操作系统它直接将文件缓冲区的内容发送到目标 Channel 中，而不需要通过拷贝的方式，这是一种更加高效的传输方式，它实现了文件传输的“零拷贝”。</p>
<h4 id="2-2-3-内存池"><a href="#2-2-3-内存池" class="headerlink" title="2.2.3. 内存池"></a>2.2.3. 内存池</h4><p>随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区 Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty 提供了基于内存池的缓冲区重用机制。下面我们一起看下 Netty ByteBuf 的实现：</p>
<p><img src="http://static.cyblogs.com/0d9692e17bb3043beb02d33dbecac08c.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-12 内存池 ByteBuf</p>
<p>Netty 提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。</p>
<p>下面通过性能测试，我们看下基于内存池循环利用的 ByteBuf 和普通 ByteBuf 的性能差异。</p>
<p>用例一，使用内存池分配器创建直接内存缓冲区：</p>
<p><img src="http://static.cyblogs.com/8507ccdefc46002a1ad0b4ead8d7a0cd.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-13 基于内存池的非堆内存缓冲区测试用例</p>
<p>用例二，使用非堆内存分配器创建的直接内存缓冲区：</p>
<p><img src="http://static.cyblogs.com/c65837b68656af7d15f18bbca2768e06.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-14 基于非内存池创建的非堆内存缓冲区测试用例</p>
<p>各执行 300 万次，性能对比结果如下所示：</p>
<p><img src="http://static.cyblogs.com/b5851489d3fb28a6e323d839abbc89ec.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-15 内存池和非内存池缓冲区写入性能对比</p>
<p>性能测试表明，采用内存池的 ByteBuf 相比于朝生夕灭的 ByteBuf，性能高 23 倍左右（性能数据与使用场景强相关）。</p>
<p>下面我们一起简单分析下 Netty 内存池的内存分配：</p>
<p><img src="http://static.cyblogs.com/ce56ef417f28d249fa7cc9a639693302.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-16 AbstractByteBufAllocator 的缓冲区分配</p>
<p>继续看 newDirectBuffer 方法，我们发现它是一个抽象方法，由 AbstractByteBufAllocator 的子类负责具体实现，代码如下：</p>
<p><img src="http://static.cyblogs.com/030cc27df48180894970645a7fa2f25f.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-17 newDirectBuffer 的不同实现</p>
<p>代码跳转到 PooledByteBufAllocator 的 newDirectBuffer 方法，从 Cache 中获取内存区域 PoolArena，调用它的 allocate 方法进行内存分配：</p>
<p><img src="http://static.cyblogs.com/fc924c121fcfe8db907cc4cb7355225e.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-18 PooledByteBufAllocator 的内存分配</p>
<p>PoolArena 的 allocate 方法如下：</p>
<p><img src="http://static.cyblogs.com/d83ac0ed80161b86c8aaf5d0f742157f.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-18 PoolArena 的缓冲区分配</p>
<p>我们重点分析 newByteBuf 的实现，它同样是个抽象方法，由子类 DirectArena 和 HeapArena 来实现不同类型的缓冲区分配，由于测试用例使用的是堆外内存，</p>
<p><img src="http://static.cyblogs.com/95c123255dbe919bdf44ee9fbcaa37fa.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-19 PoolArena 的 newByteBuf 抽象方法</p>
<p>因此重点分析 DirectArena 的实现：如果没有开启使用 sun 的 unsafe，则</p>
<p><img src="http://static.cyblogs.com/2a86bca51226e567d0c7e13a5ab7a3fa.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-20 DirectArena 的 newByteBuf 方法实现</p>
<p>执行 PooledDirectByteBuf 的 newInstance 方法，代码如下：</p>
<p><img src="http://static.cyblogs.com/f5580a2110cefcb8a6206080de95329b.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-21 PooledDirectByteBuf 的 newInstance 方法实现</p>
<p>通过 RECYCLER 的 get 方法循环使用 ByteBuf 对象，如果是非内存池实现，则直接创建一个新的 ByteBuf 对象。从缓冲池中获取 ByteBuf 之后，调用 AbstractReferenceCountedByteBuf 的 setRefCnt 方法设置引用计数器，用于对象的引用计数和内存回收（类似 JVM 垃圾回收机制）。</p>
<h4 id="2-2-4-高效的-Reactor-线程模型"><a href="#2-2-4-高效的-Reactor-线程模型" class="headerlink" title="2.2.4. 高效的 Reactor 线程模型"></a>2.2.4. 高效的 Reactor 线程模型</h4><p>常用的 Reactor 线程模型有三种，分别如下：</p>
<p>1) Reactor 单线程模型；</p>
<p>2) Reactor 多线程模型；</p>
<p>3) 主从 Reactor 多线程模型</p>
<p>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下：</p>
<p>1) 作为 NIO 服务端，接收客户端的 TCP 连接；</p>
<p>2) 作为 NIO 客户端，向服务端发起 TCP 连接；</p>
<p>3) 读取通信对端的请求或者应答消息；</p>
<p>4) 向通信对端发送消息请求或者应答消息。</p>
<p>Reactor 单线程模型示意图如下所示：</p>
<p><img src="http://static.cyblogs.com/c9540842e8aa5c39a5c81633fcce4e50.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-22 Reactor 单线程模型</p>
<p>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过 Acceptor 接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer 派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。</p>
<p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用却不合适，主要原因如下：</p>
<p>1) 一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，即便 NIO 线程的 CPU 负荷达到 100%，也无法满足海量消息的编码、解码、读取和发送；</p>
<p>2) 当 NIO 线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了 NIO 线程的负载，最终会导致大量消息积压和处理超时，NIO 线程会成为系统的性能瓶颈；</p>
<p>3) 可靠性问题：一旦 NIO 线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</p>
<p>为了解决这些问题，演进出了 Reactor 多线程模型，下面我们一起学习下 Reactor 多线程模型。</p>
<p>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作，它的原理图如下：</p>
<p><img src="http://static.cyblogs.com/db6a1485171d0dcf2647ebe679641830.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-23 Reactor 多线程模型</p>
<p>Reactor 多线程模型的特点：</p>
<p>1) 有专门一个 NIO 线程 -Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求；</p>
<p>2) 网络 IO 操作 - 读、写等由一个 NIO 线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N 个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；</p>
<p>3) 1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，防止发生并发操作问题。</p>
<p>在绝大多数场景下，Reactor 多线程模型都可以满足性能需求；但是，在极特殊应用场景中，一个 NIO 线程负责监听和处理所有的客户端连接可能会存在性能问题。例如百万客户端并发连接，或者服务端需要对客户端的握手消息进行安全认证，认证本身非常损耗性能。在这类场景下，单独一个 Acceptor 线程可能会存在性能不足问题，为了解决性能问题，产生了第三种 Reactor 线程模型 - 主从 Reactor 多线程模型。</p>
<p>主从 Reactor 线程模型的特点是：服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的 SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责 SocketChannel 的读写和编解码工作。Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。</p>
<p>它的线程模型如下图所示：</p>
<p><img src="http://static.cyblogs.com/13edd43992b0bc2c6f30ba7ac3eec7b3.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-24 Reactor 主从多线程模型</p>
<p>利用主从 NIO 线程模型，可以解决 1 个服务端监听线程无法有效处理所有客户端连接的性能不足问题。因此，在 Netty 的官方 demo 中，推荐使用该线程模型。</p>
<p>事实上，Netty 的线程模型并非固定不变，通过在启动辅助类中创建不同的 EventLoopGroup 实例并通过适当的参数配置，就可以支持上述三种 Reactor 线程模型。正是因为 Netty 对 Reactor 线程模型的支持提供了灵活的定制能力，所以可以满足不同业务场景的性能诉求。</p>
<h4 id="2-2-5-无锁化的串行设计理念"><a href="#2-2-5-无锁化的串行设计理念" class="headerlink" title="2.2.5. 无锁化的串行设计理念"></a>2.2.5. 无锁化的串行设计理念</h4><p>在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。</p>
<p>为了尽可能提升性能，Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列 - 多个工作线程模型性能更优。</p>
<p>Netty 的串行化设计工作原理图如下：</p>
<p><img src="http://static.cyblogs.com/152658879e750890cc2337c28554600b.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-25 Netty 串行化工作原理图</p>
<p>Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的 fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。</p>
<h4 id="2-2-6-高效的并发编程"><a href="#2-2-6-高效的并发编程" class="headerlink" title="2.2.6. 高效的并发编程"></a>2.2.6. 高效的并发编程</h4><p>Netty 的高效并发编程主要体现在如下几点：</p>
<p>1) volatile 的大量、正确使用 ;</p>
<p>2) CAS 和原子类的广泛使用；</p>
<p>3) 线程安全容器的使用；</p>
<p>4) 通过读写锁提升并发性能。</p>
<p>如果大家想了解 Netty 高效并发编程的细节，可以阅读之前我在微博分享的《多线程并发编程在 Netty 中的应用分析》，在这篇文章中对 Netty 的多线程技巧和应用进行了详细的介绍和分析。</p>
<h4 id="2-2-7-高性能的序列化框架"><a href="#2-2-7-高性能的序列化框架" class="headerlink" title="2.2.7. 高性能的序列化框架"></a>2.2.7. 高性能的序列化框架</h4><p>影响序列化性能的关键因素总结如下：</p>
<p>1) 序列化后的码流大小（网络带宽的占用）；</p>
<p>2) 序列化 &amp; 反序列化的性能（CPU 资源占用）；</p>
<p>3) 是否支持跨语言（异构系统的对接和开发语言切换）。</p>
<p>Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，用户可以实现其它的高性能序列化框架，例如 Thrift 的压缩二进制编解码框架。</p>
<p>下面我们一起看下不同序列化 &amp; 反序列化框架序列化后的字节数组对比：</p>
<p><img src="http://static.cyblogs.com/0ef6d5bf56e32e6073ea03a12a85fba9.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-26 各序列化框架序列化码流大小对比</p>
<p>从上图可以看出，Protobuf 序列化后的码流只有 Java 序列化的 1/4 左右。正是由于 Java 原生序列化性能表现太差，才催生出了各种高性能的开源序列化技术和框架（性能差只是其中的一个原因，还有跨语言、IDL 定义等其它因素）。</p>
<h4 id="2-2-8-灵活的-TCP-参数配置能力"><a href="#2-2-8-灵活的-TCP-参数配置能力" class="headerlink" title="2.2.8. 灵活的 TCP 参数配置能力"></a>2.2.8. 灵活的 TCP 参数配置能力</h4><p>合理设置 TCP 参数在某些场景下对于性能的提升可以起到显著的效果，例如 SO_RCVBUF 和 SO_SNDBUF。如果设置不当，对性能的影响是非常大的。下面我们总结下对性能影响比较大的几个配置项：</p>
<p>1) SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K；</p>
<p>2) SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；</p>
<p>3) 软中断：如果 Linux 内核版本支持 RPS（2.6.35 以上版本），开启 RPS 后可以实现软中断，提升网络吞吐量。RPS 根据数据包的源地址，目的地址以及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu，从上层来看，也就是说将每个连接和 cpu 绑定，并通过这个 hash 值，来均衡软中断在多个 cpu 上，提升网络并行处理性能。</p>
<p>Netty 在启动辅助类中可以灵活的配置 TCP 参数，满足不同的用户场景。相关配置接口定义如下：</p>
<p><img src="http://static.cyblogs.com/e470acd40eea18b5b067b181cbec5f68.png" alt="Netty系列之Netty高性能之道"></p>
<p>图 2-27 Netty 的 TCP 参数配置定义</p>
<h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3. 总结"></a>2.3. 总结</h3><p>通过对 Netty 的架构和性能模型进行分析，我们发现 Netty 架构的高性能是被精心设计和实现的，得益于高质量的架构和代码，Netty 支持 10W TPS 的跨节点服务调用并不是件十分困难的事情。</p>
<h3 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h3><ul>
<li><a href="https://www.infoq.cn/article/netty-high-performance/" target="_blank" rel="noopener">https://www.infoq.cn/article/netty-high-performance/</a></li>
</ul>
<h3 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h3><p>链接:<a href="https://pan.baidu.com/s/1vf2f4KRdpZlKkrBTReP-gA" target="_blank" rel="noopener">https://pan.baidu.com/s/1vf2f4KRdpZlKkrBTReP-gA</a>  密码:yvoy</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean初始化过程</title>
    <url>/2020/02/28/2020/02/Spring%20Bean%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="init-method方法"><a href="#init-method方法" class="headerlink" title="init-method方法"></a>init-method方法</h4><p><code>init-method</code>方法，初始化<code>bean</code>的时候执行，可以针对某个具体的<code>bean</code>进行配置。<code>init-method</code>需要在<code>applicationContext.xml</code>配置文档中<code>bean</code>的定义里头写明。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"TestBean"</span> <span class="attr">class</span>=<span class="string">"nju.software.xkxt.util.TestBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，当<code>TestBean</code>在初始化的时候会执行<code>TestBean</code>中定义的<code>init</code>方法。</p>
<h4 id="afterPropertiesSet方法"><a href="#afterPropertiesSet方法" class="headerlink" title="afterPropertiesSet方法"></a>afterPropertiesSet方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Invoked by the containing &#123;<span class="doctag">@code</span> BeanFactory&#125; after it has set all bean properties</span></span><br><span class="line"><span class="comment">	 * and satisfied &#123;<span class="doctag">@link</span> BeanFactoryAware&#125;, &#123;<span class="doctag">@code</span> ApplicationContextAware&#125; etc.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method allows the bean instance to perform validation of its overall</span></span><br><span class="line"><span class="comment">	 * configuration and final initialization when all bean properties have been set.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception in the event of misconfiguration (such as failure to set an</span></span><br><span class="line"><span class="comment">	 * essential property) or if initialization fails for any other reason</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>afterPropertiesSet</code>方法，初始化<code>bean</code>的时候执行，可以针对某个具体的<code>bean</code>进行配置。afterPropertiesSet 必须实现 <code>InitializingBean</code>接口。实现 <code>InitializingBean</code>接口必须实现<code>afterPropertiesSet</code>方法。</p>
<h4 id="BeanPostProcessor类"><a href="#BeanPostProcessor类" class="headerlink" title="BeanPostProcessor类"></a>BeanPostProcessor类</h4><p><code>BeanPostProcessor</code>，针对所有<code>Spring</code>上下文中所有的<code>bean</code>，可以在配置文档<code>applicationContext.xml</code>中配置一个<code>BeanPostProcessor</code>，然后对所有的<code>bean</code>进行一个初始化之前和之后的代理。<code>BeanPostProcessor</code>接口中有两个方法： <code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>。 <code>postProcessBeforeInitialization</code>方法在<code>bean</code>初始化之前执行， <code>postProcessAfterInitialization</code>方法在<code>bean</code>初始化之后执行。</p>
<h5 id="前置后置处理器"><a href="#前置后置处理器" class="headerlink" title="前置后置处理器"></a>前置后置处理器</h5><p>Spirng中<code>BeanPostProcessor</code>和<code>InstantiationAwareBeanPostProcessorAdapter</code>两个接口都可以实现对<code>bean</code>前置后置处理的效果，那这次先讲解一下<code>BeanPostProcessor</code>处理器的使用</p>
<p>先看一下<code>BeanPostProcessor</code>接口的源码，它定义了两个方法，一个在<code>bean</code>初始化之前，一个在<code>bean</code>初始化之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们来实现这个类，测试一下<code>Spring</code>中的前置后置处理器吧</p>
<p>首先是<code>pom.xml</code>,增加<code>Spring</code>相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.myspring<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myspring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>myspring<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring 5.0 核心工具包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring 5.0 Bean管理工具包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring 5.0 context管理工具包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring 5.0 aop支持包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义一个测试接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ISomeService</span> <span class="keyword">implements</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增强效果：返回内容全部大写</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello i am kxm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"eat food"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现<code>BeanPostProcessor</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 前置处理器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Class beanClass = bean.getClass();</span><br><span class="line">        <span class="keyword">if</span> (beanClass == ISomeService<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"bean 对象初始化之前······"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置处理器 --- 此处具体的实现用的是Java中的动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="keyword">final</span> Object beanInstance, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 为当前 bean 对象注册监控代理对象，负责增强 bean 对象方法的能力</span></span><br><span class="line">        Class beanClass = beanInstance.getClass();</span><br><span class="line">        <span class="keyword">if</span> (beanClass == ISomeService<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            Object proxy = Proxy.newProxyInstance(beanInstance.getClass().getClassLoader(),beanInstance.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"ISomeService 中的 doSome() 被拦截了···"</span>);</span><br><span class="line">                    String result = (String) method.invoke(beanInstance, args);</span><br><span class="line">                    <span class="keyword">return</span> result.toUpperCase(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);     </span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Spring</code>的配置文件如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册 bean：被监控的实现类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"iSomeService"</span> <span class="attr">class</span>=<span class="string">"com.my.spring.beanprocessor.ISomeService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注册代理实现类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.my.spring.beanprocessor.MyBeanPostProcessor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * BeanPostProcessor 前置后置处理器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ApplicationContext factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_config.xml"</span>);</span><br><span class="line">        BaseService serviceObj = (BaseService) factory.getBean(<span class="string">"iSomeService"</span>);</span><br><span class="line">        System.out.println(serviceObj.doSomething());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果截图：</p>
<p><img src="https://img-blog.csdn.net/20180924211535371?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgzNDQ2NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="https://img-blog.csdn.net/20180924211535371?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDgzNDQ2NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>可以观察到，我们明明在代码中对于<code>doSomething</code>方法定义的是小写，但是通过后置处理器，拦截了原本的方法，而是通过动态代理的方式把方法的结果进行了一定程度的改变，这就是<code>Spring</code>中的前置后置处理器—-<code>BeanPostProcessor</code>。</p>
<p>总之，<code>afterPropertiesSet</code> 和<code>init-method</code>之间的执行顺序是<code>afterPropertiesSet</code> 先执行，<code>init-method</code> 后执行。从<code>BeanPostProcessor</code>的作用，可以看出最先执行的是<code>postProcessBeforeInitialization</code>，然后<code>afterPropertiesSet</code>，然后是<code>init-method</code>，然后是<code>postProcessAfterInitialization</code>。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="https://www.cnblogs.com/twelve-eleven/p/8080038.html" target="_blank" rel="noopener">https://www.cnblogs.com/twelve-eleven/p/8080038.html</a></li>
<li><a href="https://blog.csdn.net/weixin_40834464/article/details/82832173" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40834464/article/details/82832173</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Shadowsocks自定义PAC规则</title>
    <url>/2020/02/28/2020/02/Shadowsocks%E8%87%AA%E5%AE%9A%E4%B9%89PAC%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h4 id="Shadowsocks-PAC规则"><a href="#Shadowsocks-PAC规则" class="headerlink" title="Shadowsocks PAC规则"></a>Shadowsocks PAC规则</h4><p>ShadowSocks默认使用GFWList规则和使用adblock plus的引擎。要想自己添加自定义的用户规则，最好熟悉一下其规则：</p>
<p>中文版：<a href="https://adblockplus.org/zh_CN/filters" target="_blank" rel="noopener">Adblock Plus过滤规则</a></p>
<p>自定义代理规则的设置语法与GFWlist相同，语法规则如下：</p>
<ul>
<li>通配符支持。<ul>
<li>比如 <code>*.example.com/*</code></li>
<li>实际书写时可省略 <code>*</code> ， 如<code>.example.com/</code> 和 <code>*.example.com/*</code> 效果一样</li>
</ul>
</li>
<li>正则表达式支持。<ul>
<li>以 <code>\</code> 开始和结束， 如 <code>\[\w]+:\/\/example.com\</code></li>
</ul>
</li>
<li>例外规则 <code>@@</code><ul>
<li>如 <code>@@*.example.com/*</code> 满足 <code>@@</code> 后规则的地址不使用代理</li>
</ul>
</li>
<li>匹配地址开始和结尾 <code>|</code><ul>
<li>如 <code>|http://example.com</code> 、 <code>example.com|</code> 分别表示以 <code>http://example.com</code> 开始和以 <code>example.com</code> 结束的地址</li>
</ul>
</li>
<li>||<code>标记</code><ul>
<li>如 <code>||example.com</code> 则 <code>http://example.com</code> 、<code>https://example.com</code> 、 <code>ftp://example.com</code> 等地址址满足条件。</li>
</ul>
</li>
<li>注释 <code>!</code><ul>
<li>如 <code>!我是注释</code></li>
</ul>
</li>
<li>分隔符^<ul>
<li>表示除了字母、数字或者 _ - . % 之外的任何字符。如 <code>http://example.com^</code> ，<code>http://example.com/</code> 和 <code>http://example.com:8000/</code> 均满足条件，而 <code>http://example.com.ar/</code> 不满足条件。</li>
</ul>
</li>
</ul>
<h4 id="什么是PAC"><a href="#什么是PAC" class="headerlink" title="什么是PAC"></a>什么是PAC</h4><ul>
<li>维基百科摘录的关于PAC的解释：<ul>
<li>代理自动配置（英语：Proxy auto-config，简称PAC）是一种网页浏览器技术，用于定义浏览器该如何自动选择适当的代理服务器来访问一个网址。</li>
<li>一个PAC文件包含一个JavaScript形式的函数<code>FindProxyForURL(url, host)</code>。</li>
<li>这个函数返回一个包含一个或多个访问规则的字符串。</li>
<li>用户代理根据这些规则适用一个特定的代理其或者直接访问。</li>
<li>当一个代理服务器无法响应的时候，多个访问规则提供了其他的后备访问方法。</li>
<li>浏览器在访问其他页面以前，首先访问这个PAC文件。</li>
<li>PAC文件中的URL可能是手工配置的，也可能是是通过网页的网络代理自发现协议（Web Proxy Autodiscovery Protocol）自动配置的。</li>
</ul>
</li>
<li>源自网络的图解：</li>
</ul>
<p><img src="http://static.cyblogs.com/PAC.png" alt="http://static.cyblogs.com/PAC.png"></p>
<p>简单说来，PAC就是一种配置规则，它能让你的浏览器智能判断哪些网站走代理，哪些不需要走代理。</p>
<h4 id="pac-txt"><a href="#pac-txt" class="headerlink" title="pac.txt"></a>pac.txt</h4><p>shadowsocks 目录下有一个 pac.txt 文件，而pac.txt这个文件是可以使用在线PAC或通过本地的GWFlist去更新的。所以并不建议用户自定义的规则直接加在pac.txt上面。</p>
<p><img src="http://static.cyblogs.com/ShadowSocks_PAC.jpg" alt="http://static.cyblogs.com/ShadowSocks_PAC.jpg"></p>
<p>打开 pac.txt 文件，可以看到头部是如下内容：</p>
<p><img src="http://static.cyblogs.com/ShadowSocks_PAC01.jpg" alt="http://static.cyblogs.com/ShadowSocks_PAC01.jpg"></p>
<p>可以看出pac配置文件使用的是JavaScript语法，里面定义了一个变量rules，是一个JSon数组格式的数据类型，数组里面存放的是各种URL的通配符。</p>
<p>那么在pac模式下，如果当访问符合这个数组里面任意一个URL通配符的网址时，系统会走代理，反之直连。比如访问谷歌搜索首页时，会走代理，而访问百度、新浪等国内网站则会选择直连方式。</p>
<h4 id="PAC脚本"><a href="#PAC脚本" class="headerlink" title="PAC脚本"></a>PAC脚本</h4><ul>
<li>PAC，一个自动代理配置脚本，包含了很多使用 JavaScript 编写的规则，它能够决定网络流量走默认通道还是代理服务器通道，控制的流量类型包括：HTTP、HTTPS 和 FTP。</li>
<li>一段 JavaScript 脚本：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是一个最简洁的 PAC 文件，意思是所有流量都直接进入互联网，不走代理。</p>
<h4 id="PAC的优势"><a href="#PAC的优势" class="headerlink" title="PAC的优势"></a>PAC的优势</h4><p>PAC自动代理属于智能判断模式，相比全局代理，它的优点有：</p>
<ul>
<li>不影响国内网站的访问速度，防止无意义的绕路；</li>
<li>节省Shadowsocks服务的流量，节省服务器资源；</li>
<li>控制方便。</li>
<li>自动容灾。</li>
</ul>
<h4 id="PAC-语法和函数"><a href="#PAC-语法和函数" class="headerlink" title="PAC 语法和函数"></a>PAC 语法和函数</h4><p>PAC不但使用在ShadowSocks上很方便，实际上它也可以配合其它代理服务端（如Squid），运用在浏览器上，不过需要你去弄懂它的语法和函数。</p>
<p>url 字段表示浏览器地址栏输入的待访问地址，host 为该地址对应的 hostname，return 语句有三种指令：</p>
<ul>
<li>DIRECT，表示无代理直接连接</li>
<li>PROXY host:port，表示走host:port 的 proxy 服务</li>
<li>SOCKS host:port，表示走host:port 的 socks 服务</li>
</ul>
<p>而返回的接口可以是多个代理串联：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">"PROXY 222.20.74.89:8800; SOCKS 222.20.74.89:8899; DIRECT"</span>;</span><br></pre></td></tr></table></figure>

<p>上面代理的意思是，默认走<code>222.20.74.89:8800</code> 的 proxy 服务；如果代理挂了或者超时，则走 <code>222.20.74.89:8899</code>的 socks 代理；如果 socks 也挂了，则无代理直接连接。</p>
<p>从这里可以看出 PAC 的一大优势：自动容灾。</p>
<p>PAC 提供了几个内置的函数，下面一一介绍下：</p>
<p><strong>dnsDomainIs</strong></p>
<p>类似于 ==，但是对大小写不敏感，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dnsDomainIs(host, <span class="string">"google.com"</span>) || </span><br><span class="line">    dnsDomainIs(host, <span class="string">"www.google.com"</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shExpMatch</strong></p>
<p>Shell 正则匹配，* 匹配用的比较多，可以是*.<a href="http://example.com/" target="_blank" rel="noopener">http://example.com</a>，也可以是下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shExpMatch(host, <span class="string">"vpn.domain.com"</span>) ||</span><br><span class="line">    shExpMatch(url, <span class="string">"http://abcdomain.com/folder/*"</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>isInNet</strong></p>
<p>判断是否在网段内容，比如 10.1.0.0 这个网段，10.1.1.0 就在网段中，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isInNet(dnsResolve(host), <span class="string">"172.16.0.0"</span>, <span class="string">"255.240.0.0"</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>myIpAddress</strong></p>
<p>返回主机的 IP，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isInNet(myIpAddress(), <span class="string">"10.10.1.0"</span>, <span class="string">"255.255.255.0"</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"PROXY 10.10.5.1:8080"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>dnsResolve</strong></p>
<p>通过 DNS 查询主机 ip，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isInNet(dnsResolve(host), <span class="string">"10.0.0.0"</span>, <span class="string">"255.0.0.0"</span>) ||</span><br><span class="line">    isInNet(dnsResolve(host), <span class="string">"172.16.0.0"</span>,  <span class="string">"255.240.0.0"</span>) ||</span><br><span class="line">    isInNet(dnsResolve(host), <span class="string">"192.168.0.0"</span>, <span class="string">"255.255.0.0"</span>) ||</span><br><span class="line">    isInNet(dnsResolve(host), <span class="string">"127.0.0.0"</span>, <span class="string">"255.255.255.0"</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>isPlainHostName</strong></p>
<p>判断是否为诸如barret/，server-name/ 这样的主机名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPlainHostName(host)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>isResolvable</strong></p>
<p>判断主机是否可访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isResolvable(host)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"PROXY proxy1.example.com:8080"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>dnsDomainLevels</strong></p>
<p>返回是几级域名，比如 dnsDomainLevels 返回的结果就是 1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dnsDomainLevels(host) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"PROXY proxy1.example.com:8080"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>weekdayRange</strong></p>
<p>周一到周五</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (weekdayRange(<span class="string">"MON"</span>, <span class="string">"FRI"</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"PROXY proxy1.example.com:8080"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>dateRange</strong></p>
<p>一月到五月</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dateRange(<span class="string">"JAN"</span>, <span class="string">"MAR"</span>))  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"PROXY proxy1.example.com:8080"</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>timeRange</strong></p>
<p>八点到十八点，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (timeRange(<span class="number">8</span>, <span class="number">18</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"PROXY proxy1.example.com:8080"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"DIRECT"</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>alert</strong></p>
<p>这个弹窗警报信息函数可以用来配合浏览器的控制台进行调试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">resolved_host = dnsResolve(host);</span><br><span class="line">alert(resolved_host);</span><br></pre></td></tr></table></figure>

<h4 id="PAC-文件的安装和注意事项"><a href="#PAC-文件的安装和注意事项" class="headerlink" title="PAC 文件的安装和注意事项"></a>PAC 文件的安装和注意事项</h4><p>在 Windows 系统中，通过<code>「Internet选项 -&gt; 连接 -&gt; 局域网设置 -&gt; 使用自动配置脚本」</code>可以找到配置处，下方的地址栏填写 PAC 文件的 URI，这个 URI 可以是本地资源路径(<code>file:///</code>)，也可以是网络资源路径。</p>
<p>Chrome 中可以在<code>「chrome://settings/ -&gt; 显示高级设置 -&gt; 更改代理服务器设置」</code>中找到 PAC 填写地址。</p>
<p><strong>需要注意的几点：</strong></p>
<ul>
<li>PAC 文件被访问时，返回的文件类型（Content-Type）应该为：<code>application/x-ns-proxy-autoconfig</code>，当然，如果你不写，一般浏览器也能够自动辨别。</li>
<li><code>FindProxyByUrl(url, host)</code>中的 host 在上述函数对比时无需转换成小写，对大小写不敏感。</li>
<li>没必要对 <code>dnsResolve(host)</code>的结果做缓存，DNS 在解析的时候会将结果缓存到系统中。</li>
</ul>
<h4 id="PAC文件及user-rule文件的语法规则"><a href="#PAC文件及user-rule文件的语法规则" class="headerlink" title="PAC文件及user-rule文件的语法规则"></a>PAC文件及user-rule文件的语法规则</h4><p>当一个网站被墙，如何添加到PAC里面让其能够正常访问呢？以MDN web doc这个网站为例，在Shadowsocks里面，可以有如下两个方式：</p>
<h5 id="1-添加到-pac-txt-文件中"><a href="#1-添加到-pac-txt-文件中" class="headerlink" title="1. 添加到 pac.txt 文件中"></a>1. 添加到 <code>pac.txt</code> 文件中</h5><p>编辑 <code>pac.txt</code> 文件，模仿里面的一些URL通配符，在rules（中括号）列表中再添加一个，例如<code>&quot;||developer.mozilla.org^&quot;,</code> ，注意不要忘记了 <code>,</code> 半角逗号，当然如果你是在最后添加的就可以不加半角逗号。这样配置下来就是所有 <code>developer.mozilla.org</code>域名下的网址都将走Shadowsocks代理。</p>
<p><img src="https://www.tielemao.com/wp-content/uploads/2018/05/ShadowSocks_PAC02.jpg?imageView2/2/w/1280/format/jpg/interlace/1/q/100" alt="http://static.cyblogs.com/hotlink.jpg"></p>
<h5 id="2-添加到-user-rule-txt-文件中（推荐）"><a href="#2-添加到-user-rule-txt-文件中（推荐）" class="headerlink" title="2. 添加到 user-rule.txt 文件中（推荐）"></a>2. 添加到 <code>user-rule.txt</code> 文件中（推荐）</h5><p>编辑 <code>user-rule.txt</code> 文件，这里和 <code>pac.txt</code> 文件语法不完全相同，user-rule文件中，每一行表示一个URL通配符，但是通配符语法类似。例如添加一行<code>||developer.mozilla.org^</code> ，然后记得右键shadowsocks小飞机图标-PAC-从GFWList更新本地PAC。</p>
<p>推荐使用添加到user-rule.txt的这种自定义用户规则的方法，因为pac文件里的规则是有可能被在线更新掉的。</p>
<p><img src="http://static.cyblogs.com/3vjn79vf2uit5prto2asqoa39s.png" alt="http://static.cyblogs.com/3vjn79vf2uit5prto2asqoa39s.png"></p>
<p>注意末尾不要忘记 ^ 符号，意思是要么在这个符号的地方结束，要么后面跟着?,/等符号。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://fuyiyi.imdo.co/articles/2018/09/30/1538314978887.html" target="_blank" rel="noopener">https://fuyiyi.imdo.co/articles/2018/09/30/1538314978887.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Shadowsocks</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的执行计划与代价模型详细解析</title>
    <url>/2020/02/28/2020/02/MySQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E4%BB%A3%E4%BB%B7%E6%A8%A1%E5%9E%8B%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>为了后续的沟通方便，在20200213的早上创建了一个<strong>《简栈-Java技术交流群》</strong>，也方便大家通过扫二维码积极的参与进来。</p>
<p><img src="http://static.cyblogs.com/%E7%AE%80%E6%A0%88-Java%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81%E7%BE%A4.JPG" alt="http://static.cyblogs.com/简栈-Java技术交流群.JPG"></p>
<p>如果是二维码已经过期，大家可以添加<strong>简栈文化-小助手</strong>的微信号（lastpass4u），然后让他拉大家进群进群。我们保持着小而美的精神，宁缺毋滥。</p>
<p><img src="http://static.cyblogs.com/%E7%AE%80%E6%A0%88%E6%96%87%E5%8C%96-%E5%B0%8F%E5%8A%A9%E6%89%8B.jpg" alt="http://static.cyblogs.com/简栈文化-小助手.jpg"></p>
<p>然后早上群里就有人提了一个问题：</p>
<blockquote>
<p>执行计划里面的扫描函数跟执行时间不匹配，比如查询优化器发现，扫描a索引行数更多，所以更慢，因此优化器选择了索引b, 但实际上走b索引的时候比a更慢，走a索引大概是4秒左右，b是8秒。</p>
</blockquote>
<p>这个问题激发起了大家的讨论，有的人建议说：</p>
<blockquote>
<p>1、这种可以强制指定索引执行的吧</p>
<p>2、这个扫描行数都是预估的不一定准的，能操作shell的话执行analyse table看看。</p>
<p>3、看一下你的index，DDL，explain等等</p>
</blockquote>
<p>但提问者明显这些都是已经自己搞清楚了的，他关心的是底层的优化器成本规则等。这类我才意识到EXPLAIN出来的是结果，其实数据库底层本身是有优化器的，而最终选择谁，是否过索引等都是有它的规则的。这其中都涉及到效率与成本问题。</p>
<h4 id="Explain执行计划详解"><a href="#Explain执行计划详解" class="headerlink" title="Explain执行计划详解"></a>Explain执行计划详解</h4><p>使用<code>explain</code>关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。</p>
<p><strong>Explain执行计划包含的信息</strong></p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (6).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (6).png)</p>
<p>其中最重要的字段为：<code>id、type、key、rows、Extra</code>。</p>
<h5 id="id字段"><a href="#id字段" class="headerlink" title="id字段"></a>id字段</h5><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p>
<ul>
<li>三种情况：<ul>
<li>1、id相同：执行顺序由上至下</li>
</ul>
</li>
</ul>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (4).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (4).png)</p>
<ul>
<li>2、id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
</ul>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (8).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (8).png)</p>
<ul>
<li>3、id相同又不同（两种情况同时存在）：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>
</ul>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (5).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (5).png)</p>
<h5 id="select-type字段"><a href="#select-type字段" class="headerlink" title="select_type字段"></a>select_type字段</h5><p>查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询</p>
<p>1、SIMPLE：简单的select查询，查询中不包含子查询或者union<br>2、PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为primary<br>3、SUBQUERY：在select 或 where列表中包含了子查询<br>4、DERIVED：在from列表中包含的子查询被标记为derived（衍生），mysql或递归执行这些子查询，把结果放在零时表里<br>5、UNION：若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived<br>6、UNION RESULT：从union表获取结果的select</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (9).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (9).png)</p>
<h5 id="type字段"><a href="#type字段" class="headerlink" title="type字段"></a>type字段</h5><p>访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是：</p>
<p><strong>system</strong> &gt; <strong>const</strong> &gt; <strong>eq_ref</strong> &gt; <strong>ref</strong> &gt; <strong>fulltext</strong> &gt; <strong>ref_or_null</strong> &gt; <strong>index_merge</strong> &gt; <strong>unique_subquery</strong> &gt; <strong>index_subquery</strong> &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p>
<p>一般来说，好的sql查询至少达到range级别，最好能达到ref</p>
<p>1、system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计</p>
<p>2、const：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const。</p>
<p><img src="http://static.cyblogs.com/SouthEast.png" alt="http://static.cyblogs.com/SouthEast.png"></p>
<p>3、eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。</p>
<p>注意：ALL全表扫描的表记录最少的表如t1表</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (2).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (2).png)</p>
<p>4、ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (3).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (3).png)</p>
<p>5、range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了bettween、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (7).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (7).png)</p>
<p>6、index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (1).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (1).png)</p>
<p>7、ALL：Full Table Scan，遍历全表以找到匹配的行</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (10).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (10).png)</p>
<h5 id="possible-keys字段"><a href="#possible-keys字段" class="headerlink" title="possible_keys字段"></a>possible_keys字段</h5><p>查询涉及到的字段上存在索引，则该索引将被列出，但不一定被查询实际使用</p>
<h5 id="key字段"><a href="#key字段" class="headerlink" title="key字段"></a>key字段</h5><p>实际使用的索引，如果为NULL，则没有使用索引。<br>查询中如果使用了覆盖索引，则该索引仅出现在key列表中</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (11).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (11).png)</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (2).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (12).png)</p>
<h5 id="key-len字段"><a href="#key-len字段" class="headerlink" title="key_len字段"></a>key_len字段</h5><p>表示索引中使用的字节数，查询中使用的索引的长度（最大可能长度），并非实际使用长度，理论上长度越短越好。key_len是根据表定义计算而得的，不是通过表内检索出的</p>
<h5 id="ref字段"><a href="#ref字段" class="headerlink" title="ref字段"></a>ref字段</h5><p>显示索引的那一列被使用了，如果可能，是一个常量const。</p>
<h5 id="rows字段"><a href="#rows字段" class="headerlink" title="rows字段"></a>rows字段</h5><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p>
<h5 id="Extra字段"><a href="#Extra字段" class="headerlink" title="Extra字段"></a>Extra字段</h5><p>不适合在其他字段中显示，但是十分重要的额外信息</p>
<h6 id="1、Using-filesort"><a href="#1、Using-filesort" class="headerlink" title="1、Using filesort"></a>1、Using filesort</h6><p>mysql对数据使用一个外部的索引排序，而不是按照表内的索引进行排序读取。也就是说mysql无法利用索引完成的排序操作成为“文件排序”</p>
<p>由于索引是先按email排序、再按address排序，所以查询时如果直接按address排序，索引就不能满足要求了，mysql内部必须再实现一次“文件排序”</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (13).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (13).png)</p>
<h6 id="2、Using-temporary"><a href="#2、Using-temporary" class="headerlink" title="2、Using temporary"></a>2、Using temporary</h6><p>使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表，常见于order by 和 group by</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (14).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (14).png)</p>
<h6 id="3、Using-index"><a href="#3、Using-index" class="headerlink" title="3、Using index"></a>3、Using index</h6><p>表示相应的select操作中使用了覆盖索引（Covering Index），避免了访问表的数据行，效率高<br>如果同时出现Using where，表明索引被用来执行索引键值的查找（参考上图）<br>如果没用同时出现Using where，表明索引用来读取数据而非执行查找动作</p>
<p>覆盖索引（Covering Index）：也叫索引覆盖。就是select列表中的字段，只用从索引中就能获取，不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。<br>注意：<br>a、如需使用覆盖索引，select列表中的字段只取出需要的列，不要使用select *<br>b、如果将所有字段都建索引会导致索引文件过大，反而降低crud性能</p>
<p>![<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (15).png](<a href="http://static.cyblogs.com/SouthEast" target="_blank" rel="noopener">http://static.cyblogs.com/SouthEast</a> (15).png)</p>
<h6 id="4、Using-where"><a href="#4、Using-where" class="headerlink" title="4、Using where"></a>4、Using where</h6><p>使用了where过滤</p>
<h6 id="5、Using-join-buffer"><a href="#5、Using-join-buffer" class="headerlink" title="5、Using join buffer"></a>5、Using join buffer</h6><p>使用了链接缓存</p>
<h6 id="6、Impossible-WHERE"><a href="#6、Impossible-WHERE" class="headerlink" title="6、Impossible WHERE"></a>6、Impossible WHERE</h6><p>where子句的值总是false，不能用来获取任何元祖</p>
<h6 id="7、select-tables-optimized-away"><a href="#7、select-tables-optimized-away" class="headerlink" title="7、select tables optimized away"></a>7、select tables optimized away</h6><p>在没有group by子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT（*）操作，不必等到执行阶段在进行计算，查询执行计划生成的阶段即可完成优化</p>
<h6 id="8、distinct"><a href="#8、distinct" class="headerlink" title="8、distinct"></a>8、distinct</h6><p>优化distinct操作，在找到第一个匹配的元祖后即停止找同样值得动作</p>
<h4 id="优化器代价模型"><a href="#优化器代价模型" class="headerlink" title="优化器代价模型"></a>优化器代价模型</h4><h5 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h5><ol>
<li>代价模型：RBO(基于规则的优化)、CBO(基于成本的优化)</li>
<li>SQL的每一种执行路径，均可计算一个对应的执行代价，代价越小，执行效率越高</li>
</ol>
<h5 id="CBO方式成本的计算"><a href="#CBO方式成本的计算" class="headerlink" title="CBO方式成本的计算"></a>CBO方式成本的计算</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Total cost = CPU cost + IO cost</span><br></pre></td></tr></table></figure>

<h6 id="CPU-cost计算模型"><a href="#CPU-cost计算模型" class="headerlink" title="CPU cost计算模型"></a>CPU cost计算模型</h6><p>CPU cost = rows/5 + (rows/10 if comparing key)</p>
<blockquote>
<p>CPU cost:</p>
<ol>
<li>MySQL上层，处理返回记录所花开销</li>
<li>CPU Cost=records/TIME_FOR_COMPARE=Records/5</li>
<li>每5条记录处的时间，作为1 Cost</li>
</ol>
</blockquote>
<h6 id="IO-cost计算模型"><a href="#IO-cost计算模型" class="headerlink" title="IO cost计算模型"></a>IO cost计算模型</h6><p>IO cost以聚集索引叶子节点的数量进行计算</p>
<blockquote>
<ul>
<li>全扫描<br>IO Cost = table stat_clustered_index_size<br>聚簇索引page总数，一个page作为1 cost</li>
<li>范围扫描<br>IO Cost = [(ranges+rows)/total_rows]*全扫描IO Cost<br>聚簇索引范围扫描与返回记录成比率</li>
</ul>
<p>若需要回表，则IO cost以预估的记录数量进行计算，开销相当巨大</p>
<ul>
<li>二级索引之索引覆盖扫描<ul>
<li>索引覆盖扫描，减少返回聚簇索引的IO代价<br>keys_per_block=(stats_block_size/2)/(key_info[keynr].key_lenth+ref_length+1)<br>stats_block_size/2 = 索引页半满</li>
<li>IO Cost：(records+keys_per_block-1)/keys_per_block</li>
<li>计算range占用多少个二级索引页面，既为索引覆盖扫描的IO Cost</li>
</ul>
</li>
<li>二级索引之索引非覆盖扫描<ul>
<li>索引非覆盖扫描，需要回聚簇索引读取完整记录，增加IO代价</li>
<li>IO Cost = （range+rows）</li>
<li>range:多少个范围<br>对于IN查询，就会转换为多个索引范围查询</li>
<li>row:为范围中一共有多少记录<br>由于每一条记录都需要返回聚簇索引，因此每一条记录都会产生1 Cost</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="Cost模型分析"><a href="#Cost模型分析" class="headerlink" title="Cost模型分析"></a>Cost模型分析</h5><ul>
<li>聚簇索引扫描代价为索引页面总数量</li>
<li>二级索引覆盖扫描代价较小</li>
<li>二级索引非覆盖扫描，代价巨大</li>
<li>Cost模型的计算，需要统计信息的支持<ul>
<li>stat_clustered_index_size</li>
<li>ranges</li>
<li>records/rows</li>
<li>stats_block_size</li>
<li>key_info[keynr].key_length</li>
<li>rec_per_key</li>
<li>……</li>
</ul>
</li>
</ul>
<h5 id="实战如何看日志确定Cost的选择"><a href="#实战如何看日志确定Cost的选择" class="headerlink" title="实战如何看日志确定Cost的选择"></a>实战如何看日志确定Cost的选择</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> lyj;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> lyj;</span><br><span class="line"><span class="keyword">use</span> lyj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (</span><br><span class="line">    c1 <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">'0'</span>,</span><br><span class="line">    c2 <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    c3 <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    c4 <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    primary <span class="keyword">key</span> (c1),</span><br><span class="line">    <span class="keyword">key</span> ind_c2 (c2),</span><br><span class="line">    <span class="keyword">key</span> ind_c4 (c4));</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'a'</span>,<span class="string">'A'</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'b'</span>,<span class="string">'B'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'b'</span>,<span class="string">'BB'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'b'</span>,<span class="string">'BBB'</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'b'</span>,<span class="string">'BBB'</span>,<span class="number">40</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">'c'</span>,<span class="string">'C'</span>,<span class="number">50</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">'d'</span>,<span class="string">'D'</span>,<span class="number">60</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1;</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">| c1 | c2   | c3   | c4   |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">|  1 | a    | A    |   10 |</span><br><span class="line">|  2 | b    | B    |   20 |</span><br><span class="line">|  3 | b    | BB   |   20 |</span><br><span class="line">|  4 | b    | BBB  |   30 |</span><br><span class="line">|  5 | b    | BBB  |   40 |</span><br><span class="line">|  6 | c    | C    |   50 |</span><br><span class="line">|  7 | d    | D    |   60 |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br></pre></td></tr></table></figure>

<p><strong>执行以下SQL为什么不走索引ind_c2？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 where c4=20 and c2='b'\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: ind_c2,ind_c4,ind_c2_c4</span><br><span class="line">          key: ind_c4</span><br><span class="line">      key_len: 5</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 2</span><br><span class="line">        Extra: Using where</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> optimizer_trace=<span class="string">'enabled=on'</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">set</span> end_markers_in_json=<span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> c4=<span class="number">20</span> <span class="keyword">and</span> c2=<span class="string">'b'</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.optimizer_trace\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                            QUERY: <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> c4=<span class="number">20</span> <span class="keyword">and</span> c2=<span class="string">'b'</span></span><br><span class="line">                            <span class="keyword">TRACE</span>: &#123;</span><br><span class="line">......</span><br><span class="line">                  <span class="string">"potential_range_indices"</span>: [ <span class="comment"># 列出备选索引</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"PRIMARY"</span>, </span><br><span class="line">                      <span class="string">"usable"</span>: <span class="literal">false</span>,         <span class="comment"># 本行表明主键索引不可用</span></span><br><span class="line">                      <span class="string">"cause"</span>: <span class="string">"not_applicable"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c2"</span>,</span><br><span class="line">                      <span class="string">"usable"</span>: <span class="literal">true</span>,</span><br><span class="line">                      <span class="string">"key_parts"</span>: [</span><br><span class="line">                        <span class="string">"c2"</span>,</span><br><span class="line">                        <span class="string">"c1"</span></span><br><span class="line">                      ] <span class="comment">/* key_parts */</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c4"</span>,</span><br><span class="line">                      <span class="string">"usable"</span>: <span class="literal">true</span>,</span><br><span class="line">                      <span class="string">"key_parts"</span>: [</span><br><span class="line">                        <span class="string">"c4"</span>,</span><br><span class="line">                        <span class="string">"c1"</span></span><br><span class="line">                      ] <span class="comment">/* key_parts */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ] <span class="comment">/* potential_range_indices */</span>,</span><br><span class="line">                  <span class="string">"setup_range_conditions"</span>: [</span><br><span class="line">                  ] <span class="comment">/* setup_range_conditions */</span>,</span><br><span class="line">                  <span class="string">"group_index_range"</span>: &#123;</span><br><span class="line">                    <span class="string">"chosen"</span>: <span class="literal">false</span>,</span><br><span class="line">                    <span class="string">"cause"</span>: <span class="string">"not_group_by_or_distinct"</span></span><br><span class="line">                  &#125; <span class="comment">/* group_index_range */</span>,</span><br><span class="line">                  <span class="string">"analyzing_range_alternatives"</span>: &#123;   <span class="comment"># 开始计算每个索引做范围扫描的花费</span></span><br><span class="line">                    <span class="string">"range_scan_alternatives"</span>: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c2"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"b &lt;= c2 &lt;= b"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">4</span>,         <span class="comment"># c2=b的结果有4行</span></span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">5.81</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">false</span>,   <span class="comment"># 这个索引没有被选中，原因是cost</span></span><br><span class="line">                        <span class="string">"cause"</span>: <span class="string">"cost"</span>   </span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c4"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"20 &lt;= c4 &lt;= 20"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">3.41</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">true</span>     <span class="comment"># 这个索引的代价最小,被选中</span></span><br><span class="line">                      &#125;</span><br><span class="line">......</span><br><span class="line">                  <span class="string">"chosen_range_access_summary"</span>: &#123;  <span class="comment"># 总结：因为cost最小选择了ind_c4</span></span><br><span class="line">                    <span class="string">"range_access_plan"</span>: &#123;</span><br><span class="line">                      <span class="string">"type"</span>: <span class="string">"range_scan"</span>,</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c4"</span>,</span><br><span class="line">                      <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                      <span class="string">"ranges"</span>: [</span><br><span class="line">                        <span class="string">"20 &lt;= c4 &lt;= 20"</span></span><br><span class="line">                      ] <span class="comment">/* ranges */</span></span><br><span class="line">                    &#125; <span class="comment">/* range_access_plan */</span>,</span><br><span class="line">                    <span class="string">"rows_for_plan"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="string">"cost_for_plan"</span>: <span class="number">3.41</span>,</span><br><span class="line">                    <span class="string">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                  &#125; <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>因为ind_c4范围扫描的cost要小于ind_c2，所以索引不走ind_c2</p>
<p><strong>where条件中字段c2和c4换个位置，索引还是不走ind_c2？为什么？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span>  c2=<span class="string">'b'</span> <span class="keyword">and</span> c4=<span class="number">20</span>\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: ind_c2,ind_c4,ind_c2_c4</span><br><span class="line">          key: ind_c4</span><br><span class="line">      key_len: 5</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 2</span><br><span class="line">        Extra: Using where</span><br></pre></td></tr></table></figure>

<p>因为ind_c4范围扫描的cost要小于ind_c2，所以索引不走ind_c2，跟c2和c4的位置无关。验证方法同上。</p>
<p><strong>如下语句，换个条件c2=’c’，为什么可以走索引ind_c2？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from t1 where c2='c' and c4=20\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: ind_c2,ind_c4,ind_c2_c4</span><br><span class="line">          key: ind_c2</span><br><span class="line">      key_len: 387</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using index condition; Using where</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.optimizer_trace\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                            QUERY: <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> c2=<span class="string">'c'</span> <span class="keyword">and</span> c4=<span class="number">20</span></span><br><span class="line">                            <span class="keyword">TRACE</span>: &#123;</span><br><span class="line">......</span><br><span class="line">                  <span class="string">"analyzing_range_alternatives"</span>: &#123;</span><br><span class="line">                    <span class="string">"range_scan_alternatives"</span>: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c2"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"c &lt;= c2 &lt;= c"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">1</span>,           <span class="comment"># c2=c 的结果集有1行</span></span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">2.21</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">true</span>       <span class="comment"># 这个索引的代价最小,被选中</span></span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c4"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"20 &lt;= c4 &lt;= 20"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">3.41</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">false</span>,   <span class="comment"># 这个索引没有被选中，原因是cost</span></span><br><span class="line">                        <span class="string">"cause"</span>: <span class="string">"cost"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                  ......</span><br></pre></td></tr></table></figure>

<p><strong>创建复合索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t1 <span class="keyword">ADD</span> <span class="keyword">KEY</span> ind_c2_c4(c2,c4);</span><br></pre></td></tr></table></figure>

<p><strong>下面语句为什么不走复合索引ind_c2_c4？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span>  c2=<span class="string">'b'</span> <span class="keyword">and</span> c4=<span class="number">20</span>\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: ind_c2,ind_c4,ind_c2_c4</span><br><span class="line">          key: ind_c4</span><br><span class="line">      key_len: 5</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 2</span><br><span class="line">        Extra: Using where</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> optimizer_trace=<span class="string">'enabled=on'</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">set</span> end_markers_in_json=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span>  c2=<span class="string">'b'</span> <span class="keyword">and</span> c4=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                            QUERY: <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span>  c2=<span class="string">'b'</span> <span class="keyword">and</span> c4=<span class="number">20</span></span><br><span class="line">                            <span class="keyword">TRACE</span>: &#123;</span><br><span class="line">......</span><br><span class="line">                  <span class="string">"potential_range_indices"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"PRIMARY"</span>,</span><br><span class="line">                      <span class="string">"usable"</span>: <span class="literal">false</span>,</span><br><span class="line">                      <span class="string">"cause"</span>: <span class="string">"not_applicable"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c2"</span>,</span><br><span class="line">                      <span class="string">"usable"</span>: <span class="literal">true</span>,</span><br><span class="line">                      <span class="string">"key_parts"</span>: [</span><br><span class="line">                        <span class="string">"c2"</span>,</span><br><span class="line">                        <span class="string">"c1"</span></span><br><span class="line">                      ] <span class="comment">/* key_parts */</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c4"</span>,</span><br><span class="line">                      <span class="string">"usable"</span>: <span class="literal">true</span>,</span><br><span class="line">                      <span class="string">"key_parts"</span>: [</span><br><span class="line">                        <span class="string">"c4"</span>,</span><br><span class="line">                        <span class="string">"c1"</span></span><br><span class="line">                      ] <span class="comment">/* key_parts */</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c2_c4"</span>,</span><br><span class="line">                      <span class="string">"usable"</span>: <span class="literal">true</span>,</span><br><span class="line">                      <span class="string">"key_parts"</span>: [</span><br><span class="line">                        <span class="string">"c2"</span>,</span><br><span class="line">                        <span class="string">"c4"</span>,</span><br><span class="line">                        <span class="string">"c1"</span></span><br><span class="line">                      ] <span class="comment">/* key_parts */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ] <span class="comment">/* potential_range_indices */</span>,</span><br><span class="line">                  <span class="string">"setup_range_conditions"</span>: [</span><br><span class="line">                  ] <span class="comment">/* setup_range_conditions */</span>,</span><br><span class="line">                  <span class="string">"group_index_range"</span>: &#123;</span><br><span class="line">                    <span class="string">"chosen"</span>: <span class="literal">false</span>,</span><br><span class="line">                    <span class="string">"cause"</span>: <span class="string">"not_group_by_or_distinct"</span></span><br><span class="line">                  &#125; <span class="comment">/* group_index_range */</span>,</span><br><span class="line">                  <span class="string">"analyzing_range_alternatives"</span>: &#123;</span><br><span class="line">                    <span class="string">"range_scan_alternatives"</span>: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c2"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"b &lt;= c2 &lt;= b"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">4</span>,</span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">5.81</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"cause"</span>: <span class="string">"cost"</span></span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c4"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"20 &lt;= c4 &lt;= 20"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">3.41</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c2_c4"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"b &lt;= c2 &lt;= b AND 20 &lt;= c4 &lt;= 20"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">3.41</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"cause"</span>: <span class="string">"cost"</span></span><br><span class="line">                      &#125;</span><br><span class="line">......</span><br><span class="line">                  <span class="string">"chosen_range_access_summary"</span>: &#123;</span><br><span class="line">                    <span class="string">"range_access_plan"</span>: &#123;</span><br><span class="line">                      <span class="string">"type"</span>: <span class="string">"range_scan"</span>,</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c4"</span>,</span><br><span class="line">                      <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                      <span class="string">"ranges"</span>: [</span><br><span class="line">                        <span class="string">"20 &lt;= c4 &lt;= 20"</span></span><br><span class="line">                      ] <span class="comment">/* ranges */</span></span><br><span class="line">                    &#125; <span class="comment">/* range_access_plan */</span>,</span><br><span class="line">                    <span class="string">"rows_for_plan"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="string">"cost_for_plan"</span>: <span class="number">3.41</span>,</span><br><span class="line">                    <span class="string">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                  &#125; <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">                &#125; <span class="comment">/* range_analysis */</span></span><br><span class="line">              &#125;</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>

<p>索引ind_c4和ind_c2_c4都是非覆盖扫描，而ind_c4和ind_c2_c4的cost是一样的，mysql会选择叶子块数量较少的那个索引，很明显ind_c4叶子块数量较少。</p>
<p><strong>下面语句为什么又可以走复合索引ind_c2_c4？</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> c2,c4 <span class="keyword">from</span> t1 <span class="keyword">where</span> c2=<span class="string">'b'</span> <span class="keyword">and</span> c4=<span class="number">20</span>\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t1</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: ind_c2,ind_c4,ind_c2_c4</span><br><span class="line">          key: ind_c2_c4</span><br><span class="line">      key_len: 392</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 2</span><br><span class="line">        Extra: Using where; Using index</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> optimizer_trace=<span class="string">'enabled=on'</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">set</span> end_markers_in_json=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">select</span> c2,c4 <span class="keyword">from</span> t1 <span class="keyword">where</span> c2=<span class="string">'b'</span> <span class="keyword">and</span> c4=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br><span class="line"></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                            QUERY: <span class="keyword">select</span> c2,c4 <span class="keyword">from</span> t1 <span class="keyword">where</span> c2=<span class="string">'b'</span> <span class="keyword">and</span> c4=<span class="number">20</span></span><br><span class="line">                            <span class="keyword">TRACE</span>: &#123;</span><br><span class="line">......</span><br><span class="line">                  <span class="string">"analyzing_range_alternatives"</span>: &#123;</span><br><span class="line">                    <span class="string">"range_scan_alternatives"</span>: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c2"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"b &lt;= c2 &lt;= b"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">4</span>,</span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">5.81</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"cause"</span>: <span class="string">"cost"</span></span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c4"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"20 &lt;= c4 &lt;= 20"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">3.41</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"cause"</span>: <span class="string">"cost"</span></span><br><span class="line">                      &#125;,</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="string">"index"</span>: <span class="string">"ind_c2_c4"</span>,</span><br><span class="line">                        <span class="string">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"b &lt;= c2 &lt;= b AND 20 &lt;= c4 &lt;= 20"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="string">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="string">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"index_only"</span>: <span class="literal">true</span>,    <span class="comment"># 索引覆盖扫描</span></span><br><span class="line">                        <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="string">"cost"</span>: <span class="number">3.41</span>,</span><br><span class="line">                        <span class="string">"chosen"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"cause"</span>: <span class="string">"cost"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    ] <span class="comment">/* range_scan_alternatives */</span>,</span><br><span class="line">                    <span class="string">"analyzing_roworder_intersect"</span>: &#123;</span><br><span class="line">                      <span class="string">"intersecting_indices"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="string">"index"</span>: <span class="string">"ind_c2_c4"</span>,</span><br><span class="line">                          <span class="string">"index_scan_cost"</span>: <span class="number">1.0476</span>,</span><br><span class="line">                          <span class="string">"cumulated_index_scan_cost"</span>: <span class="number">1.0476</span>,</span><br><span class="line">                          <span class="string">"disk_sweep_cost"</span>: <span class="number">0</span>,</span><br><span class="line">                          <span class="string">"cumulated_total_cost"</span>: <span class="number">1.0476</span>,</span><br><span class="line">                          <span class="string">"usable"</span>: <span class="literal">true</span>,</span><br><span class="line">                          <span class="string">"matching_rows_now"</span>: <span class="number">2</span>,</span><br><span class="line">                          <span class="string">"isect_covering_with_this_index"</span>: <span class="literal">true</span>,</span><br><span class="line">                          <span class="string">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                      ] <span class="comment">/* intersecting_indices */</span>,</span><br><span class="line">                      <span class="string">"clustered_pk"</span>: &#123;</span><br><span class="line">                        <span class="string">"clustered_pk_added_to_intersect"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="string">"cause"</span>: <span class="string">"no_clustered_pk_index"</span></span><br><span class="line">                      &#125; <span class="comment">/* clustered_pk */</span>,</span><br><span class="line">                      <span class="string">"chosen"</span>: <span class="literal">false</span>,</span><br><span class="line">                      <span class="string">"cause"</span>: <span class="string">"too_few_indexes_to_merge"</span></span><br><span class="line">                    &#125; <span class="comment">/* analyzing_roworder_intersect */</span></span><br><span class="line">                  &#125; <span class="comment">/* analyzing_range_alternatives */</span></span><br><span class="line">                &#125; <span class="comment">/* range_analysis */</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* rows_estimation */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"considered_execution_plans"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">"plan_prefix"</span>: [</span><br><span class="line">                ] <span class="comment">/* plan_prefix */</span>,</span><br><span class="line">                <span class="string">"table"</span>: <span class="string">"`t1`"</span>,</span><br><span class="line">                <span class="string">"best_access_path"</span>: &#123;</span><br><span class="line">                  <span class="string">"considered_access_paths"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"access_type"</span>: <span class="string">"ref"</span>,</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c2"</span>,</span><br><span class="line">                      <span class="string">"rows"</span>: <span class="number">4</span>,</span><br><span class="line">                      <span class="string">"cost"</span>: <span class="number">2.8</span>,</span><br><span class="line">                      <span class="string">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"access_type"</span>: <span class="string">"ref"</span>,</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c4"</span>,</span><br><span class="line">                      <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                      <span class="string">"cost"</span>: <span class="number">2.4</span>,</span><br><span class="line">                      <span class="string">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"access_type"</span>: <span class="string">"ref"</span>,</span><br><span class="line">                      <span class="string">"index"</span>: <span class="string">"ind_c2_c4"</span>,</span><br><span class="line">                      <span class="string">"rows"</span>: <span class="number">2</span>,</span><br><span class="line">                      <span class="string">"cost"</span>: <span class="number">1.4476</span>,</span><br><span class="line">                      <span class="string">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">"access_type"</span>: <span class="string">"scan"</span>,</span><br><span class="line">                      <span class="string">"cause"</span>: <span class="string">"covering_index_better_than_full_scan"</span>,  </span><br><span class="line">                      <span class="string">"chosen"</span>: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ] <span class="comment">/* considered_access_paths */</span></span><br><span class="line">                &#125; <span class="comment">/* best_access_path */</span>,</span><br><span class="line">                <span class="string">"cost_for_plan"</span>: <span class="number">1.4476</span>,</span><br><span class="line">                <span class="string">"rows_for_plan"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>因为语中ind_c2_c4是索引覆盖扫描，不需要回表，代价较小。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>我们看执行计划（Explain）仅仅只是结果，而看代价模型（Cost）才是过程。</strong>如果我们真的想了解数据库是如何优化我们的SQL或者真的是如何执行的，需要深入深入的理解底层才行。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/gua___gua/article/details/50819629" target="_blank" rel="noopener">https://blog.csdn.net/gua___gua/article/details/50819629</a></li>
<li><a href="https://blog.csdn.net/qingsong3333/article/details/77170831" target="_blank" rel="noopener">https://blog.csdn.net/qingsong3333/article/details/77170831</a></li>
<li><a href="https://keithlan.github.io/2015/07/14/mysql_group_order_limit/" target="_blank" rel="noopener">https://keithlan.github.io/2015/07/14/mysql_group_order_limit/</a></li>
<li>[<a href="http://dbase.cc/2017/10/24/mysql/MySQL-性能优化最佳实践课程学习/09-MySQL-性能优化最佳实践" target="_blank" rel="noopener">http://dbase.cc/2017/10/24/mysql/MySQL-性能优化最佳实践课程学习/09-MySQL-性能优化最佳实践</a> /](<a href="http://dbase.cc/2017/10/24/mysql/MySQL-性能优化最佳实践课程学习/09-MySQL-性能优化最佳实践" target="_blank" rel="noopener">http://dbase.cc/2017/10/24/mysql/MySQL-性能优化最佳实践课程学习/09-MySQL-性能优化最佳实践</a> /)</li>
<li><a href="https://blog.csdn.net/wuseyukui/article/details/71512793" target="_blank" rel="noopener">https://blog.csdn.net/wuseyukui/article/details/71512793</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper Leader选举算法</title>
    <url>/2020/02/28/2020/02/Zookeeper%20Leader%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>当Leader崩溃或者Leader失去大多数的Follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的Leader，让所有的Server都恢复到一个正确的状态。Zookeeper中Leader的选举采用了三种算法：</p>
<ul>
<li>LeaderElection</li>
<li>FastLeaderElection</li>
<li>AuthFastLeaderElection</li>
</ul>
<p>并且在配置文件中是可配置的，对应的配置项为electionAlg。</p>
<h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><p>Zookeeper Server的状态可分为四种：</p>
<ul>
<li>LOOKING：寻找Leader</li>
<li>LEADING：Leader状态，对应的节点为Leader。</li>
<li>FOLLOWING：Follower状态，对应的节点为Follower。</li>
<li>OBSERVING：Observer状态，对应节点为Observer，该节点不参与Leader选举。</li>
</ul>
<p>成为Leader的必要条件： Leader要具有最高的zxid；当集群的规模是n时，集群中大多数的机器（至少n/2+1）得到响应并follow选出的Leader。</p>
<p>心跳机制：Leader与Follower利用PING来感知对方的是否存活，当Leader无法相应PING时，将重新发起Leader选举。</p>
<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p><strong>zxid</strong>：zookeeper transaction id, 每个改变Zookeeper状态的操作都会形成一个对应的zxid，并记录到transaction log中。 这个值越大，表示更新越新。</p>
<p><strong>electionEpoch/logicalclock</strong>：逻辑时钟，用来判断是否为同一次选举。每调用一次选举函数，logicalclock自增1，并且在选举过程中如果遇到election比当前logicalclock大的值，就更新本地logicalclock的值。</p>
<p><strong>peerEpoch</strong>: 表示节点的Epoch。</p>
<h4 id="LeaderElection选举算法"><a href="#LeaderElection选举算法" class="headerlink" title="LeaderElection选举算法"></a>LeaderElection选举算法</h4><p>LeaderElection是Fast Paxos最简单的一种实现，每个Server启动以后都询问其它的Server它要投票给谁，收到所有Server回复以后，就计算出zxid最大的哪个Server，并将这个Server相关信息设置成下一次要投票的Server。该算法于Zookeeper 3.4以后的版本废弃。</p>
<p>选举算法流程如下：</p>
<ol>
<li>选举线程首先向所有Server发起一次询问(包括自己)；</li>
<li>选举线程收到回复后，验证是否是自己发起的询问(验证xid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</li>
<li>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</li>
<li>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得多数Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</li>
</ol>
<p><a href="http://www.yidooo.net/images/leader_election.jpg" target="_blank" rel="noopener"><img src="http://www.yidooo.net/images/leader_election.jpg" alt="leader-election"></a></p>
<p>通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.</p>
<p>异常问题的处理：</p>
<ol>
<li>选举过程中，Server的加入<br>当一个Server启动时它都会发起一次选举，此时由选举线程发起相关流程，那么每个 Serve r都会获得当前zxi d最大的哪个Serve r是谁，如果当次最大的Serve r没有获得n/2+1 个票数，那么下一次投票时，他将向zxid最大的Server投票，重复以上流程，最后一定能选举出一个Leader。</li>
<li>选举过程中，Server的退出<br>只要保证n/2+1个Server存活就没有任何问题，如果少于n/2+1个Server 存活就没办法选出Leader。</li>
<li>选举过程中，Leader死亡<br>当选举出Leader以后，此时每个Server应该是什么状态(FLLOWING)都已经确定，此时由于Leader已经死亡我们就不管它，其它的Fllower按正常的流程继续下去，当完成这个流程以后，所有的Fllower都会向Leader发送Ping消息，如果无法ping通，就改变自己的状为(FLLOWING ==&gt; LOOKING)，发起新的一轮选举。</li>
<li>选举完成以后，Leader死亡<br>处理过程同上。</li>
<li>双主问题<br>Leader的选举是保证只产生一个公认的Leader的，而且Follower重新选举与旧Leader恢复并退出基本上是同时发生的，当Follower无法ping同Leader是就认为Leader已经出问题开始重新选举，Leader收到Follower的ping没有达到半数以上则要退出Leader重新选举。</li>
</ol>
<h4 id="FastLeaderElection选举算法"><a href="#FastLeaderElection选举算法" class="headerlink" title="FastLeaderElection选举算法"></a>FastLeaderElection选举算法</h4><p>由于LeaderElection收敛速度较慢，所以Zookeeper引入了FastLeaderElection选举算法，FastLeaderElection也成了Zookeeper默认的Leader选举算法。</p>
<p>FastLeaderElection是标准的Fast Paxos的实现，它首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决 epoch 和 zxid 的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息。FastLeaderElection算法通过异步的通信方式来收集其它节点的选票，同时在分析选票时又根据投票者的当前状态来作不同的处理，以加快Leader的选举进程。</p>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据恢复阶段"><a href="#数据恢复阶段" class="headerlink" title="数据恢复阶段"></a>数据恢复阶段</h5><p>每个ZooKeeper Server读取当前磁盘的数据（transaction log），获取最大的zxid。</p>
<h5 id="发送选票"><a href="#发送选票" class="headerlink" title="发送选票"></a>发送选票</h5><p>每个参与投票的ZooKeeper Server向其他Server发送自己所推荐的Leader，这个协议中包括几部分数据：</p>
<ul>
<li>所推举的Leader id。在初始阶段，第一次投票所有Server都推举自己为Leader。</li>
<li>本机的最大zxid值。这个值越大，说明该Server的数据越新。</li>
<li>logicalclock。这个值从0开始递增，每次选举对应一个值，即在同一次选举中，这个值是一致的。这个值越大说明选举进程越新。</li>
<li>本机的所处状态。包括LOOKING，FOLLOWING，OBSERVING，LEADING。</li>
</ul>
<h4 id="处理选票"><a href="#处理选票" class="headerlink" title="处理选票"></a>处理选票</h4><p>每台Server将自己的数据发送给其他Server之后，同样也要接受其他Server的选票，并做一下处理。</p>
<h5 id="如果Sender的状态是LOOKING"><a href="#如果Sender的状态是LOOKING" class="headerlink" title="如果Sender的状态是LOOKING"></a>如果Sender的状态是LOOKING</h5><ul>
<li>如果发送过来的logicalclock大于目前的logicalclock。说明这是更新的一次选举，需要更新本机的logicalclock，同事清空已经收集到的选票，因为这些数据已经不再有效。然后判断是否需要更新自己的选举情况。首先判断zxid，zxid大者胜出；如果相同比较leader id，大者胜出。</li>
<li>如果发送过来的logicalclock小于于目前的logicalclock。说明对方处于一个比较早的选举进程，只需要将本机的数据发送过去即可。</li>
<li>如果发送过来的logicalclock等于目前的logicalclock。根据收到的zxid和leader id更新选票，然后广播出去。</li>
</ul>
<p>当Server处理完选票后，可能需要对Server的状态进行更新：</p>
<ul>
<li>判断服务器是否已经收集到所有的服务器的选举状态。如果是根据选举结果设置自己的角色（FOLLOWING or LEADER），然后退出选举。</li>
<li>如果没有收到没有所有服务器的选举状态，也可以判断一下根据以上过程之后更新的选举Leader是不是得到了超过半数以上服务器的支持。如果是，那么尝试在200ms内接收下数据，如果没有心数据到来说明大家已经认同这个结果。这时，设置角色然后退出选举。</li>
</ul>
<h5 id="如果Sender的状态是FOLLOWING或者LEADER"><a href="#如果Sender的状态是FOLLOWING或者LEADER" class="headerlink" title="如果Sender的状态是FOLLOWING或者LEADER"></a>如果Sender的状态是FOLLOWING或者LEADER</h5><ul>
<li>如果LogicalClock相同，将数据保存早recvset，如果Sender宣称自己是Leader，那么判断是不是半数以上的服务器都选举它，如果是设置角色并退出选举。</li>
<li>否则，这是一条与当前LogicalClock不符合的消息，说明在另一个选举过程中已经有了选举结果，于是将该选举结果加入到OutOfElection集合中，根据OutOfElection来判断是否可以结束选举，如果可以也是保存LogicalClock，更新角色，退出选举。</li>
</ul>
<p><a href="http://www.yidooo.net/images/fast_leader_election.png" target="_blank" rel="noopener"><img src="http://www.yidooo.net/images/fast_leader_election.png" alt="fast-leader-election"></a></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>本地消息结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static public class Notification &#123;</span><br><span class="line">long leader;  &#x2F;&#x2F;所推荐的Server id</span><br><span class="line"></span><br><span class="line">long zxid;      &#x2F;&#x2F;所推荐的Server的zxid(zookeeper transtion id)</span><br><span class="line"></span><br><span class="line">long epoch;   &#x2F;&#x2F;描述leader是否变化(每一个Server启动时都有一个logicalclock，初始值为0)</span><br><span class="line"></span><br><span class="line">QuorumPeer.ServerState state;   &#x2F;&#x2F;发送者当前的状态</span><br><span class="line">InetSocketAddress addr;            &#x2F;&#x2F;发送者的ip地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网络消息结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static public class ToSend &#123;</span><br><span class="line"></span><br><span class="line">int type;        &#x2F;&#x2F;消息类型</span><br><span class="line">long leader;  &#x2F;&#x2F;Server id</span><br><span class="line">long zxid;     &#x2F;&#x2F;Server的zxid</span><br><span class="line">long epoch;  &#x2F;&#x2F;Server的epoch</span><br><span class="line">QuorumPeer.ServerState state; &#x2F;&#x2F;Server的state</span><br><span class="line">long tag;      &#x2F;&#x2F;消息编号</span><br><span class="line"></span><br><span class="line">InetSocketAddress addr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程处理"><a href="#线程处理" class="headerlink" title="线程处理"></a>线程处理</h5><p>每个Server都一个接收线程池和一个发送线程池, 在没有发起选举时，这两个线程池处于阻塞状态，直到有消息到来时才解除阻塞并处理消息，同时每个Server都有一个选举线程(可以发起选举的线程担任)。</p>
<ul>
<li>接收线程的处理<br>notification: 首先检测当前Server上所被推荐的zxid,epoch是否合法(currentServer.epoch &lt;= currentMsg.epoch &amp;&amp; (currentMsg.zxid &gt; currentServer.zxid || (currentMsg.zxid == currentServer.zxid &amp;&amp; currentMsg.id &gt; currentServer.id))) 如果不合法就用消息中的zxid,epoch,id更新当前Server所被推荐的值，此时将收到的消息转换成Notification消息放入接收队列中，将向对方发送ack消息。<br>ack: 将消息编号放入ack队列中，检测对方的状态是否是LOOKING状态，如果不是说明此时已经有Leader已经被选出来，将接收到的消息转发成Notification消息放入接收对队列</li>
<li>发送线程池的处理<br>notification: 将要发送的消息由Notification消息转换成ToSend消息，然后发送对方，并等待对方的回复,如果在等待结束没有收到对方法回复，重做三次,如果重做次还是没有收到对方的回复时检测当前的选举(epoch)是否已经改变，如果没有改变，将消息再次放入发送队列中，一直重复直到有Leader选出或者收到对方回复为止。<br>ack: 主要将自己相关信息发送给对方</li>
<li>选举线程的处理<br>首先自己的epoch加1，然后生成notification消息,并将消息放入发送队列中，系统中配置有几个Server就生成几条消息，保证每个Server都能收到此消息,如果当前Server的状态是LOOKING就一直循环检查接收队列是否有消息，如果有消息，根据消息中对方的状态进行相应的处理。</li>
</ul>
<h4 id="AuthFastLeaderElection选举算法"><a href="#AuthFastLeaderElection选举算法" class="headerlink" title="AuthFastLeaderElection选举算法"></a>AuthFastLeaderElection选举算法</h4><p>AuthFastLeaderElection算法同FastLeaderElection算法基本一致，只是在消息中加入了认证信息，该算法在最新的Zookeeper中也建议弃用。</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>下面看一个Leader选举的例子以加深对Leader选举算法的理解。</p>
<ol>
<li>服务器1启动,此时只有它一台服务器启动了,它发出去的报没有任何响应,所以它的选举状态一直是LOOKING状态.</li>
<li>服务器2启动,它与最开始启动的服务器1进行通信,互相交换自己的选举结果,由于两者都没有历史数据,所以id值较大的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3),所以服务器1,2还是继续保持LOOKING状态.</li>
<li>服务器3启动,根据前面的理论分析,服务器3成为服务器1,2,3中的Leader,而与上面不同的是,此时有三台服务器选举了它,所以它成为了这次选举的Leader.</li>
<li>服务器4启动,根据前面的分析,理论上服务器4应该是服务器1,2,3,4中最大的,但是由于前面已经有半数以上的服务器选举了服务器3,所以它只能是Follower.</li>
<li>服务器5启动,同4一样,Follower.</li>
</ol>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="http://www.yidooo.net/2014/10/18/zookeeper-leader-election.html" target="_blank" rel="noopener">http://www.yidooo.net/2014/10/18/zookeeper-leader-election.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper 一致性协议Zab</title>
    <url>/2020/02/28/2020/02/Zookeeper%20%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AEZab/</url>
    <content><![CDATA[<p>Zookeeper使用了一种称为Zab（Zookeeper Atomic Broadcast）的协议作为其一致性的核心。Zab协议是Paxos协议的一种变形，下面将展示一些协议的核心内容。</p>
<p>考虑到Zookeeper的主要操作数据状态，为了保证一致性，Zookeeper提出了两个安全属性：</p>
<ul>
<li>全序（Total Order）：如果消息A在消息B之前发送，则所有Server应该看到相同结果。</li>
<li>因果顺序（Causal Order）：如果消息A在消息B之前发生（A导致了B），并且一起发送，则消息A始终在消息B之前被执行。</li>
</ul>
<p>为了保证上述两个安全属性，Zookeeper使用了TCP协议和Leader。通过使用TCP协议保证了消息的全序的特性（先发先到），通过Leader解决了因果顺序(先到Leader先执行)。因为有了Leader，Zookeeper的架构就变成为：Master-Slave模式，但在该模式中Master（Leader）会Crash，因此，Zookeeper引入Leader选举算法，以保证系统的健壮性。</p>
<p>当Zookeeper Server收到写操作，Follower会将其转发给Leader，由Leader执行操作。Client可以直接从Follower上读取数据，如果需要读取最新数据，则需要从Leader节点读取，Zookeeper设计的读写比大致为2：1。</p>
<p>Leader执行写操作可以简化为一个两段式提交的transaction：</p>
<ol>
<li>Leader发送proposal给所有的Follower。</li>
<li>收到proposal后，Follower回复ACK给Leader，接受Leader的proposal.</li>
<li>当Leader收到大多数的Follower的ACK后，将commit其proposal。</li>
</ol>
<p><a href="http://www.yidooo.net/images/broadcast.png" target="_blank" rel="noopener"><img src="http://www.yidooo.net/images/broadcast.png" alt="broadcast"></a></p>
<p>在这个过程中，proposal的确认不需要所有节点都同意，如果有2n+1个节点，那么只要有n个节点同意即可，也就是说Zookeeper允许n个节点down掉。任何两个多数派必然有交集，在Leader切换（Leader down）时，这些交集依然保持着最新的系统状态。如果集群节点个数少于n+1个时，Zookeeper将无法进行同步，也就无法继续工作。</p>
<h4 id="Zab与Paxos"><a href="#Zab与Paxos" class="headerlink" title="Zab与Paxos"></a>Zab与Paxos</h4><p>Zab的作者认为Zab与paxos并不相同，只所以没有采用Paxos是因为Paxos保证不了全序顺序：</p>
<blockquote>
<p>Because multiple leaders can propose a value for a given instance two problems arise.<br>First, proposals can conflict. Paxos uses ballots to detect and resolve conflicting proposals.<br>Second, it is not enough to know that a given instance number has been committed, processes must also be able to figure out which value has been committed.</p>
</blockquote>
<p>举个例子。假设一开始Paxos系统中的Leader是P1，他发起了两个事务{t1, v1}（表示序号为t1的事务要写的值是v1）和{t2, v2}，过程中Leader挂了。新来个Leader是P2，他发起了事务{t1, v1’}。而后又来个新Leader是P3，他汇总了一下，得出最终的执行序列{t1, v1’}和{t2, v2}。</p>
<p>这样的序列为什么不能满足ZooKeeper的需求呢？ZooKeeper是一个树形结构，很多操作都要先检查才能确定能不能执行，比如P1的事务t1可能是创建节点“/a”，t2可能是创建节点“/a/aa”，只有先创建了父节点“/a”，才能创建子节点“/a/aa”。而P2所发起的事务t1可能变成了创建“/b”。这样P3汇总后的序列是先创建“/b”再创建“/a/aa”，由于“/a”还没建，创建“a/aa”就搞不定了。</p>
<p>为了保证这一点，ZAB要保证同一个leader的发起的事务要按顺序被apply，同时还要保证只有先前的leader的所有事务都被apply之后，新选的leader才能在发起事务。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="http://www.yidooo.net/2014/10/22/zab.html" target="_blank" rel="noopener">http://www.yidooo.net/2014/10/22/zab.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat是如何实现异步Servlet的</title>
    <url>/2020/02/28/2020/02/Tomcat%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5Servlet%E7%9A%84/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>通过我之前的Tomcat系列文章，相信看我博客的同学对Tomcat应该有一个比较清晰的了解了，在前几篇博客我们讨论了Tomcat在SpringBoot框架中是如何启动的，讨论了Tomcat的内部组件是如何设计以及请求是如何流转的，那么我们这篇博客聊聊Tomcat的异步Servlet，Tomcat是如何实现异步Servlet的以及异步Servlet的使用场景。</p>
<h4 id="手撸一个异步的Servlet"><a href="#手撸一个异步的Servlet" class="headerlink" title="手撸一个异步的Servlet"></a>手撸一个异步的Servlet</h4><p>我们直接借助SpringBoot框架来实现一个Servlet,这里只展示Servlet代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/async"</span>,asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService =Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//开启异步,获取异步上下文</span></span><br><span class="line">        <span class="keyword">final</span> AsyncContext ctx = req.startAsync();</span><br><span class="line">        <span class="comment">// 提交线程池异步执行</span></span><br><span class="line">        executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"async Service 准备执行了"</span>);</span><br><span class="line">                    <span class="comment">//模拟耗时任务</span></span><br><span class="line">                    Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line">                    ctx.getResponse().getWriter().print(<span class="string">"async servlet"</span>);</span><br><span class="line">                    log.info(<span class="string">"async Service 执行了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//最后执行完成后完成回调。</span></span><br><span class="line">                ctx.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现了一个异步的Servlet,实现了<code>doGet</code>方法注意在SpringBoot中使用需要再启动类加上<code>@ServletComponentScan</code>注解来扫描Servlet。既然代码写好了，我们来看看实际运行效果。</p>
<p><img src="https://github.com/kinglaw1204/blogImage/blob/master/Tomcat%E8%A7%A3%E6%9E%90/%E5%BC%82%E6%AD%A5Servlet/async%20Servlet%20result.png?raw=true" alt="img"></p>
<p>我们发送一个请求后，看到页面有响应，同时，看到请求时间花费了10.05s,那么我们这个Servlet算是能正常运行啦。有同学肯定会问，这不是异步servlet吗？你的响应时间并没有加快，有什么用呢？对，我们的响应时间并不能加快，还是会取决于我们的业务逻辑，但是我们的异步servlet请求后，依赖于业务的异步执行，我们可以立即返回，也就是说，Tomcat的线程可以立即回收，默认情况下，Tomcat的核心线程是<strong>10</strong>，最大线程数是<strong>200</strong>,我们能及时回收线程，也就意味着我们能处理更多的请求，能够增加我们的吞吐量，这也是异步Servlet的主要作用。</p>
<h4 id="异步Servlet的内部原理"><a href="#异步Servlet的内部原理" class="headerlink" title="异步Servlet的内部原理"></a>异步Servlet的内部原理</h4><p>了解完异步Servlet的作用后，我们来看看，Tomcat是如何是先异步Servlet的。其实上面的代码，主要核心逻辑就两部分，<code>final AsyncContext ctx = req.startAsync()</code>和<code>ctx.complete()</code>那我们来看看他们究竟做了什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AsyncContext <span class="title">startAsync</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">         ServletResponse response)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!isAsyncSupported()) &#123;</span><br><span class="line">         IllegalStateException ise =</span><br><span class="line">                 <span class="keyword">new</span> IllegalStateException(sm.getString(<span class="string">"request.asyncNotSupported"</span>));</span><br><span class="line">         log.warn(sm.getString(<span class="string">"coyoteRequest.noAsync"</span>,</span><br><span class="line">                 StringUtils.join(getNonAsyncClassNames())), ise);</span><br><span class="line">         <span class="keyword">throw</span> ise;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (asyncContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">         asyncContext = <span class="keyword">new</span> AsyncContextImpl(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     asyncContext.setStarted(getContext(), request, response,</span><br><span class="line">             request==getRequest() &amp;&amp; response==getResponse().getResponse());</span><br><span class="line">     asyncContext.setTimeout(getConnector().getAsyncTimeout());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> asyncContext;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们发现<code>req.startAsync()</code>只是保存了一个异步上下文，同时设置一些基础信息，比如<code>Timeout</code>,顺便提一下，这里设置的默认超时时间是<strong>30S</strong>，如果你的异步处理逻辑超过<strong>30S</strong>,此时执行<code>ctx.complete()</code>就会抛出IllegalStateException 异常。</p>
<p>我们来看看<code>ctx.complete()</code>的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            logDebug(<span class="string">"complete   "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        check();</span><br><span class="line">        request.getCoyoteRequest().action(ActionCode.ASYNC_COMPLETE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//类：AbstractProcessor </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(ActionCode actionCode, Object param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ASYNC_COMPLETE: &#123;</span><br><span class="line">            clearDispatches();</span><br><span class="line">            <span class="keyword">if</span> (asyncStateMachine.asyncComplete()) &#123;</span><br><span class="line">                processSocketEvent(SocketEvent.OPEN_READ, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类：AbstractProcessor </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processSocketEvent</span><span class="params">(SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">        SocketWrapperBase&lt;?&gt; socketWrapper = getSocketWrapper();</span><br><span class="line">        <span class="keyword">if</span> (socketWrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            socketWrapper.processSocket(event, dispatch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//类：AbstractEndpoint</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">            SocketEvent event, <span class="keyword">boolean</span> dispatch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">            SocketProcessorBase&lt;S&gt; sc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (processorCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sc = processorCache.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.reset(socketWrapper, event);</span><br><span class="line">            &#125;</span><br><span class="line">            Executor executor = getExecutor();</span><br><span class="line">            <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sc.run();</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以，这里最终会调用<code>AbstractEndpoint</code>的<code>processSocket</code>方法，之前看过我前面博客的同学应该有印象，<code>EndPoint</code>是用来接受和处理请求的，接下来就会交给<code>Processor</code>去进行协议处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类：AbstractProcessorLight</span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分diam</span></span><br><span class="line">        SocketState state = SocketState.CLOSED;</span><br><span class="line">        Iterator&lt;DispatchType&gt; dispatches = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">                DispatchType nextDispatch = dispatches.next();</span><br><span class="line">                state = dispatch(nextDispatch.getSocketStatus());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.DISCONNECT) &#123;</span><br><span class="line">            </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync() || isUpgrade() || state == SocketState.ASYNC_END) &#123;</span><br><span class="line">                state = dispatch(status);</span><br><span class="line">                <span class="keyword">if</span> (state == SocketState.OPEN) &#123;</span><br><span class="line">                    state = service(socketWrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">                state = SocketState.LONG;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_READ)&#123;</span><br><span class="line">                state = service(socketWrapper);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = SocketState.CLOSED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (state == SocketState.ASYNC_END ||</span><br><span class="line">                dispatches != <span class="keyword">null</span> &amp;&amp; state != SocketState.CLOSED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这部分是重点，<code>AbstractProcessorLight</code>会根据<code>SocketEvent</code>的状态来判断是不是要去调用<code>service(socketWrapper)</code>,该方法最终会去调用到容器，从而完成业务逻辑的调用，我们这个请求是执行完成后调用的，肯定不能进容器了，不然就是死循环了，这里通过<code>isAsync()</code>判断，就会进入<code>dispatch(status)</code>,最终会调用<code>CoyoteAdapter</code>的<code>asyncDispatch</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">asyncDispatch</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res,</span></span></span><br><span class="line"><span class="function"><span class="params">            SocketEvent status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        Request request = (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">        Response response = (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">        AsyncContextImpl asyncConImpl = request.getAsyncContextInternal();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!request.isAsync()) &#123;</span><br><span class="line">                response.setSuspended(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (status==SocketEvent.TIMEOUT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!asyncConImpl.timeout()) &#123;</span><br><span class="line">                    asyncConImpl.setErrorState(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status==SocketEvent.ERROR) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!request.isAsyncDispatching() &amp;&amp; request.isAsync()) &#123;</span><br><span class="line">                WriteListener writeListener = res.getWriteListener();</span><br><span class="line">                ReadListener readListener = req.getReadListener();</span><br><span class="line">                <span class="keyword">if</span> (writeListener != <span class="keyword">null</span> &amp;&amp; status == SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">                    ClassLoader oldCL = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        oldCL = request.getContext().bind(<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                        res.onWritePossible();<span class="comment">//这里执行浏览器响应，写入数据</span></span><br><span class="line">                        <span class="keyword">if</span> (request.isFinished() &amp;&amp; req.sendAllDataReadEvent() &amp;&amp;</span><br><span class="line">                                readListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            readListener.onAllDataRead();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                       </span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        request.getContext().unbind(<span class="keyword">false</span>, oldCL);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里判断异步正在进行，说明这不是一个完成方法的回调，是一个正常异步请求，继续调用容器。</span></span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br><span class="line">                Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    asyncConImpl.setErrorState(t, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意，这里，如果超时或者出错，request.isAsync()会返回false，这里是为了尽快的输出错误给客户端。</span></span><br><span class="line">            <span class="keyword">if</span> (!request.isAsync()) &#123;</span><br><span class="line">                <span class="comment">//这里也是输出逻辑</span></span><br><span class="line">                request.finishRequest();</span><br><span class="line">                response.finishResponse();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//销毁request和response</span></span><br><span class="line">            <span class="keyword">if</span> (!success || !request.isAsync()) &#123;</span><br><span class="line">                updateWrapperErrorCount(request, response);</span><br><span class="line">                request.recycle();</span><br><span class="line">                response.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是<code>ctx.complete()</code>执行最终的方法了（当然省略了很多细节），完成了数据的输出，最终输出到浏览器。</p>
<p>这里有同学可能会说，我知道异步执行完后，调用<code>ctx.complete()</code>会输出到浏览器，但是，第一次doGet请求执行完成后，Tomcat是怎么知道不用返回到客户端的呢？关键代码在<code>CoyoteAdapter</code>中的<code>service</code>方法，部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">          <span class="comment">//省略部分代码</span></span><br><span class="line">          <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">              request.setAsyncSupported(</span><br><span class="line">                      connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">              connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                      request, response);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">              async = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//输出数据到客户端</span></span><br><span class="line">              request.finishRequest();</span><br><span class="line">              response.finishResponse();</span><br><span class="line">          <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">              updateWrapperErrorCount(request, response);</span><br><span class="line">              <span class="comment">//销毁request和response</span></span><br><span class="line">              request.recycle();</span><br><span class="line">              response.recycle();</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码在调用完<code>Servlet</code>后，会通过<code>request.isAsync()</code>来判断是否是异步请求，如果是异步请求，就设置<code>async = true</code>。如果是非异步请求就执行输出数据到客户端逻辑，同时销毁<code>request</code>和<code>response</code>。这里就完成了请求结束后不响应客户端的操作。</p>
<h4 id="为什么说Spring-Boot的-EnableAsync注解不是异步Servlet"><a href="#为什么说Spring-Boot的-EnableAsync注解不是异步Servlet" class="headerlink" title="为什么说Spring Boot的@EnableAsync注解不是异步Servlet"></a>为什么说Spring Boot的@EnableAsync注解不是异步Servlet</h4><p>因为之前准备写本篇文章的时候就查询过很多资料，发现很多资料写SpringBoot异步编程都是依赖于<code>@EnableAsync</code>注解，然后在<code>Controller</code>用多线程来完成业务逻辑，最后汇总结果，完成返回输出。这里拿一个掘金大佬的文章来举例《<a href="https://juejin.im/post/5d9e7cfa6fb9a04e1f12ec02" target="_blank" rel="noopener">新手也能看懂的 SpringBoot 异步编程指南</a>》，这篇文章写得很通俗易懂，非常不错，从业务层面来说，确实是异步编程，但是有一个问题，抛开业务的并行处理来说，针对整个请求来说，并不是异步的，也就是说不能立即释放Tomcat的线程，从而不能达到异步Servlet的效果。这里我参考上文也写了一个demo，我们来验证下，为什么它不是异步的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"testAsynch Start"</span>);</span><br><span class="line">            CompletableFuture&lt;String&gt; test1 = service.test1();</span><br><span class="line">            CompletableFuture&lt;String&gt; test2 = service.test2();</span><br><span class="line">            CompletableFuture&lt;String&gt; test3 = service.test3();</span><br><span class="line">            CompletableFuture.allOf(test1, test2, test3);</span><br><span class="line">            log.info(<span class="string">"test1====="</span> + test1.get());</span><br><span class="line">            log.info(<span class="string">"test2====="</span> + test2.get());</span><br><span class="line">            log.info(<span class="string">"test3====="</span> + test3.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">"test1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">"test2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">"test3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatdebugApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TomcatdebugApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">asyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"AsynchThread-"</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我运行下，看看效果</p>
<p><img src="https://github.com/kinglaw1204/blogImage/blob/master/Tomcat%E8%A7%A3%E6%9E%90/%E5%BC%82%E6%AD%A5Servlet/Spring%20boot%20%E5%BC%82%E6%AD%A51.gif?raw=true" alt="img"></p>
<p>这里我请求之后，在调用容器执行业务逻辑之前打了一个断点，然后在返回之后的同样打了一个断点，在<code>Controller</code>执行完之后，请求才回到了<code>CoyoteAdapter</code>中，并且判断<code>request.isAsync()</code>,根据图中看到，是为<code>false</code>,那么接下来就会执行<code>request.finishRequest()</code>和<code>response.finishResponse()</code> 来执行响应的结束，并销毁请求和响应体。很有趣的事情是，我实验的时候发现，在执行<code>request.isAsync()</code>之前，浏览器的页面上已经出现了响应体，这是SpringBoot框架已经通过<code>StringHttpMessageConverter</code>类中的<code>writeInternal</code>方法已经进行输出了。</p>
<p><strong>以上分析的核心逻辑就是</strong>，Tomcat的线程执行<code>CoyoteAdapter</code>调用容器后，必须要等到请求返回，然后再判断是否是异步请求，再处理请求，然后执行完毕后，线程才能进行回收。而我一最开始的异步Servlet例子，执行完doGet方法后，就会立即返回，也就是会直接到<code>request.isAsync()</code>的逻辑，然后整个线程的逻辑执行完毕，线程被回收。</p>
<h4 id="聊聊异步Servlet的使用场景"><a href="#聊聊异步Servlet的使用场景" class="headerlink" title="聊聊异步Servlet的使用场景"></a>聊聊异步Servlet的使用场景</h4><p>分析了这么多，那么异步Servlet的使用场景有哪些呢？其实我们只要抓住一点就可以分析了，就是异步Servlet提高了系统的吞吐量，可以接受更多的请求。假设web系统中Tomcat的线程不够用了，大量请求在等待，而此时Web系统应用层面的优化已经不能再优化了，也就是无法缩短业务逻辑的响应时间了，这个时候，如果想让减少用户的等待时间，提高吞吐量，可以尝试下使用异步Servlet。</p>
<p><strong>举一个实际的例子</strong>：比如做一个短信系统，短信系统对实时性要求很高，所以要求等待时间尽可能短，而发送功能我们实际上是委托运营商去发送的，也就是说我们要调用接口，假设并发量很高，那么这个时候业务系统调用我们的发送短信功能，就有可能把我们的Tomcat线程池用完，剩下的请求就会在队列中等待，那这个时候，短信的延时就上去了，为了解决这个问题，我们可以引入异步Servlet,接受更多的短信发送请求，从而减少短信的延时。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这篇文章我从手写一个异步Servlet来开始，分析了异步Servlet的作用，以及Tomcat内部是如何实现异步Servlet的，然后我也根据互联网上流行的SpringBoot异步编程来进行说明，其在Tomcat内部并不是一个异步的Servlet。最后，我谈到了异步Servlet的使用场景，分析了什么情况下可以尝试异步Servlet。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你快速掌握AQS</title>
    <url>/2020/02/12/2020/02/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1AQS/</url>
    <content><![CDATA[<p>作者：薛8</p>
<p>来源：<a href="https://juejin.im/post/5c890b4a51882501351d5929" target="_blank" rel="noopener">https://juejin.im/post/5c890b4a51882501351d5929</a></p>
<h4 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h4><p><strong><code>AbstractQueuedSynchronizer</code>抽象队列同步器</strong>，简称为<code>AQS</code>，可用于构建<strong>阻塞锁</strong>或者其他相关<strong>同步器</strong>的基础框，是Java并发包的基础工具类。通过<code>AQS</code>这个框架可以对<strong>同步状态原子性管理、线程的阻塞和解除阻塞、队列的管理</strong>进行统一管理。<br> <code>AQS</code>是抽象类，并不能直接实例化，当需要使用<code>AQS</code>的时候需要继承<code>AQS</code>抽象类并且重写指定的方法，这些重写方法包括<strong>线程获取资源和释放资源的方式</strong>(如ReentractLock通过分别重写线程获取和释放资源的方式实现了公平锁和非公平锁)，<strong>同时子类还需要负责共享变量state的维护，如当state为0时表示该锁没有被占，大于0时候代表该锁被一个或多个线程占领(重入锁)</strong>，而队列的维护(获取资源失败入队、线程唤醒、线程的状态等)不需要我们考虑，<code>AQS</code>已经帮我们实现好了。<code>AQS</code>的这种设计模式采用的正是<strong>模板方法模式</strong>。<br> <strong>总结起来子类的任务有：</strong></p>
<ol>
<li>通过<code>CAS</code>操作维护共享变量<code>state</code>。</li>
<li>重写资源的获取方式。</li>
<li>重写资源释放的方式。</li>
</ol>
<blockquote>
<p>如果对CAS和Java内存模型还不清楚的，建议先了解这两者之后再食用本文，效果更佳！<a href="https://ddnd.cn/2019/03/13/java-cas/" target="_blank" rel="noopener">CAS原理分析及ABA问题详解</a>         <a href="https://ddnd.cn/2019/03/11/java-memory-model/" target="_blank" rel="noopener">什么是Java内存模型？</a></p>
</blockquote>
<p>完成以上三个任务即可实现自己的锁。<br> <code>AQS</code>作为<code>J.U.C</code>的工具类，面向的是需要实现<strong>锁的实现者</strong>，而锁面向的是<strong>锁的使用者</strong>，这两者的区别还是需要搞清楚的。</p>
<h4 id="AQS数据结构"><a href="#AQS数据结构" class="headerlink" title="AQS数据结构"></a>AQS数据结构</h4><p>先看<code>AQS</code>有哪些重要的成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，不过也是最简单的，代表当前锁的状态，0代表没有被占用，大于0代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 之所以说大于0，而不是等于1，是因为锁可以重入嘛，每次重入都加上1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure>

<p>然后再看看<code>AQS</code>的内部结构，<code>AQS</code>内部数据结构为一个<strong>双向链表</strong>和一个<strong>单向链表</strong>，双链表为同步队列，队列中的每个节点对应一个<code>Node</code>内部类，<code>AQS</code>通过控制链表的节点而达到阻塞、同步的目的，单链表为条件队列，<strong>可以把同步队列和条件队列理解成储存等待状态的线程的队列</strong>，但是条件队列中的线程并不能直接去获取资源，而要先从条件队列转到同步队列中排队获取，同步队列的唤醒结果是线程去尝试获取锁，而条件队列的唤醒结果是把线程从条件队列移到同步队列中，一个线程要么是在同步队列中，要么是在条件队列中，不可能同时存在这两个队列里面。</p>
<p><img src="http://static.cyblogs.com/169ae1c4f86ba568.png" alt="http://static.cyblogs.com/169ae1c4f86ba568.png"></p>
<blockquote>
<p>Java<strong>阻塞状态</strong>和<strong>等待状态</strong>的线程从Linux内核来看，都是阻塞(等待)状态，它们都会让出CPU时间片。Java为了方便管理线程将“阻塞(等待)”状态细分成了阻塞状态和等待状态，这两个状态的区别<strong>在于由谁去唤醒</strong>，是操作系统还是其他线程。Java线程请求某一个资源失败的时候就会进入<strong>阻塞状态</strong>，处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。而当线程调用<code>wait</code>、<code>join</code>、<code>pack</code>函数时候会进入<strong>等待状态</strong>，需要其它线程显性的唤醒否则会无限期的处于等待状态。</p>
</blockquote>
<p>Java线程6状态图：</p>
<p><img src="http://static.cyblogs.com/169ae1c4f87a969e.png" alt="http://static.cyblogs.com/169ae1c4f87a969e.png"></p>
<p>内部类<code>Node</code>详解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代表当前节(线程)点是共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">//代表当前节点(线程)是独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//代表当前节点(线程)已被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//代表当前节点(线程)的后继节点需要被提醒唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//代表节点(线程)在 Condition queue中，等待某一条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//代表当前节点的后继节点(线程)会传传播唤醒的操作，仅在共享模式下才有作用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//代表当前节点的状态，它的取值除了以上说的CANCELLED、SIGNAL、CONDITION、PROPAGATE，同时</span></span><br><span class="line">    <span class="comment">//还可能为0，为0的时候代表当前节点在sync队列中，阻塞着排队获取锁。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">//当前节点的前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">//当前节点的后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//当前节点关联的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">//在condition队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前节点是否为共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回当前节点的前驱节点 没有前驱节点则抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程都关联一个节点，节点的状态也代表着线程的状态，<code>AQS</code>通过对同步队列的管理而达到对线程的管理。</p>
<h4 id="AQS的功能"><a href="#AQS的功能" class="headerlink" title="AQS的功能"></a>AQS的功能</h4><p><code>AQS</code>提供了<code>2</code>大功能，基于双链表的同步队列和基于单链表的条件队列，同步队列维护的是<strong>阻塞状态的线程对应的节点</strong>，这些线程都是阻塞着排队获取锁的，条件队列维护的是<strong>等待状态的线程对应的节点</strong>。</p>
<h5 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h5><p><code>AQS</code>提供了两种方式去获取资源，分别是<strong>共享模式</strong>和<strong>独占模式</strong>，但是一般锁只会去继承其中一种模式，不会在一个锁里同时存在<strong>共享模式</strong>和<strong>独占模式</strong>两种模式。</p>
<blockquote>
<p>资源指锁、IO、Socket等</p>
</blockquote>
<p>当一个线程以共享模式或独占模式去获取资源的时候，如果获取失败则将该线程封装成<code>Node</code>节点(同时将该节点标识为共享模式或独占模式)<strong>加入到同步队列的尾部</strong>，<code>AQS</code>实时维护着这个同步队列，这个队列以<strong>FIFO(先进先出)来管理节点的排队</strong>，即资源的转移(获取再释放)的顺序是从头结点开始到尾节点。</p>
<p><img src="http://static.cyblogs.com/169ae1c4f8d7e8d6.png" alt="http://static.cyblogs.com/169ae1c4f8d7e8d6.png"></p>
<p>共享模式和独占模式去获取、释放资源都分别对应着一套<code>API</code>，以下分别分析这两套<code>API</code></p>
<blockquote>
<p>独占模式即获取资源的<strong>排他锁</strong>，共享模式及获取资源的<strong>共享锁</strong>。</p>
</blockquote>
<h6 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h6><p>独占模式即一个线程获取到资源后，其他线程不能再对资源进行任何操作，只能阻塞获得资源。</p>
<h6 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h6><ol>
<li>线程调用子类重写的<code>tryAcquire</code>方法获取资源，如果获取成功，则流程结束，否则继续往下执行。</li>
<li>调用<code>addWaiter</code>方法(详细过程看下面的源码解析)，将该线<strong>程封装成Node节点</strong>，并添加到队列<strong>队尾</strong>。</li>
<li>调用<code>acquireQueued</code>方法让节点以”死循环”方式进行获取资源，为什么死循环加了双引号呢？因为循环并不是一直让节点无间断的去获取资源，节点会经历 获取资源-&gt;失败-&gt;线程进入等待状态-&gt;唤醒-&gt;获取资源……，<strong>线程在死循环的过程会不断等待和唤醒</strong>，节点进入到自旋状态(详细过程看下面的源码解析)，<strong>再循环过程中还会将标识为取消的前驱节点移除队列，同时标识前驱节点状态为SIGNAL</strong>。</li>
<li>线程的等待状态是通过调用<code>LockSupport.lock()</code>方法实现的，这个方法会响应<code>Thread.interrupt</code>，但是不会抛出InterruptedException异常，这点与<code>Thread.sleep</code>、<code>Thread.wait</code>不一样。</li>
</ol>
<p><img src="http://static.cyblogs.com/169ae1c4f8c40a95.png" alt="http://static.cyblogs.com/169ae1c4f8c40a95.png"></p>
<p><img src="http://static.cyblogs.com/169ae1c4f8e8cde5.png" alt="http://static.cyblogs.com/169ae1c4f8e8cde5.png"></p>
<p><strong>可以看到节点和节点之间在自旋过程中除了前驱节点会唤醒该节点之外基本不会互相通讯</strong></p>
<p><strong>源码分析</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该线程调用tryAcquire方法尝试以独占模式获取资源，如果获取失败，则调</span></span><br><span class="line">    <span class="comment">//用addWaiter函数，将线程封装到Node节点中，然后再将Node节点加入到同</span></span><br><span class="line">    <span class="comment">//步队列的尾部，然后再调用acquireQueued让线程进入到阻塞状态，如果获</span></span><br><span class="line">    <span class="comment">//取成功则返回true，然后调用selfInterrupt</span></span><br><span class="line">    <span class="comment">//函数。</span></span><br><span class="line">    <span class="comment">//注意的是，tryAcquire函数就是继承AQS的子类所需要去重写的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS的tryAcquire函数并没有获取资源的相关实现，需要继承`AQS`的子类去</span></span><br><span class="line"><span class="comment">//重写这个方法。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//创建新的节点，并将线程和节点关联。</span></span><br><span class="line">    <span class="comment">//将同步队列的尾节点后继节点指向新节点，</span></span><br><span class="line">    <span class="comment">//将新节点的前驱节点指向尾节点，</span></span><br><span class="line">    <span class="comment">//新节点称为同步队列的尾节点。</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//CAS操作将新节点插入到，成功则返回，不成功则继续下面的enq方法，</span></span><br><span class="line">        <span class="comment">//进行死循环CAS插入，直到成功。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果上面的CAS操作插入不成功，则调用enq方法 死循环插入 直到成功。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//死循环 直到插入成功。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//如果尾节点为null，说明同步队列还未初始化，则CAS操作新建头节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过CAS操作将节点插入到同步队列尾部</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点以“死循环”的方式去获取资源，为什么死循环加了双引号呢？因为循环并不</span></span><br><span class="line"><span class="comment">//是一直让节点无间断的去获取资源，节点会经历 获取资源-&gt;失败-&gt;线程进入等待</span></span><br><span class="line"><span class="comment">//状态-&gt;唤醒-&gt;获取资源......，线程在死循环的过程会不断等待和唤醒，即节点的自旋。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱节点为头结点，表示资源正在前驱节点的手上，那该节点</span></span><br><span class="line">            <span class="comment">//去尝试获取资源，如果获取成功则将该节点设置为头结点，并且</span></span><br><span class="line">            <span class="comment">//返回。</span></span><br><span class="line">            <span class="comment">//如果该节点的前驱节点并不是头节点或者是前驱节点是头结点但是</span></span><br><span class="line">            <span class="comment">//该节点获取资源失败，继续往下执行。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用shouldParkAfterFailedAcquire函数，将该节点的前驱节点</span></span><br><span class="line">            <span class="comment">//的状态设置为SIGNAL，告诉前驱节点我要去“睡觉”了，当资源排</span></span><br><span class="line">            <span class="comment">//到你的时候，你就通知我一下让我醒来，即节点做进入等待状态</span></span><br><span class="line">            <span class="comment">//的准备。</span></span><br><span class="line">            <span class="comment">//当节点做好了进入等待状态的准备，则调用parkAndCheckInterrupt</span></span><br><span class="line">            <span class="comment">//函数，让该节点进入到等待状态。</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取前驱节点的状态。</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">//如果前驱节点的状态已经为SIGNAL了，即已经做好准备了，那直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果前驱节点的状态为取消状态，则将前驱节点移除队列，循环这个过程</span></span><br><span class="line">    <span class="comment">//直到前驱节点不为取消状态为止。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    <span class="comment">//如果前驱节点没有做好准备(标志状态为SIGNAL)、前驱节点也没有被取消，</span></span><br><span class="line">    <span class="comment">//则使用CAS操作将前驱节点的状态更新为SIGNAL，然后返回false，为什么</span></span><br><span class="line">    <span class="comment">//是返回false呢？因为CAS操作并不保证一定能更新成功，返回false的目的</span></span><br><span class="line">    <span class="comment">//是让acquireQueued函数再执行一次for循环，这个循环第一可以让该节点</span></span><br><span class="line">    <span class="comment">//再尝试获取资源(万一成功了呢 是吧)，第二是让acquireQueued函数再调用</span></span><br><span class="line">    <span class="comment">//一次shouldParkAfterFailedAcquire函数(即本函数)判断节点的前驱节点是</span></span><br><span class="line">    <span class="comment">//否已经设置为SIGNAL状态了。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用LockSupport.park函数将该线程设置为等待状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//注意LockSupport遇到Thread.interrupt是会立刻返回的，但是不会抛出异常InterruptedExcept</span></span><br><span class="line">    <span class="comment">//ion，这个需要注意和Thread.wait，Thread.sleep的区别，</span></span><br><span class="line">    <span class="comment">//唤醒的时候 会返回该线程是否为中断唤醒的。</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h6><ol>
<li>线程调用子类重写的<code>tryRelease</code>方法进行释放资源，如果释放成功则继续检查线程(节点)的是否有后继节点，有后继几点则去<strong>唤醒</strong>。</li>
<li>调用<code>unparkSuccessor</code>方法进行后继节点的唤醒，<strong>如果后继节点为取消状态，则从队列的队尾往前遍历，找到一个离节点最近且不为取消状态的节点进行唤醒，如果后继节点不为取消状态则直接唤醒</strong>。</li>
</ol>
<p><img src="http://static.cyblogs.com/169ae1c515d4bfe8.png" alt="http://static.cyblogs.com/169ae1c515d4bfe8.png"></p>
<p><strong>源码解析</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程调用tryRelease方法尝试释放资源，如果释放成功则检查该节点是否有后继节点，有的话则</span></span><br><span class="line">    <span class="comment">//调用unpacrkSuccessor()方法去唤醒后继节点。</span></span><br><span class="line">    <span class="comment">//注意的是，tryRelease函数就是继承AQS的子类所需要去重写的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//头结点(即释放资源的节点)不为空，头结点的状态不为0，代表有后继节点，需要唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取头结点状态。</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">//如果状态小于0，即代表有后继节点需要唤醒。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//将头结点的状态置为0 因为只需要唤醒一次</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//如果头结点的后继节点为空 或者 头结点的后继节点处于取消状态，则从尾部开始往前寻找，</span></span><br><span class="line">    <span class="comment">//找到一个离头结点最近 且状态不是取消状态的节点。</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果头结点的后继节点不为取消状态，则直接将后继节点唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h5><p>共享模式下，线程无论是<strong>获取资源还是释放资源，都可能会唤醒后继节点</strong>。</p>
<h6 id="获取资源-1"><a href="#获取资源-1" class="headerlink" title="获取资源"></a>获取资源</h6><ol>
<li>调用子类重写的<code>tryAcquireShared</code>方法进行资源获取，获取失败则调用<code>doAcquireShared</code>将<strong>线程封装Node节点加入到同步队列队尾</strong>。</li>
<li>调用<code>doAcquireShared</code>方法让节点以”死循环”方式进行获取资源，为什么死循环加了双引号呢？因为循环并不是一直让节点无间断的去获取资源，节点会经历获取资源-&gt;失败-&gt;线程进入等待状态-&gt;唤醒-&gt;获取资源……，线程在死循环的过程会不断等待和唤醒，节点进入到自旋状态(详细过程看下面的源码解析)。<strong>如果线程节点被唤醒后，且获取资源成功，且后继节点为共享模式，那么会唤醒后继节点……唤醒会一直传递下去，直到后继节点不是共享模式，唤醒的节点同样会去获取资源</strong>，这点和独占模式不一样。</li>
</ol>
<p><img src="http://static.cyblogs.com/169ae1c51e6294d8.png" alt="http://static.cyblogs.com/169ae1c51e6294d8.png"></p>
<p><img src="http://static.cyblogs.com/169ae1c520e21e80.png" alt="http://static.cyblogs.com/169ae1c520e21e80.png"></p>
<p><strong>共享模式资源的获取和独占模式资源的获取流程差不多，就是在获取资源成功后，会唤醒为共享模式的后继节点，然后被唤醒的后继节点也去获取资源</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//和独占模式的一样，同样是调用子类重写的tryAcquireShared方法以共享模式进行资源获取。</span></span><br><span class="line">    <span class="comment">//如果获取失败，则调用doAcquireShared方法将线程封装成Node节点加入到同步队列的队尾，</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将线程封装到节点中，且将节点加入到队尾中。</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取线程(节点)的前驱节点。</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱节点为头结点，则该线程尝试获取资源。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//获取资源。</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//获取资源成功则将节点设为头结点。</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取成功 对后继SHARED节点持续唤醒</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//和独占模式的一样。</span></span><br><span class="line">            <span class="comment">//调用shouldParkAfterFailedAcquire函数，将该节点的前驱节点</span></span><br><span class="line">            <span class="comment">//的状态设置为SIGNAL，告诉前驱节点我要去“睡觉”了，当资源排</span></span><br><span class="line">            <span class="comment">//到你的时候，你就通知我一下让我醒来，即节点做进入等待状态的准备。</span></span><br><span class="line">            <span class="comment">//当节点做好了进入等待状态的准备，则调用parkAndCheckInterrupt</span></span><br><span class="line">            <span class="comment">//函数，让该节点进入到等待状态。            </span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//如果节点为共享节点，则调用doReleaseShared函数唤醒后继节点。</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="释放资源-1"><a href="#释放资源-1" class="headerlink" title="释放资源"></a>释放资源</h6><ol>
<li>调用子类重写的<code>tryReleaseShared</code>方法释放资源，释放成功则调用<code>doReleaseShared</code>方法进行后继节点的唤醒。</li>
<li>如果后继节点为共享模式，则持续唤醒。</li>
</ol>
<p><img src="http://static.cyblogs.com/169ae1c5271b53d9.png" alt="http://static.cyblogs.com/169ae1c5271b53d9.png"></p>
<p><strong>共享模式下资源释放流程和独占模式下资源释放的流程差不多，就是在释放后唤醒后继为共享模式的节点，且唤醒的动作是传播下去的，直到后继节点出现不是共享模式的，这个唤醒的过程和共享模式的获取资源的唤醒过程一样。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用子类重写的tryReleaseShared方法进行以共享模式释放资源，释放失败则调用doReleaseShared。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">//如果节点标识后继节点需要唤醒，则调用unparkSuccessor方法进行唤醒。</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h4><p>条件队列又称等待队列、条件队列等，条件队列的实现是通过<code>ConditionObject</code>的内之类来完成的，，一开始就介绍了同步队列条件队列的去，不过这里再啰嗦一下，<strong>可以把同步队和条件队列理解成储存等待状态的线程的队列</strong>，条件队列中的线程并不能直接去获取资源，而要先从条件队列转到同步队列中排队获取，一个线程要么是在同步队列中，要么是在条件队列中，不可能同时存在这两个队列里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 使当前线程进入等待状态，直到以下4种情况任意一个发生：</span></span><br><span class="line"><span class="comment"> * 1.另一个线程调用该对象的signal()，当前线程恰好是被选中的唤醒线程</span></span><br><span class="line"><span class="comment"> * 2.另一个线程调用该对象的signalAll()</span></span><br><span class="line"><span class="comment"> * 3.另一个线程interrupt当前线程（此时会抛出InterruptedException）</span></span><br><span class="line"><span class="comment"> * 4.虚假唤醒（源自操作系统，发生概率低）</span></span><br><span class="line"><span class="comment"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 与await()相同，但是不会被interrupt唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 与await()相同，增加了超时时间，超过超时时间也会停止等待</span></span><br><span class="line"><span class="comment"> * 三个方法功能相似，其返回值代表剩余的超时时间，或是否超时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 唤醒一个正在等待该条件变量对象的线程</span></span><br><span class="line"><span class="comment"> * ConditionObject会选择等待时间最长的线程来唤醒</span></span><br><span class="line"><span class="comment"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 唤醒所有正在等待该条件变量对象的线程</span></span><br><span class="line"><span class="comment"> * ConditionObject要求调用时该线程已经拿到了其外部AQS类的排它锁（acquire成功）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，其作用与Object原生的wait()/notify()/notifyAll()很相似，但是增加了更多的功能。下面以awaitUninterruptibly()、signal()为例，阐述一下其内部实现。</p>
<p><img src="http://static.cyblogs.com/169ae1c528ceaba6.png" alt="http://static.cyblogs.com/169ae1c528ceaba6.png"></p>
<h4 id="同步队列和条件队列的关系"><a href="#同步队列和条件队列的关系" class="headerlink" title="同步队列和条件队列的关系"></a>同步队列和条件队列的关系</h4><p>线程执行<code>condition.await()</code>方法，将节点1从同步队列转移到条件队列中。</p>
<p><img src="http://static.cyblogs.com/169b3432b128105d.png" alt="http://static.cyblogs.com/169b3432b128105d.png"></p>
<p>线程执行<code>condition.signal()</code>方法，将节点1从条件队列中转移到同步队列。</p>
<p><img src="http://static.cyblogs.com/169b3411b74cfff1.png" alt="http://static.cyblogs.com/169b3411b74cfff1.png"></p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>一直想搞懂的字符编码问题</title>
    <url>/2020/02/13/2020/02/%E4%B8%80%E7%9B%B4%E6%83%B3%E6%90%9E%E6%87%82%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>​        从你刚刚毕业开始最怕的问题就是乱码问题对不对？起码我是。后面渐渐的知道是编码问题，而后面为了出现这种问题就都选择<code>UTF-8</code>，然后后面渐渐的就开始淡忘了这个问题。然后当小弟弟小妹妹问我们这相关的问题的时候，也都是跟他们说，全部改成<code>UTF-8</code>就好了。</p>
<p>​        但这是一种逃避，其实编码问题困扰我好多年，其实说句实话，真的没有搞懂。之前还有同事在一起相互考问 <strong>一个中文到底占用几个字节？</strong> 对不对，你遇到过吗？你回答的上来吗？哈哈</p>
<p>推荐几个常用的地址：</p>
<ul>
<li><p>ASCII：<a href="http://tool.oschina.net/commons?type=4" target="_blank" rel="noopener">http://tool.oschina.net/commons?type=4</a></p>
</li>
<li><p>GB2312简体中文编码表：<a href="http://tools.jb51.net/table/gb2312" target="_blank" rel="noopener">http://tools.jb51.net/table/gb2312</a></p>
</li>
<li><p>Unicode编码：<a href="http://tool.chinaz.com/Tools/Unicode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/Unicode.aspx</a></p>
</li>
</ul>
<h4 id="常见的编码"><a href="#常见的编码" class="headerlink" title="常见的编码"></a>常见的编码</h4><h5 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h5><p>​        它是现今最早最通用的单字节编码系统,并等同于国际标准<code>ISO/IEC 646</code>，其中一个英文字母（不分大小写）占一个字节的空间。</p>
<p>引申：字节是指一小组相邻的二进制数码。通常是8位作为一个字节，如00001111，换算为十进制。</p>
<p>最小值：-128</p>
<p>最大值：127</p>
<p>标准ASCII 码也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。其中：</p>
<ul>
<li><p>1、0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响。</p>
</li>
<li><p>2、32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。</p>
</li>
<li><p>3、65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
</li>
</ul>
<p>同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1。</p>
<h5 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h5><p>​        UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</p>
<ul>
<li><p>1、对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。</p>
</li>
<li><p>2、对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">Unicode</th>
<th align="right">UTF-8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0000 0000 - 0000 007F</td>
<td align="right">0xxxxxxx</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0000 0080 - 0000 07FF</td>
<td align="right">110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0000 0800 - 0000 FFFF</td>
<td align="right">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0001 0000 - 0010 FFFF</td>
<td align="right">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码，大家就很容易理解了。</p>
<p>“汉”的 <code>Unicode</code> 码点是 <code>0x6c49（110 1100 0100 1001）</code>，通过上面的对照表可以发现，<code>0x0000 6c49</code> 位于第三行的范围，那么得出其格式为 <code>1110xxxx 10xxxxxx 10xxxxxx</code>。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 <code>11100110 10110001 10001001</code>，转换成十六进制就是 <code>0xE6 0xB7 0x89</code>。</p>
<h5 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h5><p>​        在了解 <code>UTF-16</code> 编码方式之前，先了解一下另外一个概念——“平面”。</p>
<p>​        在上面的介绍中，提到了 <code>Unicode</code> 是一本很厚的字典，她将全世界所有的字符定义在一个集合里。这么多的字符不是一次性定义的，而是分区定义。每个区可以存放 65536 个（216216）字符，称为一个平面（plane）。目前，一共有 17 个（2525）平面，也就是说，整个 <code>Unicode</code> 字符集的大小现在是 221221。</p>
<p>​        最前面的 65536 个字符位，称为基本平面（简称 BMP ），它的码点范围是从 0 到 216−1216−1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。剩下的字符都放在辅助平面（简称 SMP ），码点范围从 U+010000 到 U+10FFFF。</p>
<p>​        基本了解了平面的概念后，再说回到 <code>UTF-16</code>。<code>UTF-16</code> 编码介于 <code>UTF-32</code> 与 <code>UTF-8</code> 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，<code>UTF-16</code> 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。那么问题来了，当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？</p>
<p>​        这里有一个很巧妙的地方，在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。</p>
<p>​        辅助平面的字符位共有 220220 个，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。</p>
<p>​        因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。</p>
<h5 id="Unicode之Emoji表情"><a href="#Unicode之Emoji表情" class="headerlink" title="Unicode之Emoji表情"></a>Unicode之Emoji表情</h5><blockquote>
<p>1999年前后，日本一个名叫栗田穰崇的年轻人，和许多直男一样， 给女友发的短信经常会被误解。比如，“知道了”被解读成“生气了”、“不耐烦了”，随后引发冷战。 于是少年栗田想：“如果能在文字里插入一些表情符号来表达感情，大家应该会需要吧！”<br>原始的Emoji就这么诞生了。</p>
</blockquote>
<p><code>Emoji</code>字符是<code>Unicode</code>字符集中一部分. 特定形象的<code>Emoji</code>表情符号对应到特定的<code>Unicode</code>字节。<br>常见的Emoji表情符号在Unicode字符集中的范围和具体的字节映射关系, 可通过<strong>Emoji Unicode Tables</strong> (<a href="http://apps.timwhitlock.info/emoji/tables/unicode#block-6c-other-additional-symbols)查看到。" target="_blank" rel="noopener">http://apps.timwhitlock.info/emoji/tables/unicode#block-6c-other-additional-symbols)查看到。</a></p>
<p>对于做<code>UGC</code>的网站来说，现在不仅仅是苹果手机，越来越多的软件都在用<code>emoji</code>表情，因为它能很形象的来表达我们的感情。对于这里我们能做的可以是把emoji表情转码后用文本的方式存在数据库中，还有一个方式就是升级数据库，改变它的编码。</p>
<p>推荐一个对这个错误描述的地址： <a href="https://blog.csdn.net/asahinokawa/article/details/85255732" target="_blank" rel="noopener">https://blog.csdn.net/asahinokawa/article/details/85255732</a></p>
<h4 id="一个汉字占几个字符？"><a href="#一个汉字占几个字符？" class="headerlink" title="一个汉字占几个字符？"></a>一个汉字占几个字符？</h4><p>如果你说的“字符”就是指 <code>Java</code> 中的 <code>char</code>，那好，那它就是 16 位，2 字节。</p>
<p>如果你说的“字符”是指我们用眼睛看到的那些“抽象的字符”，那么，谈论它占几个字节是没有意义的。具体地讲，脱离具体的编码谈某个字符占几个字节是没有意义的。就好比有一个抽象的整数“42”，你说它占几个字节？这得具体看你是用 <code>byte</code>，<code>short</code>，<code>int</code>，还是 <code>long</code> 来存它。用 byte 存就占一字节，用 <code>short</code> 存就占两字节，<code>int</code> 通常是四字节，<code>long</code> 通常八字节。当然，如果你用 <code>byte</code>，受限于它有限的位数，有些数它是存不了的，比如 256 就无法放在一个 <code>byte</code> 里了。</p>
<p>字符是同样的道理，如果你想谈“占几个字节”，就要先把编码说清楚。同一个字符在不同的编码下可能占不同的字节。就以你举的“字”字为例，“字”在 <a href="https://www.baidu.com/s?wd=GBK&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">GBK</a> 编码下占 2 字节，在 <code>UTF-16</code> 编码下也占 2 字节，在 <code>UTF-8</code> 编码下占 3 字节，在 <code>UTF-32</code> 编码下占 4 字节。不同的字符在同一个编码下也可能占不同的字节。“字”在 <code>UTF-8</code> 编码下占3字节，而“A”在 <code>UTF-8</code> 编码下占 1 字节。（因为 <code>UTF-8</code> 是变长编码），而 <code>Java</code> 中的 <code>char</code> 本质上是 <code>UTF-16</code> 编码。而 <code>UTF-16</code> 实际上也是一个变长编码（2 字节或 4字节）。</p>
<p>如果一个抽象的字符在 <code>UTF-16</code> 编码下占 4 字节，显然它是不能放到 <code>char</code> 中的。换言之， <code>char</code> 中只能放 <code>UTF-16</code> 编码下只占 2 字节的那些字符。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://zhidao.baidu.com/question/113144610.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/113144610.html</a></li>
<li><a href="https://www.jianshu.com/p/be286767563c" target="_blank" rel="noopener">https://www.jianshu.com/p/be286767563c</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>编码</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>不可不说的Java“锁”事</title>
    <url>/2020/02/01/2020/02/%E4%B8%8D%E5%8F%AF%E4%B8%8D%E8%AF%B4%E7%9A%84Java%E2%80%9C%E9%94%81%E2%80%9D%E4%BA%8B/</url>
    <content><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p>
<p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" alt="img"></p>
<h5 id="1-乐观锁-VS-悲观锁"><a href="#1-乐观锁-VS-悲观锁" class="headerlink" title="1. 乐观锁 VS 悲观锁"></a>1. 乐观锁 VS 悲观锁</h5><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p>
<p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p>
<p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/c8703cd9.png" alt="img"></p>
<p>根据从上面的概念描述我们可以发现：</p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure>

<p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p>
<p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p>
<p>CAS算法涉及到三个操作数：</p>
<ul>
<li>需要读写的内存值 V。</li>
<li>进行比较的值 A。</li>
<li>要写入的新值 B。</li>
</ul>
<p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>
<p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/feda866e.png" alt="img"></p>
<p>根据定义我们可以看出各属性的作用：</p>
<ul>
<li>unsafe： 获取并操作内存的数据。</li>
<li>valueOffset： 存储value在AtomicInteger中的偏移量。</li>
<li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li>
</ul>
<p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------------------------- JDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// AtomicInteger 自增方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- OpenJDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>
<p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p>
<p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p>
<ol>
<li><p>ABA问题</p>
<p>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>
<ul>
<li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>
</ul>
</li>
<li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<p>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p>
<ul>
<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ol>
<h5 id="2-自旋锁-VS-适应性自旋锁"><a href="#2-自旋锁-VS-适应性自旋锁" class="headerlink" title="2. 自旋锁 VS 适应性自旋锁"></a>2. 自旋锁 VS 适应性自旋锁</h5><p>在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/452a3363.png" alt="img"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/83b3f85e.png" alt="img"></p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p>
<h5 id="3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h5><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p>
<p>首先为什么Synchronized能实现线程同步？</p>
<p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>
<h5 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h5><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>
<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>
<p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<h5 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h5><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p>
<table>
<thead>
<tr>
<th align="left">锁状态</th>
<th align="left">存储内容</th>
<th align="left">存储内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">无锁</td>
<td align="left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">偏向锁</td>
<td align="left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">轻量级锁</td>
<td align="left">指向栈中锁记录的指针</td>
<td align="left">00</td>
</tr>
<tr>
<td align="left">重量级锁</td>
<td align="left">指向互斥量（重量级锁）的指针</td>
<td align="left">10</td>
</tr>
</tbody></table>
<p><strong>无锁</strong></p>
<p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<p><strong>偏向锁</strong></p>
<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<p><strong>轻量级锁</strong></p>
<p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<p><strong>重量级锁</strong></p>
<p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<p>整体的锁状态升级流程如下：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8afdf6f2.png" alt="img"></p>
<p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<h5 id="4-公平锁-VS-非公平锁"><a href="#4-公平锁-VS-非公平锁" class="headerlink" title="4. 公平锁 VS 非公平锁"></a>4. 公平锁 VS 非公平锁</h5><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/a23d746a.png" alt="img"></p>
<p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p>
<p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/4499559e.png" alt="img"></p>
<p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/6edea205.png" alt="img"></p>
<p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p>
<p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bc6fe583.png" alt="img"></p>
<p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/bd0036bb.png" alt="img"></p>
<p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p>
<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>
<h5 id="5-可重入锁-VS-非可重入锁"><a href="#5-可重入锁-VS-非可重入锁" class="headerlink" title="5. 可重入锁 VS 非可重入锁"></a>5. 可重入锁 VS 非可重入锁</h5><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1执行..."</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p>
<p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p>
<p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/58fc5bc9.png" alt="img"></p>
<p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ea597a0c.png" alt="img"></p>
<p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p>
<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p>
<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p>
<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/32536e7a.png" alt="img"></p>
<h5 id="6-独享锁-VS-共享锁"><a href="#6-独享锁-VS-共享锁" class="headerlink" title="6. 独享锁 VS 共享锁"></a>6. 独享锁 VS 共享锁</h5><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p>
<p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>
<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p>下图为ReentrantReadWriteLock的部分源码：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/762a042b.png" alt="img"></p>
<p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p>
<p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>
<p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>
<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8793e00a.png" alt="img"></p>
<p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	Thread current = Thread.currentThread();</span><br><span class="line">	<span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line">	<span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line">	<span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">		<span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">		<span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li>
<li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li>
<li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li>
<li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li>
<li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li>
</ul>
<p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>
<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>
<p>接着是读锁的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>
<p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8b7878ec.png" alt="img"></p>
<p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p>
<h5 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h5><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p>
<p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul>
<li><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/11/15/java-lock.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Java内存模型？</title>
    <url>/2020/02/08/2020/02/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>要想深入了解Java并发编程，就要先理解好<strong>Java内存模型</strong>，而要理解Java内存模型又不得不从硬件、计算机内存模型说起，本文从计算机内存模型产生的原因、解决的问题谈起，然后再对Java模型进行介绍，最后对计算机内存模型和Java内存模型进行总结，希望大家看完本文之后有所收获！</p>
<h4 id="CPU工作过程及出现的问题"><a href="#CPU工作过程及出现的问题" class="headerlink" title="CPU工作过程及出现的问题"></a>CPU工作过程及出现的问题</h4><h5 id="CPU执行过程"><a href="#CPU执行过程" class="headerlink" title="CPU执行过程"></a>CPU执行过程</h5><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道，而计算机上面的临时数据，是储存在<strong>主存</strong>中的。</p>
<blockquote>
<p>计算机内存包括<strong>高速缓存</strong>和<strong>主存</strong>。</p>
</blockquote>
<p>我们知道CPU执行指令的速度比从主存读取数据和向主存写入数据快很多，所以为了高效利用CPU，CPU增加了<strong>高速缓存(cache)</strong>来匹配CPU的执行速度，最终程序的执行过程如下</p>
<ol>
<li>首先会将数据从主存中复制一份到CPU的高速缓存中</li>
<li>当CPU执行计算的时候就可以直接从高速缓存中读取数据和写入数据</li>
<li>当运算结束后，再将高速缓存的数据更新到主存中</li>
</ol>
<h5 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h5><p>上面的执行过程在单线程情况下并没有问题，但是在多线程情况下就会出现问题，<strong>因为CPU如果含有多个核心，则每个核心都有自己独占高速缓存</strong>，如果出现多个线程同时执行同一个操作，那么结果是无法预知。例如<code>2</code>个线程同时执行<code>i++</code>，假设i的初始值是<code>0</code>，那么我们希望<code>2</code>个线程执行完成之后<code>i</code>的值变为<code>2</code>，但是事实会是这样吗？<br><img src="http://static.cyblogs.com/WX20200212-224624@2x.png" alt="http://static.cyblogs.com/WX20200212-224624@2x.png"></p>
<p>可能出现的情况有：</p>
<ol>
<li>线程1先将<code>i=0</code>从主存中读取到线程1的高速缓存中，然后CPU完成运算，再将<code>i=1</code>写入到主存中，然后线程2开始从主存中读取<code>i=1</code>到线程2的高速缓存中，然后CPU完成运算，再将<code>i=2</code>写入到主存中，那么<code>i=2</code>即为我们想要的结果。</li>
<li>线程1将<code>i=0</code>从主存中读取到线程1的高速缓存中的同时线程2也从主存中读取<code>i=0</code>到线程2的高速缓存中，然后线程1和线程2完成运算后，也都将<code>i=1</code>写入到主存中，那么结果<code>i=1</code>，结果就不是我们想要的了。出现这个情况，我们称为<strong>缓存不一致问题</strong>。</li>
</ol>
<p>那么如何解决CPU出现的<strong>缓存不一致问题</strong>呢？通常使用的解决方法有2种：</p>
<ol>
<li>通过给总线加锁</li>
<li>使用<strong>缓存一致性协议</strong></li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200212-224440@2x.png" alt="http://static.cyblogs.com/WX20200212-224440@2x.png"></p>
<p>第<code>1</code>种方法虽然也达到了目的，但是在总线被锁住的期间，其他的CPU也无法访问主存，<strong>效率很低</strong>，所以就出现了缓存一致性协议即第<code>2</code>种方法，其中最出名的就是<code>Intel</code>的MESI协议，MESI协议保证每个CPU高速缓存中的变量都是一致的。它的核心思想是，当CPU写数据时候，如果发现操作的变量是共享变量(即其他CPU上也存在该变量)，就会发出信号通知<strong>其他CPU</strong>将它高速缓存中缓存这个变量的缓存行置为<strong>无效状态</strong>，因此当其他CPU需要读取这个变量时，发现自己高速缓存中缓存该变量的缓存行为无效状态，那么它就会从主存中<strong>重新读取</strong>。<br><img src="http://static.cyblogs.com/WX20200212-224337@2x.png" alt="http://static.cyblogs.com/WX20200212-224337@2x.png"></p>
<h5 id="处理器重排序问题"><a href="#处理器重排序问题" class="headerlink" title="处理器重排序问题"></a>处理器重排序问题</h5><p>在多线程场景下，CPU除了会出现缓存一致性问题，还会出现因为<strong>处理器重排序</strong>即<strong>处理器(CPU)为了提高效率可能会对输入的代码进行乱序执行</strong>，而造成多线程的情况下出现问题。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>

<p>线程1由于处理器重排序，先执行性了语句2，那么此时线程2会认为<code>context</code>已经初始化完成，那么跳出循环，去执行<code>doSomethingwithconfig(context)</code>方法，实际上此时context并未初始化(即线程1的语句1还未执行)，而导致程序出错。</p>
<h4 id="什么是计算机内存模型"><a href="#什么是计算机内存模型" class="headerlink" title="什么是计算机内存模型"></a>什么是计算机内存模型</h4><p>上面提到的<strong>缓存一致性问题</strong>、<strong>处理器重排序问题</strong>都是在多线程情况下CPU可能出现的问题，那我们应该怎么处理这些问题？实际上这些问题并不需要我们考虑，这些问题CPU都会处理好，而CPU处理这些问题的时候是按照特定的<strong>操作规范</strong>，对特定的主存进行访问或告诉CPU高速缓存怎么访问主存，保证了多线程场景下的<strong>原子性、可见性、有序性</strong>，这个操作规范就称为<strong>计算机内存模型</strong>。</p>
<blockquote>
<p>可见性即当一个变量修改后，这个变量会马上更新到主存中，其他线程会收到通知这个变量修改过了，使用这个变量的时候重新去主存获取</p>
</blockquote>
<h4 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h4><p>从前面的介绍了解到计算机内存模型是一种解决多线程场景下的一个主存操作规范，既然是规范，那么不同的编程语言都可以遵循这种操作规范，在多线程场景下访问主存保证原子性、可见性、有序性。<br><strong>Java内存模型(Java Memory Model，JMM)</strong>即是Java语言对这个操作规范的遵循，<code>JMM</code>规定了所有的变量都存储在<strong>主存</strong>中，每个线程都有自己的<strong>工作区</strong>，线程将使用到的变量从主存中<strong>复制</strong>一份到自己的工作区，线程对变量的<strong>所有操作</strong>(读取、赋值等)都必须在工作区，不同的线程也无法直接访问对方工作区，线程之间的消息传递都需要通过主存来完成。<strong>可以把这里主存类比成计算机内存模型中的主存，工作区类比成计算机内存模型中的高速缓存</strong>。</p>
<p><img src="http://static.cyblogs.com/WX20200212-224252@2x.png" alt="http://static.cyblogs.com/WX20200212-224252@2x.png"></p>
<p>而我们知道<code>JMM</code>其实是工作主存中的，Java内存模型中的工作区也是主存中的一部分，所以可以这样说Java内存模型解决的是<strong>内存一致性问题(主存和主存)</strong>而计算机内存模型解决的是<strong>缓存一致性问题(CPU高速缓存和主存)</strong>，这两个模型类似，但是作用域不一样，Java内存模型保证的是主存和主存之间的原子性、可见性、有序性，而计算机内存模型保证的是CPU高速缓存和主存之间的原子性、可见性、有序性。</p>
<p><img src="http://static.cyblogs.com/WX20200212-224147@2x.png" alt="http://static.cyblogs.com/WX20200212-224147@2x.png"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文很多观点都是按照笔者自己的理解然后总结出来的，若有偏颇，欢迎指正！</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://ddnd.cn/2019/03/11/java-memory-model/" target="_blank" rel="noopener">https://ddnd.cn/2019/03/11/java-memory-model/</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用HashMap的时候小心点</title>
    <url>/2020/02/09/2020/02/%E4%BD%BF%E7%94%A8HashMap%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%8F%E5%BF%83%E7%82%B9/</url>
    <content><![CDATA[<h5 id="Map家族介绍"><a href="#Map家族介绍" class="headerlink" title="Map家族介绍"></a>Map家族介绍</h5><p>我们都知道<code>HashMap</code>是线程不安全的，但是<code>HashMap</code>的使用频率在所有<code>Map</code>中确实属于比较高的。因为它可以满足我们大多数的场景了。</p>
<p>看一眼Map家族的关系图：</p>
<p><img src="http://static.cyblogs.com/WX20200117-161643@2x.png" alt="http://static.cyblogs.com/WX20200117-161643@2x.png"></p>
<p><code>Map</code>是一个接口，我们常用的实现类有<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>，<code>HashTable</code>。</p>
<h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><p><code>HashMap</code>根据<code>key</code>的·值来保存value，需要注意的是，<code>HashMap</code>不保证遍历的顺序和插入的顺序是一致的。<code>HashMap</code>允许有一条记录的<code>key</code>为<code>null</code>，但是对值是否为<code>null</code>不做要求。</p>
<h6 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h6><p><code>HashTable</code>类是线程安全的，它使用<code>synchronize</code>来做线程安全，全局只有一把锁，在线程竞争比较激烈的情况下<code>hashtable</code>的效率是比较低下的。因为当一个线程访问<code>hashtable</code>的同步方法时，其他线程再次尝试访问的时候，会进入阻塞或者轮询状态，比如当线程1使用put进行元素添加的时候，线程2不但不能使用put来添加元素，而且不能使用get获取元素。所以，竞争会越来越激烈。相比之下，<code>ConcurrentHashMap</code>使用了分段锁技术来提高了并发度，不在同一段的数据互相不影响，多个线程对多个不同的段的操作是不会相互影响的。每个段使用一把锁。所以在需要线程安全的业务场景下，推荐使用<code>ConcurrentHashMap</code>，而<code>HashTable</code>不建议在新的代码中使用，如果需要线程安全，则使用<code>ConcurrentHashMap</code>，否则使用<code>HashMap</code>就足够了。</p>
<h6 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h6><p><code>LinkedHashMap</code>属于<code>HashMap</code>的子类，与<code>HashMap</code>的区别在于<code>LinkedHashMap</code>保存了记录插入的顺序。</p>
<h6 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h6><p><code>TreeMap</code>实现了<code>SortedMap</code>接口，<code>TreeMap</code>有能力对插入的记录根据<code>key</code>排序，默认按照升序排序，也可以自定义比较强，在使用<code>TreeMap</code>的时候，<code>key</code>应当实现<code>Comparable</code>。</p>
<h5 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a>HashMap的实现</h5><p><code>Java7</code>和<code>Java7</code>在实现<code>HashMap</code>上有所区别，当然<code>Java7</code>的效率要更好一些，主要是<code>Java7</code>的<code>HashMap</code>在<code>Java7</code>的基础上增加了红黑树这种数据结构，使得在桶里面查找数据的复杂度从<code>O(n)</code>降到<code>O(logn)</code>，当然还有一些其他的优化，比如<code>resize</code>的优化等。<br> 介于<code>Java7</code>的<code>HashMap</code>较为复杂，本文将基于<code>Java7</code>的<code>HashMap</code>实现来说明，主要的实现部分还是一致的，<code>Java7</code>的实现上主要是做了一些优化，内容还是没有变化的，依然是线程不安全的。<br> <code>HashMap</code>的实现使用了一个数组，每个数组项里面有一个链表的方式来实现，因为<code>HashMap</code>使用<code>key</code>的<code>hashCode</code>来寻找存储位置，不同的<code>key</code>可能具有相同的<code>hashCode</code>，这时候就出现哈希冲突了，也叫做哈希碰撞，为了解决哈希冲突，有开放地址方法，以及链地址方法。<code>HashMap</code>的实现上选取了链地址方法，也就是将哈希值一样的<code>entry</code>保存在同一个数组项里面，可以把一个数组项当做一个桶，桶里面装的<code>entry</code>的<code>key</code>的<code>hashCode</code>是一样的。</p>
<p><img src="http://static.cyblogs.com/WX20200117-160020@2x.png" alt="http://static.cyblogs.com/WX20200117-160020@2x.png"></p>
<p>上面的图片展示了我们的描述，其中有一个非常重要的数据结构<code>Node&lt;K,V&gt;</code>，这就是实际保存我们的<code>key-value</code>对的数据结构，下面是这个数据结构的主要内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;    </span><br><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>

<p>一个<code>Node</code>就是一个链表节点，也就是我们插入的一条记录，明白了<code>HashMap</code>使用链地址方法来解决哈希冲突之后，我们就不难理解上面的数据结构，<code>hash</code>字段用来定位桶的索引位置，<code>key</code>和<code>value</code>就是我们的数据内容，需要注意的是，我们的<code>key</code>是<code>final</code>的，也就是不允许更改，这也好理解，因为<code>HashMap</code>使用<code>key</code>的<code>hashCode</code>来寻找桶的索引位置，一旦key被改变了，那么<code>key</code>的<code>hashCode</code>很可能就会改变了，所以随意改变key会使得我们丢失记录（无法找到记录）。<code>next</code>字段指向链表的下一个节点。</p>
<p><code>HashMap</code>的初始桶的数量为<code>16</code>，<code>loadFact</code>为<code>0.75</code>,当桶里面的数据记录超过阈值的时候，<code>HashMap</code>将会进行扩容则操作，每次都会变为原来大小的<code>2倍</code>，直到设定的最大值之后就无法再<code>resize</code>了。</p>
<p>下面对<code>HashMap</code>的实现做简单的介绍，具体实现还得看代码，对于<code>Java7</code>中的<code>HashMap</code>实现，还需要能理解红黑树这种数据结构。</p>
<p>1、根据<code>key</code>的<code>hashCode</code>来决定应该将该记录放在哪个桶里面，无论是插入、查找还是删除，这都是第一步，计算桶的位置。因为<code>HashMap</code>的<code>length</code>总是<code>2的n</code>次幂，所以可以使用下面的方法来做模运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">h &amp; (length-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code>h</code>是<code>key</code>的<code>hashCode</code>值，计算好<code>hashCode</code>之后，使用上面的方法来对桶的数量取模，将这个数据记录落到某一个桶里面。当然取模是<code>Java7</code>中的做法，<code>Java7</code>进行了优化，做得更加巧妙，因为我们的<code>length</code>总是<code>2的n</code>次幂，所以在一次<code>resize</code>之后，当前位置的记录要么保持当前位置不变，要么就向前移动<code>length</code>就可以了。所以<code>Java7</code>中的<code>HashMap</code>的<code>resize</code>不需要重新计算<code>hashCode</code>。我们可以通过观察java7中的计算方法来抽象出算法，然后进行优化，具体的细节看代码就可以了。</p>
<p>2、<code>HashMap</code>的<code>put</code>方法</p>
<p><img src="http://static.cyblogs.com/WX20200117-160735@2x.png" alt="http://static.cyblogs.com/WX20200117-160735@2x.png"></p>
<p>上图展示了<code>Java7</code>中<code>put</code>方法的处理逻辑，比<code>Java7</code>多了红黑树部分，以及在一些细节上的优化，<code>put</code>逻辑和<code>Java7</code>中是一致的。</p>
<p>3、<code>resize</code>机制</p>
<p>HashMap的扩容机制就是重新申请一个容量是当前的2倍的桶数组，然后将原先的记录逐个重新映射到新的桶里面，然后将原先的桶逐个置为null使得引用失效。后面会讲到，HashMap之所以线程不安全，就是resize这里出的问题。</p>
<h5 id="为什么HashMap线程不安全？"><a href="#为什么HashMap线程不安全？" class="headerlink" title="为什么HashMap线程不安全？"></a>为什么HashMap线程不安全？</h5><p>上面说到，<code>HashMap</code>会进行<code>resize</code>操作，在<code>resize</code>操作的时候会造成线程不安全。下面将举两个可能出现线程不安全的地方。</p>
<p><strong>1、put的时候导致的多线程数据不一致。</strong><br> 这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个<code>key-value</code>对到<code>HashMap</code>中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p>
<p><strong>2、另外一个比较明显的线程不安全的问题是HashMap的get操作可能因为resize而引起死循环（cpu100%），具体分析如下：</strong></p>
<p>下面的代码是resize的核心内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;  </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;  </span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;           </span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;  </span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);   </span><br><span class="line">            e.next = newTable[i];  </span><br><span class="line">            newTable[i] = e;  </span><br><span class="line">            e = next;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的功能是将原来的记录重新计算在新桶的位置，然后迁移过去。</p>
<p><img src="http://static.cyblogs.com/WX20200117-160831@2x.png" alt="http://static.cyblogs.com/WX20200117-160831@2x.png"></p>
<p><strong>多线程HashMap的resize</strong>：我们假设有两个线程同时需要执行resize操作，我们原来的桶数量为2，记录数为3，需要resize桶到4，原来的记录分别为：<code>[3,A]</code>，<code>[7,B]</code>，<code>[5,C]</code>，在原来的map里面，我们发现这三个entry都落到了第二个桶里面。<br> 假设线程thread1执行到了<code>transfer</code>方法的<code>Entry next = e.next</code>这一句，然后时间片用完了，此时的<code>e = [3,A]</code>, <code>next = [7,B]</code>。线程<code>thread2</code>被调度执行并且顺利完成了<code>resize</code>操作，需要注意的是，此时的<code>[7,B]</code>的<code>next</code>为<code>[3,A]</code>。此时线程<code>thread1</code>重新被调度运行，此时的<code>thread1</code>持有的引用是已经被<code>thread2 resize</code>之后的结果。线程thread1首先将[3,A]迁移到新的数组上，然后再处理<code>[7,B]</code>，而<code>[7,B]</code>被链接到了<code>[3,A]</code>的后面，处理完<code>[7,B]</code>之后，就需要处理<code>[7,B]</code>的<code>next</code>了啊，而通过<code>thread2</code>的<code>resize</code>之后，<code>[7,B]</code>的<code>next</code>变为了<code>[3,A]</code>，此时，<code>[3,A]</code>和<code>[7,B]</code>形成了环形链表，在<code>get</code>的时候，如果<code>get</code>的<code>key</code>的桶索引和<code>[3,A]</code>和<code>[7,B]</code>一样，那么就会陷入死循环。</p>
<p>如果在取链表的时候从头开始取（现在是从尾部开始取）的话，则可以保证节点之间的顺序，那样就不存在这样的问题了。</p>
<p>综合上面两点，可以说明<code>HashMap</code>是线程不安全的。</p>
<h5 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h5><ul>
<li><a href="https://www.jianshu.com/p/1e9cf0ac07f4" target="_blank" rel="noopener">https://www.jianshu.com/p/1e9cf0ac07f4</a></li>
<li><a href="https://www.jianshu.com/p/e2f75c8cce01" target="_blank" rel="noopener">https://www.jianshu.com/p/e2f75c8cce01</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>HashMap</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SimpleDateFormat的时候小心点</title>
    <url>/2020/02/10/2020/02/%E4%BD%BF%E7%94%A8SimpleDateFormat%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%8F%E5%BF%83%E7%82%B9/</url>
    <content><![CDATA[<p>SimpleDateFormat是Java提供的一个格式化和解析日期的工具类，日常开发中应该经常会用到，但是由于它是线程不安全的，多线程公用一个SimpleDateFormat实例对日期进行解析或者格式化会导致程序出错。</p>
<h4 id="代码示例演示"><a href="#代码示例演示" class="headerlink" title="代码示例演示"></a>代码示例演示</h4><p>写一段小Demo来模拟多线程下<code>SimpleDateFormat</code>做时间格式化的时候报错,代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan</span></span><br><span class="line"><span class="comment"> * Date：2019/3/20 Time：2:03 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatCase</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、创建单例实例</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2、创建多个线程，并启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">//3、使用单例日期实例解析文本</span></span><br><span class="line">                        System.out.println(sdf.parse(<span class="string">"2017-12-13 15:17:27"</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">	          <span class="comment">//4、启动线程</span></span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="控制台正常的情况：-运气好"><a href="#控制台正常的情况：-运气好" class="headerlink" title="控制台正常的情况： 运气好~"></a><strong>控制台正常的情况：</strong> 运气好~</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:57434', transport: 'socket'</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:57434', transport: 'socket'</span><br></pre></td></tr></table></figure>

<h6 id="控制台非正常的情况-运气不好"><a href="#控制台非正常的情况-运气不好" class="headerlink" title="控制台非正常的情况 运气不好~"></a><strong>控制台非正常的情况</strong> 运气不好~</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:57756', transport: 'socket'</span><br><span class="line">Exception in thread "Thread-2" Exception in thread "Thread-0" java.lang.NumberFormatException: multiple points</span><br><span class="line">	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line">	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line">	at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line">	at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line">	at java.text.DecimalFormat.parse(DecimalFormat.java:2056)</span><br><span class="line">	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line">	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line">	at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line">	at com.vernon.test.demo.jdk.text.SimpleDateFormatCase$1.run(SimpleDateFormatCase.java:23)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">java.lang.NumberFormatException: multiple points</span><br><span class="line">	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)</span><br><span class="line">	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)</span><br><span class="line">	at java.lang.Double.parseDouble(Double.java:538)</span><br><span class="line">	at java.text.DigitList.getDouble(DigitList.java:169)</span><br><span class="line">	at java.text.DecimalFormat.parse(DecimalFormat.java:2056)</span><br><span class="line">	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br><span class="line">	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)</span><br><span class="line">	at java.text.DateFormat.parse(DateFormat.java:364)</span><br><span class="line">	at com.vernon.test.demo.jdk.text.SimpleDateFormatCase$1.run(SimpleDateFormatCase.java:23)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Fri Dec 12 15:17:27 CST 2217</span><br><span class="line">Thu Dec 13 15:17:27 CST 2012</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Wed Dec 13 15:17:27 CST 2017</span><br><span class="line">Fri Jun 09 15:17:27 CST 5881628</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:57756', transport: 'socket'</span><br></pre></td></tr></table></figure>

<p>通过IntelliJ IDEA的功能查看一下SimpleDateFormat的一个类关系图：</p>
<p><img src="http://static.cyblogs.com/WX20200116-175032.png" alt="http://static.cyblogs.com/WX20200116-175032.png"></p>
<p>可知每个<code>SimpleDateFormat</code>实例里面有一个<code>Calendar</code>对象，从后面会知道其实<code>SimpleDateFormat</code>之所以是线程不安全的就是因为<code>Calendar</code>是线程不安全的，后者之所以是线程不安全的是因为其中存放日期数据的变量都是线程不安全的，比如里面的<code>fields</code>、<code>time</code>等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String text, ParsePosition pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、解析日期字符串放入CalendarBuilder的实例calb中</span></span><br><span class="line">    .....</span><br><span class="line">    Date parsedDate;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//2、使用calb中解析好的日期数据设置calendar</span></span><br><span class="line">        parsedDate = calb.establish(calendar).getTime();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parsedDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Calendar <span class="title">establish</span><span class="params">(Calendar cal)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//3、重置日期对象cal的属性值</span></span><br><span class="line">   cal.clear();</span><br><span class="line">   <span class="comment">//4、使用calb中中属性设置cal</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//5、返回设置好的cal对象</span></span><br><span class="line">   <span class="keyword">return</span> cal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; ) &#123;</span><br><span class="line">        stamp[i] = fields[i] = <span class="number">0</span>; <span class="comment">// UNSET == 0</span></span><br><span class="line">        isSet[i++] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    areAllFieldsSet = areFieldsSet = <span class="keyword">false</span>;</span><br><span class="line">    isTimeSet = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>1、解析日期字符串放入<code>CalendarBuilder</code>的实例<code>calb</code>中；</p>
</li>
<li><p>2、使用calb中解析好的日期数据设置<code>calendar</code>；</p>
</li>
<li><p>3、重置日期对象<code>cal</code>的属性值；</p>
</li>
<li><p>4、使用<code>calb</code>中中属性设置<code>cal</code>；</p>
</li>
<li><p>5、返回设置好的<code>cal</code>对象；</p>
</li>
</ul>
<p>从上面步骤可知步骤<code>3、4、5</code>操作不是原子性操作，当多个线程调用parse方法时候比如线程A执行了步骤<code>3、4</code>也就是设置好了cal对象，在执行步骤<code>5</code>前线程B执行了步骤<code>3</code>清空了cal对象，由于多个线程使用的是一个cal对象，所以线程A执行步骤<code>5</code>返回的就可能是被线程B清空后的对象，当然也有可能线程B执行了步骤<code>4</code>被线程B修改后的cal对象，从而导致程序错误。</p>
<h4 id="那么怎么解决呢？"><a href="#那么怎么解决呢？" class="headerlink" title="那么怎么解决呢？"></a>那么怎么解决呢？</h4><h6 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h6><p>每次使用时候new一个SimpleDateFormat的实例，这样可以保证每个实例使用自己的Calendar实例,但是每次使用都需要new一个对象，并且使用后由于没有其它引用，就会需要被回收，开销会很大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan</span></span><br><span class="line"><span class="comment"> * Date：2019/3/20</span></span><br><span class="line"><span class="comment"> * Time：2:07 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatCase2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line">                            System.out.println(sdf.parse(<span class="string">"2020-01-16 15:17:27"</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h6><p>究其原因是因为多线程下步骤3、4、5三个步骤不是一个原子性操作，那么容易想到的是对其进行同步，让3、4、5成为原子操作，可以使用synchronized进行同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan Date：2019/3/21 Time：10:32 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatCase3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line">                            System.out.println(sdf.parse(<span class="string">"2020-01-16 15:17:27"</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="第三种方式："><a href="#第三种方式：" class="headerlink" title="第三种方式："></a>第三种方式：</h6><p>使用ThreadLocal，这样每个线程只需要使用一个SimpleDateFormat实例相比第一种方式大大节省了对象的创建销毁开销，并且不需要对多个线程直接进行同步，使用ThreadLocal方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan</span></span><br><span class="line"><span class="comment"> * Date：2019/3/21 Time：10:32 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatCase4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;DateFormat&gt; safeSdf = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(safeSdf.get().parse(<span class="string">"2020-01-16 15:17:27"</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="第四种方式："><a href="#第四种方式：" class="headerlink" title="第四种方式："></a>第四种方式：</h6><p>在JDK8中新增了<code>DateTimeFormatter</code>，由<code>DateTimeFormatter</code>的静态方法<code>ofPattern()</code>构建日期格式，<code>LocalDateTime</code>和<code>LocalDate</code>等一些表示日期或时间的类使用<code>parse</code>和<code>format</code>方法把日期和字符串做转换。使用新的API，整个转换过程都不需要考虑线程安全的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.demo.jdk.text;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> * User：chenyuan</span></span><br><span class="line"><span class="comment"> * Date：2019/3/21 Time：10:32 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatCase5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(LocalDate.parse(<span class="string">"2020-01-16 15:17:27"</span>, formatter));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Java8</code>发布，已有数年之久，但是发现很多人都还是坚持着用<code>SimpleDateFormat</code>和<code>Date</code>进行时间操作。<code>SimpleDateFormat</code>这个类不是线程安全的，在使用的时候稍不注意，就会产生致命的问题。<code>Date</code>这个类，是可以重新设置时间的，这对于一些类内部的属性来说，是非常不安全的。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化和反序列化的底层实现原理是什么？</title>
    <url>/2020/02/11/2020/02/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="1、什么是序列化和反序列化"><a href="#1、什么是序列化和反序列化" class="headerlink" title="1、什么是序列化和反序列化"></a>1、什么是序列化和反序列化</h5><p>（1）Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程；</p>
<p>（2）序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。</p>
<p>（3）反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
<p>（4）本质上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。</p>
<h5 id="2、为什么需要序列化与反序列化"><a href="#2、为什么需要序列化与反序列化" class="headerlink" title="2、为什么需要序列化与反序列化"></a>2、为什么需要序列化与反序列化</h5><p>我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。</p>
<p>那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的！如何做到呢？这就需要Java序列化与反序列化了！</p>
<p>换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。</p>
<p>当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p>
<p>总的来说可以归结为以下几点：</p>
<p>（1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中；<br>（2）通过序列化以字节流的形式使对象在网络中进行传递和接收；<br>（3）通过序列化在进程间传递对象；</p>
<h5 id="3、序列化算法一般会按步骤做如下事情："><a href="#3、序列化算法一般会按步骤做如下事情：" class="headerlink" title="3、序列化算法一般会按步骤做如下事情："></a>3、序列化算法一般会按步骤做如下事情：</h5><p>（1）将对象实例相关的类元数据输出。<br>（2）递归地输出类的超类描述直到不再有超类。<br>（3）类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。<br>（4）从上至下递归输出实例的数据</p>
<h4 id="Java如何实现序列化和反序列化"><a href="#Java如何实现序列化和反序列化" class="headerlink" title="Java如何实现序列化和反序列化"></a>Java如何实现序列化和反序列化</h4><h5 id="1、JDK类库中序列化和反序列化API"><a href="#1、JDK类库中序列化和反序列化API" class="headerlink" title="1、JDK类库中序列化和反序列化API"></a>1、JDK类库中序列化和反序列化API</h5><p>（1）java.io.ObjectOutputStream：表示对象输出流；</p>
<p>它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；</p>
<p>（2）java.io.ObjectInputStream：表示对象输入流；</p>
<p>它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回；</p>
<h5 id="2、实现序列化的要求"><a href="#2、实现序列化的要求" class="headerlink" title="2、实现序列化的要求"></a>2、实现序列化的要求</h5><p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！</p>
<h5 id="3、实现Java对象序列化与反序列化的方法"><a href="#3、实现Java对象序列化与反序列化的方法" class="headerlink" title="3、实现Java对象序列化与反序列化的方法"></a>3、实现Java对象序列化与反序列化的方法</h5><p>假定一个User类，它的对象需要序列化，可以有如下三种方法：</p>
<p>（1）若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化</p>
<p>ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。<br>ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。</p>
<p>（2）若User类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。</p>
<p>ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化。<br>ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化。</p>
<p>（3）若User类实现了Externalnalizable接口，且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。</p>
<p>ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化。<br>ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化。</p>
<h5 id="4、JDK类库中序列化的步骤"><a href="#4、JDK类库中序列化的步骤" class="headerlink" title="4、JDK类库中序列化的步骤"></a>4、JDK类库中序列化的步骤</h5><p>步骤一：创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\object.out"</span>));</span><br></pre></td></tr></table></figure>

<p>步骤二：通过对象输出流的writeObject()方法写对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">oos.writeObject(<span class="keyword">new</span> User(<span class="string">"xuliugen"</span>, <span class="string">"123456"</span>, <span class="string">"male"</span>));</span><br></pre></td></tr></table></figure>

<h5 id="5、JDK类库中反序列化的步骤"><a href="#5、JDK类库中反序列化的步骤" class="headerlink" title="5、JDK类库中反序列化的步骤"></a>5、JDK类库中反序列化的步骤</h5><p>步骤一：创建一个对象输入流，它可以包装一个其它类型输入流，如文件输入流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream ois= <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"object.out"</span>));</span><br></pre></td></tr></table></figure>

<p>步骤二：通过对象输出流的readObject()方法读取对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; (User) ois.readObject();</span><br></pre></td></tr></table></figure>

<p>说明：为了正确读取数据，完成反序列化，必须保证向对象输出流写对象的顺序与从对象输入流中读对象的顺序一致。</p>
<h5 id="6、序列化和反序列化的示例"><a href="#6、序列化和反序列化的示例" class="headerlink" title="6、序列化和反序列化的示例"></a>6、序列化和反序列化的示例</h5><p>为了更好地理解Java序列化与反序列化，举一个简单的示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"object.out"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="string">"xuliugen"</span>, <span class="string">"123456"</span>, <span class="string">"male"</span>);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"object.out"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        User user2 = (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName() + <span class="string">" "</span> + user2.getPassword() + <span class="string">" "</span> + user2.getSex());</span><br><span class="line">        <span class="comment">//反序列化的输出结果为：xuliugen 123456 male</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">//全参构造方法、get和set方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>object.out文件如下（使用UltraEdit打开）：</p>
<p><img src="http://static.cyblogs.com/20180407130515728.png" alt="http://static.cyblogs.com/20180407130515728.png"></p>
<p>注：上图中0000000h-000000c0h表示行号；0-f表示列；行后面的文字表示对这行16进制的解释；对上述字节码所表述的内容感兴趣的可以对照相关的资料，查阅一下每一个字符代表的含义，这里不在探讨！</p>
<p>类似于我们Java代码编译之后的.class文件，每一个字符都代表一定的含义。序列化和反序列化的过程就是生成和解析上述字符的过程！</p>
<p>序列化图示：</p>
<p><img src="http://static.cyblogs.com/20180408163613978.jpeg" alt="http://static.cyblogs.com/20180408163613978.jpeg"></p>
<p>反序列化图示：</p>
<p><img src="http://static.cyblogs.com/20180408163634701.jpeg" alt="http://static.cyblogs.com/20180408163634701.jpeg"></p>
<h4 id="相关注意事项"><a href="#相关注意事项" class="headerlink" title="相关注意事项"></a>相关注意事项</h4><p>1、序列化时，只对对象的状态进行保存，而不管对象的方法；</p>
<p>2、当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</p>
<p>3、当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</p>
<p>4、并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如：</p>
<ul>
<li>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的；</li>
<li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现；</li>
</ul>
<p>5、声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。</p>
<p>6、序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途：</p>
<ul>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</li>
<li>在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</li>
</ul>
<p>7、Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的；</p>
<p>8、如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；</p>
<p>​    序列化时，类的所有数据成员应可序列化除了声明为transient或static的成员。将变量声明为transient告诉JVM我们会负责将变元序列化。将数据成员声明为transient后，序列化过程就无法将其加进对象字节流中，没有从transient数据成员发送的数据。后面数据反序列化时，要重建数据成员（因为它是类定义的一部分），但不包含任何数据，因为这个数据成员不向流中写入任何数据。记住，对象流不序列化static或transient。我们的类要用writeObject()与readObject()方法以处理这些数据成员。使用writeObject()与readObject()方法时，还要注意按写入的顺序读取这些数据成员</p>
<p>那对于这些问题，我们该如何进行序列化和反序列化呢？</p>
<p>简单，也就是说我们要对这俩个类型的变量单独处理，怎么办？就是在出现这类变量的所属类中增加俩个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>;</span><br><span class="line">        而对应于我们的类中添加的方法就是</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialTest</span> <span class="keyword">extends</span> <span class="title">parent</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.defaultWriteObject();</span><br><span class="line">        out.writeInt(<span class="keyword">this</span>.testStatic);</span><br><span class="line">        out.writeInt(<span class="keyword">this</span>.testTransient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        <span class="keyword">this</span>.testStatic = in.readInt();</span><br><span class="line">        <span class="keyword">this</span>.testTransient = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当ObjectOutputStream对一个SerialTest对象进行序列化时，如果该对象具有writeObject()方法，那么就会执行这一方法，否则就按默认方式序列化。在该对象的writeObjectt()方法中，可以先调用ObjectOutputStream的defaultWriteObject()方法，使得对象输出流先执行默认的序列化操作。同理可得出反序列化的情况，不过这次是defaultReadObject()方法。</p>
<p>  <em>ObjectOutputStream.defaultWriteObject()</em> ：将当前类的非静态(static)和非瞬态字段(transient)写入此流。</p>
<p>  <em>ObjectInputStream.defaultReadObject()</em> ：  从此流读取当前类的非静态和非瞬态字段。</p>
<p>Externalizable的作用</p>
<p>对于实现Serializable的类来说，在序列化的时候，所有的非静态(static)和非瞬态字段(transient)会被自动序列化，如果有一些特殊要求，我们可以完全手动控制哪些字段要被序列化，哪些不要序列化。将他们的生死大权完全掌握在咱手中。怎么办？这个时候就应该谈谈Externalizable类了。</p>
<p>只要实现Externalizable这个类，并且复写 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readExternal(ObjectInput in) <span class="keyword">throws</span> IOException,CalssNotFoundException</span><br><span class="line"> </span><br><span class="line">writeExternal(ObjectOutput out) <span class="keyword">throws</span> IOException,CalssNotFoundException</span><br></pre></td></tr></table></figure>

<p>就可以了，在readExternal(ObjectInput in) throws IOException,CalssNotFoundException方法中，可以自行决定从in读取哪些对象数据。</p>
<p>writeExternal(ObjectOutput out) throws IOException,CalssNotFoundException方法中，可以自行决定将什么数据write到out去。</p>
<p>这俩个方法分别会在在ObjectOutputStream.writeObject(object);ObjectInputStream.readObject()自动执行。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><p>1、<a href="https://zhidao.baidu.com/question/688891250408618484.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/688891250408618484.html</a><br>2、<a href="https://blog.csdn.net/morethinkmoretry/article/details/5929345" target="_blank" rel="noopener">https://blog.csdn.net/morethinkmoretry/article/details/5929345</a><br>3、<a href="https://www.jianshu.com/p/edcf7bd2c085" target="_blank" rel="noopener">https://www.jianshu.com/p/edcf7bd2c085</a><br>4、<a href="https://blog.csdn.net/xiaocaidexuexibiji/article/details/22692097" target="_blank" rel="noopener">https://blog.csdn.net/xiaocaidexuexibiji/article/details/22692097</a></p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>序列化和反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>来自淘宝的分布式数据层-TDDL</title>
    <url>/2020/02/02/2020/02/%E6%9D%A5%E8%87%AA%E6%B7%98%E5%AE%9D%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%B1%82-TDDL/</url>
    <content><![CDATA[<p>淘宝根据自身业务需求研发了TDDL（Taobao Distributed Data Layer）框架，主要用于解决分库分表场景下的访问路由（持久层与数据访问层的配合）以及异构数据库之间的数据同步，它是一个基于集中式配置的<code>JDBC DataSource</code>实现，具有<code>分库分表</code>、<code>Master/Salve</code>、<code>动态数据源配置</code>等功能。</p>
<p>就目前而言，许多大厂也在出一些更加优秀和社区支持更广泛的DAL层产品，比如Hibernate Shards、Ibatis-Sharding等。TDDL位于数据库和持久层之间，它直接与数据库建立交道，如图所示：</p>
<p><img src="http://static.cyblogs.com/20160601111503650.png" alt="http://static.cyblogs.com/20160601111503650.png"></p>
<p>​        淘宝很早就对数据进行过分库的处理，上层系统连接多个数据库，中间有一个叫做<code>DBRoute</code>的路由来对数据进行统一访问。<code>DBRoute</code>对数据进行多库的操作、数据的整合，让上层系统像操作一个数据库一样操作多个库。但是随着数据量的增长，对于库表的分法有了更高的要求，例如，你的商品数据到了百亿级别的时候，任何一个库都无法存放了，于是分成2个、4个、8个、16个、32个……直到1024个、2048个。好，分成这么多，数据能够存放了，那怎么查询它？这时候，数据查询的中间件就要能够承担这个重任了，它对上层来说，必须像查询一个数据库一样来查询数据，还要像查询一个数据库一样快（每条查询在几毫秒内完成），<code>TDDL</code>就承担了这样一个工作。在外面有些系统也用<code>DAL</code>（数据访问层） 这个概念来命名这个中间件。下图展示了一个简单的分库分表数据查询策略：</p>
<p><img src="http://static.cyblogs.com/20160601111544711.png" alt="http://static.cyblogs.com/20160601111544711.png"></p>
<p><strong>TDDL的主要优点：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、数据库主备和动态切换</span><br><span class="line">2、带权重的读写分离</span><br><span class="line">3、单线程读重试</span><br><span class="line">4、集中式数据源信息管理和动态变更</span><br><span class="line">5、剥离的稳定jboss数据源</span><br><span class="line">6、支持mysql和oracle数据库</span><br><span class="line">7、基于jdbc规范，很容易扩展支持实现jdbc规范的数据源</span><br><span class="line">8、无server,client-jar形式存在，应用直连数据库</span><br><span class="line">9、读写次数,并发度流程控制，动态变更</span><br><span class="line">10、可分析的日志打印,日志流控，动态变更12345678910</span><br></pre></td></tr></table></figure>

<p><strong>TDDL的体系架构</strong></p>
<p>TDDL其实主要可以划分为3层架构，分别是Matrix层、Group层和Atom层。</p>
<p><strong>Matrix层：</strong>用于实现分库分表逻辑，底层持有多个Group实例。而Group层和Atom共同组成了动态数据源</p>
<p><strong>Group层：</strong>实现了数据库的Master/Salve模式的写分离逻辑，底层持有多个Atom实例。</p>
<p><strong>Atom层 (TAtomDataSource)：</strong>实现数据库ip,port,password,connectionProperties等信息的动态推送,以及持有原子的数据源分离的JBOSS数据源）。</p>
<p><img src="http://static.cyblogs.com/20160601111711995.png" alt="http://static.cyblogs.com/20160601111711995.png"></p>
<p>​        持久层只关心对数据源的<code>CRUD</code>操作，而多数据源的访问并不应该由它来关心。也就是说<code>TDDL</code>透明给持久层的数据源接口应该是统一且“单一”的，至于数据库到底如何分库分表持久层无需知道也无需编写对应的<code>SQL</code>去实行应对策略。这个时候对<code>TDDL</code>一些疑问就出现了，<code>TDDL</code>需要对<code>SQL</code>进行二次解析和拼装吗？答案是不解析仅拼装。<code>TDDL</code>只需要从持久层拿到发出的<code>SQL</code>再按照一些分库分表条件，进行特定的<code>SQL</code>扩充以此满足访问路路由操作。<br>​        <code>TDDL</code>除了拿到分库分表条件外，还需要拿到<code>order by</code>、<code>group by</code>、<code>limit</code>、<code>join</code>等信息，<code>SUM</code>、<code>MAX</code>、<code>MIN</code>等聚合函数信息，<code>DISTINCT</code>信息。具有这些关键字的<code>SQL</code>将会在单库和多库情况下进行,语义是不同的。<code>TDDL</code>必须对使用这些关键字的SQL返回的结果做出合适的处理；<br>​        <code>TDDL</code>行复制需重新拼写<code>SQL</code>，带上<code>sync_version</code>字段。不通过<code>SQL</code>解析,因为<code>TDDL</code>遵守<code>JDBC</code>规范,它不可能去扩充<code>JDBC</code>规范里面的接口，所以只能通过<code>SQL</code>中加额外的字符条件(也就是HINT方式)或者<code>ThreadLocal</code>方式进行传递，前者使<code>SQL</code>过长,后者难以维护，开发debug时不容易跟踪，而且需要判定是在一条SQL执行后失效还是1个连接关闭后才失效；<br>​        <code>TDDL</code>现在也同时支持<code>Hint</code>方式和<code>ThreadLocal</code>方式传递这些信息；</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/diu_brother/article/details/51554555" target="_blank" rel="noopener">https://blog.csdn.net/diu_brother/article/details/51554555</a></li>
<li><a href="https://github.com/alibaba/tb_tddl" target="_blank" rel="noopener">https://github.com/alibaba/tb_tddl</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>TDDL</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析零拷贝技术</title>
    <url>/2020/02/05/2020/02/%E6%B5%85%E6%9E%90%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>零拷贝（英语：Zero-copy）技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p>
</blockquote>
<p>零拷贝操作减少了<strong>在用户空间与内核空间之间切换模式的次数</strong>。</p>
<p>举例来说，如果要读取一个文件并通过网络发送它，传统方式下如下图，<strong>传统的I/O操作进行了4次用户空间与内核空间的上下文切换，以及4次数据拷贝。其中4次数据拷贝中包括了2次DMA拷贝和2次CPU拷贝</strong>。通过零拷贝技术完成相同的操作，减少了在用户空间与内核空间交互，并且不需要CPU复制数据。</p>
<p><img src="http://static.cyblogs.com/%E6%B5%85%E6%9E%90%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF-1.png" alt="http://static.cyblogs.com/浅析零拷贝技术-1.png"></p>
<h4 id="linux中零拷贝技术"><a href="#linux中零拷贝技术" class="headerlink" title="linux中零拷贝技术"></a>linux中零拷贝技术</h4><h5 id="Linux系统的“用户空间”和“内核空间”"><a href="#Linux系统的“用户空间”和“内核空间”" class="headerlink" title="Linux系统的“用户空间”和“内核空间”"></a>Linux系统的“用户空间”和“内核空间”</h5><p>从Linux系统上看，除了引导系统的BIN区，整个内存空间主要被分成两个部分：内核空间(Kernel space)、用户空间(User space)。</p>
<p>“用户空间”和“内核空间”的空间、操作权限以及作用都是不一样的。</p>
<p>内核空间是Linux自身使用的内存空间，主要提供给程序调度、内存分配、连接硬件资源等程序逻辑使用；用户空间则是提供给各个进程的主要空间。</p>
<p>用户空间不具有访问内核空间资源的权限，因此如果应用程序需要使用到内核空间的资源，则需要通过系统调用来完成：从用户空间切换到内核空间，然后在完成相关操作后再从内核空间切换回用户空间。</p>
<h5 id="Linux-中零拷贝技术的实现方向"><a href="#Linux-中零拷贝技术的实现方向" class="headerlink" title="Linux 中零拷贝技术的实现方向"></a>Linux 中零拷贝技术的实现方向</h5><ul>
<li>直接 I/O：对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输。这种方式依旧存在用户空间和内核空间的上下文切换，但是硬件上的数据不会拷贝一份到内核空间，而是直接拷贝至了用户空间，因此直接I/O不存在内核空间缓冲区和用户空间缓冲区之间的数据拷贝。</li>
<li>在数据传输过程中，避免数据在用户空间缓冲区和系统内核空间缓冲区之间的CPU拷贝，以及数据在系统内核空间内的CPU拷贝。本文主要讨论的就是该方式下的零拷贝机制。</li>
<li>copy-on-write(写时复制技术)：在某些情况下，Linux操作系统的内核空间缓冲区可能被多个应用程序所共享，操作系统有可能会将用户空间缓冲区地址映射到内核空间缓存区中。当应用程序需要对共享的数据进行修改的时候，才需要真正地拷贝数据到应用程序的用户空间缓冲区中，并且对自己用户空间的缓冲区的数据进行修改不会影响到其他共享数据的应用程序。所以，如果应用程序不需要对数据进行任何修改的话，就不会存在数据从系统内核空间缓冲区拷贝到用户空间缓冲区的操作。</li>
</ul>
<h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buf = mmap(diskfd, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure>

<p>应用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p>
<p><img src="http://static.cyblogs.com/%E6%B5%85%E6%9E%90%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF-2.png" alt="http://static.cyblogs.com/浅析零拷贝技术-2.png"></p>
<p>使用mmap替代read很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。但是使用mmap是有代价的。当你使用mmap时，你可能会遇到一些隐藏的陷阱。例如，当你的程序map了一个文件，但是当这个文件被另一个进程截断(truncate)时, write系统调用会因为访问非法地址而被SIGBUS信号终止。SIGBUS信号默认会杀死你的进程并产生一个coredump,如果你的服务器这样被中止了，那会产生一笔损失。</p>
<p>当然也有办法解决，本文忽略解决办法。</p>
<h5 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ssize_t <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, off_t *offset, size_t count)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/%E6%B5%85%E6%9E%90%E9%9B%B6%E6%8B%B7%E8%B4%9D-03.jpg" alt="http://static.cyblogs.com/浅析零拷贝-03.jpg"></p>
<p>sendfile实现的零拷贝I/O只使用了2次用户空间与内核空间的上下文切换，以及3次数据的拷贝。其中3次数据拷贝中包括了2次DMA拷贝和1次CPU拷贝。</p>
<h5 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h5><p>sendfile只适用于将数据从文件拷贝到套接字上，限定了它的使用范围。Linux在2.6.17版本引入splice系统调用，用于在两个文件描述符中移动数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#define _GNU_SOURCE         /* See feature_test_macros(7) */</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"><span class="function">ssize_t <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in, loff_t *off_in, <span class="keyword">int</span> fd_out, loff_t *off_out, size_t len, unsigned <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="Java中如何使用零拷贝"><a href="#Java中如何使用零拷贝" class="headerlink" title="Java中如何使用零拷贝"></a>Java中如何使用零拷贝</h4><h5 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h5><p>io读写的方式：中断，DMA</p>
<p>DMA 直接内存存取,是允许外设组件将I/O数据直接传送到主存储器中并且传输不需要CPU的参与，以此将CPU解放出来去完成其他的事情。，相较于中断方式，减少cpu中断次数，不用cpu拷贝数据。</p>
<p>主要流程如下：</p>
<ol>
<li>用户进程发起数据读取请求</li>
<li>系统调度为该进程分配cpu</li>
<li>cpu向DMA发送io请求</li>
<li>用户进程等待io完成，让出cpu</li>
<li>系统调度cpu执行其他任务</li>
<li>数据写入至io控制器的缓冲寄存器</li>
<li>DMA不断获取缓冲寄存器中的数据（需要cpu时钟）</li>
<li>传输至内存（需要cpu时钟）</li>
<li>所需的全部数据获取完毕后向cpu发出中断信号</li>
</ol>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ol>
<li>浅析Linux中的零拷贝技术：<a href="https://www.jianshu.com/p/fad3339e3448" target="_blank" rel="noopener">https://www.jianshu.com/p/fad3339e3448</a></li>
<li>零复制：<a href="https://zh.wikipedia.org/wiki/零复制" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/零复制</a></li>
<li>零拷贝原理-数据的收发-软中断和DMA：<a href="https://blog.csdn.net/xiaofei0859/article/details/74321216" target="_blank" rel="noopener">https://blog.csdn.net/xiaofei0859/article/details/74321216</a></li>
<li>浅谈 Linux下的零拷贝机制：<a href="https://cloud.tencent.com/developer/article/1152609" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1152609</a></li>
</ol>
<h4 id="参考地址-1"><a href="#参考地址-1" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="http://trumandu.github.io/2019/06/14/浅析零拷贝技术" target="_blank" rel="noopener">http://trumandu.github.io/2019/06/14/浅析零拷贝技术</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>零拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Linux的CPU上下文切换</title>
    <url>/2020/02/07/2020/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%9A%84CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="如何理解Linux的上下文切换"><a href="#如何理解Linux的上下文切换" class="headerlink" title="如何理解Linux的上下文切换"></a>如何理解Linux的上下文切换</h4><ul>
<li><code>Linux</code> 是一个多任务操作系统，它支持同时运行的任务数量远大于 <code>CPU</code> 个数。其实这些任务没有真正的同时运行，是因为系统在很短的时间内，将 <code>CPU</code> 轮流分配给它们，造成多任务同时运行的错觉。</li>
<li>而在每个任务运行前，<code>CPU</code> 都需要知道任务从哪里加载、从哪里开始运行，需要系统事先设置好 <code>CPU 寄存器</code>和<code>程序计数器</code>。<code>CPU</code> 寄存器是 <code>CPU</code> 内置的容量小、速度极快的内存。而程序计数器则是用来存储 <code>CPU</code> 正在执行的指令位置、或即将执行的下一条指令位置。它们都是 <code>CPU</code> 在运行任务前必须依赖的环境，也被叫做 <code>CPU 上下文</code>。</li>
<li><code>上下文切换</code>，就是先把前一个任务的 <code>CPU</code> 上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳到程序计数器所指的新位置，运行新任务。而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</li>
</ul>
<p>根据任务的不同，<code>CPU</code> 的上下文切换可以分为几个不同的场景，也就是：进程上下文切换、线程上下文切换、中断上下文切换。</p>
<h4 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h4><p><strong>1、用户空间与内核空间</strong></p>
<p><code>Linux</code> 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着 CPU 特权等级的 <code>Ring 0</code> 和 <code>Ring 3</code>。</p>
<ul>
<li>内核空间(<code>Ring 0</code>)具有最高权限，可以直接访问所有资源。</li>
<li>用户空间(<code>Ring 3</code>)只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入内核中才能访问这些特权资源。</li>
<li>进程既可以在用户空间运行，又可以在内核空间运行。在用户空间运行时被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</li>
</ul>
<p><strong>2、系统调用</strong></p>
<p>从用户态到内核态的转变，需要通过<code>系统调用</code>来完成。比如查看文件时，需要执行多次系统调用：open、read、write、close等。系统调用的过程如下：</p>
<ul>
<li>首先，把 CPU 寄存器里原来用户态的指令位置保存起来</li>
<li>为了执行内核代码，CPU 寄存器需要更新为内核态指令的新位置，最后跳转到内核态运行内核任务。</li>
<li>系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</li>
<li>所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。</li>
</ul>
<p>但系统调用的过程中并不会涉及虚拟内存等进程用户态的资源，也不会切换进程，这和平时说的进程上下文切换是不一样的：</p>
<ul>
<li>进程上下文切换，是指从一个进程切换到另一个进程运行</li>
<li>系统调用过程中一直是同一个进程在运行</li>
</ul>
<p>因此，系统调用的过程通常称为特权模式切换，而不是上下文切换。</p>
<p><strong>3、进程上下文切换</strong></p>
<p>进程是由内核来管理和调度的，进程的切换只能发生在内核态，因此进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p>
<p>因此进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需先把该进程的<code>虚拟内存、栈等保存</code>下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p>
<p>保存上下文和恢复上下文的过程并不是<code>免费</code>的，需要内核在 CPU 上运行才能完成。据测试，每次上下文切换都需要几十纳秒到数微妙的 <code>CPU</code> 时间。特别是在进程上下文切换次数较多的情况下，很容易导致 <code>CPU</code> 将大量时间消耗在寄存器、内核栈、虚拟内存等资源的保存和恢复上，从而大大缩短了真正运行进程的时间。</p>
<p><code>Linux</code> 通过 <code>TLB</code> 来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，<code>TLB</code> 也需要刷新，内存的访问也会随之变慢。特别是多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其它处理器的进程。</p>
<p><strong>4、进程上下文何时切换</strong></p>
<p><code>Linux</code> 为每个 <code>CPU</code> 维护了一个就绪队列，将活跃进程按照优先级和等待 <code>CPU</code> 的时间排序，然后选择最需要 <code>CPU</code> 的进程，也就是优先级最高和等待 <code>CPU</code> 时间最长的进程来运行。那么，进程在什么时候才会被调度到 <code>CPU</code> 上运行呢？</p>
<ul>
<li>进程执行完终止了，它之前使用的 <code>CPU</code> 会释放出来，这时再从就绪队列中拿一个新的进程来运行</li>
<li>为了保证所有进程可以得到公平调度，<code>CPU</code> 时间被划分为一段段的时间片，这些时间片被轮流分配给各个进程。当某个进程时间片耗尽了就会被系统挂起，切换到其它等待 <code>CPU</code> 的进程运行。</li>
<li>进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行。</li>
<li>当进程通过睡眠函数 <code>sleep</code> 主动挂起时，也会重新调度。</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li>
<li>发生硬件中断时，<code>CPU</code> 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li>
</ul>
<h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><p>线程与进程最大的区别在于，线程是操作系统调度的最小单位，而进程是操作系统分配资源的最小单位。所谓内核调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。对于线程和进程我们可以这么理解：</p>
<ul>
<li>当进程只有一个线程时，可以认为进程就等于线程</li>
<li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li>
<li>另外线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也时需要保存的。</li>
</ul>
<p>其实线程的上下文切换可以分为两种情况：</p>
<ul>
<li>前后两个线程属于不同进程。此时因为资源不共享，所以切换过程就跟进程上下文切换是一样的。</li>
<li>前后两个线程属于同一个进程。此时虚拟内存是共享的，上下文切换时，虚拟内存这些资源保持不动，只需要切换线程的私有数、寄存器等不共享的数据。</li>
</ul>
<p>可以发现同进程内的线程切换，要比多进程间的切换消耗更少的资源，这也正是多线程代替多进程的一个优势。</p>
<h4 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h4><p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其它进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p>
<ul>
<li>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以即便中断过程打断了一个正在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文其实只包括内核态中断服务程序执行所必需的状态，包括 <code>CPU</code> 寄存器、内核堆栈、硬件中断参数等。</li>
<li>对同一个 <code>CPU</code> 来说，中断处理比进程拥有更高的优先级，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</li>
<li>跟进程上下文切换一样，中断上下文切换也需要消耗 <code>CPU</code>，当发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</li>
</ul>
<h4 id="概念小结"><a href="#概念小结" class="headerlink" title="概念小结"></a>概念小结</h4><p>总结一下，不管是哪种场景导致的上下文切换，你都应该知道：</p>
<ul>
<li><code>CPU</code> 上下文切换是保证 <code>Linux</code> 系统正常工作的核心功能之一，一般情况下我们无需特别关注。</li>
<li>过多的上下文切换，会把 <code>CPU</code> 时间消耗在寄存器、内核栈、虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。</li>
</ul>
<h4 id="如何查看系统的上下文切换"><a href="#如何查看系统的上下文切换" class="headerlink" title="如何查看系统的上下文切换"></a>如何查看系统的上下文切换</h4><p>我们可以通过 <code>vmstat</code> 工具来查看系统的上下文切换情况。<code>vmstat</code> 主要用来分析系统内存使用情况，也常用来分析 <code>CPU</code> 上下文切换和中断的次数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每隔 5 秒输出 1 组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vmstat 5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b  swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0    0 7005360  91564 818900    0    0     0     0   25   33  0  0 100  0  0</span><br></pre></td></tr></table></figure>

<p>我们需要重点关注下列四项内容：</p>
<ul>
<li>cs(context switch) 是每秒上下文切换的次数。</li>
<li>in(interrupt) 是每秒中断的次数。</li>
<li>r(Running or Runnable) 是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。</li>
<li>b(Blocked) 是处于不可中断睡眠状态的进程数。</li>
</ul>
<p>想要查看每个进程的详细情况，需要使用 pidstat，给它加上 <code>-w</code> 选项，就可以查看每个进程上下文切换的情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每隔 5 秒输出 1 组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -w 5</span></span><br><span class="line">Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)</span><br><span class="line">08:18:26      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:18:31        0         1      0.20      0.00  systemd</span><br><span class="line">08:18:31        0         8      5.40      0.00  rcu_sched</span><br></pre></td></tr></table></figure>

<p>上述结果有两列是我们重点关注的对象，一个是 cswch，表示每秒自愿上下文切换的次数；另一个是 nvcswch，表示每秒非自愿上下文切换的次数。</p>
<ul>
<li>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如，IO、内存等系统资源不足时，就会发生自愿上下文切换。</li>
<li>非资源上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在抢占 CPU 时，就容易发生非自愿上下文切换。</li>
</ul>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p><strong>准备环境</strong></p>
<p><code>sysbench</code> 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况，本次案例把它当作一个异常进程来看，作用是模拟上下文切换过多的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 预先安装 sysbench</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install sysbench -y</span></span><br></pre></td></tr></table></figure>

<p><strong>操作和分析</strong></p>
<p>首先在第一个终端里运行 <code>sysbench</code>，模拟系统多线程调度的瓶颈：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysbench --threads=10 --max-time=300 threads run</span></span><br></pre></td></tr></table></figure>

<p>接着在第二个终端运行 <code>vmstat</code>，观察上下文切换情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vmstat 1</span></span><br><span class="line">procs --------memory-------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b swpd   free   buff  cache  si so bi bo   in   cs us sy id wa st</span><br><span class="line"> 6  0  0 6487428 118240 1292772    0   0  0  0 9019 1398830 16 84  0  0  0</span><br><span class="line"> 8  0  0 6487428 118240 1292772    0   0  0  0 10191 1392312 16 84  0  0  0</span><br></pre></td></tr></table></figure>

<p>可以发现，cs 列的上下文切换次数从之前的 35 上升到了 139 万，观察其他几个指标：</p>
<ul>
<li>r 列：就绪队列长度为 8，远大于 CPU 个数，所以会有大量的 CPU 竞争</li>
<li>us 和 sys 列：这两列加一起上升到 100%，sys 列高达 84%，说明 CPU 主要是被内核占用了。</li>
<li>in 列：中断次数为 1 万左右，说明中断也是个潜在的问题。</li>
</ul>
<p>综合分析，由于系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。</p>
<p>我们可以使用 pidstat 继续分析到底是哪个进程导致了这些问题？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -w -u 1</span></span><br><span class="line">08:06:33      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">08:06:34        0     10488   30.00  100.00    0.00    0.00  100.00     0  sysbench</span><br><span class="line">08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2</span><br><span class="line"></span><br><span class="line">08:06:33      UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:06:34        0         8     11.00      0.00  rcu_sched</span><br><span class="line">08:06:34        0        16      1.00      0.00  ksoftirqd/1</span><br><span class="line">08:06:34        0       471      1.00      0.00  hv_balloon</span><br><span class="line">08:06:34        0      1230      1.00      0.00  iscsid</span><br><span class="line">08:06:34        0      4089      1.00      0.00  kworker/1:5</span><br><span class="line">08:06:34        0      4333      1.00      0.00  kworker/0:3</span><br><span class="line">08:06:34        0     10499      1.00    224.00  pidstat</span><br><span class="line">08:06:34        0     26326    236.00      0.00  kworker/u4:2</span><br><span class="line">08:06:34     1000     26784    223.00      0.00  sshd</span><br></pre></td></tr></table></figure>

<p>可以发现，<code>CPU</code> 使用率的升高是 <code>sysbench</code> 导致的，但上下文切换则来自其他进程，包括非自愿上下文切换频率最高的 <code>pidstat</code>，以及自愿上下文切换频率最高的内核线程 <code>kworker</code> 和 <code>sshd</code>。</p>
<p>默认 <code>pidstat</code> 显示进程的指标数据，加上 <code>-t</code> 参数后，才会输出线程的指标</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -wt 1</span></span><br><span class="line">08:14:05      UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">...</span><br><span class="line">08:14:05        0     10551         -      6.00      0.00  sysbench</span><br><span class="line">08:14:05        0         -     10551      6.00      0.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10552  18911.00 103740.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10553  18915.00 100955.00  |__sysbench</span><br><span class="line">08:14:05        0         -     10554  18827.00 103954.00  |__sysbench</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>虽然 <code>sysbench</code> 进程的上下文切换次数不多，但它的子线程的上下文切换次数非常多，可以判定上下文切换罪魁祸首的是 <code>sysbench</code> 进程。还没完，记得我们通过 <code>vmstat</code> 看到的中断次数到了 1 万，到底是什么类型的中断上升了呢？</p>
<p>我们可以通过 <code>/proc/interrupts</code> 来读取中断的使用情况，通过运行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d 参数表示高亮显示变化的区域</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> watch -d cat /proc/interrupts</span></span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line">RES:    2450431    5279697   Rescheduling interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以发现，变化速度最快的是<code>重调度中断(RES)</code>，表示唤醒空闲状态的 <code>CPU</code> 来调度新的任务运行。这是多处理器系统(SMP)中，调度器用来分散任务队列到不同 <code>CPU</code> 的机制，通常也被称为<code>处理器间中断</code>。根本原因还是因为过多任务的调度问题，跟前边分析结果是一致的。</p>
<h4 id="每秒上下文切换多少次算正常"><a href="#每秒上下文切换多少次算正常" class="headerlink" title="每秒上下文切换多少次算正常"></a>每秒上下文切换多少次算正常</h4><p>这个数值其实取决于系统本身的 <code>CPU</code> 性能。如果系统的上下文切换次数比较稳定，从数百到一万以内，都应该算是正常的。如果当上下文切换次数超过一万次，或者切换次数出现数量级增长时，很可能已经出现了性能问题。</p>
<p>这时，你还需要根据上下文切换的类型，再做具体分析，比方说：</p>
<ul>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 <code>IO</code> 等其他问题</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 <code>CPU</code>，说明 <code>CPU</code> 的确成了瓶颈。</li>
<li>中断次数变多了，说明 <code>CPU</code> 被中断处理程序占用，还需要通过查看 <code>/proc/interrupts</code> 文件来分析具体的中断类型。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.linuxblogs.cn/articles/18120200.html" target="_blank" rel="noopener">https://www.linuxblogs.cn/articles/18120200.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/79772089" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79772089</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析synchronized原理和锁膨胀过程</title>
    <url>/2020/02/06/2020/02/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90synchronized%E5%8E%9F%E7%90%86%E5%92%8C%E9%94%81%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>上一篇文章介绍了多线程的概念及<code>synchronized</code>的使用方法<a href="https://ddnd.cn/2019/03/21/java-synchronized/" target="_blank" rel="noopener">《synchronized的使用（一）》</a>，但是仅仅会用还是不够的，只有了解其底层实现才能在开发过程中运筹帷幄，所以本篇探讨<code>synchronized</code>的实现原理及锁升级(膨胀)的过程。</p>
<h4 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h4><p><code>synchronized</code>是依赖于<code>JVM</code>来实现同步的，在同步方法和代码块的原理有点区别。</p>
<h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><p>我们在代码块加上<code>synchronized</code>关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        System.out.println(<span class="string">"synSay----"</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #2                  // Field object:Ljava/lang/String;</span><br><span class="line">       <span class="number">4</span>: dup</span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: monitorenter</span><br><span class="line">       7: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      10: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">13</span>: dup</span><br><span class="line">      14: invokespecial #5                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      17: ldc           #6                  // String synSay----</span><br><span class="line">      19: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      22: invokestatic  #8                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">      25: invokevirtual #9                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">      28: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      31: invokevirtual #10                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      34: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">37</span>: aload_1</span><br><span class="line">      <span class="number">38</span>: monitorexit</span><br><span class="line">      <span class="number">39</span>: goto          <span class="number">47</span></span><br><span class="line">      <span class="number">42</span>: astore_2</span><br><span class="line">      <span class="number">43</span>: aload_1</span><br><span class="line">      <span class="number">44</span>: monitorexit</span><br><span class="line">      <span class="number">45</span>: aload_2</span><br><span class="line">      <span class="number">46</span>: athrow</span><br><span class="line">      <span class="number">47</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">7</span>    <span class="number">39</span>    <span class="number">42</span>   any</span><br><span class="line">          <span class="number">42</span>    <span class="number">45</span>    <span class="number">42</span>   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">21</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">22</span>: <span class="number">7</span></span><br><span class="line">      line <span class="number">23</span>: <span class="number">37</span></span><br><span class="line">      line <span class="number">24</span>: <span class="number">47</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">48</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/T1;</span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">      frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">        offset_delta = <span class="number">42</span></span><br><span class="line">        locals = [ class cn/T1, class java/lang/Object ]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">        offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>可以发现<code>synchronized</code>同步代码块是通过加<code>monitorenter</code>和<code>monitorexit</code>指令实现的。<br> 每个对象都有个<strong>监视器锁(monitor) *<em>，当<code>monitor</code>被占用的时候就代表对象处于锁定状态，而<code>monitorenter</code>指令的作用就是获取<code>monitor</code>的所有权，<code>monitorexit</code>的作用是释放<code>monitor</code>的所有权，这两者的工作流程如下：<br> *</em>monitorenter</strong>：</p>
<ol>
<li>如果<code>monitor</code>的进入数为0，则线程进入到<code>monitor</code>，然后将进入数设置为<code>1</code>，该线程称为<code>monitor</code>的所有者。</li>
<li>如果是线程已经拥有此<code>monitor</code>(即<code>monitor</code>进入数不为0)，然后该线程又重新进入<code>monitor</code>，则将<code>monitor</code>的进入数<code>+1</code>，这个即为<strong>锁的重入</strong>。</li>
<li>如果其他线程已经占用了<code>monitor</code>，则该线程进入到<strong>阻塞状态，知道<code>monitor</code>的进入数为0，该线程再去重新尝试获取<code>monitor</code>的所有权</strong>。</li>
</ol>
<p><strong>monitorexit</strong>：执行该指令的线程必须是<code>monitor</code>的所有者，指令执行时，<code>monitor</code>进入数<code>-1</code>，如果<code>-1</code>后进入数为<code>0</code>，那么线程退出<code>monitor</code>，不再是这个<code>monitor</code>的所有者。这个时候其它阻塞的线程可以尝试获取<code>monitor</code>的所有权。</p>
<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>在方法上加上<code>synchronized</code>关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"synSay----"</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译之后，我们利用反编译命令<code>javap -v xxx.class</code>查看对应的字节码，这里为了减少篇幅，我就只粘贴对应的方法的字节码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synSay</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: new           #3                  // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">6</span>: dup</span><br><span class="line">       7: invokespecial #4                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      10: ldc           #5                  // String synSay----</span><br><span class="line">      12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      15: invokestatic  #7                  // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;</span><br><span class="line">      18: invokevirtual #8                  // Method java/lang/Thread.getName:()Ljava/lang/String;</span><br><span class="line">      21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">21</span>: <span class="number">30</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcn/T1;</span><br></pre></td></tr></table></figure>

<p>从字节码上看，加有<code>synchronized</code>关键字的方法，常量池中比普通的方法多了个<code>ACC_SYNCHRONIZED</code>标识，<code>JVM</code>就是根据这个标识来实现方法的同步。<br> 当调用方法的时候，调用指令会检查方法是否有<code>ACC_SYNCHRONIZED</code>标识，有的话<strong>线程需要先获取<code>monitor</code>，获取成功才能继续执行方法，方法执行完毕之后，线程再释放<code>monitor</code>，同一个<code>monitor</code>同一时刻只能被一个线程拥有。</strong></p>
<h5 id="两种同步方式区别"><a href="#两种同步方式区别" class="headerlink" title="两种同步方式区别"></a>两种同步方式区别</h5><p><code>synchronized</code>同步代码块的时候通过加入字节码<code>monitorenter</code>和<code>monitorexit</code>指令来实现<code>monitor</code>的获取和释放，也就是需要<strong>JVM通过字节码显式的去获取和释放monitor实现同步</strong>，而synchronized同步方法的时候，没有使用这两个指令，而是检查方法的<code>ACC_SYNCHRONIZED</code>标志是否被设置，如果设置了则线程需要先去获取monitor，执行完毕了线程再释放monitor，也就是不需要JVM去显式的实现。<br> <strong>这两个同步方式实际都是通过获取monitor和释放monitor来实现同步的，而monitor的实现依赖于底层操作系统的<code>mutex</code>互斥原语，而操作系统实现线程之间的切换的时候需要从用户态转到内核态，这个转成过程开销比较大。</strong><br> 线程获取、释放<code>monitor</code>的过程如下：</p>
<p><img src="http://static.cyblogs.com/WX20200201-131434@2x.png" alt="http://static.cyblogs.com/WX20200201-131434@2x.png"></p>
<p>线程尝试获取<code>monitor</code>的所有权，如果获取失败说明<code>monitor</code>被其他线程占用，则将线程加入到的<strong>同步队列</strong>中，等待其他线程释放<code>monitor</code>，<strong>当其他线程释放<code>monitor</code>后，有可能刚好有线程来获取<code>monitor</code>的所有权，那么系统会将<code>monitor</code>的所有权给这个线程，而不会去唤醒同步队列的第一个节点去获取，所以<code>synchronized</code>是非公平锁</strong>。如果线程获取<code>monitor</code>成功则进入到<code>monitor</code>中，并且将其进入数<code>+1</code>。</p>
<blockquote>
<p>关于什么是公平锁、非公平锁可以参考一下美团技术团队写的<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">《不可不说的Java“锁”事》</a></p>
</blockquote>
<p>到这里我们也清楚了<code>synchronized</code>的语义底层是通过一个<code>monitor</code>的对象完成，其实<code>wait</code>、<code>notiyf</code>和<code>notifyAll</code>等方法也是依赖于<code>monitor</code>对象来完成的，<strong>这也就是为什么需要在同步方法或者同步代码块中调用的原因(需要先获取对象的锁，才能执行)，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常</strong></p>
<h4 id="Java对象的组成"><a href="#Java对象的组成" class="headerlink" title="Java对象的组成"></a>Java对象的组成</h4><p>我们知道了线程要访问同步方法、代码块的时候，首先需要取得锁，在退出或者抛出异常的时候又必须释放锁，那么锁到底是什么？又储存在哪里？<br> 为了解开这个疑问，我们需要进入<strong>Java虚拟机(JVM)</strong> 的世界。在<code>HotSpot</code>虚拟机中，<code>Java</code>对象在内存中储存的布局可以分为<code>3</code>块区域：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。<strong>synchronized使用的锁对象储存在对象头中</strong></p>
<p><img src="http://static.cyblogs.com/WX20200201-131531@2x.png" alt="http://static.cyblogs.com/WX20200201-131531@2x.png"></p>
<p><img src="http://static.cyblogs.com/WX20200201-131609@2x.png" alt="http://static.cyblogs.com/WX20200201-131609@2x.png"></p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>对象头的数据长度在<code>32</code>位和<code>64</code>位(未开启压缩指针)的虚拟机中分别为<code>32bit</code>和<code>64bit</code>。对象头由以下三个部分组成：</p>
<ul>
<li>Mark Word：记录了对象和锁的有关信息，储存对象自身的运行时数据，如哈希码(HashCode)、<code>GC</code>分代年龄、锁标志位、线程持有的锁、偏向线程<code>ID</code>、偏向时间戳、对象分代年龄等。<strong>注意这个Mark Word结构并不是固定的，它会随着锁状态标志的变化而变化，而且里面的数据也会随着锁状态标志的变化而变化，这样做的目的是为了节省空间</strong>。</li>
<li>类型指针：指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>数组长度：这个属性只有数组对象才有，储存着数组对象的长度。</li>
</ul>
<p>在<code>32</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>5</code>种中的一种。</p>
<p><img src="http://static.cyblogs.com/WX20200201-131652@2x.png" alt="http://static.cyblogs.com/WX20200201-131652@2x.png"></p>
<p>在<code>64</code>位虚拟机下，<code>Mark Word</code>的结构和数据可能为以下<code>2</code>种中的一种。</p>
<p><img src="http://static.cyblogs.com/WX20200201-131726@2x.png" alt="http://static.cyblogs.com/WX20200201-131726@2x.png"></p>
<p>这里重点注意<strong>是否偏向锁</strong>和<strong>锁标志位</strong>，这两个标识和<code>synchronized</code>的锁膨胀息息相关。</p>
<h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><p>储存着对象的实际数据，也就是我们在程序中定义的各种类型的字段内容。</p>
<h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><p><code>HotSpot</code>虚拟机的对齐方式为<code>8</code>字节对齐，即一个对象必须为<code>8</code>字节的整数倍，如果不是，则通过这个对齐填充来占位填充。</p>
<h4 id="synchronized锁膨胀过程"><a href="#synchronized锁膨胀过程" class="headerlink" title="synchronized锁膨胀过程"></a>synchronized锁膨胀过程</h4><p>上文介绍的 “<code>synchronized</code>实现原理” 实际是synchronized实现<strong>重量级锁的原理</strong>，那么上文频繁提到<code>monitor</code>对象和对象又存在什么关系呢，或者说<code>monitor</code>对象储存在对象的哪个地方呢？<br> <strong>在对象的对象头中，当锁的状态为重量级锁的时候，它的指针即指向<code>monitor</code>对象</strong>，如图：</p>
<p><img src="http://static.cyblogs.com/WX20200201-131856@2x.png" alt="http://static.cyblogs.com/WX20200201-131856@2x.png"></p>
<p><img src="http://static.cyblogs.com/WX20200201-131932@2x.png" alt="http://static.cyblogs.com/WX20200201-131932@2x.png"></p>
<p>那锁的状态为其它状态的时候是不是就没用上<code>monitor</code>对象？答案:是的。<br> 这也是<code>JVM</code>对<code>synchronized</code>的优化，我们知道重量级锁的实现是基于底层操作系统的<code>mutex</code>互斥原语的，这个开销是很大的。所以<code>JVM</code>对<code>synchronized</code>做了优化，<code>JVM</code>先利用对象头实现锁的功能，如果线程的竞争过大则会将锁升级(膨胀)为重量级锁，也就是使用<code>monitor</code>对象。当然<code>JVM</code>对锁的优化不仅仅只有这个，还有引入适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁等。</p>
<p>那么锁的是怎么进行膨胀的或者依据什么来膨胀，这也就是本篇需要介绍的重点，首先我们需要了解几个概念。</p>
<h5 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h5><h5 id="自旋锁和自适应性自旋锁"><a href="#自旋锁和自适应性自旋锁" class="headerlink" title="自旋锁和自适应性自旋锁"></a>自旋锁和自适应性自旋锁</h5><p><strong>自旋</strong>：当有个线程<code>A</code>去请求某个锁的时候，这个锁正在被其它线程占用，但是线程<code>A</code>并不会马上进入阻塞状态，而是循环请求锁(自旋)。这样做的目的是因为很多时候持有锁的线程会很快释放锁的，线程<code>A</code>可以尝试一直请求锁，没必要被挂起放弃<code>CPU</code>时间片，因为线程被挂起然后到唤醒这个过程开销很大,当然如果线程<code>A</code>自旋指定的时间还没有获得锁，仍然会被挂起。</p>
<p><strong>自适应性自旋</strong>：自适应性自旋是自旋的升级、优化，自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。例如<strong>线程如果自旋成功了，那么下次自旋的次数会增多</strong>，因为<code>JVM</code>认为既然上次成功了，那么这次自旋也很有可能成功，那么它会允许自旋的次数更多。反之，如果<strong>对于某个锁，自旋很少成功</strong>，那么在以后获取这个锁的时候，自旋的次数会变少甚至忽略，避免浪费处理器资源。有了自适应性自旋，随着程序运行和性能监控信息的不断完善，<code>JVM</code>对程序锁的状况预测就会变得越来越准确，<code>JVM</code>也就变得越来越聪明。</p>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除是指虚拟机即时编译器在运行时，<strong>对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除</strong>。</p>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>在使用锁的时候，需要让同步块的作用范围尽可能小，这样做的目的是<strong>为了使需要同步的操作数量尽可能小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁</strong>。</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>所谓<strong>轻量级锁</strong>是相对于使用底层操作系统<code>mutex</code>互斥原语实现同步的<strong>重量级锁</strong>而言的，因为轻量级锁同步的<strong>实现是基于对象头的Mark Word</strong>。那么轻量级锁是怎么使用对象头来实现同步的呢，我们看看具体实现过程。</p>
<p><strong>获取锁过程</strong>：</p>
<ol>
<li>在线程进入同步方法、同步块的时候，如果<strong>同步对象锁状态为无锁状态(锁标志位为”01”状态，是否为偏向锁为”0”)</strong>，虚拟机首先将在当前线程的栈帧中<strong>建立一个名为锁记录(Lock Recored)的空间</strong>，用于储存锁对象目前的Mark Word的拷贝(官方把这份拷贝加了个Displaced前缀，即Displaced Mark Word)。</li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200201-132045@2x.png" alt="http://static.cyblogs.com/WX20200201-132045@2x.png"></p>
<ol>
<li>将对象头的<code>Mark Word</code>拷贝到线程的锁记录(Lock Recored)中。</li>
<li>拷贝成功后，虚拟机将使用<code>CAS</code>操作<strong>尝试将对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针</strong>。如果这个更新成功了，则执行步骤<code>4</code>，否则执行步骤<code>5</code>。</li>
<li>更新成功，这个<strong>线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为”00”，即表示此对象处于轻量级锁的状态。</strong>。</li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200201-132119@2x.png" alt="http://static.cyblogs.com/WX20200201-132119@2x.png"></p>
<ol>
<li>更新失败，虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其其它线程抢占了。<strong>进行自旋执行步骤<code>3</code>，如果自旋结束仍然没有获得锁，轻量级锁就需要膨胀为重量级锁，锁标志位状态值变为”10”，Mark Word中储存就是指向<code>monitor</code>对象的指针，当前线程以及后面等待锁的线程也要进入阻塞状态。</strong></li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200201-132152@2x.png" alt="http://static.cyblogs.com/WX20200201-132152@2x.png"></p>
<p><strong>释放锁的过程</strong>：</p>
<ol>
<li>使用<code>CAS</code>操作将对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来(依据<code>Mark Word</code>中锁记录指针是否还指向本线程的锁记录)，如果替换成功，则执行步骤<code>2</code>，否则执行步骤<code>3</code>。</li>
<li>如果替换成功，整个同步过程就完成了，恢复到无锁的状态(01)。</li>
<li>如果替换失败，说明有其他线程尝试获取该锁(此时锁已膨胀)，那就要在释放锁的同时，唤醒被挂起的线程。</li>
</ol>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁的目的是消除数据在无竞争情况下的同步原语，<strong>进一步提高程序的运行性能</strong>。如果说轻量级锁是在无竞争的情况下使用<code>CAS</code>操作区消除同步使用的互斥量，那么偏向锁就是在无竞争的情况下把整个同步都消除掉，连<code>CAS</code>操作都不用做了。<strong>偏向锁默认是开启的，也可以关闭</strong>。<br> 偏向锁”偏”，就是”偏心”的”偏”，它的意思是这个锁会偏向于第一个获得它的程序，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p><strong>获取锁的过程</strong>：</p>
<ol>
<li>检查<code>Mark Word</code>是否为<strong>可偏向锁的状态</strong>，即是否偏向锁即为1即表示支持可偏向锁，否则为0表示不支持可偏向锁。</li>
<li>如果是可偏向锁，则<strong>检查<code>Mark Word</code>储存的线程<code>ID</code>是否为当前线程<code>ID</code></strong>，如果是则执行同步块，否则执行步骤<code>3</code>。</li>
<li>如果检查到<code>Mark Word</code>的<code>ID</code>不是本线程的<code>ID</code>，则通过<code>CAS</code>操作去修改线程<code>ID</code>修改成本线程的<code>ID</code>，如果修改成功则执行同步代码块，否则执行步骤<code>4</code>。</li>
<li>当拥有该锁的线程到达安全点之后，挂起这个线程，升级为轻量级锁。</li>
</ol>
<p><strong>锁释放的过程</strong>：</p>
<ol>
<li>有其他线程来获取这个锁，偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。</li>
<li>等待全局安全点(在这个是时间点上没有字节码正在执行)。</li>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着，如果不处于活动状态，则将对象头设置为无锁状态，否则设置为被锁定状态。如果锁对象处于<strong>无锁状态，则恢复到无锁状态(01)</strong>，以允许其他线程竞争，如果<strong>锁对象处于锁定状态</strong>，则挂起持有偏向锁的线程，并将对象头<code>Mark Word</code>的锁记录指针改成当前线程的锁记录，锁<strong>升级为轻量级锁状态(00)</strong>。</li>
</ol>
<p><img src="http://static.cyblogs.com/WX20200201-132302@2x.png" alt="http://static.cyblogs.com/WX20200201-132302@2x.png"></p>
<h5 id="锁的转换过程"><a href="#锁的转换过程" class="headerlink" title="锁的转换过程"></a>锁的转换过程</h5><p>锁主要存在<code>4</code>种状态，级别从低到高依次是：<strong>无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</strong>，这几个状态会随着竞争的情况逐渐升级，这几个锁只有重量级锁是需要使用操作系统底层<code>mutex</code>互斥原语来实现，其他的锁都是使用对象头来实现的。<strong>需要注意锁可以升级，但是不可以降级。</strong></p>
<p><img src="http://static.cyblogs.com/WX20200201-132345@2x.png" alt="http://static.cyblogs.com/WX20200201-132345@2x.png"></p>
<p>这里盗个图，这个图总结的挺好的！(图被压缩过了 看不清，可以打开这个地址查看高清图<a href="http://wx2.sinaimg.cn/large/e0e01e43gy1g1cozajzz3j22zf1e7u0x.jpg" target="_blank" rel="noopener">&gt;&gt;高清图&lt;&lt;</a>)</p>
<p><img src="http://static.cyblogs.com/WX20200201-132428@2x.png" alt="http://static.cyblogs.com/WX20200201-132428@2x.png"></p>
<h5 id="三种锁的优缺点比较"><a href="#三种锁的优缺点比较" class="headerlink" title="三种锁的优缺点比较"></a>三种锁的优缺点比较</h5><p><img src="http://static.cyblogs.com/WX20200201-132500@2x.png" alt="http://static.cyblogs.com/WX20200201-132500@2x.png"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://blog.csdn.net/liupeifeng3514/article/details/79111565" target="_blank" rel="noopener">JVM（三）JVM中对象的内存布局详解</a></li>
<li><a href="https://www.cnblogs.com/zhengbin/p/6490953.html" target="_blank" rel="noopener">JVM——深入分析对象的内存布局</a></li>
<li><a href="https://juejin.im/post/5b4eec7df265da0fa00a118f#heading-16" target="_blank" rel="noopener">啃碎并发（七）：深入分析Synchronized原理</a></li>
<li><a href="http://bigdatadecode.club/JavaSynchronizedTheory.html" target="_blank" rel="noopener">Java Synchronized实现原理</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Linux用户态和内核态</title>
    <url>/2020/02/03/2020/02/%E7%90%86%E8%A7%A3Linux%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/</url>
    <content><![CDATA[<h4 id="Linux整体架构图"><a href="#Linux整体架构图" class="headerlink" title="Linux整体架构图"></a>Linux整体架构图</h4><p>我们先来看一张<code>Linux</code>整体架构图。</p>
<p><img src="http://static.cyblogs.com/3433091-63269eb8f87c2bb9.png" alt="http://static.cyblogs.com/3433091-63269eb8f87c2bb9.png"></p>
<h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><p>​        系统调用时操作系统的最小功能单位。根据不同的应用场景，不同的<code>Linux</code>发行版本提供的系统调用数量也不尽相同，大致在240-350之间。这些系统调用组成了用户态跟内核态交互的基本接口，例如：用户态想要申请一块20K大小的动态内存，就需要brk系统调用，将数据段指针向下偏移，如果用户态多处申请20K动态内存，同时又释放呢？这个内存的管理就变得非常的复杂。</p>
<h5 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h5><p>​        库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现。它对系统调用进行封装，提供简单的基本接口给用户，这样增强了程序的灵活性，当然对于简单的接口，也可以直接使用系统调用访问资源，例如：<code>open()</code>，<code>write()</code>，<code>read()</code>等等。库函数根据不同的标准也有不同的版本，例如：<code>glibc</code>库，<code>posix</code>库等。</p>
<h5 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h5><p>​        <code>Shell</code>顾名思义，就是外壳的意思。就好像把内核包裹起来的外壳。它是一种特殊的应用程序，俗称命令行。为了方便用户和系统交互，一般一个<code>Shell</code>对应一个终端，呈现给用户交互窗口。当然<code>Shell</code>也是编程的，它有标准的<code>shell</code>语法，符合其语法的文本叫<code>Shell</code>脚本。很多人都会用<code>Shell</code>脚本实现一些常用的功能，可以提高工作效率。</p>
<h4 id="为什么要区分用户态与内核态？"><a href="#为什么要区分用户态与内核态？" class="headerlink" title="为什么要区分用户态与内核态？"></a>为什么要区分用户态与内核态？</h4><p>在<code>CPU</code>的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。如果所有的程序都能使用这些指令，那么你的系统一天死机N回就不足为奇了。所以，<code>CPU</code>将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。<code>Intel</code>的<code>CPU</code>将特权级别分为4个级别：<code>RING0</code>、<code>RING1</code>、<code>RING2</code>、<code>RING3</code>。</p>
<p>​        当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。</p>
<ul>
<li>当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</li>
<li>当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。</li>
</ul>
<p>​        当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。<code>Linux</code>使用了<code>Ring3</code>级别运行用户态，<code>Ring0</code>作为 内核态，没有使用<code>Ring1</code>和<code>Ring2</code>。<code>Ring3</code>状态不能访问<code>Ring0</code>的地址空间，包括代码和数据。<code>Linux</code>进程的<code>4GB</code>地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过<code>write</code>，<code>send</code>等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到<code>Ring0</code>，然后进入<code>3GB-4GB</code>中的内核地址空间去执行这些代码完成操作，完成后，切换回<code>Ring3</code>，回到用户态。</p>
<p>这样，用户态的程序就不能 随意操作内核地址空间，具有一定的安全保护作用。</p>
<p> 处理器总处于以下状态中的一种：</p>
<ul>
<li><p>1、内核态，运行于进程上下文，内核代表进程运行于内核空间；</p>
</li>
<li><p>2、内核态，运行于中断上下文，内核代表硬件运行于内核空间；</p>
</li>
<li><p>3、用户态，运行于用户空间。</p>
</li>
</ul>
<h4 id="用户态到内核态怎样切换？"><a href="#用户态到内核态怎样切换？" class="headerlink" title="用户态到内核态怎样切换？"></a>用户态到内核态怎样切换？</h4><p>从用户态到内核态切换可以通过三种方式：</p>
<p><strong>系统调用：</strong>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p><strong>异常：</strong>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p><strong>外设中断：</strong>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://zhuanlan.zhihu.com/p/69554144" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69554144</a></li>
<li><a href="https://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html" target="_blank" rel="noopener">https://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊Java内省Introspector</title>
    <url>/2020/02/04/2020/02/%E8%81%8A%E8%81%8AJava%E5%86%85%E7%9C%81Introspector/</url>
    <content><![CDATA[<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>这篇文章主要分析一下<code>Introspector</code>(内省)的用法。<code>Introspector</code>是一个专门处理<code>JavaBean</code>的工具类，用来获取<code>JavaBean</code>里描述符号，常用的<code>JavaBean</code>的描述符号相关类有<code>BeanInfo</code>、<code>PropertyDescriptor</code>，<code>MethodDescriptor</code>、<code>BeanDescriptor</code>、<code>EventSetDescriptor</code>和<code>ParameterDescriptor</code>。下面会慢慢分析这些类的使用方式，以及<code>Introspector</code>的一些特点。</p>
<h4 id="JavaBean是什么"><a href="#JavaBean是什么" class="headerlink" title="JavaBean是什么"></a>JavaBean是什么</h4><p><code>JavaBean</code>是一种特殊（其实说普通也可以，也不是十分特殊）的类，主要用于传递数据信息，这种类中的方法主要用于访问私有的字段，且方法名符合某种命名规则（字段都是私有，每个字段具备<code>Setter</code>和<code>Getter</code>方法，方法和字段命名满足首字母小写驼峰命名规则）。如果在两个模块之间传递信息，可以将信息封装进<code>JavaBean</code>中，这种对象称为值对象(<code>Value Object</code>)或者<code>VO</code>。这些信息储存在类的私有变量中，通过<code>Setter</code>、<code>Getter</code>方法获得。<code>JavaBean</code>的信息在<code>Introspector</code>里对应的概念是<code>BeanInfo</code>，它包含了<code>JavaBean</code>所有的<code>Descriptor</code>(描述符)，主要有<code>PropertyDescriptor</code>，<code>MethodDescriptor</code>(<code>MethodDescriptor</code>里面包含<code>ParameterDescriptor</code>)、<code>BeanDescriptor</code>和<code>EventSetDescriptor</code>。</p>
<h4 id="属性Field和属性描述PropertiesDescriptor的区别"><a href="#属性Field和属性描述PropertiesDescriptor的区别" class="headerlink" title="属性Field和属性描述PropertiesDescriptor的区别"></a>属性Field和属性描述PropertiesDescriptor的区别</h4><p>如果是严格的<code>JavaBean</code>(<code>Field</code>名称不重复，并且<code>Field</code>具备<code>Setter</code>和<code>Getter</code>方法)，它的<code>PropertyDescriptor</code>会通过解析<code>Setter</code>和<code>Getter</code>方法，合并解析结果，最终得到对应的<code>PropertyDescriptor</code>实例。所以<code>PropertyDescriptor</code>包含了属性名称和属性的<code>Setter</code>和<code>Getter</code>方法(如果存在的话)。</p>
<h4 id="内省Introspector和反射Reflection的区别"><a href="#内省Introspector和反射Reflection的区别" class="headerlink" title="内省Introspector和反射Reflection的区别"></a>内省Introspector和反射Reflection的区别</h4><ul>
<li><code>Reflection</code>：反射就是运行时获取一个类的所有信息，可以获取到类的所有定义的信息（包括成员变量，成员方法，构造器等）可以操纵类的字段、方法、构造器等部分。可以想象为镜面反射或者照镜子，这样的操作是带有客观色彩的，也就是反射获取到的类信息是必定正确的。</li>
<li><code>Introspector</code>：内省基于反射实现，主要用于操作<code>JavaBean</code>，基于<code>JavaBean</code>的规范进行<code>Bean</code>信息描述符的解析，依据于类的<code>Setter</code>和<code>Getter</code>方法，可以获取到类的描述符。可以想象为“自我反省”，这样的操作带有主观的色彩，不一定是正确的(如果一个类中的属性没有<code>Setter</code>和<code>Getter</code>方法，无法使用内省)。</li>
</ul>
<h4 id="常用的内省相关类"><a href="#常用的内省相关类" class="headerlink" title="常用的内省相关类"></a>常用的内省相关类</h4><p>主要介绍一下几个核心类所提供的方法。</p>
<h4 id="Introspector"><a href="#Introspector" class="headerlink" title="Introspector"></a>Introspector</h4><p><code>Introspector</code>类似于<code>BeanInfo</code>的静态工厂类，主要是提供静态方法通过<code>Class</code>实例获取到<code>BeanInfo</code>，得到<code>BeanInfo</code>之后，就能够获取到其他描述符。主要方法：</p>
<ul>
<li><code>public static BeanInfo getBeanInfo(Class beanClass)</code>：通过<code>Class</code>实例获取到<code>BeanInfo</code>实例。</li>
</ul>
<h4 id="BeanInfo"><a href="#BeanInfo" class="headerlink" title="BeanInfo"></a>BeanInfo</h4><p><code>BeanInfo</code>是一个接口，具体实现是<code>GenericBeanInfo</code>，通过这个接口可以获取一个类的各种类型的描述符。主要方法：</p>
<ul>
<li><code>BeanDescriptor getBeanDescriptor()</code>：获取<code>JavaBean</code>描述符。</li>
<li><code>EventSetDescriptor[] getEventSetDescriptors()</code>：获取<code>JavaBean</code>的所有的<code>EventSetDescriptor</code>。</li>
<li><code>PropertyDescriptor[] getPropertyDescriptors()</code>：获取<code>JavaBean</code>的所有的<code>PropertyDescriptor</code>。</li>
<li><code>MethodDescriptor[] getMethodDescriptors()</code>：获取<code>JavaBean</code>的所有的<code>MethodDescriptor</code>。</li>
</ul>
<p>这里要注意一点，通过<code>BeanInfo#getPropertyDescriptors()</code>获取到的<code>PropertyDescriptor</code>数组中，除了<code>Bean</code>属性的之外，还会带有一个属性名为<code>class</code>的<code>PropertyDescriptor</code>实例，它的来源是<code>Class</code>的<code>getClass</code>方法，如果不需要这个属性那么最好判断后过滤。</p>
<h4 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h4><p><code>PropertyDescriptor</code>类表示<code>JavaBean</code>类通过存储器(<code>Setter</code>和<code>Getter</code>)导出一个属性，它应该是内省体系中最常见的类。主要方法：</p>
<ul>
<li><code>synchronized Class getPropertyType()</code>：获得属性的<code>Class</code>对象。</li>
<li><code>synchronized Method getReadMethod()</code>：获得用于读取属性值的方法；</li>
<li><code>synchronized Method getWriteMethod()</code>：获得用于写入属性值的方法。</li>
<li><code>int hashCode()</code>：获取对象的哈希值。</li>
<li><code>synchronized void setReadMethod(Method readMethod)</code>：设置用于读取属性(<code>Getter</code>)值的方法。</li>
<li><code>synchronized void setWriteMethod(Method writeMethod)</code>：设置用于写入属性值(<code>Setter</code>)的方法。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">复制<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo beanInfo = Introspector.getBeanInfo(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">"class"</span>.equals(propertyDescriptor.getName())) &#123;</span><br><span class="line">                System.out.println(propertyDescriptor.getName());</span><br><span class="line">                System.out.println(propertyDescriptor.getWriteMethod().getName());</span><br><span class="line">                System.out.println(propertyDescriptor.getReadMethod().getName());</span><br><span class="line">                System.out.println(<span class="string">"======================="</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">复制age</span><br><span class="line">setAge</span><br><span class="line">getAge</span><br><span class="line">=======================</span><br><span class="line">id</span><br><span class="line">setId</span><br><span class="line">getId</span><br><span class="line">=======================</span><br><span class="line">name</span><br><span class="line">setName</span><br><span class="line">getName</span><br><span class="line">=======================</span><br></pre></td></tr></table></figure>

<h4 id="不正当使用Introspector会导致内存溢出"><a href="#不正当使用Introspector会导致内存溢出" class="headerlink" title="不正当使用Introspector会导致内存溢出"></a>不正当使用Introspector会导致内存溢出</h4><p>如果框架或者程序用到了<code>JavaBeans Introspector</code>，那么就相当于启用了一个系统级别的缓存，这个缓存会存放一些曾加载并分析过的<code>Javabean</code>的引用，当<code>web</code>服务器关闭的时候，由于这个缓存中存放着这些<code>Javabean</code>的引用，所以垃圾回收器不能对<code>Web</code>容器中的<code>JavaBean</code>对象进行回收，导致内存越来越大。还有一点值得注意，清除<code>Introspector</code>缓存的唯一方式是刷新整个缓存缓冲区，这是因为<code>JDK</code>没法判断哪些是属于当前的应用的引用，所以刷新整个<code>Introspector</code>缓存缓冲区会导致把服务器的所有应用的<code>Introspector</code>缓存都删掉。<code>Spring</code>中提供的<code>org.springframework.web.util.IntrospectorCleanupListener</code>就是为了解决这个问题，它会在<code>Web</code>服务器停止的时候，清理一下这个<code>Introspector</code>缓存，使那些<code>Javabean</code>能被垃圾回收器正确回收。</p>
<p>也就是说<code>JDK</code>的<code>Introspector</code>缓存管理是有一定缺陷的。但是如果使用在<code>Spring</code>体系则不会出现这种问题，因为<code>Spring</code>把<code>Introspector</code>缓存的管理移交到<code>Spring</code>自身而不是<code>JDK</code>（或者在<code>Web</code>容器销毁后完全不管），在加载并分析完所有类之后，会针对类加载器对<code>Introspector</code>缓存进行清理，避免内存泄漏的问题，详情可以看<code>CachedIntrospectionResults</code>和<code>SpringBoot</code>刷新上下文的方法<code>AbstractApplicationContext#refresh()</code>中<code>finally</code>代码块中存在清理缓存的方法<code>AbstractApplicationContext#resetCommonCaches();</code>。但是有很多程序和框架在使用了<code>JavaBeans Introspector</code>之后，都没有进行清理工作，比如<code>Quartz、Struts</code>等，这类操作会成为内存泄漏的隐患。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>在标准的<code>JavaBean</code>中，可以考虑使用<code>Introspector</code>体系解析<code>JavaBean</code>，主要是方便使用反射之前的时候快速获取到<code>JavaBean</code>的<code>Setter</code>和<code>Getter</code>方法。</li>
<li>在<code>Spring</code>体系中，为了防止<code>JDK</code>对内省信息的缓存无法被垃圾回收机制回收导致内存溢出，主要的操作除了可以通过配置<code>IntrospectorCleanupListener</code>预防，还有另外一种方式，就是通过<code>CachedIntrospectionResults</code>类自行管理<code>Introspector</code>中的缓存(这种方式才是优雅的方式，这样可以避免刷新整个<code>Introspector</code>的缓存缓冲区而导致其他应用的<code>Introspector</code>也被清空)，<strong>也就是把Jdk自行管理的Introspector相关缓存交给Spring自己去管理</strong>。在<code>SpringBoot</code>刷新上下文的方法<code>AbstractApplicationContext#refresh()</code>中finally代码块中存在清理缓存的方法<code>AbstractApplicationContext#resetCommonCaches();</code>，里面调用到的<code>CachedIntrospectionResults#clearClassLoader(getClassLoader())</code>方法就是清理指定的<code>ClassLoader</code>下的所有<code>Introspector</code>中的缓存的引用。</li>
</ul>
<p>（本文完 e-a-20191225 c-1-d 更新了博客主题，感觉比以前好看一点点…）</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="http://www.throwable.club/2019/12/25/java-introspector-usage" target="_blank" rel="noopener">http://www.throwable.club/2019/12/25/java-introspector-usage</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList中几个不为人知的事情</title>
    <url>/2020/03/09/2020/03/ArrayList%E4%B8%AD%E5%87%A0%E4%B8%AA%E4%B8%8D%E4%B8%BA%E4%BA%BA%E7%9F%A5%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    <content><![CDATA[<p>今天学习下<code>ArrayList</code>的源代码，不同于其他人写的博客，很多都是翻译源代码中的注释，然后直接贴到文章中去。小编打算换一种书写风格，带着问题看源码可能收获会更大，本文将围绕着下面几个问题展开讨论。</p>
<h3 id="一、问题产生"><a href="#一、问题产生" class="headerlink" title="一、问题产生"></a>一、问题产生</h3><ul>
<li>1、为什么<code>ArrayList</code>集合中存储元素的容器声明为<code>transient Object[] elementData;</code>？</li>
<li>2、既然<code>ArrayList</code>可以自动扩容，那么它的扩容机制是怎样实现的？</li>
<li>3、调用<code>ArrayList</code>的<code>iterator()</code>返回的迭代器是怎样的？</li>
<li>4、采用<code>ArrayList</code>的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出<code>ConcurrentModificationException</code>,我们该如何避免？</li>
<li>5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么<code>ArrayList</code>的数组拷贝是怎么实现的？</li>
<li>6、<code>ArrayList</code>中的序列化机制</li>
</ul>
<p>小编对<code>ArrayList</code>源码大概浏览了之后，总结出以上几个问题，带着这些问题，让我们一起翻开源码解决吧！</p>
<h3 id="二、问题解答"><a href="#二、问题解答" class="headerlink" title="二、问题解答"></a>二、问题解答</h3><h5 id="1、为什么ArrayList集合中存储元素的容器声明为transient-Object-elementData-？"><a href="#1、为什么ArrayList集合中存储元素的容器声明为transient-Object-elementData-？" class="headerlink" title="1、为什么ArrayList集合中存储元素的容器声明为transient Object[] elementData;？"></a>1、为什么<code>ArrayList</code>集合中存储元素的容器声明为<code>transient Object[] elementData;</code>？</h5><p><code>ArrayList</code>是一个集合容器，既然是一个容器，那么肯定需要存储某些东西，既然需要存储某些东西，那总得有一个存储的地方吧！就好比说你需要装一吨的水，总得有个池子给你装吧！或者说你想装几十毫升水，总得那个瓶子或者袋子给你装吧！区别就在于不同大小的水，我们需要的容器大小也不相同而已！</p>
<p>既然<code>ArrayList</code>已经支持泛型了，那么为什么<code>ArrayList</code>源码的容器定义为什么还要定义成下面的<code>Object[]</code>类型呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>其实无论你采用<code>transient E[] elementData;</code>的方式声明，或者是采用<code>transient Object[] elementData;</code>声明，都是允许的，差别在于前者要求我们我们在具体实例化<code>elementData</code>时需要做一次类型转换，而这次类型转换要求我们程序员保证这种转换不会出现任何错误。为了提醒程序员关注可能出现的类型转换异常，编译器会发出一个<code>Type safety: Unchecked cast from String[] to E[]</code>警告,这样讲不知道会不会很懵比，下面的代码告诉你：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 声明数组，类型为E[]</span></span><br><span class="line">    E[] DATAS;</span><br><span class="line">    <span class="comment">// 初始化数组，必须做一次类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    	DATAS = (E[]) <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getDATAS</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> DATAS[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDATAS</span><span class="params">(E[] dATAS)</span> </span>&#123;</span><br><span class="line">    	DATAS = dATAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在<code>1</code>处我们声明了<code>E[]</code>数组，具体类型取决于你传入<code>E</code>的实际类型，但是要注意，当你对<code>DATAS</code>进行初始化时，你不能像下面这样初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E[] DATAS = <span class="keyword">new</span> E[<span class="number">10</span>]; <span class="comment">// 这句代码将报错</span></span><br></pre></td></tr></table></figure>

<p>也就是说，<strong>泛型数组是不能具体化的</strong>，也就是不能通过<code>new 泛型[size];</code>的方式进行具体化，那么怎么解决呢？有两种方式：</p>
<ul>
<li><p>1、进行前面说的做一次转换，但不推荐</p>
<p>就像上面代码所展示的，我们可以初始化成<code>Object[]</code>类型之后再转换成<code>E[]</code>，但前提是你得保证这次转换不会出现任何错误，通常我们不建议这样子写！</p>
</li>
<li><p>2、直接声明为<code>Object[]</code></p>
<p>这种方式也是<code>ArrayList</code>源码的定义方式，那么我们来看看<code>ArrayList</code>是怎么初始化的：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 此处直接new Object[]，不会出现任何错误</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是有一点还需要注意，但你调用<code>ArrayList</code>的<code>toArray</code>方法将集合转换为对象数组时，有可能出现意想不到的结果，具体可参考小编的另外一篇博文。</p>
<p><strong>总结：</strong> 总的来说，我们要知道泛型数组是不能具体化的，以及其解决办法！你可能会很好奇我为什么没有讲<code>transient</code>，这个小编放到下面序列化反序列化时讲。</p>
<h5 id="2、既然ArrayList可以自动扩容，那么它的扩容机制是怎样实现的？"><a href="#2、既然ArrayList可以自动扩容，那么它的扩容机制是怎样实现的？" class="headerlink" title="2、既然ArrayList可以自动扩容，那么它的扩容机制是怎样实现的？"></a>2、既然<code>ArrayList</code>可以自动扩容，那么它的扩容机制是怎样实现的？</h5><p>有时候，我们得保证当增加水的时，原来的容器也可以装入新的的水而不至于溢出，也就是<code>ArrayList</code>的自动扩容机制。我们可以想象，假如列表大小为10，那么正常情况下只能装10个元素，我们很好奇在此之后调用<code>add()</code>方法时底层做了什么神奇的事，所以我们看看<code>add()</code>方法是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保内部容量大小，size指的是当前列表的实际元素个数</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面方法可以看出先判断内部容量是否足够满足<code>size + 1</code>个元素，如果可以，就直接<code>elementData[size++] = e;</code>，否则就需要扩容，那么怎么扩容呢?我们到<code>ensureCapacityInternal()</code>方法看看，这里有一点很重要，请记住下面的参数:</p>
<ul>
<li><code>minCapacity</code>永远代表增加之后实际的总元素个数</li>
<li><code>newCapacity</code>永远表示列表能够满足存储<code>minCapacity</code>个元素列表所需要扩容的大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验内部容量大小</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法只有首次调用时会用到，不然默认返回 minCapacity</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里如果成立，表示该ArrayList是刚刚初始化，还没有add进任何元素</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容，elementData.length表示列表的空间总大小，不是列表的实际元素个数，size才是列表的实际元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面会判断集合是否刚刚初始化，即还没有调用过<code>add()</code>方法，如果成立，则将集合默认扩容至10，<code>DEFAULT_CAPACITY</code>的值为10，取最大值。最后一个方法的<code>grow()</code>成立的条件是容器的元素大于10且没有可用空间，即需要扩容了，我们再看看<code>grow()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取旧的列表大小</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩容之后的新的容器大小，默认增加一半 ..............................1</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩容一半之后还不足，则新的容器大小等于minCapacity.............................2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果新的容器大小比MAX_ARRAY_SIZE还大，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 数组拷贝操作</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大不能超过Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>1</code>处<code>&gt;&gt;</code>表示右移，也就是相当于除以2，减为一半，<code>2</code>处可能调用<code>addAll()</code>方法时成立。</p>
<p>下面我们列举几种情况：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>情况描述</th>
<th>调用add()?</th>
<th>调用addAll(size)? + size大小</th>
<th>执行结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>列表刚初始化</td>
<td>是</td>
<td>否</td>
<td>初始化一个长度为10的列表，即容器扩容至10个单位</td>
</tr>
<tr>
<td>2</td>
<td>列表实际元素个数为10，实际大小也为10，此时调用add操作</td>
<td>是</td>
<td>否</td>
<td>容器扩容至15，容器元素个数为11，即有4个位置空闲</td>
</tr>
<tr>
<td>3</td>
<td>列表实际元素个数为10，列表长度也为10，此时调用addAll操作</td>
<td>否</td>
<td>是 + 5</td>
<td>容器扩容至15，没有空余</td>
</tr>
<tr>
<td>4</td>
<td>列表实际元素个数为5，列表长度为10，此时调用addAll()操作</td>
<td>否</td>
<td>是 + 10</td>
<td>容器扩容至15，没有空余</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<p>扩容机制如下：</p>
<ul>
<li>1、先默认将列表大小<code>newCapacity</code>增加原来一半，即如果原来是10，则新的大小为15；</li>
<li>2、如果新的大小<code>newCapacity</code>依旧不能满足<code>add</code>进来的元素总个数<code>minCapacity</code>,则将列表大小改为和<code>minCapacity</code>一样大；即如果扩大一半后<code>newCapacity</code>为15，但<code>add</code>进来的总元素个数<code>minCapacity</code>为20，则15明显不能存储20个元素，那么此时就将<code>newCapacity</code>大小扩大到20，刚刚好存储20个元素；</li>
<li>3、如果扩容后的列表大小大于<code>2147483639</code>,也就是说大于<code>Integer.MAX_VALUE - 8</code>,此时就要做额外处理了，因为实际总元素大小有可能比<code>Integer.MAX_VALUE</code>还要大，当实际总元素大小<code>minCapacity</code>的值大于<code>Integer.MAX_VALUE</code>，即大于<code>2147483647</code>时，此时<code>minCapacity</code>的值将变为负数，因为int是有符号的，当超过最大值时就变为负数</li>
</ul>
<p>小编认为，上面第3点也体现了一种智慧，即当一样东西有可能出错时，我们应该提前对其做处理，而不要等到错误发生时再对其进行处理。也就是我们运维要做监控的目的。</p>
<h5 id="3、调用ArrayList的iterator-返回的迭代器是怎样的？"><a href="#3、调用ArrayList的iterator-返回的迭代器是怎样的？" class="headerlink" title="3、调用ArrayList的iterator()返回的迭代器是怎样的？"></a>3、调用<code>ArrayList</code>的<code>iterator()</code>返回的迭代器是怎样的？</h5><p>我们都知道所有集合都是<code>Collection</code>接口的实现类，又因为<code>Collection</code>继承了<code>Iterable</code>接口，因此所有集合都是可迭代的。我们常常会采用集合的迭代器来遍历集合元素，就像下面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">list.add(<span class="string">"b"</span>);</span><br><span class="line"><span class="comment">// 获取集合的迭代器对象</span></span><br><span class="line">Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    String item = iter.next();</span><br><span class="line">    System.err.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过调用集合的<code>iterator()</code>方法获取集合的迭代器对象，那么在<code>ArrayList</code>中，<code>iterator()</code>方法是怎么实现的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>超级简单，原来是新建了一个叫<code>Itr</code>的对象那么这个<code>Itr</code>又是什么呢？打开源码我们发现<code>Itr</code>类其实是<code>ArrayList</code>的一个内部类，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;......................... <span class="number">1</span></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;...&#125;<span class="comment">// 具体实现被我删除了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该迭代器实现了<code>Iterator</code>接口并实现了相关方法，提供我们对集合的遍历能力。总结：<code>ArrayList</code>的迭代器默认是其内部类实现，实现一个自定义迭代器只需要实现<code>Iterator</code>接口并实现相关方法即可。而实现<code>Iterable</code>接口表示该实现类具有像<code>for-each loop</code>迭代遍历的能力。</p>
<h5 id="4、采用ArrayList的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出ConcurrentModificationException-我们该如何避免？"><a href="#4、采用ArrayList的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出ConcurrentModificationException-我们该如何避免？" class="headerlink" title="4、采用ArrayList的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出ConcurrentModificationException,我们该如何避免？"></a>4、采用<code>ArrayList</code>的迭代器遍历集合时，对集合执行相关修改操作时为什么会抛出<code>ConcurrentModificationException</code>,我们该如何避免？</h5><p>上面第3小节我们查看了<code>ArrayList</code>迭代器的源代码，我们都知道，如果在迭代的过程中调用非迭代器内部的<code>remove</code>或者<code>clear</code>方法将会抛出<code>ConcurrentModificationException</code>异常，那到底是为什么呢？我们一起来看看。首先这里设计两个很重要的变量，一个是<code>expectedModCount</code>,另一个是<code>modCount</code>,<code>expectedModCount</code>在集合内部迭代器中定义，就像上面第三小节源码<code>1</code>处所示，<code>modCount</code>在<code>AbstractList</code>中定义。就像第三小节<code>1</code>处所看到的，默认两者是相等的，即<code>expectedModCount = modCount</code>,只有当其不想等的情况下就会抛出异常。真的是不想等就抛异常吗？我们来看看迭代器内部的<code>next</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在迭代前会对两个变量进行检查</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体检查</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出确实是当它们两者之间不想等时就报错，问题来了，那么什么时候会导致它们不想等呢？不急，我们来看看<code>ArrayList</code>的<code>remove</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">// 这里会修改modCount的值</span></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出当调用<code>remove()</code>方法时确实是修改了<code>modCount</code>的值，导致报错。那我们怎么做才能不报错有想在迭代过程中增加或者删除数据呢？答案是使用迭代器内部的<code>remove()</code>方法。</p>
<p><strong>总结：</strong></p>
<p>迭代器迭代集合时不能对被迭代集合进行修改，原因是<code>modCount</code>和<code>expectedModCount</code>两个变量值不想等导致的！</p>
<h5 id="5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么ArrayList的数组拷贝是怎么实现的？"><a href="#5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么ArrayList的数组拷贝是怎么实现的？" class="headerlink" title="5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么ArrayList的数组拷贝是怎么实现的？"></a>5、当集合扩容或者克隆时免不了对集合进行拷贝操作，那么<code>ArrayList</code>的数组拷贝是怎么实现的？</h5><p>在<code>ArrayList</code>中对集合的拷贝是通过调用<code>Arrays</code>的<code>copyOf</code>方法实现的，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());.................<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="comment">// 在创建新数组对象之前会先对传入的数据类型进行判定</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后还调用了<code>System</code>的<code>arraycopy</code>方法。</p>
<h5 id="6、ArrayList中的序列化机制"><a href="#6、ArrayList中的序列化机制" class="headerlink" title="6、ArrayList中的序列化机制"></a>6、<code>ArrayList</code>中的序列化机制</h5><p>第一小节我们知道<code>ArrayList</code>存储数据的定义方式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>我们会觉得非常奇怪，这是一个集合存储元素的核心，却声明为<code>transient</code>,是不是就说就不序列化了？这不科学呀！其实集合存储的数据还是会序列化的，具体我们看看<code>ArrayList</code>中的<code>writeObject</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writeObject</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个地方做一个序列化操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看出<code>ArrayList</code>其实是有对<code>elementData</code>进行序列化的，只不过这样做的原因是因为<code>elementData</code>中可能会有很多的null元素，为了不把null元素也序列化出去，所以自定义了<code>writeObject</code>和<code>readObject</code>方法。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://juejin.im/post/5b2c5eefe51d4558c0442e95" target="_blank" rel="noopener">https://juejin.im/post/5b2c5eefe51d4558c0442e95</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>BlockingQueue是如何把线程玩的如此之牛的？</title>
    <url>/2020/03/10/2020/03/BlockingQueue%E6%98%AF%E5%A6%82%E4%BD%95%E6%8A%8A%E7%BA%BF%E7%A8%8B%E7%8E%A9%E7%9A%84%E5%A6%82%E6%AD%A4%E4%B9%8B%E7%89%9B%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>BlockingQueue</code>即阻塞队列，它算是一种将<code>ReentrantLock</code>用得非常精彩的一种表现，依据它的基本原理，我们可以实现Web中的长连接聊天功能，当然其最常用的还是用于实现生产者与消费者模式，大致如下图所示：</p>
<p><img src="http://static.cyblogs.com/20161108212521456.png" alt="http://static.cyblogs.com/20161108212521456.png"></p>
<p>在Java中，<code>BlockingQueue</code>是一个接口，它的实现类有<code>ArrayBlockingQueue</code>、<code>DelayQueue</code>、 <code>LinkedBlockingDeque</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>、<code>SynchronousQueue</code>等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。下面的源码以<code>ArrayBlockingQueue</code>为例。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><code>BlockingQueue</code>内部有一个<code>ReentrantLock</code>，其生成了两个<code>Condition</code>，在<code>ArrayBlockingQueue</code>的属性声明中可以看见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果能把<code>notEmpty</code>、<code>notFull</code>、<code>put</code>线程、<code>take</code>线程拟人的话，那么我想<code>put</code>与<code>take</code>操作可能会是下面这种流程：</p>
<p><strong>put(e)</strong></p>
<p><img src="http://static.cyblogs.com/20161108212418173.png" alt="http://static.cyblogs.com/20161108212418173.png"></p>
<p><strong>take()</strong></p>
<p><img src="http://static.cyblogs.com/20161108212452384.png" alt="http://static.cyblogs.com/20161108212452384.png"></p>
<p>其中<code>ArrayBlockingQueue.put(E e)</code>源码如下（其中中文注释为自定义注释，下同）：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the tail of this queue, waiting</span></span><br><span class="line"><span class="comment"> * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   checkNotNull(e);</span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">   lock.lockInterruptibly();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (count == items.length)</span><br><span class="line">           notFull.await(); <span class="comment">// 如果队列已满，则等待</span></span><br><span class="line">       insert(e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element at current put position, advances, and signals.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line"> 		items[putIndex] = x;</span><br><span class="line">	 	putIndex = inc(putIndex);</span><br><span class="line">		++count;</span><br><span class="line"> 		notEmpty.signal(); <span class="comment">// 有新的元素被插入，通知等待中的取走元素线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArrayBlockingQueue.take()</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await(); <span class="comment">// 如果队列为空，则等待</span></span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extracts element at current take position, advances, and signals.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">extract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]);</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    takeIndex = inc(takeIndex);</span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal(); <span class="comment">// 有新的元素被取走，通知等待中的插入元素线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，put(E)与take()是同步的，在put操作中，当队列满了，会阻塞put操作，直到队列中有空闲的位置。而在take操作中，当队列为空时，会阻塞take操作，直到队列中有新的元素。</p>
<p>而这里使用两个Condition，则可以避免调用signal()时，会唤醒相同的put或take操作。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/t894690230/article/details/53088660" target="_blank" rel="noopener">https://blog.csdn.net/t894690230/article/details/53088660</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>BlockingQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>G1垃圾收集器详细介绍</title>
    <url>/2020/03/11/2020/03/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h4 id="1、G1垃圾收集器介绍"><a href="#1、G1垃圾收集器介绍" class="headerlink" title="1、G1垃圾收集器介绍"></a>1、G1垃圾收集器介绍</h4><p>G1垃圾收集器针对具有大量内存的多处理器机器。它试图以很高的概率满足GC停顿时间目标，同时实现高吞吐量且几乎不需要配置。G1旨在在延迟和吞吐量之间提供最佳平衡，应用场景包括如下环境特征：</p>
<ul>
<li>堆大小可达10 GB或更大，超过50％的Java堆占用实时数据。</li>
<li>随着时间的推移，对象分配速度和晋升（从新生代到老年代的晋升）速度会发生显著变化。</li>
<li>堆中大量的碎片。</li>
<li>可预测的时间停顿目标不超过几百毫秒，避免长时间垃圾收集停顿。</li>
</ul>
<p>G1取了CMS，G1也是默认的收集器（JVM9、JVM10）。</p>
<p>G1收集器有很高的性能，并尝试通过以下几节所述的几种方式来满足停顿时间的目标。</p>
<h4 id="2、启用G1收集器"><a href="#2、启用G1收集器" class="headerlink" title="2、启用G1收集器"></a>2、启用G1收集器</h4><p>G1是默认收集器，因此通常不需要执行任何其他操作。您可以通过在命令行上提供-XX：+ UseG1GC来显式启用它。</p>
<h4 id="3、基本概念"><a href="#3、基本概念" class="headerlink" title="3、基本概念"></a>3、基本概念</h4><p>G1是分代的、增量的、并行、大部分、并发的、stop-the-word、以及疏散（将活着的对象从一个区域（youngor young + old）拷贝到另一个区域）的垃圾收集器，用于监视每个stop-the-word停顿的停顿时间目标。与其他收集器类似，G1将堆分成（虚拟）新生代和老年代。空间回收的主要集中在年轻代，因为这样做最有效率，在老年代偶尔会有空间回收。</p>
<p>一些操作总是在stop-the-word停顿中执行以提高吞吐量。其他需要更多时间停止应用程序的操作（例如全局标记等全堆操作）将与应用程序同时并行并发执行。为了让空间回收stop-the-word停顿短，G1逐步地并行执行空间回收。G1通过跟踪以前的应用程序行为信息和垃圾收集停顿的信息来建立相关成本的模型，以此实现可预测性。它使用这些信息来调整在停顿中完成的工作。例如，G1首先在最有效率的区域回收空间（即大部分填充垃圾的区域，因此是名称）。</p>
<p>G1主要通过疏散回收空间：回收时，在选定的内存区域内发现的活动对象被复制到新的内存区域，在此过程中压缩它们。疏散完成后，由先前活动对象占据的空间被重新用于应用程序的分配。</p>
<p>垃圾收集器不是实时收集器。 它试图在较长的时间内，以很高的概率满足设定的停顿时间的目标，但对于给定的停顿，并不总是具有绝对的确定性。</p>
<h5 id="3-1、堆布局"><a href="#3-1、堆布局" class="headerlink" title="3.1、堆布局"></a>3.1、堆布局</h5><p>G1将堆分成一组相同大小的region，每个region占有一个连续的虚拟内存地址，如图1所示。 region是内存分配和内存回收的基本单位。 在任何给定的时间，这些region中的每一个都可以是空的（浅灰色），或者已经分配给特定的年轻代或老年代。 当内存请求出现时，内存管理器会拿出空闲区域。 内存管理器将它们分配给某一代，然后将它们作为空闲空间返回给应用程序，在该空间中，它可以分配自身。</p>
<p><img src="http://static.cyblogs.com/20180504154701245.png" alt="图1-G1堆内存布局"></p>
<p>[图1-G1堆内存布局]</p>
<p>年轻代包含eden区（红色）和幸存区（包含“S”的红色）。 这些region提供与其他收集器中相应的连续空间相同的功能，区别在于，在G1中，这些region通常在内存中以非连续模式布局。老region（浅蓝色）组成了老年代。对于跨越多个区域的物体，老年代region可能会变得很大（包含“H”的浅蓝色）。</p>
<p>应用程序总是将内存分配到新生代，即eden region，但是除了那些被直接分配到老年代的大对象。</p>
<p>G1 GC停顿可以回收整个新生代的空间，并且在任何收集停顿时，任何附加的老年代region都可以回收。停顿期间，G1将此收集集合中的对象复制到堆中的一个或多个不同region。对象的目的region域取决于该对象的源region：整个新生代被复制到幸存者或老年代region，老年代region的对象复制到其他不同老年代region。</p>
<h5 id="3-2、GC周期"><a href="#3-2、GC周期" class="headerlink" title="3.2、GC周期"></a>3.2、GC周期</h5><p>在较高的水平上，G1收集器在两个阶段之间交替。 young-only阶段包含垃圾收集，这些垃圾收集逐渐用老年代的对象来填充当前可用的内存。space-reclamation阶段是G1除了处理年轻一代之外，逐步回收老一代的空间。然后，循环以young-only阶段重新开始。</p>
<p>图2以一个可能发生的垃圾收集停顿序列为例说明了这个周期。</p>
<p><img src="http://static.cyblogs.com/20180504154735933.png" alt="img"></p>
<p>[图2垃圾收集周期概述]</p>
<p>以下列表详细介绍了G1垃圾回收周期的这两个阶段，以及它们的停顿和转换过程：</p>
<p>1、young-only阶段：这一阶段从对象晋升到老年代的收集开始。当老年代占用率达到某一阈值（Initiating Heap Occupancy threshold）时，young-only阶段和space-reclamation阶段之间的转换就开始了。在这个时候，G1安排了一个初始标记的young-only收集，而不是一个普通的young-only收集。</p>
<ul>
<li>初始标记：除了执行常规的young-only的收集之外，这种类型的收集开始标记过程。并发标记确定老年代region中的所有当前可到达（实时）对象将保留到以下space-reclamation阶段。标记尚未完全结束时，可能会发生常规新生代收集。标记结束了两个特殊的stop-the-word停顿：重新标注和清理。</li>
<li>重新标记：此停顿完成标记本身，并执行全局引用处理和类卸载。在重新标记和清理阶段之间G1并发计算对象活跃度概要信息，并将在清理停顿中用于更新内部数据结构。</li>
<li>清理：此停顿也回收完全空白的区域，并确定space-reclamation阶段是否会实际执行。如果有space-reclamation阶段，那么young-only阶段完成一次young-only收集。</li>
</ul>
<p>2、space-reclamation阶段：这一阶段由多个混合收集组成，除了新生代region之外，还会疏散老年代region存活对象。当G1确定疏散更多老一代的地区不会产生足够的可用空间时，space-reclamation阶段结束。</p>
<p>在space-reclamation之后，收集周期将以另一个young-only阶段重新开始。 作为备选，如果应用程序在收集对象存活信息时内存溢出，G1像其他收集器一样就地执行stop-the-word全局堆压缩（Full GC）。</p>
<h4 id="4、G1内部"><a href="#4、G1内部" class="headerlink" title="4、G1内部"></a>4、G1内部</h4><p>本节介绍G1 GC的一些重要细节。</p>
<h5 id="4-1、确定Initiating-HeapOccupancy"><a href="#4-1、确定Initiating-HeapOccupancy" class="headerlink" title="4.1、确定Initiating HeapOccupancy"></a>4.1、确定Initiating HeapOccupancy</h5><p>The Initiating Heap Occupancy Percent（IHOP）是触发初始标记收集的阈值，它被定义为老年代大小的百分比。</p>
<p>默认情况下，G1通过观察标记周期中标记需要多长时间以及老年代通常分配多少内存来自动确定最佳IHOP。这个功能称为Adaptive IHOP。如果此功能处于活动状态，在没有足够的观察值来很好地预测Initiating Heap Occupancy阈值的情况下，选项-XX：InitiatingHeapOccupancyPercent会以当前老年代的大小的百分比来确定初始值。 使用选项-XX：-G1UseAdaptiveIHOP关闭G1的这种行为。 在这种情况下，-XX：InitiatingHeapOccupancyPercent的值始终确定此阈值。</p>
<p>在内部，AdaptiveIHOP尝试设置Initiating Heap Occupancy，以便在老年代占有率处于当前最大老年代大小减去作为额外缓冲区的-XX：G1HeapReservePercent值时，开始空间回收阶段的第一个混合GC。</p>
<h5 id="4-2、标记"><a href="#4-2、标记" class="headerlink" title="4.2、标记"></a>4.2、标记</h5><p>G1标记使用称为 Snapshot-At-The-Beginning （SATB）的算法。 它在初始标记停顿时获取堆的虚拟快照，当标记开始时处于活动状态的所有对象，在标记剩余部分也被认为是活动的对象。这意味着标记期间变为死亡（无法访问）的对象，对space-reclamation阶段仍然被认为是存活的（有一些例外）。与其他收集器相比，这可能会导致一些额外的内存被错误保留。但是，在重新标记停顿期间，SATB可能会提供更好的延迟。在该标记过程中，过于保守考虑的存活对象，将在下一次标记过程中回收。</p>
<h5 id="4-3、在堆内存紧张下的行为"><a href="#4-3、在堆内存紧张下的行为" class="headerlink" title="4.3、在堆内存紧张下的行为"></a>4.3、在堆内存紧张下的行为</h5><p>当应用程序保持如此多的内存，疏散过程无法找到足够的空间进行复制时，会发生疏散失败。疏散失败意味着G1试图通过以下方式来完成当前GC，保留任何已经移动到新位置的对象，不复制任何尚未移动的对象，只调整对象之间的引用。疏散失败可能会带来一些额外开销，但通常应该像其他年轻代收集一样快。在疏散失败的GC之后，G1将照常恢复应用程序，无需任何其他措施。G1假定疏散失败发生在GC结束附近; 也就是说，大多数对象已经移动并且有足够的空间继续运行应用程序，直到标记完成并开始space-reclamation。</p>
<p>如果这个假设不成立，那么G1最终将安排一个fullGC。 这种类型的收集就地执行整个堆的压缩。 这可能非常缓慢。</p>
<h5 id="4-4、大对象"><a href="#4-4、大对象" class="headerlink" title="4.4、大对象"></a>4.4、大对象</h5><p>大对象是大于或等于半个region大小的对象。 除非使用-XX：G1HeapRegionSize选项进行设置，否则当前region的尺寸按照人体工程学设计确定，参考“G1 GC人体工程学默认值”章节所述。</p>
<p>这些大对象有时以特殊的方式进行处理：</p>
<ul>
<li>每一个大对象都被分配为老年代的一系列连续region。对象的开始位置始终位于该序列中第一个region的开始位置。该序列中最后一个region的剩余空间将丢失，直到整个对象被回收。</li>
<li>一般来说，只有在清理停顿期间的标记结束时，或者在Full GC期间，如果大对象变得无法到达，则可以被回收。但是，对于原始类型数组的大对象（例如bool，各种整数和浮点值）有一个特殊规定。如果G1在任何类型的GC停顿时都没有被任何对象引用，那么G1会尝试回收大对象。此行为默认启用，但可以使用选项-XX：G1EagerReclaimHumongousObjects将其禁用。</li>
<li>大对象的分配可能会导致GC停顿过早发生。 G1会在每个大对象分配中检查InitiatingHeap Occupancy阈值，如果当前占用率超过该阈值，可能会立即强制新生代收集初始标记。</li>
<li>大对象不会移动，即使在fullGC中也不会移动。 这可能会导致过早执行缓慢的fullGC或意外的内存溢出情况，尽管region空间碎片留下大量剩余空间。</li>
</ul>
<h5 id="4-5、young-only阶段代大小设置"><a href="#4-5、young-only阶段代大小设置" class="headerlink" title="4.5、young-only阶段代大小设置"></a>4.5、young-only阶段代大小设置</h5><p>在young-only阶段，要收集的region集合（收集集合）只包括新生代region。G1一直在young-only 收集结束时设置新生代大小。这样，G1根据实际暂停时间的长期观察值，就可以满足使用-XX：MaxGCPauseTimeMillis和-XX：PauseTimeIntervalMillis设置的停顿时间目标。它考虑了新生代同样规模的疏散需要多长时间。这包括诸如在收集期间需要复制多少个对象以及这些对象之间是如何相互关联的信息。</p>
<p>如果没有其他约束，则G1适应性地将年轻代大小设定为-XX：G1NewSizePercent和-XX：G1MaxNewSizePercent确定的值以满足停顿时间。</p>
<h5 id="4-6、Space-reclamation阶段代大小设置"><a href="#4-6、Space-reclamation阶段代大小设置" class="headerlink" title="4.6、Space-reclamation阶段代大小设置"></a>4.6、Space-reclamation阶段代大小设置</h5><p>在space-reclamation阶段，G1试图在单个垃圾收集停顿中最大回收化老年代空间。新生代的大小设置为允许的最小值，通常由-XX：G1NeSizeSizePercent确定，并且任何老年代region回收空间都会被添加，直到G1确定添加更多region将超过停顿时间的目标。在特定的GC停顿中，G1按其回收效率、剩余可用时间顺序添加老年代region，以获得最终收集集合。</p>
<p>要收集的潜在候选老年代region（收集集合候选region）的低端数量除以由-XX：G1MixedGCCountTarget确定的space-reclamation阶段的长度，得到商X，每次GC所采用的老年代region数量由商X确定下界。收集集合候选region：在本阶段开始时所占用的（小于-XX:G1MixedGCLiveThresholdPercent）老年代region</p>
<p>当收集组候选region中可回收的剩余空间量小于-XX：G1HeapWastePercent设置的百分比时，space-reclamation阶段结束。</p>
<h4 id="5、G1-GC的人机工程学默认值"><a href="#5、G1-GC的人机工程学默认值" class="headerlink" title="5、G1 GC的人机工程学默认值"></a>5、G1 GC的人机工程学默认值</h4><p>本主题概述了G1的最重要的参数及其默认值。他们给出了对预期行为和资源使用情况粗略概述，没有任何其他选项。</p>
<p><img src="http://static.cyblogs.com/20180504155312661.png" alt="img"><br>**</p>
<p>注意：<ergo>意味着实际的值是由人体工程学决定的，这取决于环境。</p>
<p><strong>6、与其他收集器对比</strong></p>
<p>这是对G1和其他收集器之间主要区别的总结：</p>
<ul>
<li>Parallel GC在老年代中全部压缩和回收空间。G1逐渐将这个工作分布在多个更短的收集中。这显著缩短了暂停时间，但可能会降低吞吐量。</li>
<li>与CMS相似，G1并发执行部分老年代space-reclamation。然而，CMS不能将老年代堆碎片整理出来，最终会运行长时间的full GC。</li>
<li>G1的开销可能比其他收集器高，因为它的并发特性影响了吞吐量。</li>
</ul>
<p>由于它的工作原理，G1有一些独特的机制来提高垃圾收集效率：</p>
<ul>
<li>在任何收集过程中，G1都可以回收老年代的一些完全空的、大的区域。这可以避免许多不必要的垃圾收集，在不费多大力气的情况下释放大量的空间。</li>
<li>G1可以选择性地尝试同时在Java堆上删除重复的字符串。</li>
</ul>
<p>从老年代中回收空的大型对象总是启用的。您可以使用选项-XX：-G1EagerReclaimHumongousObjects来禁用该特性。在默认情况下，字符串重复删除是禁用的。你可以使用选项-XX：+ G1EnableStringDeduplication来启用它。</p>
<p>由于水平有限，翻译的不好，欢迎批评指正。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/bill_hai/article/details/80196149" target="_blank" rel="noopener">https://blog.csdn.net/bill_hai/article/details/80196149</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>G1</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程系列：ReentrantLock</title>
    <url>/2020/03/13/2020/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%EF%BC%9AReentrantLock/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>ReentrantLock</code>和<code>synchronized</code>都是提供了同步的功能，<code>JDK1.6</code>之后对<code>synchronized</code>性能进行了优化，所以两者的性能上几乎没什么区别，但是<code>ReentrantLock</code>提供了了一些高级功能。</p>
<ul>
<li><p>等待可中断：在<code>synchronized</code>中，如果一个线程在等待锁，他只用两种结果，要么获得锁执行完，要么一直保持等待。可中断的等待是通知正在等待的线程，告诉他没必要再等待后。</p>
</li>
<li><p>实现公平锁：公平锁：会按照时间的先后顺序，保证先到先得。特点是它不会产生饥饿现象。而synchroized关键字进行所控制时，锁是非公平的。而重入锁可以设置为公平锁。 <code>public ReetranLock(boolean fair)</code> 当<code>fair</code>为<code>true</code>时，表示锁是公平的。实现公平锁必然要求系统维护一个有序队列，因此公平锁的成本比较高，性能也非常低向。默认情况下锁是非公平的。</p>
</li>
<li><p>绑定多个条件：类似于<code>Object</code>类的<code>wait</code>和<code>notify</code>方法，它是与<code>ReentrantLock</code>绑定的条件，可以绑定多个条件。</p>
</li>
</ul>
<h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p>注意：退出临界区要释放锁，否则其他线程就没有机回访问临界区了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReentrantLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock rlock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            rlock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                rlock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestReentrantLock tl = <span class="keyword">new</span> TestReentrantLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(tl); </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(tl); </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//表示当前线程等待t1执行完</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：退出临界区要释放锁，否则其他线程就没有机回访问临界区了。</p>
<h4 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h4><p><code>Lock</code>接口是<code>JDK1.5</code>新加的同步工具接口，它的实现类有<code>ReentrantLock</code>、<code>WriteLock</code>等，接口中定义了通用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 可中断获取锁，与lock()不同之处在于可响应中断操作，即在获取锁的过程中可中断</span></span><br><span class="line"><span class="comment">// synchronized在获取锁时是不可中断的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//尝试非阻塞获取锁，调用该方法后立即返回结果，如果能够获取则返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//根据传入的时间段获取锁，在指定时间内没有获取锁则返回false，如果在指定时间内当前线程未被中并断获取到锁则返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">//获取等待通知组件，该组件与当前锁绑定，当前线程只有获得了锁</span></span><br><span class="line"><span class="comment">//才能调用该组件的wait()方法，而调用后，当前线程将释放锁。</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>lock</code>和<code>unlock</code>方法提供了<code>synchronized</code>的功能，其他方法使得同步过程更加的灵活。</p>
<h4 id="什么叫重入锁"><a href="#什么叫重入锁" class="headerlink" title="什么叫重入锁"></a>什么叫重入锁</h4><p>一个线程可以多次进入，当然必须多次释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rlock.lock();</span><br><span class="line">rlock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    rlock.unlock();</span><br><span class="line">    rlock.unlock();</span><br><span class="line">    <span class="comment">//如果释放次数多，则回抛出java.lang.IllegalMonitorStateException异常</span></span><br><span class="line">    <span class="comment">//rlock.unlock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面根据案例主要介绍<code>ReentrantLock</code>的用法，在后面的文章中介绍它的实现原理。</p>
<h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h4><p>如果一个线程正在等待锁，那么它可以收到一个通知，被告知无序再等待，可以停止工作了。在<code>synchronized</code>中，<br>如果一个线程在等待锁，他只用两种结果，要么获得锁执行完，要么一直保持等待。</p>
<p>下面通过一个死锁的例子，介绍中断响应的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeathLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeathLock</span><span class="params">(<span class="keyword">int</span> lock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(lock==<span class="number">1</span>)&#123;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" get lock1"</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" get lock2"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" get lock2"</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" get lock1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//判断当前线程是否拥有该锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock1.isHeldByCurrentThread())</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            <span class="keyword">if</span>(lock2.isHeldByCurrentThread())</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" 退出！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="comment">//这里new出两个实现Runnable的对象是因为为了传进去不同的lock值</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeathLock(<span class="number">1</span>),<span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeathLock(<span class="number">1</span>),<span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行过程是<code>thread1</code>占用<code>lock1</code>，休眠500毫秒，然后想占用<code>lock2</code>，与此同时，<code>thread2</code>占用<code>lock2</code>，休眠1000毫秒后在请求<code>lock1</code>。可是当<code>thread1</code>，想请求<code>lock2</code>时，已经被<code>thread2</code>占用，因此只能进入阻塞状态，<code>thread2</code>也同理进入阻塞状态。因此进入死锁。但是这里使用了<code>lockInterruptibly()</code>方法。这是一个可以对中断进行响应的锁申请动作，即在等待锁的过程中可以响应中断。在<code>thred2</code>调用<code>interrupt()</code>方法，<code>thread2</code>线程被中断，<code>thread2</code>放弃对<code>lock</code>的申请，同时释放已获得的<code>lock2</code>，所以<code>thread1</code>可以得到<code>lock2</code>继续执行下去。</p>
<p>结果为：</p>
<p><img src="http://static.cyblogs.com/20170809094510953.png" alt="http://static.cyblogs.com/20170809094510953.png"></p>
<p><code>thread2</code>先中断，抛出异常，跳入<code>finally</code>块，释放资源，最终退出。</p>
<h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a>锁申请等待限时</h4><p>如果给定一个等待时间，超过时间，让线程自动放弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" get　lock failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())</span><br><span class="line">                lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        TimeLock t = <span class="keyword">new</span> TimeLock();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(t,<span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(t,<span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryLock()</code>两个参数分别表示等待时长和计时单位，表示线程在请求锁的过程中，最多等待5秒，如果超过改时间则返回false，如果成果获得锁，则返回<code>true</code>。<br>该程序中首先任意一个线程先获得锁，然后休眠5秒，然而它一直占有锁，因此另一个线程无法再2秒内获得锁，因此失败。</p>
<p><code>tryLock()</code>方法也可以不带参数，这种情况下，当前线程会尝试获得锁，如果锁未被其他线程占用，则申请锁会成功，把那个返回<code>true</code>，如果锁被其他线程占用，则当前线程不会等待，而是立即返回<code>false</code>。这种模式下不会引起线程等待，因此也不会产生死锁。</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>大多数情况下，锁的申请都是非公平的，也就是说，线程1首先申请锁A，接着线程2也请求了锁A，当锁A可用时，线程1,2都有可能获得锁，系统只是在等待队列中随机挑选一个，因此不能保证公平性。<br>所以有了公平锁，公平锁：会按照时间的先后顺序，保证先到先得。特点是它不会产生饥饿现象。而<code>synchroized</code>关键字进行所控制时，锁是非公平的。而重入锁可以设置为公平锁。<br><code>public ReetranLock(boolean fair)</code><br>当<code>fair</code>为<code>true</code>时，表示锁是公平的。实现公平锁必然要求系统维护一个有序队列，因此公平锁的成本比较高，性能也非常低向。默认情况下锁是非公平的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" get　lock !"</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        FairLock f = <span class="keyword">new</span> FairLock();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(f,<span class="string">"thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(f,<span class="string">"thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分结果为：</p>
<p><img src="http://static.cyblogs.com/20170809094651573.png" alt="http://static.cyblogs.com/20170809094651573.png"></p>
<p>可以看出两个线程基本上是交替获得锁。</p>
<h4 id="Condition条件（搭配重入锁使用）"><a href="#Condition条件（搭配重入锁使用）" class="headerlink" title="Condition条件（搭配重入锁使用）"></a>Condition条件（搭配重入锁使用）</h4><p><code>Condition</code>类似于<code>wait()</code>和<code>notify()</code>的功能，它是与重入锁关联使用的。<code>Lock</code>接口中提供了<code>newCondition()</code>方法，该方法可以返回绑定到此<code>Lock</code>的<code>Condition</code>实例。</p>
<p>方法解释：<br><code>await</code>方法会使当前线程等待，同时释放当前锁，当其他线程中使用<code>signal()</code>或<code>signalAll()</code>方法时，线程会重新获得锁并继续执行，当线程被中断时，也能跳出等待。与<code>Object</code>的<code>wait()</code>方法相似。<br><code>singal()</code>方法用于唤醒一个在等待中的线程。<br>注意：以上连个方法调用之前必须当前线程拥有锁。否则抛出<code>IllegalMonitorStateException</code>异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//当前线程释放锁，进入等待状态</span></span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" get　lock !"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConditionDemo t = <span class="keyword">new</span> ConditionDemo();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(t,<span class="string">"thread1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">//当thread1进入处于等待状态，main线程获得锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" get lock !"</span>);</span><br><span class="line">        condition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果：</span></span><br><span class="line"><span class="comment">main get lock !</span></span><br><span class="line"><span class="comment">thread1 get　lock !</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<p><code>thread1</code>线程调用<code>await</code>时，要求线程持有相关的重入锁，调用后，线程释放这把锁，同理<code>signal</code>方法调用时，也要求线程先获得相关的锁，在<code>signal</code>方法调用后，系统会从当前的<code>Condition</code>对象的等待队列中唤醒一个线程，一旦线程唤醒，它会重新尝试获得之前绑定的锁，一旦成功获取<code>await</code>方法返回，继续执行。在调用<code>signal</code>后先睡眠2秒，并且保持了锁，释放了锁之后，<code>await</code>方法获取锁后才得以返回继续执行。因此打印出来的时间差为2000毫秒。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>上面结合例子介绍了<code>ReentrantLock</code>主要的用法，还有一些很有意思的用法，比如正在等待锁的线程，当前线程是否拥有锁等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询当前线程保持此锁的次数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。      </span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  Thread   <span class="title">getOwner</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//返回一个 collection，它包含可能正等待获取此锁的线程，其内部维持一个队列，这点稍后会分析。      </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  Collection&lt;Thread&gt;   <span class="title">getQueuedThreads</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//返回正等待获取此锁的线程估计数。   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  Collection&lt;Thread&gt;   <span class="title">getWaitingThreads</span><span class="params">(Condition condition)</span></span>; </span><br><span class="line"><span class="comment">//返回等待与此锁相关的给定条件的线程估计数。       </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span></span>;</span><br><span class="line"><span class="comment">// 查询给定线程是否正在等待获取此锁。     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread thread)</span></span>; </span><br><span class="line"><span class="comment">//查询是否有些线程正在等待获取此锁。     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//查询是否有些线程正在等待与此锁有关的给定条件。     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span></span>; </span><br><span class="line"><span class="comment">//如果此锁的公平设置为 true，则返回 true。     </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//查询当前线程是否保持此锁。      </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//查询此锁是否由任意线程保持。        </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>进入<code>ReentrantLock</code>的源码发现，<code>ReentrantLock</code>类的绝大部分功能是通过它的内部类<code>Sync</code>来实现的，而<code>Sync</code>又继承了<code>AbstractQueuedSynchronizer</code>类。这就是大名鼎鼎的<code>AQS</code>，<code>Doug Lea</code>最著名的作品，后面的文章分析它的精华所在。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/TheLudlows/article/details/76962006" target="_blank" rel="noopener">https://blog.csdn.net/TheLudlows/article/details/76962006</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程：任务的取消和关闭</title>
    <url>/2020/03/12/2020/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>任务和线程的启动很容易。在大多数时候，我们都会让它们运行直到结束，或者让它们自行停止。然而，有时候我们希望提前结束任务或线程，或许是因为用户取消了操作，或者应用程序需要被快速关闭。</p>
<p>要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java 没有提供任何机制来安全的终止线程。但它提供了中断，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。</p>
<p>这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用一种协作的方式：当需要停止时，它们首先会清除当前正在执行的工作，然后再结束。这提供了更好的灵活性，因为任务本身的代码比发出取消请求的代码更清除如何执行清除工作。</p>
<h4 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h4><p>在开始文章前，有几个问题需要思考一下：</p>
<ul>
<li>取消任务的方式由哪几种？</li>
<li>中断的策略是什么？</li>
<li>如何响应中断？</li>
</ul>
<h5 id="取消任务的方式有哪几种"><a href="#取消任务的方式有哪几种" class="headerlink" title="取消任务的方式有哪几种"></a>取消任务的方式有哪几种</h5><p>取消任务的方式大体上有一下两种：</p>
<ul>
<li>设置取消标志位</li>
<li>中断</li>
</ul>
<h6 id="设置取消标志位"><a href="#设置取消标志位" class="headerlink" title="设置取消标志位"></a>设置取消标志位</h6><p>设置某个“已请求取消”标志，而任务将定期地查看该标志。如果设置了这个标记，那么任务将提前结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BigInteger p = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">            p = p.nextProbablePrime();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                primes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;BigInteger&gt; <span class="title">aSecondOfPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PrimeGenerator generator = <span class="keyword">new</span> PrimeGenerator();</span><br><span class="line">        exec.execute(generator);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            generator.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> generator.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码使用了这项技术，其中的 <code>PrimeGenerator</code> 持续地枚举素数，知道它被取消。<code>cancel</code> 方法将设置 <code>cancelled</code> 标志，并且主循环在搜索下一个素数之前会首先检查这个标志（为了使这个过程能可靠的工作，标志 <code>cancelled</code> 必须为 <code>volatile</code> 类型）。</p>
<p><code>PrimeGenerator</code> 使用了一种简单的取消策略：客户代码通过调用 <code>cancel</code> 来请求取消，<code>PrimeGenerator</code> 在每次搜索素数前首先检查是否存在取消请求，如果存在则退出。</p>
<p>一个可取消的任务必须拥有取消策略，在这个策略中将详细地定义取消操作的<code>“How”</code>、<code>“When”</code>以及<code>“What”</code>，即其他代码如何（<code>How</code>）请求取消该任务，任务在何时（<code>When</code>）检查是否已经请求了取消，以及在响应取消请求时应该执行哪些（<code>What</code>）操作。</p>
<h6 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h6><p><code>PrimeGenerator</code> 中的取消机制最终会使得搜索素数的任务退出，但在退出过程中需要花费一定的时间。然而，如果使用这种方法的任务调用了一个阻塞方法，例如 <code>BlockingQueue.put</code>，那么可能会产生一个更严重的问题——任务可能永远不会检查取消标志位，因此永远不会结束。</p>
<p>接下来的代码说明了这个问题。生产者线程生成素数，并将它们放入一个阻塞队列。如果生产者的速度超过了消费者的处理速度，队列将被填满，<code>put</code> 方法也会阻塞。当生产者在 <code>put</code> 方法中阻塞时，如果消费者希望取消生产者任务，那么将发生什么情况？它可以调用 <code>cancel</code> 方法设置 <code>cancelled</code> 标志，但此时生产者却永远不能检查这个标志，因为它无法从阻塞的 <code>put</code> 方法中恢复过来（因为消费者此时已经停止从队列中取出素数，所以 <code>put</code> 方法将一直保持阻塞状态）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> needMoreStatus = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">	BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">    	<span class="keyword">this</span>.queue = queue;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">        	BigInteger p = BigInteger.ONE;</span><br><span class="line">        	<span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">            	queue.put(p = p.nextProbablePrime());</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cancelled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> BlockingQueue&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> BlockingQueue&lt;BigInteger&gt; <span class="title">aSecondOfPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayBlockingQueue&lt;BigInteger&gt;(<span class="number">10</span>);</span><br><span class="line">        BrokenPrimeProducer producer = <span class="keyword">new</span> BrokenPrimeProducer(primes);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> producer.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BrokenPrimeProducer</code> 说明了一些自定义的取消机制无法与可阻塞的库函数实现良好交互的原因。如果任务代码能够响应中断，那么可以使用中断作为取消机制，并且利用许多库类中提供的中断支持。通常，中断是实现取消的最合理方式。</p>
<p>线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在合适的或者可能的情况下停止当前工作，并转而执行其他的工作。</p>
<p>在 <code>Java</code> 的 <code>API</code> 或语言规范中，并没有将中断与任何取消语义关联起来，但实际上，如果在取消之外的其他操作中使用中断，那么都是不合适的，并且很难支撑起更大的应用。</p>
<p>每个线程都有一个 <code>boolean</code> 类型的中断状态。当中断线程时，这个线程的中断状态将被设置为 <code>true</code>。在 <code>Thread</code> 中包含了中断线程以及查询线程中断状态的方法。。<code>interrupt</code> 方法能中断目标线程，而 <code>isInterrupted</code> 方法能返回目标线程的中断状态。静态的 <code>interrupted</code> 方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">// 中断线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">// 中断状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">// 清除中断状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻塞库方法，例如 <code>Thread.sleep</code> 和 <code>Object.wait</code> 等，都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出 <code>InterruptedException</code>，表示阻塞操作由于中断而提前结束。<code>JVM</code> 并不能保证阻塞方法检测到中断的速度，但在实际情况中响应速度还是非常快的。</p>
<p>当线程在非阻塞状态下中断时，它的中断状态将被设置，然后根据将被取消的操作来检查中断状态以判断发生了中断。通过这样的方法，中断操作将变得“有黏性”——如果不触发 <code>InterruptedException</code>，那么中断状态一直保持，直到明确地清除中断状态。</p>
<p>调用 <code>interrupt</code> 并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</p>
<p>对中断操作的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己（这些时刻也被称为取消点）。有些方法，例如 <code>wait</code>、<code>sleep</code> 和 <code>join</code> 等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已经被设置好的中断状态时，将抛出一个异常。设计良好的方法可以完全忽略这种请求，只要它们能使调用代码对中断请求进行某种处理。设计槽糕的方法可能会屏蔽中断请求，从而导致调用栈中的其他代码无法对中断请求做出响应。</p>
<p>在使用静态的 <code>interrupted</code> 时应该小心，因为它会清除当前线程的中断状态。如果调用 <code>interrupted</code> 时返回了 <code>true</code>，那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出 <code>InterruptedException</code>，或者通过再次调用 <code>interrupt</code> 来恢复中断状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    </span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                queue.put(p = p.nextProbablePrime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">            <span class="comment">/* Allow thread to exit */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> BlockingQueue&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，在每次迭代循环中，有两个位置可以检测出中断：在阻塞的 <code>put</code> 方法调用中，以及在循环开始处查询中断状态时。由于调用了阻塞的 <code>put</code> 方法，因此这里并不一定需要进行显式的检测，但执行检测却会使 <code>PrimeProducer</code> 对中断具有更高的响应性，因为它是在启动寻找素数任务之前检查中断的，而不是在任务完成之后。如果可中断的阻塞方法的调用频率并不高，不足以获得足够的响应性，那么显式的检测中断状态能起到一定的帮助作用。</p>
<h5 id="中断策略是什么"><a href="#中断策略是什么" class="headerlink" title="中断策略是什么"></a>中断策略是什么</h5><p>正如任务中应该包含取消策略一样，线程同样应该包含中断策略中断策略规定线程如何解释某个中断请求——当发现中断请求时，应该做哪些工作（如果需要的话），哪些工作单元对于中断来说是原子操作，以及以多块的速度来响应中断。</p>
<p>最合理的中断策略是某种形式的线程级取消操作或服务级取消操作：尽快退出，在必要时进行清理，通知某个所有者该线程已经退出。此外还可以建立其他的中断策略，例如暂停服务或重新开始服务，但对于那些包含非标准终端策略的线程或线程池，只能用于能知道这些策略的任务中。</p>
<p>区分任务和线程对中断的反应是很重要的。一个中断请求可以有一个或多个接收者——中断线程池中的某个工作者线程，同时意味着“取消当前任务”和“关闭工作者线程”。</p>
<p>任务不会在其自己拥有的线程中执行，而是在某个服务（例如线程池）拥有的线程中执行。对于非线程所有者的代码来说（例如，对于线程池而言，任何在线程池实现以外的代码），应该小心的保存中断状态，这样拥有线程的代码才能对中断做出响应，即使“非所有者”代码也可以做出响应。</p>
<p>这就是为什么大多数可阻塞的库函数都只是抛出 <code>InterruptedException</code> 作为中断响应。它们永远不会在某个由自己拥有的线程中运行，因为它们为任务或库代码实现了最合理的取消策略：尽快退出执行流程，并把中断信息传递给调用者，从而使调用栈中的上层代码可以取消进一步的操作。</p>
<p>当检查到中断请求时，任务并不需要放弃所有的操作——它可以推迟处理中断请求，并直到某个更合适的时刻。因此需要记住中断请求，并在完成当前任务后抛出 <code>InterruptedException</code> 或者表示已经收到中断请求。这项技术能够确保在更新过程中发生中断时，数据结构不会被破坏。</p>
<p>任务不应该对执行该任务的线程的中断策略做出任何假设，除非该任务被专门设计为在服务中运行，并且在这些服务中心包含特定的中断策略。无论任务把中断视为取消，还是其他某个中断响应操作，都应该小心地保存执行线程的中断状态。如果除了将 <code>InterruptedException</code> 传递给调用者外还需要执行其他操作，那么应该在捕获 <code>InterruptedException</code> 之后恢复中断状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().interrupt();</span><br></pre></td></tr></table></figure>


<p>正如任务代码不应该对其执行所在的线程的中断策略做出假设，执行取消操作的代码也不应该对线程的中断策略做出假设。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中，例如关闭（<code>shutdown</code>）方法。</p>
<p>由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。</p>
<h5 id="如何响应中断"><a href="#如何响应中断" class="headerlink" title="如何响应中断"></a>如何响应中断</h5><p>当调用可中断的阻塞库函数时，例如 <code>Thread.sleep</code> 或 <code>BlockingQueue.put</code> 等，有两种使用策略可用来处理 <code>InterruptedException</code>：</p>
<p>传递异常（可能在执行某个特定于任务的清除操作之后），从而使你的方法也成为可中断的阻塞方法。<br>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。<br>传递 <code>InterruptedException</code> 与将 <code>InterruptedException</code> 添加到 <code>throws</code> 字句中一样容易，如下代码清单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">getNextInteger</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果不想或无法传递 <code>InterruptedException</code>（或许通过 <code>Runnable</code> 来定义任务），那么需要寻找另一种方式来保存中断请求。一种标准的方法就是再次调用 <code>interrupt</code> 来恢复中断状态。你不能屏蔽 <code>InterruptedException</code>，例如在 <code>catch</code> 块中捕获到异常却不做任何处理，除非在你的代码中实现了线程的中断策略。虽然 <code>PrimeProducer</code> 屏蔽了中断，但这是因为它已经知道线程将要结束，因此在调用栈中已经没有上层代码需要知道中断信息。由于大多数代码并不知道它们将在哪个线程中运行，因此应该保存中断状态。</p>
<p>只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。</p>
<p>对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，它们应该在本地保存中断状态，并在返回前恢复状态而不是在捕获 <code>InterruptedException</code> 时恢复状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigInteger <span class="title">getNextInteger</span><span class="params">(BlockingQueue&lt;BigInteger&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 重新尝试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(interrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，如果过早的设置中断状态，就可能引起无限循环，因为大多数可中断的阻塞方法都会在入口处检查中断状态，并且当发现该状态已经被设置时会立即抛出 <code>InterruptedException</code>（通常，可中断的方法会在阻塞或进行重要的工作前首先检查中断，从而尽快地响应中断）。</p>
<p>如果代码不会调用可中断的阻塞方法，那么仍然可以通过在任务代码中轮询当前线程的中断状态来响应中断。要选择合适的轮询频率，就需要在效率和响应性之间进行权衡。如果响应性要求较高，那么不应该调用那些执行时间较长并且不响应中断的方法，从而对可调用的库代码进行一些限制。</p>
<p>在取消过程中可能涉及除了中断状态之外的其他状态。中断可以用来获得线程的注意，并且由中断线程保存的信息，可以为中断的线程提供进一步指示（当访问这些信息时，要确保使用同步）。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/dilixinxixitong2009/article/details/79752404" target="_blank" rel="noopener">https://blog.csdn.net/dilixinxixitong2009/article/details/79752404</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java新生代老年代的划分及回收算法</title>
    <url>/2020/03/16/2020/03/Java%E6%96%B0%E7%94%9F%E4%BB%A3%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%88%92%E5%88%86%E5%8F%8A%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Java堆(Java Heap)是JVM所管理的最大内存区域，也是所有线程共享的一块区域，在JVM启动时创建。</p>
<p>此内存区域存放的都是对象的实例和数组。JVM规范中说到:”所有的对象实例以及数组都要在堆上分配”。</p>
<p>Java堆是垃圾回收器管理的主要区域，百分之九十九的垃圾回收发生在Java堆，另外百分之一发生在方法区，因此又称之为”GC堆”。根据JVM规范规定的内容，Java堆可以处于物理上不连续的内存空间中。</p>
<p>当前JVM对于堆的垃圾回收，采用分代收集的策略。根据堆中对象的存活周期将堆内存分为新生代和老年代。在新生代中，每次垃圾回收都有大批对象死去，只有少量存活。而老年代中存放的对象存活率高。</p>
<p>这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记清除算法是最基础的回收算法，分为标记和清除两个部分：首先标记出所有需要回收的对象，这一过程在可达性分析过程中进行。在标记完之后统一回收所有被标记的对象。</p>
<p>标记清除算法有如下不足</p>
<ul>
<li>效率问题</li>
</ul>
<p>标记和清除这两个过程的效率不高</p>
<ul>
<li>空间问题</li>
</ul>
<p>清除之后会产生大量不连续的内存碎片，内存碎片太多会导致以后的程序运行中无法分配出较大的内存，从内不得不触发另外的垃圾回收。</p>
<p><img src="http://static.cyblogs.com/20180617105859782.png" alt="http://static.cyblogs.com/20180617105859782.png"></p>
<p>如上图中，经过标记清除之后，假设有了100M空间，但是这100M是不连续的，最大的一块连续空间可能才10M，所以导致之后程序需要一块20M内存空间时就不得不再进行一次GC来继续清理空间，效率极低。</p>
<p>鉴于标记清除算法有如上的缺陷，所以现在一般是用的是其的变种算法。</p>
<h4 id="复制算法-新生代算法"><a href="#复制算法-新生代算法" class="headerlink" title="复制算法(新生代算法)"></a>复制算法(新生代算法)</h4><h5 id="复制算法概念"><a href="#复制算法概念" class="headerlink" title="复制算法概念"></a>复制算法概念</h5><p>复制算法是针对Java堆中的新生代内存垃圾回收所使用的回收策略，解决了”标记-清理”的效率问题。</p>
<p>复制算法将堆中可用的新生代内存按容量划分成大小相等的两块内存区域，每次只使用其中的一块区域。当其中一块内存区域需要进行垃圾回收时，会将此区域内还存活着的对象复制到另一块上面，然后再把此内存区域一次性清理掉。</p>
<p>这样做的好处是每次都是对整个新生代一半的内存区域进行内存回收，内存分配时也就不需要考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配即可。此算法实现简单，运行高效。算法的执行流程如下图 :</p>
<p><img src="http://static.cyblogs.com/2018061711175251.png" alt="http://static.cyblogs.com/2018061711175251.png"></p>
<p>现在主流的虚拟机，包括HotSpot都是采用的这种回收策略进行新生代内存的回收。</p>
<h5 id="新生代内存划分"><a href="#新生代内存划分" class="headerlink" title="新生代内存划分"></a>新生代内存划分</h5><p>新生代中98%的对象都是”朝生夕死”的，所以并不需要按照1 : 1的比例来划分内存空间，而是将内存(新生代内存)分为一块较大的Eden(伊甸园)空间和两块较小的Survivor(幸存者)空间，每次使用Eden和其中一块Survivor（两个Survivor区域一个称为From区，另一个称为To区域）。</p>
<p>当进行垃圾回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>当Survivor空间不够用时，则需要依赖其他内存(老年代)进行分配担保。</p>
<p>HotSpot默认Eden与Survivor的大小比例是8 : 1，也就是说Eden:Survivor From : Survivor To = 8:1:1。所以每次新生代可用内存空间为整个新生代容量的90%,而剩下的10%用来存放回收后存活的对象。</p>
<p>HotSpot实现的复制算法流程如下:</p>
<p> 1. 当Eden区满的时候,会触发第一次Minor gc,把还活着的对象拷贝到Survivor From区；当Eden区再次触发Minor gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。</p>
<p> 2. 当后续Eden又发生Minor gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。</p>
<p> 3. 部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。</p>
<p><img src="http://static.cyblogs.com/20180617112302206.png" alt="http://static.cyblogs.com/20180617112302206.png"></p>
<p>发生在新生代的垃圾回收成为Minor GC，Minor GC又称为新生代GC，因为新生代对象大多都具备朝生夕灭的特性，因此Minor GC(采用复制算法)非常频繁，一般回收速度也比较快。</p>
<ol start="3">
<li>标记整理算法(老年代回收算法)<br> 复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以在栈的老年代不适用复制算法。</li>
</ol>
<p> 针对老年代对象存活率高的特点，提出了一种称之为”标记-整理算法”。标记过程仍与”标记-清除”过程一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。流程图如下:</p>
<p><img src="http://static.cyblogs.com/20180617112627331.png" alt="http://static.cyblogs.com/20180617112627331.png"></p>
<p>发生在老年代的GC称为Full GC，又称为Major GC，其经常会伴随至少一次的Minor GC(并非绝对，在Parallel Scavenge收集器中就有直接进行Full GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/weixin_40739833/article/details/80717638" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40739833/article/details/80717638</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程与Linux内核线程的映射关系</title>
    <url>/2020/03/15/2020/03/Java%E7%BA%BF%E7%A8%8B%E4%B8%8ELinux%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p><code>Java</code>线程与<code>Linux</code>内核线程的映射关系<code>Linux</code>从内核2.6开始使用<code>NPTL （Native POSIX Thread Library）</code>支持，但这时线程本质上还轻量级进程。 </p>
<p><code>Java</code>里的线程是由<code>JVM</code>来管理的，它如何对应到操作系统的线程是由<code>JVM</code>的实现来确定的。<code>Linux 2.6</code>上的<code>HotSpot</code>使用了<code>NPTL</code>机制，<strong>JVM线程跟内核轻量级进程有一一对应的关系</strong>。线程的调度完全交给了操作系统内核，当然jvm还保留一些策略足以影响到其内部的线程调度，举个例子，在linux下，只要一个<code>Thread.run</code>就会调用一个<code>fork</code>产生一个线程。</p>
<p><code>Java</code>线程在<code>Windows</code>及<code>Linux</code>平台上的实现方式，现在看来，是内核线程的实现方式。<strong>这种方式实现的线程，是直接由操作系统内核支持的——由内核完成线程切换，内核通过操纵调度器（Thread Scheduler）实现线程调度，并将线程任务反映到各个处理器上。</strong>内核线程是内核的一个分身。程序一般不直接使用该内核线程，而是使用其高级接口，即轻量级进程（<code>LWP</code>），也即线程。这看起来可能很拗口。看图：</p>
<p><img src="http://static.cyblogs.com/1350871014_7132.jpg" alt="Java线程与Linux内核线程的映射关系"></p>
<p>（说明：KLT即内核线程<code>Kernel Thread</code>，是“内核分身”。每一个KLT对应到进程P中的某一个轻量级进程<code>LWP</code>（也即线程），期间要经过用户态、内核态的切换，并在<code>Thread Scheduler</code> 下反应到处理器<code>CPU</code>上。）</p>
<p>​    这种线程实现的方式也有它的缺陷：在程序面上使用内核线程，必然在操作系统上多次来回切换用户态及内核态；另外，因为是一对一的线程模型，<code>LWP</code>的支持数是有限的。</p>
<p>对于一个大型程序，我们可以<strong>开辟的线程数量至少等于运行机器的cpu内核数量</strong>。java程序里我们可以通过下面的一行代码得到这个数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>

<p>所以最小线程数量即时<code>cpu</code>内核数量。如果所有的任务都是计算密集型的，这个最小线程数量就是我们需要的线程数。开辟更多的线程只会影响程序的性能，因为线程之间的切换工作，会消耗额外的资源。如果任务是IO密集型的任务，我们可以开辟更多的线程执行任务。当一个任务执行<code>IO</code>操作的时候，线程将会被阻塞，处理器立刻会切换到另外一个合适的线程去执行。如果我们只拥有与内核数量一样多的线程，即使我们有任务要执行，他们也不能执行，因为处理器没有可以用来调度的线程。</p>
<p>​    <strong>如果线程有50%的时间被阻塞，线程的数量就应该是内核数量的2倍。</strong>如果更少的比例被阻塞，那么它们就是计算密集型的，则需要开辟较少的线程。如果有更多的时间被阻塞，那么就是<code>IO</code>密集型的程序，则可以开辟更多的线程。于是我们可以得到下面的线程数量计算公式：线程数量=内核数量 / (1 – 阻塞率)</p>
<p>我们可以通过相应的分析工具或者<code>java</code>的<code>management</code>包来得到阻塞率的数值。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="http://www.hongyanliren.com/2015m07/35068.html" target="_blank" rel="noopener">http://www.hongyanliren.com/2015m07/35068.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程的6种状态及切换</title>
    <url>/2020/03/14/2020/03/Java%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<p>Java中线程的状态分为6种。</p>
<blockquote>
<ol>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>
<li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>
<li>阻塞(BLOCKED)：表示线程阻塞于锁。</li>
<li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>
</ol>
</blockquote>
<p>这6种状态定义在Thread类的State枚举中，可查看源码进行一一对应。</p>
<h4 id="线程的状态图"><a href="#线程的状态图" class="headerlink" title="线程的状态图"></a>线程的状态图</h4><p><img src="http://static.cyblogs.com/20181120173640764.jpg" alt="http://static.cyblogs.com/20181120173640764.jpg"></p>
<h5 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h5><p>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p>
<h5 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h5><p>就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。<br>调用线程的start()方法，此线程进入就绪状态。<br>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。<br>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。<br>锁池里的线程拿到对象锁后，进入就绪状态。</p>
<h5 id="运行中状态"><a href="#运行中状态" class="headerlink" title="运行中状态"></a>运行中状态</h5><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</p>
<h5 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h5><p>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p>
<h5 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h5><p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p>
<h5 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h5><p>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p>
<h5 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h5><p>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。<br>在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。<br>与等待队列相关的步骤和图</p>
<p><img src="http://static.cyblogs.com/20180701221233161.jpg" alt="http://static.cyblogs.com/20180701221233161.jpg"></p>
<p>1、线程1获取对象A的锁，正在使用对象A。<br>2、线程1调用对象A的wait()方法。<br>3、线程1释放对象A的锁，并马上进入等待队列。<br>4、锁池里面的对象争抢对象A的锁。<br>5、线程5获得对象A的锁，进入synchronized块，使用对象A。<br>6、线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入同步队列。若线程5调用对象A的notify()方法，则唤醒一个线程，不知道会唤醒谁，被唤醒的那个线程进入同步队列。<br>7、notifyAll()方法所在synchronized结束，线程5释放对象A的锁。<br>8、同步队列的线程争抢对象锁，但线程1什么时候能抢到就不知道了。 </p>
<h4 id="同步队列状态"><a href="#同步队列状态" class="headerlink" title="同步队列状态"></a>同步队列状态</h4><ul>
<li>当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此时当前线程进入同步队列。简言之，同步队列里面放的都是想争夺对象锁的线程。</li>
<li>当一个线程1被另外一个线程2唤醒时，1线程进入同步队列，去争夺对象锁。</li>
<li>同步队列是在同步的环境下才有的概念，一个对象对应一个同步队列。</li>
<li>线程等待时间到了或被notify/notifyAll唤醒后，会进入同步队列竞争锁，如果获得锁，进入RUNNABLE状态，否则进入BLOCKED状态等待获取锁。</li>
</ul>
<h4 id="几个方法的比较"><a href="#几个方法的比较" class="headerlink" title="几个方法的比较"></a>几个方法的比较</h4><p>1、Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。<br>2、Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。<br>3、thread.join()/thread.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程一般情况下进入RUNNABLE状态，也有可能进入BLOCKED状态（因为join是基于wait实现的）。<br>4、obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。<br>5、obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。<br>6、LockSupport.park()/LockSupport.parkNanos(long nanos),LockSupport.parkUntil(long deadlines), 当前线程进入WAITING/TIMED_WAITING状态。对比wait方法,不需要获得锁就可以让线程进入WAITING/TIMED_WAITING状态，需要通过LockSupport.unpark(Thread thread)唤醒。</p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><ul>
<li>等待队列里许许多多的线程都wait()在一个对象上，此时某一线程调用了对象的notify()方法，那唤醒的到底是哪个线程？随机？队列FIFO？or sth else？Java文档就简单的写了句：选择是任意性的（The choice is arbitrary and occurs at the discretion of the implementation）。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/pange1991/article/details/53860651" target="_blank" rel="noopener">https://blog.csdn.net/pange1991/article/details/53860651</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL MVCC实现原理</title>
    <url>/2020/03/18/2020/03/MYSQL%20MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>MySQL是现在最流行的关系型数据库(RDB)的选择，创建一个应用时，无论是用户数据还是订单数据，使用关系型数据库存储是最可靠稳定的选择，借助RDB提供的可靠性、事务等功能，为应用提供完善的支持。MySQL是开源软件，可以免费使用，MySQL在发展多年后越来越成熟，成为大部分公司的数据库首选。MySQL采用插件式的存储引擎架构，5.5版本后默认使用InnoDB存储引擎。</p>
<h4 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h4><p>MySQL从概念上可以分为四层:</p>
<ul>
<li><strong>第一层是接入层：</strong> 不同语言的客户端通过mysql的协议与mysql服务器进行连接通信，接入层进行权限验证、连接池管理、线程管理等。</li>
<li><strong>第二层是服务层：</strong> 包括sql解析器、sql优化器、数据缓冲、缓存等。</li>
<li><strong>第三层是存储引擎层：</strong> mysql中存储引擎是基于表的。</li>
<li><strong>第四层是系统文件层：</strong> 保存数据、索引、日志等。<br><img src="http://static.cyblogs.com/mysql-arch.png" alt="http://static.cyblogs.com/mysql-arch.png"></li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC是<code>Multi Version Concurrency Control</code>的简称，代表多版本并发控制。为什么需要MVCC，还要从数据库事务的ACID特性说起。<br>相信很多朋友都了解ACID，它们分别代表了</p>
<ul>
<li>Atomicity(原子性)</li>
<li>Consistency(一致性)</li>
<li>Isolation(隔离性)</li>
<li>Durability(持久性)</li>
</ul>
<p>原子性表示一个事务的操作结果要么全部执行要么全部不执行。</p>
<p>一致性表示事务总是从一个一致的状态转换到另一个一致的状态。</p>
<p>隔离性表示一个事务的修改结果在什么时间能够被其他事务看到，SQL1992规范中对隔离性定义了不同的隔离级别，分为读未提交(READ UNCOMMITED),事务能够看到其他事务没有提及的修改，当另一个事务又回滚了修改后的情况又被称为脏读dirty read。<br>读已提交<code>（READ COMMITTED）</code>，事务能够看到其他事务提交后的修改，这时会出现一个事务内两次读取数据可能因为其他事务提交的修改导致不一致的情况，称为不可重复读。 可重复读<code>（REPEATABLE READ）</code>，在两次读取时读取到的数据的状态是一致的，和序列化<code>（SERIALIZABLE）</code>可重复读中可能出现第二次读读到第一次没有读到的数据，也就是被其他事务插入的数据，这种情况称为幻读<code>phantom read</code>，序列化级别中不能出现幻读。<br>隔离级别依次增强，但是导致的问题是并发能力的减弱。各种数据库厂商会对各个隔离级别进行实现。和<code>Java</code>中的多线程问题相同，数据库通常使用锁来实现隔离性。<br>        最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。所以就使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够，又提出了能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务<code>session</code>会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能。</p>
<h4 id="InnoDB与MVCC"><a href="#InnoDB与MVCC" class="headerlink" title="InnoDB与MVCC"></a>InnoDB与MVCC</h4><p>MySQL中的InnoDB存储引擎的特性有，默认隔离级别<code>REPEATABLE READ</code>，行级锁，实现了MVCC，Consistent nonlocking read(默认读不加锁，一致性非锁定读)，Insert Buffer，Adaptive Hash Index，DoubleWrite，Cluster Index。<br>上面列举了这么多，表示InnoDB有很多特性、很快。<br>InnoDB中通过UndoLog实现了数据的多版本，而并发控制通过锁来实现。<br>Undo Log除了实现MVCC外，还用于事务的回滚。</p>
<h4 id="Redo-log，bin-log，Undo-log"><a href="#Redo-log，bin-log，Undo-log" class="headerlink" title="Redo log，bin log，Undo log"></a>Redo log，bin log，Undo log</h4><p>MySQL Innodb中存在多种日志，除了错误日志、查询日志外，还有很多和数据持久性、一致性有关的日志。<br>binlog，是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的，另外通过解析binlog能够实现mysql到其他数据源（如ElasticSearch)的数据复制。<br>redo log记录了数据操作在物理层面的修改，mysql中使用了大量缓存，缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘，当内存和磁盘的数据不一致时，称内存中的数据为脏页(dirty page)。为了保证数据的安全性，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中，redo log是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。这样实现了事务的原子性、一致性和持久性。</p>
<p>Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。</p>
<p>redo log 和binlog的一致性，为了防止写完binlog但是redo log的事务还没提交导致的不一致，innodb 使用了两阶段提交<br>大致执行序列为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InnoDB prepare  （持有prepare_commit_mutex）；</span><br><span class="line">write/sync Binlog；</span><br><span class="line"><span class="function">InnoDB <span class="title">commit</span> <span class="params">(写入COMMIT标记后释放prepare_commit_mutex)</span>。</span></span><br></pre></td></tr></table></figure>

<h4 id="MVCC实现"><a href="#MVCC实现" class="headerlink" title="MVCC实现"></a>MVCC实现</h4><p><code>innodb</code>中通过B+树作为索引的数据结构，并且主键所在的索引为<code>ClusterIndex</code>(聚簇索引)，<code>ClusterIndex</code>中的叶子节点中保存了对应的数据内容。一个表只能有一个主键，所以只能有一个聚簇索引，如果表没有定义主键，则选择第一个非NULL唯一索引作为聚簇索引，如果还没有则生成一个隐藏id列作为聚簇索引。<br>除了<code>Cluster Index</code>外的索引是<code>Secondary Index</code>(辅助索引)。辅助索引中的叶子节点保存的是聚簇索引的叶子节点的值。<br><code>InnoDB</code>行记录中除了刚才提到的<code>rowid</code>外，还有<code>trx_id</code>和<code>db_roll_ptr</code>，<code>trx_id</code>表示最近修改的事务的id，<code>db_roll_ptr</code>指向<code>undo segment</code>中的<code>undo log</code>。<br>新增一个事务时事务id会增加，<code>trx_id</code>能够表示事务开始的先后顺序。</p>
<p><code>Undo log</code>分为<code>Insert</code>和<code>Update</code>两种，<code>delete</code>可以看做是一种特殊的<code>update</code>，即在记录上修改删除标记。<br><code>update undo log</code>记录了数据之前的数据信息，通过这些信息可以还原到之前版本的状态。<br>当进行插入操作时，生成的Insert undo log在事务提交后即可删除，因为其他事务不需要这个<code>undo log</code>。<br>进行删除修改操作时，会生成对应的<code>undo log</code>，并将当前数据记录中的<code>db_roll_ptr</code>指向新的<code>undo log</code><br><img src="http://static.cyblogs.com/undolog.png" alt="undolog"></p>
<h4 id="数据可见性判断"><a href="#数据可见性判断" class="headerlink" title="数据可见性判断"></a>数据可见性判断</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`testunique`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT，</span><br><span class="line">  <span class="string">`uid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>，</span><br><span class="line">  <span class="string">`ukey`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>，</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)，</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`id_uid`</span> (<span class="string">`uid`</span>)，</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_key`</span> (<span class="string">`ukey`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">70</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>隔离级别REPEATABLE READ</p>
<table>
<thead>
<tr>
<th align="left">session1</th>
<th align="left">session2</th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">select * from testunique;</td>
</tr>
<tr>
<td align="left">insert into testunique values(NULL，NULL，1);</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">select * from testunique;</td>
</tr>
<tr>
<td align="left">commit</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">select * from testunique;</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">commit</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">select * from testunique;</td>
</tr>
</tbody></table>
<p>只有当session2 commit之后的查询才能查到session1插入的数据</p>
<p>事务可见性的处理过程:<br><img src="http://static.cyblogs.com/readview-visible.png" alt="undo-view"><br>RR级别下一个事务开始后第一个<code>snapshot read</code>的时候，会将当期活动的事务id记录下来，记录到<code>read view</code>中。RC级别则是每次<code>snapshot read</code>都会创建一个新的<code>read view</code>。<br>假设当前，<code>read view</code>中最大的事务id为<code>tmax</code>，最小为<code>tmin</code>。则判断一个数据是否可见以及对应的版本的方法为。<br>如果该行中的<code>trx_id</code>，赋值给<code>tid</code>，如果tid和当前事务id相等或小于<code>tmin</code>，说明是事务内发生的或开启前的修改，则直接返回该版本数据; 如果<br><code>trx_id</code>大于<code>tmax</code>，则查看该版本的<code>db_roll_ptr</code>中的<code>trx_id</code>，赋值给tid并从头开始判断。如果<code>tid</code>小于<code>tmax</code>并且不在<code>read view</code>中，则返回，否则中回滚段中找出<code>undo log</code>的<code>trx_id</code>，赋值给tid从头判断。</p>
<p>所以可见性是，只有当第一次读之前提交的修改和自己的修改可见，其他的均不可见。</p>
<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="https://www.jianshu.com/p/f692d4f8a53e" target="_blank" rel="noopener">https://www.jianshu.com/p/f692d4f8a53e</a></li>
<li><a href="https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/" target="_blank" rel="noopener">https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor模型的Java NIO实现</title>
    <url>/2020/03/19/2020/03/Reactor%E6%A8%A1%E5%9E%8B%E7%9A%84Java%20NIO%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>实现Reactor模型可分为以下三种：</p>
<ul>
<li>单线程模型</li>
<li>单Reactor多线程模型</li>
<li>主从Reactor多线程模型。</li>
</ul>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>Reactor单线程模型，指的是所有的IO操作都在同一个线程上面完成，线程的职责如下：</p>
<ul>
<li><p>作为NIO服务端，接收客户端的TCP连接；</p>
</li>
<li><p>作为NIO客户端，向服务端发起TCP连接；</p>
</li>
<li><p>读取通信对端的请求或者应答消息；</p>
</li>
<li><p>向通信对端发送消息请求或者应答消息。</p>
</li>
</ul>
<p>由于Reactor模式使用的是异步非阻塞IO，所有的IO操作都不会导致阻塞，理论上一个线程可以独立处理所有IO相关的操作。从架构层面看，一个NIO线程确实可以完成其承担的职责。例如，通过Acceptor接收客户端的TCP连接请求消息，链路建立成功之后，通过Dispatch将对应的ByteBuffer派发到指定的Handler上进行消息解码。用户线程可以通过消息编码通过NIO线程将消息发送给客户端。</p>
<h5 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel acceptServerSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel socketChannel = acceptServerSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    System.out.println(<span class="string">"accept from "</span>+socketChannel.socket().getInetAddress().toString());</span><br><span class="line">                  <span class="comment">//  LOGGER.info("Accept request from &#123;&#125;", socketChannel.getRemoteAddress());</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable() &amp;&amp; key.isValid()) &#123;</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                        key.cancel();</span><br><span class="line">                        System.out.println(<span class="string">"Received invalide data, close the connection"</span>);</span><br><span class="line">                        <span class="comment">//LOGGER.info("Received invalide data, close the connection");</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"Received message"</span>+<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                    <span class="comment">//LOGGER.info("Received message &#123;&#125;", new String(buffer.array()));</span></span><br><span class="line">                &#125;</span><br><span class="line">                keys.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel;</span><br><span class="line">        socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//socketChannel.configureBlocking(false);</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">1234</span>));</span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>);<span class="comment">//可以方便地修改日期格式</span></span><br><span class="line">        String str = dateFormat.format( now );</span><br><span class="line">        <span class="keyword">byte</span>[] requst = str.getBytes();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(requst.length);</span><br><span class="line">        buffer.put(requst);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发的应用场景却不合适，主要原因如下：</p>
<p>一个NIO线程同时处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送；<br>当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；<br>可靠性问题：一旦NIO线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。<br>为了解决这些问题，演进出了Reactor多线程模型。</p>
<h4 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h4><p>经典Reactor模式中，尽管一个线程可同时监控多个请求（Channel），但是所有读/写请求以及对新连接请求的处理都在同一个线程中处理，无法充分利用多CPU的优势,同时读/写操作也会阻塞对新连接请求的处理。当获取到IO的读写事件之后，交由线程池来处理，这样可以减小主reactor的性能开销，从而更专注的做事件分发工作了，从而提升整个应用的吞吐。<br><img src="http://static.cyblogs.com/20180720174300266.png" alt="http://static.cyblogs.com/20180720174300266.png"></p>
<p><strong>Reactor多线程模型的特点：</strong></p>
<ol>
<li><p>有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求；</p>
</li>
<li><p>网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送；</p>
</li>
<li><p>1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。</p>
</li>
</ol>
<p>在绝大多数场景下，Reactor多线程模型都可以满足性能需求；</p>
<h5 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reactor2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(selector.selectNow() &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; sets = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = sets.iterator();</span><br><span class="line">            <span class="keyword">while</span>(keys.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keys.next();</span><br><span class="line">                keys.remove();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel Serverchannel = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel channel = Serverchannel.accept();</span><br><span class="line">                    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    System.out.println(<span class="string">"accept from "</span>+channel.socket().getInetAddress().toString());</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isValid()&amp;&amp;key.isReadable()) &#123;</span><br><span class="line">                    pool.submit(<span class="keyword">new</span> Processor(key));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Processor</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    SelectionKey key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Processor</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">int</span> count = socketChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (count &lt;  <span class="number">0</span>) &#123;</span><br><span class="line">            key.cancel();</span><br><span class="line">            socketChannel.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Received invalide data, close the connection"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(<span class="string">"Received message"</span>+<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">            System.out.println(<span class="string">"current thread"</span>+Thread.currentThread().toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在极个别特殊场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型-主从Reactor多线程模型。</p>
<h4 id="多个Reactor模式（主从Reactor）"><a href="#多个Reactor模式（主从Reactor）" class="headerlink" title="多个Reactor模式（主从Reactor）"></a>多个Reactor模式（主从Reactor）</h4><p>Netty中使用的Reactor模式，引入了多Reactor，也即一个主Reactor负责监控所有的连接请求，多个子Reactor负责监控并处理读/写请求，减轻了主Reactor的压力，降低了主Reactor压力太大而造成的延迟。并且每个子Reactor分别属于一个独立的线程，每个成功连接后的Channel的所有操作由同一个线程处理。这样保证了同一请求的所有状态和上下文在同一个线程中，避免了不必要的上下文切换，同时也方便了监控请求响应状态。</p>
<p><strong>多个Reactor模式架构图</strong><br><img src="http://static.cyblogs.com/2018072113140256.png" alt="http://static.cyblogs.com/2018072113140256.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainReactor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> coreNum = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        FollowerReactor[] followers = <span class="keyword">new</span> FollowerReactor[coreNum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;coreNum; i++) &#123;</span><br><span class="line">            followers[i] = <span class="keyword">new</span> FollowerReactor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(selector.select()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            <span class="keyword">for</span>(SelectionKey key:keys) &#123;</span><br><span class="line">                keys.remove(key);</span><br><span class="line">                <span class="keyword">if</span>(key.isValid()&amp;&amp;key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel serverSocketChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel1.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Accept request:"</span> + socketChannel.socket().getInetAddress());</span><br><span class="line">                    FollowerReactor follower = followers[++index%coreNum];</span><br><span class="line">                    follower.register(socketChannel);</span><br><span class="line">                    <span class="comment">//follower.wakeUp();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是主Reactor，子Reactor根据前机器可用核数的两倍（与Netty默认的子Reactor个数一致）。对于每个成功连接的SocketChannel，通过round robin的方式交给不同的子Reactor。子Reactor的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FollowerReactor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  ExecutorService service =Executors.newFixedThreadPool(</span><br><span class="line">            <span class="number">2</span>*Runtime.getRuntime().availableProcessors());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FollowerReactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        select();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(<span class="number">500</span>)&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(count&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                            channel.close();</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            System.out.println(channel+<span class="string">"-&gt;red end !"</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">                            System.out.println(channel+<span class="string">",size is 0 !"</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            System.out.println(channel+<span class="string">",message is :"</span>+<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子Reactor中创建了一个静态的线程池，且线程池的大小为机器核数的两倍，每个字Reactor包换一个Selector实例，同事每次创建一个子Reactor都提交一个任务到线程池，阻塞到selector方法，直到新的channel注册到该Selector上，才继续执行。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/TheLudlows/article/details/81136359" target="_blank" rel="noopener">https://blog.csdn.net/TheLudlows/article/details/81136359</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactor</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongodb分片集群部署</title>
    <url>/2020/03/17/2020/03/Mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h4 id="Mongodb分片概括"><a href="#Mongodb分片概括" class="headerlink" title="Mongodb分片概括"></a>Mongodb分片概括</h4><ul>
<li>分片在多台服务器上分布数据的方法， Mongodb使用分片来支持具有非常大的数据集和高吞吐量的操作的部署</li>
<li>具有大数据集和高吞吐量应用程序的数据库系统，可以挑战单台服务器的容量。<br> 例如，高查询率可以耗尽服务器的cpu容量，工作集大小大于系统的RAM强制磁盘驱动器的I/O容量，</li>
<li>有两种方法来解决系统增长：垂直和水平缩放。<ul>
<li>垂直缩放 涉及增加的单个服务器的容量，例如使用更强大的CPU，加入更多的RAM，或增加的存储空间量。可用技术中的限制可能限制单个机器对于给定工作负载足够强大。此外，基于云的提供商具有基于可用硬件配置的硬上限。因此，对于垂直缩放存在实际的最大值。</li>
<li>包括将系统数据和负载在多个服务器，添加额外的服务器，需要增加容量。虽然单个机器的总速度或容量可能不高，但是每个机器处理整个工作负载的子集，潜在地提供比单个高速大容量服务器更好的效率。扩展部署的容量仅需要根据需要添加额外的服务器，这可以是比单个机器的高端硬件低的总体成本。权衡是基础设施的复杂性和部署的维护。</li>
</ul>
</li>
<li>Mongodb的支持水平扩展，分片。</li>
</ul>
<h5 id="分片目的"><a href="#分片目的" class="headerlink" title="分片目的"></a>分片目的</h5><p>对于单台数据库服务器，庞大的数据量及高吞吐量的应用程序对它而言无疑是个巨大的挑战。频繁的CRUD操作能够耗尽服务器的CPU资源，快速的数据增长也会让硬盘存储无能为力，最终内存无法满足数据需要导致大量的I/O，主机负载严重。为了解决这种问题，对于数据库系统一般有两种方法：<strong>垂直扩展</strong>和<strong>分片（水平扩展）。</strong></p>
<p><strong>【垂直扩展</strong>】：添加更多的CPU和存储资源来增加系统性能。这种方式缺点是：拥有大量CPU和RAM资源的高端机器比普通PC机器昂贵得太多，而且单点故障会影响整个系统的服务。</p>
<p><strong>【分片】</strong>：相反地，分片将大的数据集分配到多台主机上，每个分片是一个独立的数据库，这些分片整体上构成一个完整的逻辑数据库。分片减少了每台服务器上的数据操作量，随着集群的增长，每台分片处理越来越少的数据，结果，增加了系统整体服务能力。另外，分片还减少了每台服务器需要存储的数据量。</p>
<h5 id="MongoDB中的分片"><a href="#MongoDB中的分片" class="headerlink" title="MongoDB中的分片"></a>MongoDB中的分片</h5><p>MongoDB通过配置分片集群来支持分片，一个分片集群包括以下几个组件：分片，查询路由，配置服务器</p>
<ul>
<li><strong>分片：</strong>用来存储数据，为了提供系统可用性和数据一致性，一个生产环境的分片集群，通常每个分片是一个副本集。</li>
<li><strong>查询路由</strong>：指客户端应用访问每个分片的路径。</li>
<li><strong>配置服务器</strong>：存储集群的元数据，这些数据包含了集群数据集到各分片的映射关系。查询路由就是通过这些元数据到特定的分片上执行指定的数据操作。（从v3.2开始，配置服务器也可以作为副本集，但是必须使用<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.cnblogs.com%2Fwiredtiger.html" target="_blank" rel="noopener"><em>WiredTiger</em></a>存储引擎，反对使用3个镜像实例作为配置服务器）</li>
</ul>
<h5 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h5><p>MongoDB的数据划分，是以集合级别为标准。分片通过shard key来划分集合数据。</p>
<ul>
<li><strong>shard key：</strong></li>
</ul>
<p>为了对集合分片，你需要指定一个shard key。shard key既可以是集合的每个文档的索引字段也可以是集合中每个文档都有的组合索引字段。MongoDB将shard keys值按照块（chunks）划分，并且均匀的将这些chunks分配到各个分片上。MongoDB使用<strong>基于范围划分</strong>或<strong>基于散列划分</strong>来划分chunks的。</p>
<ul>
<li><strong>基于范围划分</strong>：</li>
</ul>
<p>MongoDB通过shard key值将数据集划分到不同的范围就称为基于范围划分。对于数值型的shard key：你可以虚构一条从负无穷到正无穷的直线（理解为x轴），每个shard key 值都落在这条直线的某个点上，然后MongoDB把这条线划分为许多更小的没有重复的范围成为块（chunks），一个chunk就是就某些最小值到最大值的范围。</p>
<ul>
<li><strong>基于散列划分：</strong></li>
</ul>
<p>MongoDB计算每个字段的hash值，然后用这些hash值建立chunks。</p>
<ul>
<li><strong>基于范围和基于散列划分的性能比较：</strong></li>
</ul>
<p>基于范围划分对于范围查询比较高效。假设在shard key上进行范围查询，查询路由很容易能够知道哪些块与这个范围重叠，然后把相关查询按照这个路线发送到仅仅包含这些chunks的分片。但是基于范围划分很容易导致数据不均匀分布，这样会削弱分片集群的功能。例如当shard key是个成直线上升的字段，如时间。那么，所有在给定时间范围内的请求都会映射到相同的chunk，也就是相同的分片上。这种情况下，小部分的分片将会承受大多数的请求，那么系统整体扩展并不理想。</p>
<p>相反的，基于散列划分是以牺牲高效范围查询为代价，它能够均匀的分布数据，散列值能够保证数据随机分布到各个分片上。</p>
<ul>
<li><strong>使用标签来自定义数据分布</strong></li>
</ul>
<p>MongoDB允许DBA们通过标签标记分片的方式直接平衡数据分布策略，DBA可以创建标签并且将它们与shard key值的范围进行关联，然后分配这些标签到各个分片上，最终平衡器转移带有标签标记的数据到对应的分片上，确保集群总是按标签描述的那样进行数据分布。标签是控制平衡器行为及集群中块分布的主要方法</p>
<h5 id="维持数据分布平衡"><a href="#维持数据分布平衡" class="headerlink" title="维持数据分布平衡"></a>维持数据分布平衡</h5><p>新加入的数据及服务器都会导致集群数据分布不平衡，MongoDB采用两种方式确保数据分布的平衡：</p>
<ul>
<li><strong>拆分</strong></li>
</ul>
<p>拆分是一个后台进程，防止块变得太大。当一个块增长到指定块大小的时候，拆分进程就会块一分为二，整个拆分过程是高效的。不会涉及到数据的迁移等操作。</p>
<ul>
<li><strong>平衡</strong></li>
</ul>
<p>平衡器是一个后台进程，管理块的迁移。平衡器能够运行在集群任何的mongd实例上。当集群中数据分布不均匀时，平衡器就会将某个分片中比较多的块迁移到拥有块较少的分片中，直到数据分片平衡为止。举个例子：如果集合users有100个块在分片1里，50个块在分片2中，那么平衡器就会将分片1中的块迁移到分片2中，直到维持平衡。</p>
<p>分片采用后台操作的方式管理着源分片和目标分片之间块的迁移。在迁移的过程中，源分片中的块会将所有文档发送到目标分片中，然后目标分片会获取并应用这些变化。最后，更新配置服务器上关于块位置元数据。</p>
<ul>
<li><strong>从集群中增加和删除分片</strong></li>
</ul>
<p>添加新分片到集群中会产生数据不平衡，因为新分片中没有块，当MongoDB开始迁移数据到新分片中时，等到数据分片平衡恐怕需要点时间。</p>
<p>当删除一个分片时，平衡器将会把分片中所有块迁移到另一个分片中，在完成这些迁移并更新元数据后，你就可以安全的删除分片了。</p>
<h4 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h4><ul>
<li><p>一个mongodb分片集群由以下几部分组成</p>
<p><img src="http://static.cyblogs.com/10506346-13c6d148967b44c0.jpg" alt="img"></p>
</li>
<li><p><code>shard</code> 每个shard包含分片数据的子集，每个shard可以部署一个副本集<br> 一台机器的一个数据表 Collection1 存储了 1T 数据，压力太大了！在分给4个机器后，每个机器都是256G，则分摊了集中在一台机器的压力。也许有人问一台机器硬盘加大一点不就可以了，为什么要分给四台机器呢？不要光想到存储空间，实际运行的数据库还有硬盘的读写、网络的IO、CPU和内存的瓶颈。在mongodb集群只要设置好了分片规则，通过mongos操作数据库就能自动把对应的数据操作请求转发到对应的分片机器上。在生产环境中分片的片键可要好好设置，这个影响到了怎么把数据均匀分到多个分片机器上，不要出现其中一台机器分了1T，其他机器没有分到的情况，这样还不如不分片！</p>
</li>
</ul>
<p><img src="http://static.cyblogs.com/10506346-e50031975b9199c4.jpg" alt="img"></p>
<ul>
<li><code>mongos</code> MongoS充当一个查询的路由器，提供客户端应用程序和所述分片簇之间的接口,mongos作为数据库集群请求的入口，所有的请求都是通过mongos来进行协调的，不需要在应用程序添加一个路由选择器，mongos自己就是一个请求分发中心，它负责把对应的数据请求转发到对应的shard服务器上，在生产环境中通常有多个monogs作为请求的入口，防止其中一个挂掉所有mongos请求都没有办法操作</li>
<li><code>config servers</code> 为集群配置的服务器存储元数据和配置设置，从Mongodb3.4开始，配置服务器必须部署为复制集，mongos本身没有物理存储分片服务器和数据路由信息，只是缓存在内存当中，配置服务器则实际存储这些数据，mongos第一次启动或者关掉重启会从configserver中加载配置信息，以后如果配置信息有变化会通过所有的mongos更新自己的状态，这样mongs就能继续准确路由，在生产环境中通常有多个config server配置服务器，因为它存储了分片路由的元数据，如果就一个如果挂掉一个，整个mongodb基础就会挂掉。</li>
</ul>
<h5 id="片键"><a href="#片键" class="headerlink" title="片键"></a>片键</h5><ul>
<li><p>片键<br> 1、在分发集合中文件时，mongodb的分区使用的收集片键关键，在片键由存在目标集合中的每个文档中的一个不可变或多个字段<br> 2、在分割集合的时候选择片键，<font color=red>分片键完成之后是不能更改的</font>，分片集合只能有1个片键，到片键的非空集合，集合必须有一个索引，与片键启动，对于空空集合，如果集合尚未具有指定分片键的相关索引，则Mongodb会创建索引<br> 3、分片键的选择会影响分片集群的性能和效率以及可伸缩性，具有最佳可能的硬件可以通过分片达到瓶颈，片键和其支持指数的选择也可以影响数据的拆分，但集群可以使用<br> 4、片键决定了集群中一个集合的文件咋不同的片键中的分布，片键字段必须被索引，且在集合中的每条记录都不能为空，可以是单个字段或者是复合字段<br> 5、Mongodb使用片键的范围是吧数据分布在分片中，每个范围，又称为数据块，定义了一个不重叠的片键范围Mongodb把数据块与他们存储的文档分布到集群中的不同分布中，当一个数据块的大小超过数据块最大大小的时候，Mongodb会宜聚片键的范围将数据块分裂为更小的数据块</p>
<p><img src="http://static.cyblogs.com/10506346-573cd236b695d18e.png" alt="img"></p>
</li>
<li><p>片键的使用语法<br> 1、在分片集合，必须制定目标集合和片键的<code>sh.shardCollection()</code></p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">sh.shardCollection(namespace, key)</span><br></pre></td></tr></table></figure>

<p>2、哈希片键使用单字段的哈希索引进行数据在分片之间的平均分发，<code>除数取余</code>和<code>一致性哈希</code><br> 3、被选为片键的字段必须有足够大的基数，或者有足够多的不同的值，对于单调的递增的字段如果<code>ObjectID</code>或是时间戳，哈希索引效果更好<br> 4、如果在一个空集合创建哈希片键，Mongodb会自动创建并迁移数据块，以保证每个分片上都有两个数据块，也可以执行<code>shardCollection</code>指定<code>numInitialChunks</code>参数以控制初始化时Mongodb创建数据块数目，或者手动调用<code>split</code>命令在分片上分裂数据块<br> 5、对使用了哈希片键分片的集合进行请求时，Mongodb会自动计算哈希值，应用不需要解析哈希值</p>
<h4 id="shard集群部署"><a href="#shard集群部署" class="headerlink" title="shard集群部署"></a>shard集群部署</h4><ul>
<li><p>部署ip规划</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">172.17.237.33:30001    config1</span><br><span class="line">172.17.237.34:30002    config2</span><br><span class="line">172.17.237.36:30003    config3</span><br><span class="line">172.17.237.37:40000    mongos</span><br><span class="line">172.17.237.38:50000    shard1</span><br><span class="line">172.17.237.39:50001    shard2</span><br><span class="line">172.17.237.40:50002    shard3</span><br><span class="line">172.17.237.41:60000    sha1</span><br><span class="line">172.17.237.42:60001    sha2</span><br><span class="line">172.17.237.43:60002    sha3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="配置config-server-副本集"><a href="#配置config-server-副本集" class="headerlink" title="配置config server 副本集"></a>配置config server 副本集</h5><ul>
<li>配置confi1配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root@My-Dev db2]<span class="comment"># vim config1.conf </span></span><br><span class="line">[root@My-Dev db1]<span class="comment"># vim configsvr.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>1/log/db1.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>1/db1.pid</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">30000</span>  </span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>1/data</span><br><span class="line">configsvr=<span class="literal">true</span>   <span class="comment"># 在配置文件添加此项就行</span></span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=config</span><br></pre></td></tr></table></figure>

<ul>
<li>配置confi2配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root@My-Dev db2]<span class="comment"># vim config2.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>2/log/db2.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>2/db2.pid</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">30001</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>2/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=config</span><br><span class="line">configsvr=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置confi3配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root@My-Dev db2]<span class="comment"># vim config3.conf</span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>3/log/db3.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>3/db3.pid</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">30002</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>3/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=config</span><br><span class="line">configsvr=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动config server</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@My-Dev bin]# ./mongod -f /home/mongodb/test/db1/config1.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 5260</span><br><span class="line">child process started successfully, parent exiting</span><br><span class="line"></span><br><span class="line">[root@My-Dev bin]# ./mongod -f /home/mongodb/test/db2/config2.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 5202</span><br><span class="line">child process started successfully, parent exiting</span><br><span class="line"></span><br><span class="line">[root@My-Dev bin]# ./mongod -f /home/mongodb/test/db3/config3.conf </span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 4260</span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure>

<ul>
<li>配置config副本集</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line"></span><br><span class="line">&gt; config = &#123; _<span class="keyword">id</span>:<span class="string">"config"</span>,members:[ &#123;_<span class="keyword">id</span>:<span class="number">0</span>,host:<span class="string">"conf1:30000"</span>&#125;, &#123;_<span class="keyword">id</span>:<span class="number">1</span>,host:<span class="string">"conf2:30001"</span>&#125;, &#123;_<span class="keyword">id</span>:<span class="number">2</span>,host:<span class="string">"conf3:30002"</span>&#125;] &#125;        #定义副本集</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : <span class="string">"config"</span>,</span><br><span class="line">    <span class="string">"members"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_id"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"host"</span> : <span class="string">"conf1:30000"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_id"</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">"host"</span> : <span class="string">"conf2:30001"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_id"</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">"host"</span> : <span class="string">"conf3:30002"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.initiate(config)     #初始化副本集</span><br><span class="line">&#123; <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置mongos"><a href="#配置mongos" class="headerlink" title="配置mongos"></a>配置mongos</h5><ul>
<li>添加配置mongos配置文件<br> 遇到坑了，在启动mongos的时候启动失败，结果是mongodb3.0以后的版本<code>config server</code>必须是复制集才行，结果我的版本是3.4最新的版本，所以说还需要添加两台<code>confi server</code></li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root@My-Dev db4]<span class="comment"># vim  mongos.conf </span></span><br><span class="line"></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>4/log/db4.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>4/db4.pid</span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">40004</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">configdb=mongos/<span class="number">172.17</span>.<span class="number">237.33</span><span class="symbol">:</span><span class="number">30000</span>,<span class="number">172.17</span>.<span class="number">237.34</span><span class="symbol">:</span><span class="number">30001</span>,<span class="number">172.17</span>.<span class="number">237.36</span><span class="symbol">:</span><span class="number">30002</span>   <span class="comment">#如果有多个mongo confi的话就用逗号分隔开</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动mongos</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongos -f /home/mongodb/test/db4/mongos.conf </span></span><br><span class="line">about to fork child process, waiting until server <span class="keyword">is</span> ready <span class="keyword">for</span> connections.</span><br><span class="line">forked process: <span class="number">6268</span></span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure>

<h5 id="shard2副本集集群部署"><a href="#shard2副本集集群部署" class="headerlink" title="shard2副本集集群部署"></a>shard2副本集集群部署</h5><ul>
<li>配置sha配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root@My-Dev db8]<span class="comment"># more shard21.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>8/log/db8.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>8/db8.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">60000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>8/data </span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=sha</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@My-Dev db9]<span class="comment"># more shard22.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>9/log/db9.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>9/db9.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">60001</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>9/data </span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=sha</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@My-Dev db1<span class="number">0</span>]<span class="comment"># more shard23.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>1<span class="number">0</span>/log/db1<span class="number">0</span>.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>1<span class="number">0</span>/db1<span class="number">0</span>.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">60002</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>1<span class="number">0</span>/data </span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=sha</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动shard</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db8/shard21.conf </span></span><br><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db9/shard22.conf </span></span><br><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db10/shard23.conf</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置shard2副本集集群</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&gt; use admin </span><br><span class="line">switched to db admin</span><br><span class="line">&gt; sha = &#123; _<span class="keyword">id</span>:<span class="string">"sha"</span>,members:[ &#123;_<span class="keyword">id</span>:<span class="number">0</span>,host:<span class="string">"sha1:60000"</span>&#125;, &#123;_<span class="keyword">id</span>:<span class="number">1</span>,host:<span class="string">"sha2:60001"</span>&#125;, &#123;_<span class="keyword">id</span>:<span class="number">2</span>,host:<span class="string">"sha3:60002"</span>&#125;]&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : <span class="string">"sha"</span>,</span><br><span class="line">    <span class="string">"members"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_id"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"host"</span> : <span class="string">"sha1:60000"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_id"</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">"host"</span> : <span class="string">"sha2:60001"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_id"</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">"host"</span> : <span class="string">"sha3:60002"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.initiate(sha)</span><br><span class="line">&#123; <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="shard1副本集集群部署"><a href="#shard1副本集集群部署" class="headerlink" title="shard1副本集集群部署"></a>shard1副本集集群部署</h5><ul>
<li>配置shard配置文件</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[root@My-Dev db5]<span class="comment"># vim shard1.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>5/log/db5.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>5/db5.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">50000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>5/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=shard</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@My-Dev db6]<span class="comment"># vim shard2.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>6/log/db6.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>6/db6.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">50001</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>6/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=shard</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@My-Dev db7]<span class="comment"># vim shard3.conf </span></span><br><span class="line">logpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>7/log/db7.log</span><br><span class="line">pidfilepath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>7/db7.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">port=<span class="number">50002</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">dbpath=<span class="regexp">/home/mongodb</span><span class="regexp">/test/db</span>7/data</span><br><span class="line">oplogSize=<span class="number">512</span></span><br><span class="line">replSet=shard</span><br><span class="line">shardsvr=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动shard</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db7/shard1.conf </span></span><br><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db7/shard2.conf </span></span><br><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongod -f /home/mongodb/test/db7/shard3.conf</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置shard2副本集集群</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; shard = &#123; _<span class="keyword">id</span>:<span class="string">"shard"</span>,members:[ &#123;_<span class="keyword">id</span>:<span class="number">0</span>,host:<span class="string">"shard1:50000"</span>&#125;, &#123;_<span class="keyword">id</span>:<span class="number">1</span>,host:<span class="string">"shard2:50001"</span>&#125;, &#123;_<span class="keyword">id</span>:<span class="number">2</span>,host:<span class="string">"shard3:50002"</span>&#125;] &#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"_id"</span> : <span class="string">"shard"</span>,</span><br><span class="line">    <span class="string">"members"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_id"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"host"</span> : <span class="string">"shard1:50000"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_id"</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">"host"</span> : <span class="string">"shard2:50001"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"_id"</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">"host"</span> : <span class="string">"shard3:50002"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&gt; rs.initiate(shard)</span><br><span class="line">&#123; <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="分片配置"><a href="#分片配置" class="headerlink" title="分片配置"></a>分片配置</h5><ul>
<li>分片集合中是否有数据<br> 默认第一个添加的shard就是主shard，存放没有被分割的shard就是主shard<br> 在创建分片的时，必须在索引中创建的，如果这个集合中有数据，则首先自己先创建索引，然后进行分片，如果是分片集合中没有数据的话，则就不需要创建索引，就可以分片</li>
<li>登陆mongos配置分片，向分区集群中添加shard服务器和副本集</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@My-Dev bin</span>]<span class="meta"># ./mongo mongos:40004    #登陆到mongos中</span></span><br><span class="line"></span><br><span class="line">mongos&gt; sh.status()  <span class="meta">#查看分片状态</span></span><br><span class="line">--- Sharding Status --- </span><br><span class="line">  sharding version: &#123;</span><br><span class="line">    <span class="string">"_id"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">"minCompatibleVersion"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">"currentVersion"</span> : <span class="number">6</span>,</span><br><span class="line">    <span class="string">"clusterId"</span> : ObjectId(<span class="string">"589b0cff36b0915841e2a0a2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">  active mongoses:</span><br><span class="line">    <span class="string">"3.4.1"</span> : <span class="number">1</span></span><br><span class="line"> autosplit:</span><br><span class="line">    Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">    Currently enabled:  yes</span><br><span class="line">    Currently running:  no</span><br><span class="line">        Balancer <span class="keyword">lock</span> taken at Wed Feb <span class="number">08</span> <span class="number">2017</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">16</span> GMT+<span class="number">0800</span> (CST) <span class="keyword">by</span> ConfigServer:Balancer</span><br><span class="line">    Failed balancer rounds <span class="keyword">in</span> last <span class="number">5</span> attempts:  <span class="number">0</span></span><br><span class="line">    Migration Results <span class="keyword">for</span> the last <span class="number">24</span> hours: </span><br><span class="line">        No recent migrations</span><br><span class="line">  databases:</span><br></pre></td></tr></table></figure>

<ul>
<li>添加shard副本集</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#首先要登陆到shard副本集中查看那个是主节点，本次实验室使用了两个shard副本集 sh.addShard("&lt;replSetName&gt;/主节点IP/port") </span></span><br><span class="line">mongos&gt; sh.addShard(<span class="string">"shard/shard1:50000"</span>)  </span><br><span class="line">&#123; <span class="string">"shardAdded"</span> : <span class="string">"shard"</span>, <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">mongos&gt; sh.addShard(<span class="string">"sha/sha:60000"</span>)</span><br><span class="line">&#123; <span class="string">"shardAdded"</span> : <span class="string">"shard"</span>, <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">mongos&gt; sh.status()  <span class="meta">#查看分片集群已经成功把shard加入分片中</span></span><br><span class="line">--- Sharding Status --- </span><br><span class="line">  sharding version: &#123;</span><br><span class="line">    <span class="string">"_id"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">"minCompatibleVersion"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">"currentVersion"</span> : <span class="number">6</span>,</span><br><span class="line">    <span class="string">"clusterId"</span> : ObjectId(<span class="string">"589b0cff36b0915841e2a0a2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">    &#123;  <span class="string">"_id"</span> : <span class="string">"sha"</span>,  <span class="string">"host"</span> : <span class="string">"sha/sha1:60000,sha2:60001,sha3:60002"</span>,  <span class="string">"state"</span> : <span class="number">1</span> &#125;</span><br><span class="line">    &#123;  <span class="string">"_id"</span> : <span class="string">"shard"</span>,  <span class="string">"host"</span> : <span class="string">"shard/shard1:50000,shard2:50001,shard3:50002"</span>,  <span class="string">"state"</span> : <span class="number">1</span> &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">    <span class="string">"3.4.1"</span> : <span class="number">1</span></span><br><span class="line"> autosplit:</span><br><span class="line">    Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">    Currently enabled:  yes</span><br><span class="line">    Currently running:  no</span><br><span class="line">        Balancer <span class="keyword">lock</span> taken at Wed Feb <span class="number">08</span> <span class="number">2017</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">16</span> GMT+<span class="number">0800</span> (CST) <span class="keyword">by</span> ConfigServer:Balancer</span><br><span class="line">    Failed balancer rounds <span class="keyword">in</span> last <span class="number">5</span> attempts:  <span class="number">5</span></span><br><span class="line">    Last reported error:  Cannot accept sharding commands <span class="keyword">if</span> not started with --shardsvr</span><br><span class="line">    Time of Reported error:  Thu Feb <span class="number">09</span> <span class="number">2017</span> <span class="number">17</span>:<span class="number">42</span>:<span class="number">21</span> GMT+<span class="number">0800</span> (CST)</span><br><span class="line">    Migration Results <span class="keyword">for</span> the last <span class="number">24</span> hours: </span><br><span class="line">        No recent migrations</span><br><span class="line">  databa</span><br></pre></td></tr></table></figure>

<ul>
<li>指定那个数据库使用分片，创建片键</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos&gt; sh.enableSharding(<span class="string">"zhao"</span>)  <span class="comment">#指定zhao数据库中使用分片</span></span><br><span class="line">&#123; <span class="string">"ok"</span> : 1 &#125;</span><br><span class="line"></span><br><span class="line">mongos&gt; sh.shardCollection(<span class="string">"zhao.call"</span>,&#123;name:1,age:1&#125;)   <span class="comment">#在zhao数据库和call集合中创建了name和age为升序的片键</span></span><br><span class="line">&#123; <span class="string">"collectionsharded"</span> : <span class="string">"zhao.call"</span>, <span class="string">"ok"</span> : 1 &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看<code>sh.status()</code>信息</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">mongos&gt; sh.status()</span><br><span class="line">--- Sharding Status --- </span><br><span class="line">  sharding version: &#123;</span><br><span class="line">    &quot;_id&quot; : 1,</span><br><span class="line">    &quot;minCompatibleVersion&quot; : 5,</span><br><span class="line">    &quot;currentVersion&quot; : 6,</span><br><span class="line">    &quot;clusterId&quot; : ObjectId(&quot;589b0cff36b0915841e2a0a2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">    &#123;  &quot;_id&quot; : &quot;sha&quot;,  &quot;host&quot; : &quot;sha&#x2F;sha1:60000,sha2:60001,sha3:60002&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">    &#123;  &quot;_id&quot; : &quot;shard&quot;,  &quot;host&quot; : &quot;shard&#x2F;shard1:50000,shard2:50001,shard3:50002&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">    &quot;3.4.1&quot; : 1</span><br><span class="line"> autosplit:</span><br><span class="line">    Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">    Currently enabled:  yes</span><br><span class="line">    Currently running:  no</span><br><span class="line">        Balancer lock taken at Wed Feb 08 2017 20:20:16 GMT+0800 (CST) by ConfigServer:Balancer</span><br><span class="line">    Failed balancer rounds in last 5 attempts:  5</span><br><span class="line">    Last reported error:  Cannot accept sharding commands if not started with --shardsvr</span><br><span class="line">    Time of Reported error:  Thu Feb 09 2017 17:56:02 GMT+0800 (CST)</span><br><span class="line">    Migration Results for the last 24 hours: </span><br><span class="line">        No recent migrations</span><br><span class="line">  databases:</span><br><span class="line">    &#123;  &quot;_id&quot; : &quot;zhao&quot;,  &quot;primary&quot; : &quot;shard&quot;,  &quot;partitioned&quot; : true &#125;</span><br><span class="line">        zhao.call</span><br><span class="line">            shard key: &#123; &quot;name&quot; : 1, &quot;age&quot; : 1 &#125;</span><br><span class="line">            unique: false</span><br><span class="line">            balancing: true</span><br><span class="line">            chunks:</span><br><span class="line">                shard    1</span><br><span class="line">            &#123; &quot;name&quot; : &#123; &quot;$minKey&quot; : 1 &#125;, &quot;age&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;name&quot; : &#123; &quot;$maxKey&quot; : 1 &#125;, &quot;age&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard Timestamp(1, 0)</span><br></pre></td></tr></table></figure>

<ul>
<li>测试批量插入数据验证</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">mongos&gt; <span class="keyword">for</span> ( var i=<span class="number">1</span>;i&lt;<span class="number">10000000</span>;i++)&#123;db.call.insert(&#123;<span class="string">"name"</span><span class="symbol">:<span class="string">"user"</span>+i</span>,<span class="symbol">age:</span>i&#125;)&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前是否已经分片到两个shard中去了</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">mongos&gt; sh.status()</span><br><span class="line">--- Sharding Status --- </span><br><span class="line">  sharding version: &#123;</span><br><span class="line">    <span class="string">"_id"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">"minCompatibleVersion"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">"currentVersion"</span> : <span class="number">6</span>,</span><br><span class="line">    <span class="string">"clusterId"</span> : ObjectId(<span class="string">"589b0cff36b0915841e2a0a2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">    &#123;  <span class="string">"_id"</span> : <span class="string">"sha"</span>,  <span class="string">"host"</span> : <span class="string">"sha/sha1:60000,sha2:60001,sha3:60002"</span>,  <span class="string">"state"</span> : <span class="number">1</span> &#125;</span><br><span class="line">    &#123;  <span class="string">"_id"</span> : <span class="string">"shard"</span>,  <span class="string">"host"</span> : <span class="string">"shard/shard1:50000,shard2:50001,shard3:50002"</span>,  <span class="string">"state"</span> : <span class="number">1</span> &#125;</span><br><span class="line">  active mongoses:</span><br><span class="line">    <span class="string">"3.4.1"</span> : <span class="number">1</span></span><br><span class="line"> autosplit:</span><br><span class="line">    Currently enabled: yes</span><br><span class="line">  balancer:</span><br><span class="line">    Currently enabled:  yes</span><br><span class="line">    Currently running:  no</span><br><span class="line">        Balancer <span class="keyword">lock</span> taken at Wed Feb <span class="number">08</span> <span class="number">2017</span> <span class="number">20</span>:<span class="number">20</span>:<span class="number">16</span> GMT+<span class="number">0800</span> (CST) <span class="keyword">by</span> ConfigServer:Balancer</span><br><span class="line">    Failed balancer rounds <span class="keyword">in</span> last <span class="number">5</span> attempts:  <span class="number">5</span></span><br><span class="line">    Last reported error:  Cannot accept sharding commands <span class="keyword">if</span> not started with --shardsvr</span><br><span class="line">    Time of Reported error:  Thu Feb <span class="number">09</span> <span class="number">2017</span> <span class="number">17</span>:<span class="number">56</span>:<span class="number">02</span> GMT+<span class="number">0800</span> (CST)</span><br><span class="line">    Migration Results <span class="keyword">for</span> the last <span class="number">24</span> hours: </span><br><span class="line">        <span class="number">4</span> : Success</span><br><span class="line">  databases:</span><br><span class="line">    &#123;  <span class="string">"_id"</span> : <span class="string">"zhao"</span>,  <span class="string">"primary"</span> : <span class="string">"shard"</span>,  <span class="string">"partitioned"</span> : <span class="literal">true</span> &#125;</span><br><span class="line">        zhao.call</span><br><span class="line">            shard key: &#123; <span class="string">"name"</span> : <span class="number">1</span>, <span class="string">"age"</span> : <span class="number">1</span> &#125;</span><br><span class="line">            unique: <span class="literal">false</span></span><br><span class="line">            balancing: <span class="literal">true</span></span><br><span class="line">            chunks:   <span class="meta">#数据已经分片到两个chunks里面了</span></span><br><span class="line">                sha    <span class="number">4</span></span><br><span class="line">                shard    <span class="number">5</span></span><br><span class="line">            &#123; <span class="string">"name"</span> : &#123; <span class="string">"$minKey"</span> : <span class="number">1</span> &#125;, <span class="string">"age"</span> : &#123; <span class="string">"$minKey"</span> : <span class="number">1</span> &#125; &#125; --&gt;&gt; &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">1</span> &#125; <span class="keyword">on</span> : <span class="function">sha <span class="title">Timestamp</span>(<span class="params"><span class="number">4</span>, <span class="number">1</span></span>) </span></span><br><span class="line"><span class="function"></span>            &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">1</span> &#125; --&gt;&gt; &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">21</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">5</span>, <span class="number">1</span></span>) </span></span><br><span class="line"><span class="function"></span>            &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">21</span> &#125; --&gt;&gt; &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">164503</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">2</span>, <span class="number">2</span></span>) </span></span><br><span class="line"><span class="function"></span>            &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">164503</span> &#125; --&gt;&gt; &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">355309</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">2</span>, <span class="number">3</span></span>) </span></span><br><span class="line"><span class="function"></span>            &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">355309</span> &#125; --&gt;&gt; &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">523081</span> &#125; <span class="keyword">on</span> : <span class="function">sha <span class="title">Timestamp</span>(<span class="params"><span class="number">3</span>, <span class="number">2</span></span>) </span></span><br><span class="line"><span class="function"></span>            &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">523081</span> &#125; --&gt;&gt; &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">710594</span> &#125; <span class="keyword">on</span> : <span class="function">sha <span class="title">Timestamp</span>(<span class="params"><span class="number">3</span>, <span class="number">3</span></span>) </span></span><br><span class="line"><span class="function"></span>            &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">710594</span> &#125; --&gt;&gt; &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">875076</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">4</span>, <span class="number">2</span></span>) </span></span><br><span class="line"><span class="function"></span>            &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">875076</span> &#125; --&gt;&gt; &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">1056645</span> &#125; <span class="keyword">on</span> : <span class="function">shard <span class="title">Timestamp</span>(<span class="params"><span class="number">4</span>, <span class="number">3</span></span>) </span></span><br><span class="line"><span class="function"></span>            &#123; <span class="string">"name"</span> : <span class="string">"user1"</span>, <span class="string">"age"</span> : <span class="number">1056645</span> &#125; --&gt;&gt; &#123; <span class="string">"name"</span> : &#123; <span class="string">"$maxKey"</span> : <span class="number">1</span> &#125;, <span class="string">"age"</span> : &#123; <span class="string">"$maxKey"</span> : <span class="number">1</span> &#125; &#125; <span class="keyword">on</span> : <span class="function">sha <span class="title">Timestamp</span>(<span class="params"><span class="number">5</span>, <span class="number">0</span></span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前分片中是否均匀的分配到连个shard当中,<code>true</code>是均匀的<br> ，<code>false</code>不是均匀的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos&gt; sh.getBalancerState()</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="选择sharing-kes注意点"><a href="#选择sharing-kes注意点" class="headerlink" title="选择sharing kes注意点"></a>选择sharing kes注意点</h5><ul>
<li>考虑应该在哪里储存数据？</li>
<li>应该在哪里读取数据？</li>
<li>sharding key 应该是主键</li>
<li>sharding key 应该你能尽量保证避免分片查询</li>
</ul>
<h4 id="sharing-进级"><a href="#sharing-进级" class="headerlink" title="sharing 进级"></a>sharing 进级</h4><ul>
<li>如果sharing 分片不均匀没有分片均匀</li>
<li>sharding ： 新增<code>shard</code>和移除<code>shard</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos&gt; sh.addShard(<span class="string">"sha4/192.168.2.10:21001"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="Balancer"><a href="#Balancer" class="headerlink" title="Balancer"></a>Balancer</h5><ul>
<li>开启Balncer<br> 开启Balancer之后，chunks之后会自动均分</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mongos</span>&gt; <span class="selector-tag">sh</span><span class="selector-class">.startBalancer</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li>设置Balancer进程运行时间窗口<br> 默认情况ixaBalancing进程在运行时为降低Balancing进程对系统的影响，可以设置Balancer进程的运行时间窗口，让Balancer进程在指定时间窗口操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置时间窗口</span></span><br><span class="line">db.settings.update(&#123; _id : <span class="string">"balancer"</span> &#125;, &#123; <span class="variable">$set</span> : &#123; activeWindow : &#123; start : <span class="string">"23:00"</span>, stop : <span class="string">"6:00"</span> &#125; &#125; &#125;, <span class="literal">true</span> )</span><br></pre></td></tr></table></figure>

<ul>
<li>查看Balancer运行时间窗口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看Balancer时间窗口</span></span><br><span class="line">mongos&gt; db.settings.find();</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"balancer"</span>, <span class="string">"activeWindow"</span> : &#123; <span class="string">"start"</span> : <span class="string">"23:00"</span>, <span class="string">"stop"</span> : <span class="string">"6:00"</span> &#125;, <span class="string">"stopped"</span> : <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">mongos&gt; sh.getBalancerWindow()</span><br><span class="line">&#123; <span class="string">"start"</span> : <span class="string">"23:00"</span>, <span class="string">"stop"</span> : <span class="string">"6:00"</span> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除Balancer进程运行时间窗口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> mongos&gt; db.settings.update(&#123; <span class="string">"_id"</span> : <span class="string">"balancer"</span> &#125;, &#123; <span class="variable">$unset</span> : &#123; activeWindow : 1 &#125;&#125;);</span><br><span class="line">mongos&gt; db.settings.find();</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"chunksize"</span>, <span class="string">"value"</span> : 10 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="string">"balancer"</span>, <span class="string">"stopped"</span> : <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="在shell脚本中执行mongodb"><a href="#在shell脚本中执行mongodb" class="headerlink" title="在shell脚本中执行mongodb"></a>在shell脚本中执行mongodb</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@My-Dev ~]<span class="meta"># echo  -e <span class="meta-string">"use zhao \n  db.call.find()"</span> |mongo --port 60001</span></span><br></pre></td></tr></table></figure>

<h5 id="Mongodb片键的添加"><a href="#Mongodb片键的添加" class="headerlink" title="Mongodb片键的添加"></a>Mongodb片键的添加</h5><ul>
<li>首先进入mongos的的admin数据库中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos&gt; use admin</span><br><span class="line">switched to db admin  </span><br><span class="line">mongos&gt; db.runCommand(&#123;<span class="string">"enablesharding"</span>:<span class="string">"zl"</span>&#125;)   <span class="comment">#创建zl库中</span></span><br><span class="line">&#123; <span class="string">"ok"</span> : 1 &#125;</span><br><span class="line">mongos&gt; db.runCommand(db.runCommand(&#123;<span class="string">"shardcollection"</span>:<span class="string">"<span class="variable">$ent</span>.t_srvappraise_back"</span>,<span class="string">"key"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>分片脚本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">url=10.241.96.155</span><br><span class="line">port=30000</span><br><span class="line">ent=test1</span><br><span class="line"></span><br><span class="line">./mongo <span class="variable">$url</span>:<span class="variable">$port</span>/admin &lt;&lt;EOF</span><br><span class="line">db.runCommand(&#123;<span class="string">"enablesharding"</span>:<span class="string">"<span class="variable">$ent</span>"</span>&#125;);</span><br><span class="line">db.runCommand(&#123;<span class="string">"shardcollection"</span>:<span class="string">"<span class="variable">$ent</span>.t_srvappraise_back"</span>,<span class="string">"key"</span>:&#123;<span class="string">"sa_seid"</span>:<span class="string">"hashed"</span>&#125;&#125;)</span><br><span class="line"><span class="built_in">exit</span>;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.jianshu.com/p/cb55bb333e2d" target="_blank" rel="noopener">https://www.jianshu.com/p/cb55bb333e2d</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Mongodb</category>
      </categories>
      <tags>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis为什么要使用跳跃表</title>
    <url>/2020/03/22/2020/03/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p>
<p>以下是个典型的跳跃表例子</p>
<p><img src="http://static.cyblogs.com/skiplist.png" alt="http://static.cyblogs.com/skiplist.png"></p>
<p>从图中可以看到， 跳跃表主要由以下部分构成：</p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针。</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 <code>NULL</code> 组成，表示跳跃表的末尾。</li>
</ul>
<p>因为跳跃表的定义可以在任何一本算法或数据结构的书中找到， 所以本章不介绍跳跃表的具体实现方式或者具体的算法， 而只介绍跳跃表在 Redis 的应用、核心数据结构和 API 。</p>
<h4 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h4><p>为了满足自身的功能需要， Redis 基于 William Pugh 论文中描述的跳跃表进行了以下修改：</p>
<ol>
<li>允许重复的 <code>score</code> 值：多个不同的 <code>member</code> 的 <code>score</code> 值可以相同。</li>
<li>进行对比操作时，不仅要检查 <code>score</code> 值，还要检查 <code>member</code> ：当 <code>score</code> 值可以重复时，单靠 <code>score</code> 值无法判断一个元素的身份，所以需要连 <code>member</code> 域都一并检查才行。</li>
<li>每个节点都带有一个高度为 1 层的后退指针，用于从表尾方向向表头方向迭代：当执行 <a href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrange.html#zrevrange" target="_blank" rel="noopener">ZREVRANGE</a> 或 <a href="http://redis.readthedocs.org/en/latest/sorted_set/zrevrangebyscore.html#zrevrangebyscore" target="_blank" rel="noopener">ZREVRANGEBYSCORE</a> 这类以逆序处理有序集的命令时，就会用到这个属性。</li>
</ol>
<p>这个修改版的跳跃表由 <code>redis.h/zskiplist</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>跳跃表的节点由 <code>redis.h/zskiplistNode</code> 定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>以下是操作这两个数据结构的 API ，API 的用途与相应的算法复杂度：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
<th align="left">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zslCreateNode</code></td>
<td align="left">创建并返回一个新的跳跃表节点</td>
<td align="left">最坏 O(1)O(1)</td>
</tr>
<tr>
<td align="left"><code>zslFreeNode</code></td>
<td align="left">释放给定的跳跃表节点</td>
<td align="left">最坏 O(1)O(1)</td>
</tr>
<tr>
<td align="left"><code>zslCreate</code></td>
<td align="left">创建并初始化一个新的跳跃表</td>
<td align="left">最坏 O(1)O(1)</td>
</tr>
<tr>
<td align="left"><code>zslFree</code></td>
<td align="left">释放给定的跳跃表</td>
<td align="left">最坏 O(N)O(N)</td>
</tr>
<tr>
<td align="left"><code>zslInsert</code></td>
<td align="left">将一个包含给定 <code>score</code> 和 <code>member</code> 的新节点添加到跳跃表中</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslDeleteNode</code></td>
<td align="left">删除给定的跳跃表节点</td>
<td align="left">最坏 O(N)O(N)</td>
</tr>
<tr>
<td align="left"><code>zslDelete</code></td>
<td align="left">删除匹配给定 <code>member</code> 和 <code>score</code> 的元素</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslFirstInRange</code></td>
<td align="left">找到跳跃表中第一个符合给定范围的元素</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslLastInRange</code></td>
<td align="left">找到跳跃表中最后一个符合给定范围的元素</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslDeleteRangeByScore</code></td>
<td align="left">删除 <code>score</code> 值在给定范围内的所有节点</td>
<td align="left">最坏 O(N2)O(N2)</td>
</tr>
<tr>
<td align="left"><code>zslDeleteRangeByRank</code></td>
<td align="left">删除给定排序范围内的所有节点</td>
<td align="left">最坏 O(N2)O(N2)</td>
</tr>
<tr>
<td align="left"><code>zslGetRank</code></td>
<td align="left">返回目标元素在有序集中的排位</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
<tr>
<td align="left"><code>zslGetElementByRank</code></td>
<td align="left">根据给定排位，返回该排位上的元素节点</td>
<td align="left">最坏 O(N)O(N) 平均 O(logN)O(log⁡N)</td>
</tr>
</tbody></table>
<h4 id="跳跃表的应用"><a href="#跳跃表的应用" class="headerlink" title="跳跃表的应用"></a>跳跃表的应用</h4><p>和字典、链表或者字符串这几种在 Redis 中大量使用的数据结构不同， 跳跃表在 Redis 的唯一作用， 就是实现有序集数据类型。</p>
<p>跳跃表将指向有序集的 <code>score</code> 值和 <code>member</code> 域的指针作为元素， 并以 <code>score</code> 值为索引， 对有序集元素进行排序。</p>
<p>举个例子， 以下代码创建了一个带有 3 个元素的有序集：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD s 6 x 10 y 15 z</span></span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZRANGE s 0 -1 WITHSCORES</span></span><br><span class="line">1) "x"</span><br><span class="line">2) "6"</span><br><span class="line">3) "y"</span><br><span class="line">4) "10"</span><br><span class="line">5) "z"</span><br><span class="line">6) "15"</span><br></pre></td></tr></table></figure>

<p>在底层实现中， Redis 为 <code>x</code> 、 <code>y</code> 和 <code>z</code> 三个 <code>member</code> 分别创建了三个字符串， 值分别为 <code>double</code> 类型的 <code>6</code> 、 <code>10</code> 和 <code>15</code> ， 然后用跳跃表将这些指针有序地保存起来， 形成这样一个跳跃表：</p>
<p><img src="http://static.cyblogs.com/QQ20200329-225534@2x.jpg" alt="http://static.cyblogs.com/QQ20200329-225534@2x.jpg"></p>
<p>为了方便展示， 在图片中我们直接将 <code>member</code> 和 <code>score</code> 值包含在表节点中， 但是在实际的定义中， 因为跳跃表要和另一个实现有序集的结构（字典）分享 <code>member</code> 和 <code>score</code> 值， 所以跳跃表只保存指向 <code>member</code> 和 <code>score</code> 的指针。 更详细的信息，请参考《<a href="https://redisbook.readthedocs.io/en/latest/datatype/sorted_set.html#sorted-set-chapter" target="_blank" rel="noopener">有序集</a>》章节。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>❑跳跃表是有序集合的底层实现之一。</p>
<p>❑Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</p>
<p>❑每个跳跃表节点的层高都是1至32之间的随机数。</p>
<p>❑在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</p>
<p>❑跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html" target="_blank" rel="noopener">https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html</a></li>
<li>书籍：《Redis设计与实现》</li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务的设计与实现</title>
    <url>/2020/03/21/2020/03/Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Redis 通过 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 和 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 四个命令来实现事务功能， 本章首先讨论使用 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 和 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 三个命令实现的一般事务， 然后再来讨论带有 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 的事务的实现。</p>
<p>因为事务的安全性也非常重要， 所以本章最后通过常见的 ACID 性质对 Redis 事务的安全性进行了说明。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。</p>
<p>以下是一个事务的例子， 它先以 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令触发事务， 一并执行事务中的所有命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> MULTI</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET book-name <span class="string">"Mastering C++ in 21 days"</span></span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET book-name</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD tag <span class="string">"C++"</span> <span class="string">"Programming"</span> <span class="string">"Mastering Series"</span></span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SMEMBERS tag</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXEC</span></span><br><span class="line">1) OK</span><br><span class="line">2) "Mastering C++ in 21 days"</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) 1) "Mastering Series"</span><br><span class="line">   2) "C++"</span><br><span class="line">   3) "Programming"</span><br></pre></td></tr></table></figure>

<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ol>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ol>
<p>下文将分别介绍事务的这三个阶段。</p>
<h4 id="开始事务"><a href="#开始事务" class="headerlink" title="开始事务"></a>开始事务</h4><p><a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 命令的执行标记着事务的开始：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> MULTI</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>这个命令唯一做的就是， 将客户端的 <code>REDIS_MULTI</code> 选项打开， 让客户端从非事务状态切换到事务状态。</p>
<p><img src="http://static.cyblogs.com/QQ20200308-222741@2x.jpg" alt="http://static.cyblogs.com/QQ20200308-222741@2x.jpg"></p>
<h4 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello moto"</span></span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET msg</span></span><br><span class="line">"hello moto"</span><br></pre></td></tr></table></figure>

<p>但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 <code>QUEUED</code> ， 表示命令已入队：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> MULTI</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello moto"</span></span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET msg</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>

<p>以下流程图展示了这一行为：</p>
<p><img src="http://static.cyblogs.com/Redis%E4%BA%8B%E7%89%A9%E9%98%9F%E5%88%97.jpg" alt="http://static.cyblogs.com/Redis事物队列.jpg"></p>
<p>事务队列是一个数组， 每个数组项是都包含三个属性：</p>
<ol>
<li>要执行的命令（cmd）。</li>
<li>命令的参数（argv）。</li>
<li>参数的个数（argc）。</li>
</ol>
<p>举个例子， 如果客户端执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> MULTI</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET book-name <span class="string">"Mastering C++ in 21 days"</span></span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET book-name</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD tag <span class="string">"C++"</span> <span class="string">"Programming"</span> <span class="string">"Mastering Series"</span></span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SMEMBERS tag</span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure>

<p>那么程序将为客户端创建以下事务队列：</p>
<table>
<thead>
<tr>
<th align="left">数组索引</th>
<th align="left">cmd</th>
<th align="left">argv</th>
<th align="left">argc</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code></td>
<td align="left"><code>SET</code></td>
<td align="left"><code>[&quot;book-name&quot;, &quot;Mastering C++ in 21 days&quot;]</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left"><code>GET</code></td>
<td align="left"><code>[&quot;book-name&quot;]</code></td>
<td align="left"><code>1</code></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>SADD</code></td>
<td align="left"><code>[&quot;tag&quot;, &quot;C++&quot;, &quot;Programming&quot;, &quot;Mastering Series&quot;]</code></td>
<td align="left"><code>4</code></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>SMEMBERS</code></td>
<td align="left"><code>[&quot;tag&quot;]</code></td>
<td align="left"><code>1</code></td>
</tr>
</tbody></table>
<h4 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h4><p>前面说到， 当客户端进入事务状态之后， 客户端发送的命令就会被放进事务队列里。</p>
<p>但其实并不是所有的命令都会被放进事务队列， 其中的例外就是 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 和 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-225830@2x.jpg" alt="http://static.cyblogs.com/QQ20200308-225830@2x.jpg"></p>
<p>如果客户端正处于事务状态， 那么当 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令执行时， 服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p>
<p>比如说，对于以下事务队列：</p>
<table>
<thead>
<tr>
<th align="left">数组索引</th>
<th align="left">cmd</th>
<th align="left">argv</th>
<th align="left">argc</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code></td>
<td align="left"><code>SET</code></td>
<td align="left"><code>[&quot;book-name&quot;, &quot;Mastering C++ in 21 days&quot;]</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left"><code>GET</code></td>
<td align="left"><code>[&quot;book-name&quot;]</code></td>
<td align="left"><code>1</code></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left"><code>SADD</code></td>
<td align="left"><code>[&quot;tag&quot;, &quot;C++&quot;, &quot;Programming&quot;, &quot;Mastering Series&quot;]</code></td>
<td align="left"><code>4</code></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left"><code>SMEMBERS</code></td>
<td align="left"><code>[&quot;tag&quot;]</code></td>
<td align="left"><code>1</code></td>
</tr>
</tbody></table>
<p>程序会首先执行 <a href="http://redis.readthedocs.org/en/latest/string/set.html#set" target="_blank" rel="noopener">SET</a> 命令， 然后执行 <a href="http://redis.readthedocs.org/en/latest/string/get.html#get" target="_blank" rel="noopener">GET</a> 命令， 再然后执行 <a href="http://redis.readthedocs.org/en/latest/set/sadd.html#sadd" target="_blank" rel="noopener">SADD</a> 命令， 最后执行 <a href="http://redis.readthedocs.org/en/latest/set/smembers.html#smembers" target="_blank" rel="noopener">SMEMBERS</a> 命令。</p>
<p>执行事务中的命令所得的结果会以 FIFO 的顺序保存到一个回复队列中。</p>
<p>比如说，对于上面给出的事务队列，程序将为队列中的命令创建如下回复队列：</p>
<table>
<thead>
<tr>
<th align="left">数组索引</th>
<th align="left">回复类型</th>
<th align="left">回复内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code></td>
<td align="left">status code reply</td>
<td align="left"><code>OK</code></td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left">bulk reply</td>
<td align="left"><code>&quot;Mastering C++ in 21 days&quot;</code></td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left">integer reply</td>
<td align="left"><code>3</code></td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left">multi-bulk reply</td>
<td align="left"><code>[&quot;Mastering Series&quot;, &quot;C++&quot;, &quot;Programming&quot;]</code></td>
</tr>
</tbody></table>
<p>当事务队列里的所有命令被执行完之后， <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令会将回复队列作为自己的执行结果返回给客户端， 客户端从事务状态返回到非事务状态， 至此， 事务执行完毕。</p>
<p>事务的整个执行过程可以用以下伪代码表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute_transaction</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建空白的回复队列</span></span><br><span class="line">    reply_queue = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出事务队列里的所有命令、参数和参数数量</span></span><br><span class="line">    <span class="keyword">for</span> cmd, argv, argc <span class="keyword">in</span> client.transaction_queue:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行命令，并取得命令的返回值</span></span><br><span class="line">        reply = execute_redis_command(cmd, argv, argc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将返回值追加到回复队列末尾</span></span><br><span class="line">        reply_queue.append(reply)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清除客户端的事务状态</span></span><br><span class="line">    clear_transaction_state(client)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清空事务队列</span></span><br><span class="line">    clear_transaction_queue(client)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将事务的执行结果返回给客户端</span></span><br><span class="line">    send_reply_to_client(client, reply_queue)</span><br></pre></td></tr></table></figure>

<h4 id="在事务和非事务状态下执行命令"><a href="#在事务和非事务状态下执行命令" class="headerlink" title="在事务和非事务状态下执行命令"></a>在事务和非事务状态下执行命令</h4><p>无论在事务状态下， 还是在非事务状态下， Redis 命令都由同一个函数执行， 所以它们共享很多服务器的一般设置， 比如 AOF 的配置、RDB 的配置，以及内存限制，等等。</p>
<p>不过事务中的命令和普通命令在执行上还是有一点区别的，其中最重要的两点是：</p>
<ol>
<li><p>非事务状态下的命令以单个命令为单位执行，前一个命令和后一个命令的客户端不一定是同一个；</p>
<p>而事务状态则是以一个事务为单位，执行事务队列中的所有命令：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。</p>
</li>
<li><p>在非事务状态下，执行命令所得的结果会立即被返回给客户端；</p>
<p>而事务则是将所有命令的结果集合到回复队列，再作为 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令的结果返回给客户端。</p>
</li>
</ol>
<h4 id="事务状态下的-DISCARD-、-MULTI-和-WATCH-命令"><a href="#事务状态下的-DISCARD-、-MULTI-和-WATCH-命令" class="headerlink" title="事务状态下的 DISCARD 、 MULTI 和 WATCH 命令"></a>事务状态下的 DISCARD 、 MULTI 和 WATCH 命令</h4><p>除了 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 <a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 、 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 和 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 。</p>
<p><a href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" target="_blank" rel="noopener">DISCARD</a> 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 <code>OK</code> 给客户端， 说明事务已被取消。</p>
<p>Redis 的事务是不可嵌套的， 当客户端已经处于事务状态， 而客户端又再向服务器发送 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</p>
<p><a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 只能在客户端进入事务状态之前执行， 在事务状态下发送 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 <a href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" target="_blank" rel="noopener">MULTI</a> 的情况一样）。</p>
<h4 id="带-WATCH-的事务"><a href="#带-WATCH-的事务" class="headerlink" title="带 WATCH 的事务"></a>带 WATCH 的事务</h4><p><a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 命令用于在事务开始之前监视任意数量的键： 当调用 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。</p>
<p>以下示例展示了一个执行失败的事务例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> WATCH name</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> MULTI</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET name peter</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> EXEC</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>以下执行序列展示了上面的例子是如何失败的：</p>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">客户端 A</th>
<th align="left">客户端 B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left"><code>WATCH name</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left"><code>MULTI</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left"><code>SET name peter</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left"><code>SET name john</code></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left"><code>EXEC</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在时间 T4 ，客户端 B 修改了 <code>name</code> 键的值， 当客户端 A 在 T5 执行 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 时，Redis 会发现 <code>name</code> 这个被监视的键已经被修改， 因此客户端 A 的事务不会被执行，而是直接返回失败。</p>
<p>下文就来介绍 <a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 的实现机制，并且看看事务系统是如何检查某个被监视的键是否被修改，从而保证事务的安全性的。</p>
<h4 id="WATCH-命令的实现"><a href="#WATCH-命令的实现" class="headerlink" title="WATCH 命令的实现"></a>WATCH 命令的实现</h4><p>在每个代表数据库的 <code>redis.h/redisDb</code> 结构类型中， 都保存了一个 <code>watched_keys</code> 字典， 字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端。</p>
<p>比如说，以下字典就展示了一个 <code>watched_keys</code> 字典的例子：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-225905@2x.jpg" alt="http://static.cyblogs.com/QQ20200308-225905@2x.jpg"></p>
<p>其中， 键 <code>key1</code> 正在被 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端监视， 其他一些键也分别被其他别的客户端监视着。</p>
<p><a href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" target="_blank" rel="noopener">WATCH</a> 命令的作用， 就是将当前客户端和要监视的键在 <code>watched_keys</code> 中进行关联。</p>
<p>举个例子， 如果当前客户端为 <code>client10086</code> ， 那么当客户端执行 <code>WATCH key1 key2</code> 时， 前面展示的 <code>watched_keys</code> 将被修改成这个样子：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-225928@2x.jpg" alt="http://static.cyblogs.com/QQ20200308-225928@2x.jpg"></p>
<p>通过 <code>watched_keys</code> 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p>
<h4 id="WATCH-的触发"><a href="#WATCH-的触发" class="headerlink" title="WATCH 的触发"></a>WATCH 的触发</h4><p>在任何对数据库键空间（key space）进行修改的命令成功执行之后 （比如 <a href="http://redis.readthedocs.org/en/latest/server/flushdb.html#flushdb" target="_blank" rel="noopener">FLUSHDB</a> 、 <a href="http://redis.readthedocs.org/en/latest/string/set.html#set" target="_blank" rel="noopener">SET</a> 、 <a href="http://redis.readthedocs.org/en/latest/key/del.html#del" target="_blank" rel="noopener">DEL</a> 、 <a href="http://redis.readthedocs.org/en/latest/list/lpush.html#lpush" target="_blank" rel="noopener">LPUSH</a> 、 <a href="http://redis.readthedocs.org/en/latest/set/sadd.html#sadd" target="_blank" rel="noopener">SADD</a> 、 <a href="http://redis.readthedocs.org/en/latest/sorted_set/zrem.html#zrem" target="_blank" rel="noopener">ZREM</a> ，诸如此类）， <code>multi.c/touchWatchedKey</code> 函数都会被调用 —— 它检查数据库的 <code>watched_keys</code> 字典， 看是否有客户端在监视已经被命令修改的键， 如果有的话， 程序将所有监视这个/这些被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-225953@2x.jpg" alt="http://static.cyblogs.com/QQ20200308-225953@2x.jpg"></p>
<p>当客户端发送 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令、触发事务执行时， 服务器会对客户端的状态进行检查：</p>
<ul>
<li>如果客户端的 <code>REDIS_DIRTY_CAS</code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li>
<li>如果 <code>REDIS_DIRTY_CAS</code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li>
</ul>
<p>可以用一段伪代码来表示这个检查：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_safety_before_execute_trasaction</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> client.state &amp; REDIS_DIRTY_CAS:</span><br><span class="line">        <span class="comment"># 安全性已破坏，清除事务状态</span></span><br><span class="line">        clear_transaction_state(client)</span><br><span class="line">        <span class="comment"># 清空事务队列</span></span><br><span class="line">        clear_transaction_queue(client)</span><br><span class="line">        <span class="comment"># 返回空回复给客户端</span></span><br><span class="line">        send_empty_reply(client)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 安全性完好，执行事务</span></span><br><span class="line">        execute_transaction()</span><br></pre></td></tr></table></figure>

<p>举个例子，假设数据库的 <code>watched_keys</code> 字典如下图所示：</p>
<p><img src="http://static.cyblogs.com/QQ20200308-230029@2x.jpg" alt="http://static.cyblogs.com/QQ20200308-230029@2x.jpg"></p>
<h4 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h4><p>在传统的关系式数据库中，常常用 <a href="http://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID 性质</a>来检验事务功能的安全性。</p>
<p>Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p>
<p>以下四小节是关于这四个性质的详细讨论。</p>
<h5 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h5><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p>
<p>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。</p>
<p>当事务失败时，Redis 也不会进行任何的重试或者回滚动作。</p>
<h5 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h5><p>Redis 的一致性问题可以分为三部分来讨论：入队错误、执行错误、Redis 进程被终结。</p>
<h6 id="入队错误"><a href="#入队错误" class="headerlink" title="入队错误"></a>入队错误</h6><p>在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等， 那么服务器将向客户端返回一个出错信息， 并且将客户端的事务状态设为 <code>REDIS_DIRTY_EXEC</code> 。</p>
<p>当客户端执行 <a href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" target="_blank" rel="noopener">EXEC</a> 命令时， Redis 会拒绝执行状态为 <code>REDIS_DIRTY_EXEC</code> 的事务， 并返回失败信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; set key</span><br><span class="line">(error) ERR wrong number of arguments for 'set' command</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXISTS key</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>

<p>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</p>
<h6 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h6><p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作， 那么 Redis 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。</p>
<h6 id="Redis-进程被终结"><a href="#Redis-进程被终结" class="headerlink" title="Redis 进程被终结"></a>Redis 进程被终结</h6><p>如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：</p>
<ul>
<li><p>内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p>
</li>
<li><p>RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</p>
</li>
<li><p>AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：</p>
<p>1）如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</p>
<p>2）如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p>
</li>
</ul>
<h5 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h5><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h5 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h5><p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：</p>
<ul>
<li><p>在单纯的内存模式下，事务肯定是不持久的。</p>
</li>
<li><p>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。</p>
</li>
<li><p>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 <code>fsync</code> 或 <code>fdatasync</code> 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</p>
<p>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</p>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li>
<li>事务在执行过程中不会被中断，所有事务命令执行完之后，事务才能结束。</li>
<li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li>
<li>带 <code>WATCH</code> 命令的事务会将客户端和被监视的键在数据库的 <code>watched_keys</code> 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开。</li>
<li>只有在客户端的 <code>REDIS_DIRTY_CAS</code> 选项未被打开时，才能执行事务，否则事务直接返回失败。</li>
<li>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="noopener">https://redisbook.readthedocs.io/en/latest/feature/transaction.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-bean的循环依赖以及解决方式</title>
    <url>/2020/03/23/2020/03/Spring-bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<blockquote>
<p>本文主要是分析Spring bean的循环依赖，以及Spring的解决方式。 通过这种解决方式，我们可以应用在我们实际开发项目中。</p>
</blockquote>
<p>什么是循环依赖？<br>怎么检测循环依赖<br>Spring怎么解决循环依赖<br>Spring对于循环依赖无法解决的场景<br>Spring解决循环依赖的方式我们能够学到什么？</p>
</blockquote>
<h4 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h4><p>循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：</p>
<p><img src="http://static.cyblogs.com/20170912082357749.jpg" alt="http://static.cyblogs.com/20170912082357749.jpg"></p>
<p>注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。</p>
<h5 id="Spring中循环依赖场景有："><a href="#Spring中循环依赖场景有：" class="headerlink" title="Spring中循环依赖场景有："></a>Spring中循环依赖场景有：</h5><p>（1）构造器的循环依赖<br>（2）field属性的循环依赖。</p>
<h4 id="怎么检测是否存在循环依赖"><a href="#怎么检测是否存在循环依赖" class="headerlink" title="怎么检测是否存在循环依赖"></a>怎么检测是否存在循环依赖</h4><p>检测循环依赖相对比较容易，Bean在创建的时候可以给该Bean打标，如果递归调用回来发现正在创建中的话，即说明了循环依赖了。</p>
<h4 id="Spring怎么解决循环依赖"><a href="#Spring怎么解决循环依赖" class="headerlink" title="Spring怎么解决循环依赖"></a>Spring怎么解决循环依赖</h4><p>Spring的循环依赖的理论依据其实是基于Java的引用传递，当我们获取到对象的引用时，对象的field或则属性是可以延后设置的(但是构造器必须是在获取引用之前)。</p>
<p>Spring的单例对象的初始化主要分为三步：</p>
<p>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象</p>
<p>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充</p>
<p>（3）initializeBean：调用spring xml中的init 方法。</p>
<p>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二部。也就是构造器循环依赖和field循环依赖。</p>
<p>那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</p>
<p>首先我们看源码，三级缓存主要指：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这三级缓存分别指：<br>singletonFactories ： 单例对象工厂的cache<br>earlySingletonObjects ：提前暴光的单例对象的Cache<br>singletonObjects：单例对象的cache</p>
<p>我们在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。主要调用方法就就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码需要解释两个参数：</p>
<p>isSingletonCurrentlyInCreation()判断当前单例bean是否正在创建中，也就是没有初始化完成(比如A的构造器依赖了B对象所以得先去创建B对象， 或则在A的populateBean过程中依赖了B对象，得先去创建B对象，这时的A就是处于创建中的状态。)<br>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象<br>分析getSingleton()的整个过程，Spring首先从一级缓存singletonObjects中获取。如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()(三级缓存)获取，如果获取到了则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</span><br></pre></td></tr></table></figure>

<p>从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</p>
<p>从上面三级缓存的分析，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口在下面被引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p>
<p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。</p>
<ul>
<li>A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</li>
</ul>
<p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/u010853261/article/details/77940767" target="_blank" rel="noopener">https://blog.csdn.net/u010853261/article/details/77940767</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵模式与分区详细分析</title>
    <url>/2020/03/20/2020/03/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%88%86%E5%8C%BA%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="一、Redis-Sentinel-哨兵"><a href="#一、Redis-Sentinel-哨兵" class="headerlink" title="一、Redis-Sentinel(哨兵)"></a>一、Redis-Sentinel(哨兵)</h3><h4 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>Redis-Sentinel是redis官方推荐的高可用性解决方案，<br>当用redis作master-slave的高可用时，如果master本身宕机，redis本身或者客户端都没有实现主从切换的功能。</p>
<p>而redis-sentinel就是一个独立运行的进程，用于监控多个master-slave集群，<br>自动发现master宕机，进行自动切换slave &gt; master。</p>
<p><strong>sentinel主要功能如下：</strong></p>
<p>　　1. 不时的监控redis是否良好运行，如果节点不可达就会对节点进行下线标识<br>　　2. 如果被标识的是主节点，sentinel就会和其他的sentinel节点“协商”，如果其他节点也认为主节点不可达，<br>　　  就会选举一个sentinel节点来完成自动故障转移<br>　　3. 在master-slave进行切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，<br>　　  即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换</p>
<h4 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h4><p>每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令</p>
<p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。</p>
<p>如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。</p>
<p>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线</p>
<p>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令</p>
<p>当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次</p>
<p>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。</p>
<p>若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p>
<p>主观下线和客观下线</p>
<p>主观下线：Subjectively Down，简称 SDOWN，指的是当前 Sentinel 实例对某个redis服务器做出的下线判断。<br>客观下线：Objectively Down， 简称 ODOWN，指的是多个 Sentinel 实例在对Master Server做出 SDOWN 判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master Server下线判断，然后开启failover.</p>
<p>SDOWN适合于Master和Slave，只要一个 Sentinel 发现Master进入了ODOWN， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对下线的主服务器执行自动故障迁移操作。</p>
<p>ODOWN只适用于Master，对于Slave的 Redis 实例，Sentinel 在将它们判断为下线前不需要进行协商， 所以Slave的 Sentinel 永远不会达到ODOWN。</p>
<h4 id="3、master宕机处理"><a href="#3、master宕机处理" class="headerlink" title="3、master宕机处理"></a>3、master宕机处理</h4><p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081403893-388342745.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081416634-1637699103.png" alt="img"></p>
<p>如果master宕机，我们应该先选一个slave出来，让他成为新的master，其他redis都修改成这个新的master的slave，但是redis本身或者客户端都没有实现主从切换的功能，当然，人为地修改配置文件，实现上图的功能也是可以的，但是如果是在深夜，所有人都睡觉了呢，谁来修改配置信息？这个时候就可以使用redis的Sentinel功能了，它就是实现了，当发现master宕机，自动帮我们去修改其他redis配置文件，选举出一个新master。</p>
<h4 id="4、Sentinel功能实现图"><a href="#4、Sentinel功能实现图" class="headerlink" title="4、Sentinel功能实现图"></a>4、Sentinel功能实现图</h4><p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081538985-1395233418.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081557550-451529206.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117081612394-1096354711.png" alt="img"></p>
<h4 id="5、redis一些查看命令"><a href="#5、redis一些查看命令" class="headerlink" title="5、redis一些查看命令"></a>5、redis一些查看命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli info  # 查看redis数据库信息</span><br><span class="line"></span><br><span class="line">redis-cli info replication # 查看redis的复制授权信息(主从复制)</span><br><span class="line"></span><br><span class="line">redis-cli info sentinel   # 查看redis的哨兵信息</span><br></pre></td></tr></table></figure>



<h4 id="6、Redis主从配置"><a href="#6、Redis主从配置" class="headerlink" title="6、Redis主从配置"></a>6、Redis主从配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.准备三个redis实例，一主两从</span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-6379.conf配置</span></span><br><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile "6379.log"</span><br><span class="line">dbfilename "dump-6379.rdb"</span><br><span class="line">dir "/var/redis/data/"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-6380.conf配置</span></span><br><span class="line">port 6380</span><br><span class="line">daemonize yes</span><br><span class="line">logfile "6380.log"</span><br><span class="line">dbfilename "dump-6380.rdb"</span><br><span class="line">dir "/var/redis/data/"</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-6381.conf配置</span></span><br><span class="line">port 6381</span><br><span class="line">daemonize yes</span><br><span class="line">logfile "6381.log"</span><br><span class="line">dbfilename "dump-6381.rdb"</span><br><span class="line">dir "/var/redis/data/"</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 准备好了三个数据库实例，启动三个数据库实例</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动前记得先去创建redis数据存放的文件夹</span></span><br><span class="line">mkdir -p /var/redis/data/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动实例</span></span><br><span class="line">redis-server  redis-6379.conf</span><br><span class="line">redis-server  redis-6380.conf</span><br><span class="line">redis-server  redis-6381.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看redis服务是否已经启动</span></span><br><span class="line">ps -ef | grep redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 确定主从关系</span><br><span class="line">redis-cli  -p 6379 info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=336,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=336,lag=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis-cli  -p 6380 info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br></pre></td></tr></table></figure>



<h4 id="7、Redis-Sentinel安装配置"><a href="#7、Redis-Sentinel安装配置" class="headerlink" title="7、Redis Sentinel安装配置"></a>7、Redis Sentinel安装配置</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. Sentinel配置解析</span><br><span class="line">port 26379  // Sentinel的端口</span><br><span class="line">dir /var/redis/data/  // Sentinel日志文件存放位置</span><br><span class="line">logfile "26379.log"  // Sentinel日志文件名字</span><br><span class="line"></span><br><span class="line">// 当前Sentinel节点监控 127.0.0.1:6379 这个主节点</span><br><span class="line">// 2代表判断主节点失败至少需要2个Sentinel节点节点同意</span><br><span class="line">// mymaster是主节点的别名</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line">// 每个Sentinel节点都要定期PING命令来判断Redis数据节点和其余Sentinel节点是否可达</span><br><span class="line">// 如果超过30000毫秒30s且没有回复，则判定不可达</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line">// 当Sentinel节点集合对主节点故障判定达成一致时，Sentinel领导者节点会做故障转移操作，选出新的主节点，</span><br><span class="line">// 原来的从节点会向新的主节点发起复制操作，限制每次向新的主节点发起复制操作的从节点个数为1</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">//故障转移超时时间为180000毫秒</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line">// 后台执行</span><br><span class="line">daemonize yes </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 准备三个哨兵，开始监控主从架构</span><br><span class="line"><span class="meta">#</span><span class="bash"> 哨兵配置文件redis-26379.conf</span></span><br><span class="line">port 26379  </span><br><span class="line">dir /var/redis/data/</span><br><span class="line">logfile "26379.log"</span><br><span class="line">sentinel monitor zbjmaster  127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds zbjmaster 30000</span><br><span class="line">sentinel parallel-syncs zbjmaster 1</span><br><span class="line">sentinel failover-timeout zbjmaster 180000</span><br><span class="line">daemonize yes </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 哨兵配置文件redis-26380.conf</span></span><br><span class="line">port 26380  </span><br><span class="line">dir /var/redis/data/</span><br><span class="line">logfile "26380.log"</span><br><span class="line">sentinel monitor zbjmaster  127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds zbjmaster 30000</span><br><span class="line">sentinel parallel-syncs zbjmaster 1</span><br><span class="line">sentinel failover-timeout zbjmaster 180000</span><br><span class="line">daemonize yes </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 哨兵配置文件redis-26381.conf</span></span><br><span class="line">port 26381  </span><br><span class="line">dir /var/redis/data/</span><br><span class="line">logfile "26381.log"</span><br><span class="line">sentinel monitor zbjmaster  127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds zbjmaster 30000</span><br><span class="line">sentinel parallel-syncs zbjmaster 1</span><br><span class="line">sentinel failover-timeout zbjmaster 180000</span><br><span class="line">daemonize yes </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">3. 启动三个哨兵实例</span><br><span class="line">redis-sentinel redis-26379.conf</span><br><span class="line">redis-sentinel redis-26380.conf</span><br><span class="line">redis-sentinel redis-26381.conf</span><br><span class="line"></span><br><span class="line">注意！！如果发现实验不成功，需删掉所有的哨兵配置文件，从新来过</span><br><span class="line">注意！！如果发现实验不成功，需删掉所有的哨兵配置文件，从新来过</span><br><span class="line">注意！！如果发现实验不成功，需删掉所有的哨兵配置文件，从新来过</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查哨兵状态是否正常</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只有发现如下信息，即为正常</span></span><br><span class="line">redis-cli -p 26379 info sentinel</span><br><span class="line"><span class="meta">#</span><span class="bash"> Sentinel</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最重要的一句</span></span><br><span class="line">master0:name=zbjmaster,status=ok,address=127.0.0.1:6380,slaves=2,sentinels=3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 测试哨兵的自动主从切换</span><br><span class="line">1,干掉6379的redis数据库</span><br><span class="line">    kill -9 6379的PID</span><br><span class="line"></span><br><span class="line">2,查看6380和6381的身份信息，是否自动的进行主从切换</span><br><span class="line">    我们设置的是30s后master没有响应，哨兵自动进行主从切换，因此30s后查看主从信息</span><br><span class="line">    redis-cli -p 6380 info replication</span><br><span class="line">    redis-cli -p 6381 info replication</span><br><span class="line">    </span><br><span class="line">3,手动启动6379挂掉的数据库，查看是否会被哨兵，添加进信息的主从集群</span><br><span class="line">    redis-server redis-6379.conf</span><br><span class="line">    redis-cli -p 6379 info replication</span><br></pre></td></tr></table></figure>



<h3 id="二、redis分区和集群"><a href="#二、redis分区和集群" class="headerlink" title="二、redis分区和集群"></a>二、redis分区和集群</h3><h4 id="1、什么是分区和集群"><a href="#1、什么是分区和集群" class="headerlink" title="1、什么是分区和集群"></a>1、什么是分区和集群</h4><ol>
<li><p>分区<br><strong>分区是分割数据到多个Redis实例的处理过程</strong>，因此每个实例只保存key的一个子集。<br>分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。<br>分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。</p>
</li>
<li><p>集群<br><strong>redis集群就是分区的一种的实现</strong></p>
</li>
</ol>
<h4 id="2、为什么要用分区"><a href="#2、为什么要用分区" class="headerlink" title="2、为什么要用分区"></a>2、为什么要用分区</h4><ol>
<li>并发问题<br>官方声称 redis 每秒可以执行10万条命令<br>但是假如业务需要每秒100万的命令执行呢(例如新浪微博某某明星出轨、官宣之类的)</li>
</ol>
<ol start="2">
<li>数据量<br>当数据量太大的时候，一台服务器内存正常是16~256G，假如你的业务需要500G内存，怎么办？</li>
</ol>
<ol start="3">
<li>解决方案<ol>
<li>方案一：<br>配置一台超级牛逼的服务器，拥有超大内存和超强的cpu，<br>但是这么做的成本是非常高的，而且，万一这台机器宕掉了，那你的服务还不是全挂了。</li>
<li>方案二：<br>考虑分布式，加机器，把数据分到不同的位置，分摊集中式的压力，一堆机器做一件事。</li>
</ol>
</li>
</ol>
<h4 id="3、分区的数据分布理论"><a href="#3、分区的数据分布理论" class="headerlink" title="3、分区的数据分布理论"></a>3、分区的数据分布理论</h4><p>redis是一个非关系型数据库，它的存储是key-value形式的，<br>redis实例集群主要思想是将redis数据的key进行散列，通过hash函数特定的key会映射到指定的redis节点上</p>
<p>分布式数据库首要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整个数据的一个子集。</p>
<p><strong>常见的分区规则有哈希分区和顺序分区。</strong></p>
<h4 id="4、顺序分区"><a href="#4、顺序分区" class="headerlink" title="4、顺序分区"></a>4、顺序分区</h4><p>假设我有三个节点，100个redis的数据，按照平均值(几乎是平均的)，顺序分区的规则就是：<br>把1-33个数据 放在 node1<br>把34-66个数据 放在node2<br>把67-100个数据 放在node3</p>
<h4 id="5、哈希分区"><a href="#5、哈希分区" class="headerlink" title="5、哈希分区"></a>5、哈希分区</h4><ol>
<li>节点取余<br>例如按照节点取余的方式，分三个节点<br>1~100的数据对3取余，可以分为三类<br>余数为0<br>余数为1<br>余数为2<br>把余数为0的数据存到同一个节点<br>把余数为1的数据存到同一个节点<br>把余数为2的数据存到同一个节点</li>
</ol>
<p>那么同样的分4个节点就是hash(key)%4，余数相同的存到同一个节点<br>节点取余的优点是简单，客户端分片直接是哈希+取余</p>
<ol start="2">
<li>一致性哈希<br>客户端进行分片，哈希+顺时针取余</li>
<li>虚拟槽分区<br>本文研究哈希分区之虚拟槽分区，因此下面单独来聊一聊</li>
</ol>
<h3 id="三、哈希分区之虚拟槽分区"><a href="#三、哈希分区之虚拟槽分区" class="headerlink" title="三、哈希分区之虚拟槽分区"></a>三、哈希分区之虚拟槽分区</h3><h4 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h4><p>Redis Cluster采用的就是虚拟槽分区</p>
<p>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有的数据映射到一个固定范围内的整数集合，<br>这些整数就定义为槽（slot）。</p>
<p><strong>Redis Cluster槽的范围是0 ～ 16383，即一共16384个槽</strong>。</p>
<p>槽是集群内数据管理和迁移的基本单位。采用大范围的槽的主要目的是为了方便数据的拆分和集群的扩展，</p>
<p>每个节点(redis实例)负责一定数量的槽。</p>
<h4 id="2、虚拟槽图解"><a href="#2、虚拟槽图解" class="headerlink" title="2、虚拟槽图解"></a>2、虚拟槽图解</h4><p><img src="https://img2018.cnblogs.com/blog/1449477/201901/1449477-20190117082348428-1446271590.png" alt="img"></p>
<h4 id="3、搭建redis-cluster"><a href="#3、搭建redis-cluster" class="headerlink" title="3、搭建redis cluster"></a>3、搭建redis cluster</h4><p>redis支持多实例的功能，我们在单机演示集群搭建，需要6个实例，三个是主节点，三个是从节点，数量为6个节点才能保证高可用的集群。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.准备6个节点，用于存储数据，分配槽位，每个节点的配置，如下，仅仅是端口的区别</span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-7000.conf配置</span></span><br><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">dir "/opt/redis/data"</span><br><span class="line">logfile "7000.log"</span><br><span class="line">dbfilename "dump-7000.rdb"</span><br><span class="line">cluster-enabled yes  </span><br><span class="line">cluster-config-file nodes-7000.conf　</span><br><span class="line"></span><br><span class="line">其余5个配置跟上面一模一样，仅仅是端口的区别</span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-7001.conf配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-7002.conf配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-7003.conf配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-7004.conf配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-7005.conf配置</span></span><br><span class="line"></span><br><span class="line">注意：要创建存放日志的文件夹  mkdir -p /opt/redis/data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.启动6个数据库实例</span><br><span class="line">redis-server redis-7000.conf</span><br><span class="line">redis-server redis-7001.conf</span><br><span class="line">redis-server redis-7002.conf</span><br><span class="line">redis-server redis-7003.conf</span><br><span class="line">redis-server redis-7004.conf</span><br><span class="line">redis-server redis-7005.conf</span><br><span class="line"></span><br><span class="line">3.开始分配redis集群状态，以及槽位分配</span><br><span class="line">Redis Cluster本身提供了自动将数据分散到Redis Cluster不同节点的能力，</span><br><span class="line">但是槽位的分配就比较麻烦了，当然了，如果你是大神，你完全可以自定义槽位的分配，</span><br><span class="line">一些大神已经写好了槽位分配的工具或脚本了，例如豆瓣公司开源的codis工具，还有ruby语言的作者，写的redsi.rb，</span><br><span class="line">因此我们可以使用一些工具帮我们进行redis cluster的搭建</span><br><span class="line"></span><br><span class="line">4.通过ruby脚本，一键创建redis-cluster,进行槽位分配</span><br><span class="line"></span><br><span class="line">5.准备ruby的编程环境</span><br><span class="line">1,下载ruby的源码包</span><br><span class="line">wget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz</span><br><span class="line"></span><br><span class="line">2,解压缩ruby远吗</span><br><span class="line">tar -zxvf ruby-2.3.1.tar.gz</span><br><span class="line"></span><br><span class="line">3,开始编译安装ruby</span><br><span class="line">进入ruby源码包</span><br><span class="line">./configure --prefix=/opt/ruby/</span><br><span class="line"></span><br><span class="line">4,开始编译且编译安装</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">5,配置ruby的环境变量</span><br><span class="line">vim /etc/profile </span><br><span class="line">写入如下配置</span><br><span class="line">PATH=你原本的PATH:/opt/ruby/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">6.安装ruby操作redis的模块</span><br><span class="line">1,下载ruby操作redis的模块</span><br><span class="line">wget http://rubygems.org/downloads/redis-3.3.0.gem</span><br><span class="line"></span><br><span class="line">2,安装</span><br><span class="line">gem install -l redis-3.3.0.gem</span><br><span class="line"></span><br><span class="line">3,搜索创建redis集群的命令</span><br><span class="line">find /opt  -name  redis-trib.rb</span><br><span class="line">/opt/redis-4.0.10/src/redis-trib.rb</span><br><span class="line"></span><br><span class="line">7.一键创建redis集群</span><br><span class="line">/opt/redis-4.0.10/src/redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br><span class="line">--replicas  进行身份授权 </span><br><span class="line">后面的1  代表，每个主节点，只有一个从节点</span><br><span class="line">默认将 7000  7001  70002  设置为主库</span><br><span class="line">将7003  7004  7005  设置为从库</span><br><span class="line"></span><br><span class="line">8.检查集群状态</span><br><span class="line">redis-cli -p 7000 cluster info</span><br><span class="line"></span><br><span class="line">9.测试集群节点，看是否能正常写入数据</span><br><span class="line">redis-cli -c -p 7000</span><br><span class="line">    -p  指定数据库端口</span><br><span class="line">    -c  指定开启集群模式</span><br><span class="line"></span><br><span class="line">set age 18  # 设置一个key会自动分配槽位，重定向到槽位所在的节点即代表成功</span><br><span class="line"></span><br><span class="line">在任意一个节点都可以get age，会自动重定向到 age 所在的节点。</span><br><span class="line"></span><br><span class="line">10.redis-cluster 会默认将不同的key，进行CRC16算法，进行分配到不同槽位</span><br><span class="line"></span><br><span class="line">11.数据正常重定向，即redis集群ok</span><br></pre></td></tr></table></figure>

<h3 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h3><ul>
<li><a href="https://www.cnblogs.com/Zzbj/p/10280363.html" target="_blank" rel="noopener">https://www.cnblogs.com/Zzbj/p/10280363.html</a></li>
<li><a href="https://www.cnblogs.com/rjzheng/p/10360619.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/10360619.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring启动invokeBeanFactoryPostProcessors方法解释</title>
    <url>/2020/03/24/2020/03/Spring%E5%90%AF%E5%8A%A8invokeBeanFactoryPostProcessors%E6%96%B9%E6%B3%95%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>本方法<code>（invokeBeanFactoryPostProcessors）</code>会实例化和调用所有 <code>BeanFactoryPostProcessor</code>（包括其子类<code>BeanDefinitionRegistryPostProcessor</code>）。</p>
<p><code>BeanFactoryPostProcessor</code> 接口是 <code>Spring</code> 初始化 <code>BeanFactory</code> 时对外暴露的扩展点，<code>Spring</code> IoC 容器允许 <code>BeanFactoryPostProcessor</code> 在容器实例化任何 <code>bean</code> 之前读取 <code>bean</code> 的定义，并可以修改它。</p>
<p><code>BeanDefinitionRegistryPostProcessor</code> 继承自 <code>BeanFactoryPostProcessor</code>，比 <code>BeanFactoryPostProcessor</code> 具有更高的优先级，主要用来在常规的 <code>BeanFactoryPostProcessor</code> 检测开始之前注册其他 <code>bean</code> 定义。特别是，你可以通过 <code>BeanDefinitionRegistryPostProcessor</code> 来注册一些常规的 <code>BeanFactoryPostProcessor</code>，因为此时所有常规的 <code>BeanFactoryPostProcessor</code> 都还没开始被处理。 </p>
<h4 id="项目中的实战"><a href="#项目中的实战" class="headerlink" title="项目中的实战"></a>项目中的实战</h4><p><code>BeanDefinitionRegistryPostProcessor</code>初始化<code>Bean</code>的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 想根据配置文件来动态的生成我们的Bean对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiOssScannerConfigurer</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Setter</span></span><br><span class="line">	<span class="keyword">private</span> MultiOssProperties multiOssProperties;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		String beanSuffixName = StringUtils.capitalize(OssConstants.BEAN_SUFFIX_NAME);</span><br><span class="line">		multiOssProperties.getClients().forEach((productCode, ossProperties) -&gt; &#123;</span><br><span class="line">			AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(OssClient<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">					() -&gt; <span class="title">OssClientUtils</span>.<span class="title">buildOssClient</span>(<span class="title">ossProperties</span>))</span></span><br><span class="line"><span class="class">					.<span class="title">getRawBeanDefinition</span>()</span>;</span><br><span class="line">			beanDefinition.setInitMethodName(<span class="string">"init"</span>);</span><br><span class="line">			beanDefinition.setDestroyMethodName(<span class="string">"shutDown"</span>);</span><br><span class="line">			beanDefinitionRegistry.registerBeanDefinition(productCode + beanSuffixName, beanDefinition);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor初始化的时候do something</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeplerBeanFactoryPostInitializer</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		Map&lt;String, AviatorFunction&gt; aviatorFunctionMap = beanFactory.getBeansOfType(AviatorFunction<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (aviatorFunctionMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			log.info(<span class="string">"初始化自定义RuleLoader..."</span>);</span><br><span class="line">			aviatorFunctionMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">				log.info(<span class="string">"加载Rule:&#123;&#125;"</span>, k);</span><br><span class="line">				AviatorEvaluator.addFunction(v);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		RuleLoader.initRule();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="跟进源代码"><a href="#跟进源代码" class="headerlink" title="跟进源代码"></a>跟进源代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">	PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">	<span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getBeanFactoryPostProcessors"><a href="#getBeanFactoryPostProcessors" class="headerlink" title="getBeanFactoryPostProcessors"></a>getBeanFactoryPostProcessors</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the list of BeanFactoryPostProcessors that will get applied</span></span><br><span class="line"><span class="comment">	 * to the internal BeanFactory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;BeanFactoryPostProcessor&gt; <span class="title">getBeanFactoryPostProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.beanFactoryPostProcessors;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这边 <code>getBeanFactoryPostProcessors()</code> 会拿到当前应用上下文中已经注册的 <code>BeanFactoryPostProcessor</code>，在默认情况下，<code>this.beanFactoryPostProcessors</code> 是返回空的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the given application context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> applicationContext the application to configure</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(C applicationContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1.判断beanFactory是否为BeanDefinitionRegistry，beanFactory为DefaultListableBeanFactory,</span></span><br><span class="line">    <span class="comment">// 而DefaultListableBeanFactory实现了BeanDefinitionRegistry接口，因此这边为true</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        <span class="comment">// 用于存放普通的BeanFactoryPostProcessor</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> LinkedList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">        <span class="comment">// 用于存放BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> LinkedList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2.首先处理入参中的beanFactoryPostProcessors</span></span><br><span class="line">        <span class="comment">// 遍历所有的beanFactoryPostProcessors, 将BeanDefinitionRegistryPostProcessor和普通BeanFactoryPostProcessor区分开</span></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                <span class="comment">// 2.1 如果是BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">                BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                <span class="comment">// 2.1.1 直接执行BeanDefinitionRegistryPostProcessor接口的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                <span class="comment">// 2.1.2 添加到registryProcessors(用于最后执行postProcessBeanFactory方法)</span></span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 2.2 否则，只是普通的BeanFactoryPostProcessor</span></span><br><span class="line">                <span class="comment">// 2.2.1 添加到regularPostProcessors(用于最后执行postProcessBeanFactory方法)</span></span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">        <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">        <span class="comment">// 用于保存本次要执行的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">        <span class="comment">// 3.调用所有实现PriorityOrdered接口的BeanDefinitionRegistryPostProcessor实现类</span></span><br><span class="line">        <span class="comment">// 3.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的Bean的beanName</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">        <span class="comment">// 3.2 遍历postProcessorNames</span></span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// 3.3 校验是否实现了PriorityOrdered接口</span></span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                <span class="comment">// 3.4 获取ppName对应的bean实例, 添加到currentRegistryProcessors中,</span></span><br><span class="line">                <span class="comment">// beanFactory.getBean: 这边getBean方法会触发创建ppName对应的bean对象, 目前暂不深入解析</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                <span class="comment">// 3.5 将要被执行的加入processedBeans，避免后续重复执行</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.6 进行排序(根据是否实现PriorityOrdered、Ordered接口和order值来排序)</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// 3.7 添加到registryProcessors(用于最后执行postProcessBeanFactory方法)</span></span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 3.8 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">// 3.9 执行完毕后, 清空currentRegistryProcessors</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">        <span class="comment">// 4.调用所有实现了Ordered接口的BeanDefinitionRegistryPostProcessor实现类（过程跟上面的步骤3基本一样）</span></span><br><span class="line">        <span class="comment">// 4.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的类, 这边重复查找是因为执行完上面的BeanDefinitionRegistryPostProcessor,</span></span><br><span class="line">        <span class="comment">// 可能会新增了其他的BeanDefinitionRegistryPostProcessor, 因此需要重新查找</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// 校验是否实现了Ordered接口，并且还未执行过</span></span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 4.2 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">        <span class="comment">// 5.最后, 调用所有剩下的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">        <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 5.1 找出所有实现BeanDefinitionRegistryPostProcessor接口的类</span></span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="comment">// 5.2 跳过已经执行过的</span></span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    <span class="comment">// 5.3 如果有BeanDefinitionRegistryPostProcessor被执行, 则有可能会产生新的BeanDefinitionRegistryPostProcessor,</span></span><br><span class="line">                    <span class="comment">// 因此这边将reiterate赋值为true, 代表需要再循环查找一次</span></span><br><span class="line">                    reiterate = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            <span class="comment">// 5.4 遍历currentRegistryProcessors, 执行postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">        <span class="comment">// 6.调用所有BeanDefinitionRegistryPostProcessor的postProcessBeanFactory方法(BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor)</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// 7.最后, 调用入参beanFactoryPostProcessors中的普通BeanFactoryPostProcessor的postProcessBeanFactory方法</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 到这里 , 入参beanFactoryPostProcessors和容器中的所有BeanDefinitionRegistryPostProcessor已经全部处理完毕,</span></span><br><span class="line">    <span class="comment">// 下面开始处理容器中的所有BeanFactoryPostProcessor</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">    <span class="comment">// 8.找出所有实现BeanFactoryPostProcessor接口的类</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    <span class="comment">// 用于存放实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    <span class="comment">// 用于存放实现了Ordered接口的BeanFactoryPostProcessor的beanName</span></span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 用于存放普通BeanFactoryPostProcessor的beanName</span></span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 8.1 遍历postProcessorNames, 将BeanFactoryPostProcessor按实现PriorityOrdered、实现Ordered接口、普通三种区分开</span></span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// 8.2 跳过已经执行过的</span></span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 8.3 添加实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 8.4 添加实现了Ordered接口的BeanFactoryPostProcessor的beanName</span></span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 8.5 添加剩下的普通BeanFactoryPostProcessor的beanName</span></span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    <span class="comment">// 9.调用所有实现PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line">    <span class="comment">// 9.1 对priorityOrderedPostProcessors排序</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 9.2 遍历priorityOrderedPostProcessors, 执行postProcessBeanFactory方法</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">    <span class="comment">// 10.调用所有实现Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// 10.1 获取postProcessorName对应的bean实例, 添加到orderedPostProcessors, 准备执行</span></span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 10.2 对orderedPostProcessors排序</span></span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    <span class="comment">// 10.3 遍历orderedPostProcessors, 执行postProcessBeanFactory方法</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">    <span class="comment">// 11.调用所有剩下的BeanFactoryPostProcessor</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// 11.1 获取postProcessorName对应的bean实例, 添加到nonOrderedPostProcessors, 准备执行</span></span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 11.2 遍历nonOrderedPostProcessors, 执行postProcessBeanFactory方法</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    <span class="comment">// 12.清除元数据缓存（mergedBeanDefinitions、allBeanNamesByType、singletonBeanNamesByType），</span></span><br><span class="line">    <span class="comment">// 因为后处理器可能已经修改了原始元数据，例如， 替换值中的占位符...</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="sortPostProcessors"><a href="#sortPostProcessors" class="headerlink" title="sortPostProcessors"></a>sortPostProcessors</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortPostProcessors</span><span class="params">(List&lt;?&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Object&gt; comparatorToUse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        <span class="comment">// 1.获取设置的比较器</span></span><br><span class="line">        comparatorToUse = ((DefaultListableBeanFactory) beanFactory).getDependencyComparator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (comparatorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.如果没有设置比较器, 则使用默认的OrderComparator</span></span><br><span class="line">        comparatorToUse = OrderComparator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.使用比较器对postProcessors进行排序</span></span><br><span class="line">    Collections.sort(postProcessors, comparatorToUse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，比较器为 <code>OrderComparator</code>；如果配置了 <code>annotation-config</code>，并且值为<code>true</code>，使用的是 <code>AnnotationAwareOrderComparator</code>，<code>AnnotationAwareOrderComparator</code> 继承自 <code>OrderComparator</code>，只是重写了部分方法，比较器的部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doCompare(o1, o2, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doCompare</span><span class="params">(Object o1, Object o2, OrderSourceProvider sourceProvider)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断o1是否实现了PriorityOrdered接口</span></span><br><span class="line">    <span class="keyword">boolean</span> p1 = (o1 <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">    <span class="comment">// 判断o2是否实现了PriorityOrdered接口</span></span><br><span class="line">    <span class="keyword">boolean</span> p2 = (o2 <span class="keyword">instanceof</span> PriorityOrdered);</span><br><span class="line">    <span class="comment">// 1.如果o1实现了PriorityOrdered接口, 而o2没有, 则o1排前面</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &amp;&amp; !p2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果o2实现了PriorityOrdered接口, 而o1没有, 则o2排前面</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p2 &amp;&amp; !p1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3.如果o1和o2都实现（都没实现）PriorityOrdered接口</span></span><br><span class="line">    <span class="comment">// Direct evaluation instead of Integer.compareTo to avoid unnecessary object creation.</span></span><br><span class="line">    <span class="comment">// 拿到o1的order值, 如果没实现Ordered接口, 值为Ordered.LOWEST_PRECEDENCE</span></span><br><span class="line">    <span class="keyword">int</span> i1 = getOrder(o1, sourceProvider);</span><br><span class="line">    <span class="comment">// 拿到o2的order值, 如果没实现Ordered接口, 值为Ordered.LOWEST_PRECEDENCE</span></span><br><span class="line">    <span class="keyword">int</span> i2 = getOrder(o2, sourceProvider);</span><br><span class="line">    <span class="comment">// 4.通过order值(order值越小, 优先级越高)排序</span></span><br><span class="line">    <span class="keyword">return</span> (i1 &lt; i2) ? -<span class="number">1</span> : (i1 &gt; i2) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一点：整个 <code>invokeBeanFactoryPostProcessors</code> 方法围绕两个接口，<code>BeanDefinitionRegistryPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code>，其中 <code>BeanDefinitionRegistryPostProcessor</code> 继承了 <code>BeanFactoryPostProcessor</code> 。<code>BeanDefinitionRegistryPostProcessor</code> 主要用来在常规 <code>BeanFactoryPostProcessor</code> 检测开始之前注册其他 Bean 定义，说的简单点，就是 <code>BeanDefinitionRegistryPostProcessor</code> 具有更高的优先级，执行顺序在 <code>BeanFactoryPostProcessor</code> 之前。</p>
<p>第二点：整个 <code>invokeBeanFactoryPostProcessors</code> 方法操作了 3 种 bean 对象：</p>
<ul>
<li>入参 <code>beanFactoryPostProcessors</code>：拿的是 <code>AbstractApplicationContext</code> 类的 <code>beanFactoryPostProcessors</code> 属性值，也就是在之前已经添加到 <code>beanFactoryPostProcessors</code> 中的 <code>BeanFactoryPostProcessor</code></li>
<li><code>BeanDefinitionRegistryPostProcessor</code> 接口实现类：实现了 <code>BeanDefinitionRegistryPostProcessor</code> 接口，并且注册到 <code>Spring IoC</code>容器中。</li>
<li>常规 <code>BeanFactoryPostProcessor</code> 接口实现类：实现了 <code>BeanFactoryPostProcessor</code> 接口，并且注册到 <code>Spring IoC</code>容器中。</li>
</ul>
<p>第三点：操作3种 bean 对象具体指的是调用它们重写的方法，调用实现方法时会遵循以下的优先级：<br>两个用于排序的重要接口：<code>PriorityOrdered</code> 和 <code>Ordered</code>，其中 <code>PriorityOrdered</code> 继承了 <code>Ordered</code>，并且 <code>PriorityOrdered</code> 的优先级要高于 <code>Ordered</code>，这跟 <code>BeanDefinitionRegistryPostProcessor</code> 继承 <code>BeanFactoryPostProcessor</code> 有点类似。实现 <code>Ordered</code> 接口需要重写 <code>getOrder</code> 方法，返回一个用于排序的 <code>order</code> 值，<code>order</code> 值的范围为 <code>Integer.MIN_VALUE ~ Integer.MAX_VALUE</code>，<code>order</code> 值越小优先级越高，<code>Integer.MIN_VALUE</code> 拥有最高优先级，而 <code>Integer.MAX_VALUE</code> 则对应的拥有最低优先级。</p>
<p>第四点：常见的 <code>Java EE</code> 相关的框架或者中间件，经常使用 <code>BeanFactoryPostProcessor</code> 来进行扩展，例如上面的 <code>Mybatis</code>，因此了解 <code>BeanFactoryPostProcessor</code> 的原理会对之后理解其他中间件的原理有帮助。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/v123411739/article/details/87741251" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/87741251</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>StringBuilder为什么线程不安全</title>
    <url>/2020/03/25/2020/03/StringBuilder%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>在这之前我只记住了StringBuilder不是线程安全的，StringBuffer是线程安全的这个结论，至于StringBuilder为什么不安全从来没有去想过。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><blockquote>
<p>在分析设个问题之前我们要知道StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。</p>
</blockquote>
<p>首先通过一段代码去看一下多线程操作StringBuilder对象会出现什么问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable( &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)&#123;</span><br><span class="line">                        stringBuilder.append(<span class="string">"a"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(stringBuilder.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们能看到这段代码创建了10个线程，每个线程循环1000次往StringBuilder对象里面append字符。正常情况下代码应该输出10000，但是实际运行会输出什么呢？</p>
<p><img src="http://static.cyblogs.com/16cc76d348d29915.png" alt="http://static.cyblogs.com/16cc76d348d29915.png"></p>
<p>我们看到输出了“9326”，小于预期的10000，并且还抛出了一个ArrayIndexOutOfBoundsException异常（异常不是必现）。</p>
<h5 id="1、为什么输出值跟预期值不一样"><a href="#1、为什么输出值跟预期值不一样" class="headerlink" title="1、为什么输出值跟预期值不一样"></a>1、为什么输出值跟预期值不一样</h5><p>我们先看一下StringBuilder的两个成员变量（这两个成员变量实际上是定义在AbstractStringBuilder里面的，StringBuilder和StringBuffer都继承了AbstractStringBuilder）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储字符串的具体内容</span></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"><span class="comment">//已经使用的字符数组的数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<p>再看StringBuilder的append()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先不管代码的第五行和第六行干了什么，直接看第七行，count += len不是一个原子操作。假设这个时候count值为10，len值为1，两个线程同时执行到了第七行，拿到的count值都是10，执行完加法运算后将结果赋值给count，所以两个线程执行完后count值为11，而不是12。这就是为什么测试代码输出的值要比10000小的原因。</p>
<h5 id="2、为什么会抛出ArrayIndexOutOfBoundsException异常。"><a href="#2、为什么会抛出ArrayIndexOutOfBoundsException异常。" class="headerlink" title="2、为什么会抛出ArrayIndexOutOfBoundsException异常。"></a>2、为什么会抛出ArrayIndexOutOfBoundsException异常。</h5><p>我们看回AbstractStringBuilder的append()方法源码的第五行，ensureCapacityInternal()方法是检查StringBuilder对象的原char数组的容量能不能盛下新的字符串，如果盛不下就调用expandCapacity()方法对char数组进行扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容的逻辑就是new一个新的char数组，新的char数组的容量是原来char数组的两倍再加2，再通过System.arryCopy()函数将原数组的内容复制到新数组，最后将指针指向新的char数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算新的容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//中间省略了一些检查逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Arrys.copyOf()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] copyOf(<span class="keyword">char</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] copy = <span class="keyword">new</span> <span class="keyword">char</span>[newLength];</span><br><span class="line">    <span class="comment">//拷贝数组</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractStringBuilder的append()方法源码的第六行，是将String对象里面char数组里面的内容拷贝到StringBuilder对象的char数组里面，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.getChars(<span class="number">0</span>, len, value, count);</span><br></pre></td></tr></table></figure>

<p>getChars()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//中间省略了一些检查</span></span><br><span class="line">    ...   </span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>拷贝流程见下图</p>
<p><img src="http://static.cyblogs.com/16cc76dc56ffc2f2.png" alt="http://static.cyblogs.com/16cc76dc56ffc2f2.png"></p>
<p>假设现在有两个线程同时执行了StringBuilder的append()方法，两个线程都执行完了第五行的ensureCapacityInternal()方法，此刻count=5。</p>
<p><img src="http://static.cyblogs.com/16cc76df391e9f4f.png" alt="http://static.cyblogs.com/16cc76df391e9f4f.png"></p>
<p>这个时候线程1的cpu时间片用完了，线程2继续执行。线程2执行完整个append()方法后count变成6了</p>
<p><img src="http://static.cyblogs.com/16cc76e4b1c9c16b.png" alt="http://static.cyblogs.com/16cc76e4b1c9c16b.png"></p>
<p>线程1继续执行第六行的str.getChars()方法的时候拿到的count值就是6了，执行char数组拷贝的时候就会抛出ArrayIndexOutOfBoundsException异常。</p>
<p>至此，StringBuilder为什么不安全已经分析完了。如果我们将测试代码的StringBuilder对象换成StringBuffer对象会输出什么呢？</p>
<p><img src="http://static.cyblogs.com/16cc76e852c2a3cb.png" alt="http://static.cyblogs.com/16cc76e852c2a3cb.png"></p>
<p>当然是输出10000啦！</p>
<p>那么StringBuffer用什么手段保证线程安全的？这个问题你点进StringBuffer的append()方法里面就知道了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://juejin.im/post/5d6228046fb9a06add4e37fe" target="_blank" rel="noopener">https://juejin.im/post/5d6228046fb9a06add4e37fe</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>StringBuilder</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP粘包拆包及解决方法</title>
    <url>/2020/03/26/2020/03/TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。</p>
<h4 id="什么是粘包、拆包？"><a href="#什么是粘包、拆包？" class="headerlink" title="什么是粘包、拆包？"></a>什么是粘包、拆包？</h4><p>假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种，现列举如下：</p>
<p><strong>第一种情况：</strong>接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。</p>
<p> <img src="http://static.cyblogs.com/1422100-20180822164943488-1549063928.png" alt="img"></p>
<p><strong>第二种情况：</strong>接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p>
<p> <img src="http://static.cyblogs.com/1422100-20180822164950622-1403347423.png" alt="img"></p>
<p><strong>第三种情况：</strong>这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p>
<p> <img src="http://static.cyblogs.com/1422100-20180822164958646-1790874821.png" alt="img"></p>
<p> <img src="http://static.cyblogs.com/1422100-20180822165003871-693771235.png" alt="img"></p>
<h4 id="为什么会发生TCP粘包、拆包？"><a href="#为什么会发生TCP粘包、拆包？" class="headerlink" title="为什么会发生TCP粘包、拆包？"></a>为什么会发生TCP粘包、拆包？</h4><p>发生TCP粘包、拆包主要是由于下面一些原因：</p>
<ul>
<li><p>应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。</p>
</li>
<li><p>应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。</p>
</li>
<li><p>进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度&gt;MSS的时候将发生拆包。</p>
</li>
<li><p>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</p>
</li>
</ul>
<h4 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h4><p>TCP本身是面向流的，作为网络服务器，如何从这源源不断涌来的数据流中拆分出或者合并出有意义的信息呢？通常会有以下一些常用的方法：</p>
<ul>
<li><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p>
</li>
<li><p>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p>
</li>
<li><p>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p>
</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.cnblogs.com/panchanggui/p/9518735.html" target="_blank" rel="noopener">https://www.cnblogs.com/panchanggui/p/9518735.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么32位的操作系统最大只能支持4GB内存？</title>
    <url>/2020/03/08/2020/03/%E4%B8%BA%E4%BB%80%E4%B9%8832%E4%BD%8D%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%A4%A7%E5%8F%AA%E8%83%BD%E6%94%AF%E6%8C%814GB%E5%86%85%E5%AD%98%EF%BC%9F/</url>
    <content><![CDATA[<p>也许大家对这个问题都不陌生，实际装过系统用过电脑的朋友可能都有这样的经历：自己电脑配的是4G的内存条，可是装完系统之后发现电脑上显示的只有3.2G左右可用内存，其它的内存跑到哪去了？网上也有很多朋友给出了一些解释，大部分我觉得都没有解释得很清楚，今天我们就来看一下其中的具体缘由。</p>
<p>在此之前先来了解一些计算机系统结构和PC硬件方面的一些知识。</p>
<h4 id="总线结构和主板的构成"><a href="#总线结构和主板的构成" class="headerlink" title="总线结构和主板的构成"></a>总线结构和主板的构成</h4><p>　　说起总线大家肯定不陌生，而且大家平时肯定跟它打过交道，我们在用U盘拷贝数据的时候先要把U盘通过USB接口与电脑相连才能拷贝。USB接口实际上就是一种总线，一般称这种总线为USB总线（也叫做通用串行总线）。在很久之前是没有USB总线的，那个时候每个外设各自采用自己的接口标准，举个最简单的例子：鼠标生产厂商采用鼠标特有的接口，键盘生产厂商用键盘特有的接口，这样一来的话，PC机上就必须提供很多接口，这样一来增加了硬件设计难度和成本，直到后来USB接口的出现，它统一了很多外设接口的标准，不仅使得用户可以很方便地连接一些外设，更增强了PC的可扩展性。所以现在大家看到的鼠标、键盘、U盘、打印机等等这些外设都可以直接通过USB接口直接插到电脑上的。</p>
<p>　　在计算机系统中总线是非常重要的一个概念，正是因为有了总线，所有的组成部件才能一起正常协同分工合作。在很久以前的PC机中，采用的是三总线结构，即：数据总线、地址总线、控制总线。它们分别用来传输不同类型的数据，数据总线用来传输数据，地址总线用来传输地址，控制总线用来传输一些控制信号。下面这幅图很清楚地展示了三总线结构：</p>
<p>　　<img src="http://static.cyblogs.com/31150701-f52612011e054b0db388487517007dc1.jpg" alt="img"></p>
<p>随着时代的发展，这种简单的总线结构逐渐被淘汰。下面这幅图是现代计算采用的结构：</p>
<p>　　<img src="http://static.cyblogs.com/31162602-cb2675a3eb5b4b199adc9c3eefcaa167.jpg" alt="img"></p>
<p>　　事实上这也是现代主板所采用的结构，当然可能部分地方有略微不同（大体结构是差不多的），仔细观察过主板构成的朋友可能对上面一幅图很熟悉。在主板上主要有两大主要部分：北桥（North Bridge也称Host Bridge）和南桥（South Bridge）。北桥主要负责CPU和内存、显卡这些部件的数据传送，而南桥主要负责I/O设备、外部存储设备以及BIOS之间的通信。现在有些主板已经没有北桥了，因为芯片厂商已经把北桥所负责的功能直接集成到CPU中了（不过暂且我们以上副图的模型来讨论）。</p>
<p>　　在上副图中，我没有画出 数据总线和地址总线等，因为在某些总线标准中它们被集成到一起了，比如在PCI总线中，地址总线和数据总线总是分时复用的（也就是说假如PCI总线有32位数据总线，这32位总线在某个时刻可以充当数据总线的作用，在下一时刻可以充当地址总线的作用）。有的总线同时提供了数据总线和地址总线。</p>
<p>　　下面来说一下几个主要总线和南北桥的作用：</p>
<p>　　FSB总线：即前端总线（Front Side Bus），CPU和北桥之间的桥梁，CPU和北桥传递的所有数据必须经过FSB总线，可以这么说FSB总线的频率直接影响到CPU访问内存的速度。</p>
<p>　　北桥：北桥是CPU和内存、显卡等部件进行数据交换的唯一桥梁，也就是说CPU想和其他任何部分通信必须经过北桥。北桥芯片中通常集成的还有内存控制器等，用来控制与内存的通信。现在的主板上已经看不到北桥了，它的功能已经被集成到CPU当中了。</p>
<p>　　PCI总线：PCI总线是一种高性能局部总线，其不受CPU限制，构成了CPU和外设之间的高速通道。比如现在的显卡一般都是用的PCI插槽，PCI总线传输速度快，能够很好地让显卡和CPU进行数据交换。</p>
<p>　　南桥：主要负责I/O设备之间的通信，CPU要想访问外设必须经过南桥芯片。</p>
<p>　　在了解了这些基础东西之后，下面来讲解一下为何32位系统最大只支持4GB内存。</p>
<h4 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h4><p>　　在使用计算机时，其最大支持的内存是由  操作系统 和 硬件 两方面决定的。</p>
<p>　　先说一下硬件方面的因素，在上面已经提到了地址总线，在计算机中 CPU的地址总线数目 决定了CPU 的 寻址 范围，这种由地址总线对应的地址称作为物理地址。假如CPU有32根地址总线（一般情况下32位的CPU的地址总线是32位，也有部分32位的CPU地址总线是36位的，比如用做服务器的CPU），那么提供的可寻址物理地址范围 为 232=4GB（在这里要注意一点，我们平常所说的32位CPU和64位CPU指的是CPU一次能够处理的数据宽度，即位宽，不是地址总线的数目）。自从64位CPU出现之后，一次便能够处理64位的数据了，其地址总线一般采用的是36位或者40位（即CPU能够寻址的物理地址空间为64GB或者1T）。在CPU访问其它任何部件的时候，都需要一个地址，就像一个快递员送快递，没有地址他是不知道往哪里送达的，举个例子，CPU想从显存单元读取数据，必须知道要读取的显存单元的实际物理地址才能实现读取操作，同样地，从内存条上的内存单元读取数据也需要知道内存单元的物理地址。换句话说，CPU访问任何存储单元必须知道其物理地址。</p>
<p>　　用户在使用计算机时能够访问的最大内存不单是由CPU地址总线的位数决定的，还需要考虑操作系统的实现。实际上用户在使用计算机时，进程所访问到的地址是逻辑地址，并不是真实的物理地址，这个逻辑地址是操作系统提供的，CPU在执行指令时需要先将指令的逻辑地址变换为物理地址才能对相应的存储单元进行数据的读取或者写入（注意逻辑地址和物理地址是一一对应的）。</p>
<p>　　对于32位的windows操作系统，其逻辑地址编码采用的地址位数是32位的，那么操作系统所提供的逻辑地址寻址范围是4GB，而在intel x86架构下，采用的是内存映射技术(Memory-Mapped I/O, MMIO)，也就说将4GB逻辑地址中一部分要划分出来与BIOS ROM、CPU寄存器、I/O设备这些部件的物理地址进行映射，那么逻辑地址中能够与内存条的物理地址进行映射的空间肯定没有4GB了，看下面这幅图就明白了：</p>
<p>　　<img src="http://static.cyblogs.com/31172853-72c5552567954880964132f5b487c036.jpg" alt="img"></p>
<p>　　所以当我们装了32位的windows操作系统，即使我们买了4GB的内存条，实际上能被操作系统访问到的肯定小于4GB，一般情况是3.2GB左右。假如说地址总线位数没有32位，比如说是20位，那么CPU能够寻址到1MB的物理地址空间，此时操作系统即使能支持4GB的逻辑地址空间并且假设内存条是4GB的，能够被用户访问到的空间不会大于1MB（当然此处不考虑虚拟内存技术），所以用户能够访问到的最大内存空间是由硬件和操作系统两者共同决定的，两者都有制约关系。</p>
<p>　　对于64位的操作系统，其逻辑地址编码采用的地址位数是40位，能够最大支持1T的逻辑地址空间。考虑一种情况，假如CPU是64位的，地址总线位数是40位，操作系统也是64位的，逻辑地址编码采用的地址位数也是40位，内存条大小是64GB，那么是不是内存条的64GB全部都能被利用了呢？答案是不一定，因为这里面还要考虑一个因素就是内存控制器，内存控制器位于北桥之内（现在基本都是放在CPU里面了），内存控制器的实际连接内存的地址线决定了可以支持的内存容量，也就是说内存控制器与内存槽实际连接的地址线如果没有40位的话，是无法完全利用64GB的内存条的存储空间的。当然对于内存控制器这个问题几乎可以不用考虑，因为现在大多数的内存控制器至少都采用的是40位地址总线。</p>
<p>　　关于这个问题就说这么多了，有兴趣深入研究的朋友可以自己查阅更多的资料。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP如何实现可靠传输</title>
    <url>/2020/03/27/2020/03/UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。</p>
<p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li>1、添加seq/ack机制，确保数据发送到对端</li>
<li>2、添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>3、添加超时重传机制。</li>
</ul>
<p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p>
<p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为 <strong>RUDP、RTP、UDT</strong>。</p>
<h3 id="开源程序"><a href="#开源程序" class="headerlink" title="开源程序"></a>开源程序</h3><h5 id="1、RUDP（Reliable-User-Datagram-Protocol）"><a href="#1、RUDP（Reliable-User-Datagram-Protocol）" class="headerlink" title="1、RUDP（Reliable User Datagram Protocol）"></a>1、RUDP（Reliable User Datagram Protocol）</h5><p><strong>RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等</strong> ，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。在不干扰协议的实时特性的同时，可靠 UDP 的拥塞控制机制允许 TCP 方式下的流控制行为。</p>
<h5 id="2、RTP（Real-Time-Protocol）"><a href="#2、RTP（Real-Time-Protocol）" class="headerlink" title="2、RTP（Real Time Protocol）"></a>2、RTP（Real Time Protocol）</h5><p><strong>RTP为数据提供了具有实时特征的端对端传送服务</strong>，如在组播或单播网络服务下的交互式视频音频或模拟数据。</p>
<p>应用程序通常在 UDP 上运行 RTP 以便使用其多路结点和校验服务；这两种协议都提供了传输层协议的功能。但是 RTP 可以与其它适合的底层网络或传输协议一起使用。如果底层网络提供组播方式，那么 RTP 可以使用该组播表传输数据到多个目的地。</p>
<p>RTP 本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于底层服务去实现这一过程。 RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。</p>
<h5 id="3、UDT（UDP-based-Data-Transfer-Protocol）"><a href="#3、UDT（UDP-based-Data-Transfer-Protocol）" class="headerlink" title="3、UDT（UDP-based Data Transfer Protocol）"></a>3、UDT（UDP-based Data Transfer Protocol）</h5><p>基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT）是一种互联网数据传输协议。<strong><em>UDT的主要目的是支持高速广域网上的海量数据传输\</em></strong>，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。</p>
<p>顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.jianshu.com/p/6c73a4585eba" target="_blank" rel="noopener">https://www.jianshu.com/p/6c73a4585eba</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>UDP</category>
      </categories>
      <tags>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>你清楚如何动态的调整动态调整corePoolSize与maximumPoolSize吗？</title>
    <url>/2020/03/04/2020/03/%E4%BD%A0%E6%B8%85%E6%A5%9A%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%9A%84%E8%B0%83%E6%95%B4%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4corePoolSize%E4%B8%8EmaximumPoolSize%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>线程池<code>ThreadPoolExecutor</code>在运行的过程中，业务并发量变动，需要不停服务调整线程池的线程数，<code>ThreadPoolExecutor</code>支持动态调整<code>corePoolSize</code>与<code>maximumPoolSize</code>的值。</p>
<h5 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadChangeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">10l</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">                        Thread.sleep(1l);</span></span><br><span class="line"><span class="comment">                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">                    &#125;*/</span></span><br><span class="line">                    System.out.println(<span class="string">"------------core:\t"</span> + executor.getCorePoolSize() + <span class="string">"\tactive:\t"</span> + executor.getActiveCount() + <span class="string">"\tmax:\t"</span> + executor.getMaximumPoolSize());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">20</span>) &#123;</span><br><span class="line">                executor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">                executor.setMaximumPoolSize(<span class="number">9</span>);</span><br><span class="line">                System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">100</span>) &#123;</span><br><span class="line">                executor.shutdown();</span><br><span class="line">                System.out.println(<span class="string">"============================================="</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序运行中动态修改线程池<code>corePoolSize</code>与<code>maximumPoolSize</code>的值</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="线程池参数调大"><a href="#线程池参数调大" class="headerlink" title="线程池参数调大"></a>线程池参数调大</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="comment">//核心线程调小，中断空闲任务，否则线程池的当前任务结束，自动调小</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="comment">//核心线程数调大后，从队列取任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We don't really know how many new threads are "needed".</span></span><br><span class="line">        <span class="comment">// As a heuristic, prestart enough new workers (up to new</span></span><br><span class="line">        <span class="comment">// core size) to handle the current number of tasks in</span></span><br><span class="line">        <span class="comment">// queue, but stop if queue becomes empty while doing so.</span></span><br><span class="line">        <span class="comment">//队列大小是否可以取任务</span></span><br><span class="line">        <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">        <span class="comment">//队列有任务就取，否则break</span></span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="comment">//中断空闲任务，否则线程池的当前任务结束，自动调小</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码看出：线程池的调节时直接设置<code>corePoolSize</code>与<code>maximumPoolSize</code>的值</p>
<p>其中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">workerCountOf(ctl.get())</span><br></pre></td></tr></table></figure>


<p>代表工作任务线程数，参考我的博客JDK8线程池-ThreadPoolExecutor源码解析</p>
<p>调大<code>corePoolSize</code>与<code>maximumPoolSize</code>，线程池运行过程中自动生效，线程池处理逻辑增强。</p>
<h5 id="线程池调小"><a href="#线程池调小" class="headerlink" title="线程池调小"></a>线程池调小</h5><p>调小<code>corePoolSize</code>与<code>maximumPoolSize</code>均会执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interruptIdleWorkers();</span><br></pre></td></tr></table></figure>

<h6 id="跟踪interruptIdleWorkers源码"><a href="#跟踪interruptIdleWorkers源码" class="headerlink" title="跟踪interruptIdleWorkers源码"></a>跟踪interruptIdleWorkers源码</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//workers是所有已存在的线程，包括空闲线程</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">//这里注意，非常关键，加锁w.tryLock()</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从上面的参数onlyOne is false</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>workers</code>注意：是一个<code>HashSet</code>，存放规则：</p>
<p>核心线程优先占满，即使核心线程有空闲，新任务来了会优先开启新的线程而不是复用，核心线程仅在占满才会复用，然后使用队列，最后使用<code>max</code>线程，<code>max</code>线程数对应的<code>workers</code>会动态变化，</p>
<p>参考我的博客<code>JDK8</code>线程池-<code>ThreadPoolExecutor</code>源码解析</p>
<h6 id="线程池任务执行源码"><a href="#线程池任务执行源码" class="headerlink" title="线程池任务执行源码"></a>线程池任务执行源码</h6><p>我们看<code>ThreadPoolExecutor</code>执行任务的源码，参考我的博客<code>JDK8</code>线程池-<code>ThreadPoolExecutor</code>源码解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里注意，加锁了，非常关键</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//任务执行</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出在任务拿出来后，立即加锁</p>
<p>包括任务执行的过程都是加锁的。</p>
<h6 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br></pre></td></tr></table></figure>
<p>使用了AQS，自定义了加锁方式CAS模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span></span><br><span class="line"><span class="class">			<span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span></span><br><span class="line"><span class="class">			<span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看出使用<code>tryAcquire</code>和<code>tryRelease</code>，均重写方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compareAndSetState(0, 1)</code></p>
<p>使用上面的代码加锁，意味着线程执行过程中都是加锁的，不会被销毁，只会销毁空闲线程，或者当前线程执行结束销毁。</p>
<p>线程池调小<code>corePoolSize</code>与<code>maximumPoolSize</code>对当前正在执行的任务没有影响。</p>
<h5 id="调节队列大小"><a href="#调节队列大小" class="headerlink" title="调节队列大小"></a>调节队列大小</h5><p>队列是不可以动态调整的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>线程池<code>corePoolSize</code>与<code>maximumPoolSize</code>调大注意<code>max</code>线程数不要调过大，计算机资源是有限的。</p>
</li>
<li><p>线程池的队列初始化大小注意，不能动态调节，队列占用的是堆内存，注意JVM的内存大小与GC能力，尽量减小大对象的存在。</p>
</li>
<li><p>线程池<code>corePoolSize</code>与<code>maximumPoolSize</code>和队列调小注意，线程池的处理能力减弱，可能会执行拒绝策略。</p>
</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/fenglllle/article/details/84473345" target="_blank" rel="noopener">https://blog.csdn.net/fenglllle/article/details/84473345</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Canal和Kafka实现MySQL的Binlog近实时同步</title>
    <url>/2020/03/01/2020/03/%E5%9F%BA%E4%BA%8ECanal%E5%92%8CKafka%E5%AE%9E%E7%8E%B0MySQL%E7%9A%84Binlog%E8%BF%91%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>近段时间，业务系统架构基本完备，数据层面的建设比较薄弱，因为笔者目前工作重心在于搭建一个小型的数据平台。优先级比较高的一个任务就是需要近实时同步业务系统的数据（包括保存、更新或者软删除）到一个另一个数据源，持久化之前需要清洗数据并且构建一个相对合理的便于后续业务数据统计、标签系统构建等扩展功能的数据模型。基于当前团队的资源和能力，优先调研了<code>Alibaba</code>开源中间件<code>Canal</code>的使用。</p>
<p><img src="http://static.cyblogs.com/m-w-c-1.png" alt="http://static.cyblogs.com/m-w-c-1.png"></p>
<p>这篇文章简单介绍一下如何快速地搭建一套<code>Canal</code>相关的组件。</p>
<h4 id="关于Canal"><a href="#关于Canal" class="headerlink" title="关于Canal"></a>关于Canal</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>下面的简介和下一节的原理均来自于<a href="https://github.com/alibaba/canal" target="_blank" rel="noopener">Canal</a>项目的<code>README</code>：</p>
<p><img src="http://static.cyblogs.com/m-w-c-2.png" alt="img"></p>
<p><code>Canal[kə&#39;næl]</code>，译意为水道/管道/沟渠，主要用途是基于<code>MySQL</code>数据库增量日志解析，提供增量数据订阅和消费。早期阿里巴巴因为杭州和美国双机房部署，存在跨机房同步的业务需求，实现方式主要是基于业务<code>trigger</code>获取增量变更。从 2010 年开始，业务逐步尝试数据库日志解析获取增量变更进行同步，由此衍生出了大量的数据库增量订阅和消费业务。</p>
<p>基于日志增量订阅和消费的业务包括：</p>
<ul>
<li>数据库镜像</li>
<li>数据库实时备份</li>
<li>索引构建和实时维护（拆分异构索引、倒排索引等）</li>
<li>业务<code>Cache</code>刷新</li>
<li>带业务逻辑的增量数据处理</li>
</ul>
<h5 id="Canal的工作原理"><a href="#Canal的工作原理" class="headerlink" title="Canal的工作原理"></a>Canal的工作原理</h5><p><code>MySQL</code>主备复制原理：</p>
<p><img src="http://static.cyblogs.com/m-w-c-3.png" alt="img"></p>
<ul>
<li><code>MySQL</code>的<code>Master</code>实例将数据变更写入二进制日志（<code>binary log</code>，其中记录叫做二进制日志事件<code>binary log events</code>，可以通过<code>show binlog events</code>进行查看）</li>
<li><code>MySQL</code>的<code>Slave</code>实例将<code>master</code>的<code>binary log events</code>拷贝到它的中继日志（<code>relay log</code>）</li>
<li><code>MySQL</code>的<code>Slave</code>实例重放<code>relay log</code>中的事件，将数据变更反映它到自身的数据</li>
</ul>
<p><code>Canal</code>的工作原理如下：</p>
<ul>
<li><code>Canal</code>模拟<code>MySQL Slave</code>的交互协议，伪装自己为<code>MySQL Slave</code>，向<code>MySQL Master</code>发送<code>dump</code>协议</li>
<li><code>MySQL Master</code>收到<code>dump</code>请求，开始推送<code>binary log</code>给<code>Slave</code>（即<code>Canal</code>）</li>
<li><code>Canal</code>解析<code>binary log</code>对象（原始为<code>byte</code>流），并且可以通过连接器发送到对应的消息队列等中间件中</li>
</ul>
<h5 id="关于Canal的版本和部件"><a href="#关于Canal的版本和部件" class="headerlink" title="关于Canal的版本和部件"></a>关于Canal的版本和部件</h5><p>截止笔者开始编写本文的时候（<code>2020-03-05</code>），<code>Canal</code>的最新发布版本是<code>v1.1.5-alpha-1</code>（<code>2019-10-09</code>发布的），最新的正式版是<code>v1.1.4</code>（<code>2019-09-02</code>发布的）。其中，<code>v1.1.4</code>主要添加了鉴权、监控的功能，并且做了一些列的性能优化，此版本集成的连接器是<code>Tcp</code>、<code>Kafka</code>和<code>RockerMQ</code>。而<code>v1.1.5-alpha-1</code>版本已经新增了<code>RabbitMQ</code>连接器，但是此版本的<code>RabbitMQ</code>连接器暂时不能定义连接<code>RabbitMQ</code>的端口号，不过此问题已经在<code>master</code>分支中修复（具体可以参看源码中的<code>CanalRabbitMQProducer</code>类的提交记录）。换言之，<code>v1.1.4</code>版本中目前能使用的内置连接器只有<code>Tcp</code>、<code>Kafka</code>和<code>RockerMQ</code>三种，如果想尝鲜使用<code>RabbitMQ</code>连接器，可以选用下面的两种方式之一：</p>
<ul>
<li>选用<code>v1.1.5-alpha-1</code>版本，但是无法修改<code>RabbitMQ</code>的<code>port</code>属性，默认为<code>5672</code>。</li>
<li>基于<code>master</code>分支自行构建<code>Canal</code>。</li>
</ul>
<p>目前，<code>Canal</code>项目的活跃度比较高，但是考虑到功能的稳定性问题，笔者建议选用稳定版本在生产环境中实施，当前可以选用<code>v1.1.4</code>版本，<strong>本文的例子用选用的就是<code>v1.1.4</code>版本，配合<code>Kafka</code>连接器使用</strong>。<code>Canal</code>主要包括三个核心部件：</p>
<ul>
<li><code>canal-admin</code>：后台管理模块，提供面向<code>WebUI</code>的<code>Canal</code>管理能力。</li>
<li><code>canal-adapter</code>：适配器，增加客户端数据落地的适配及启动功能，包括<code>REST</code>、日志适配器、关系型数据库的数据同步（表对表同步）、<code>HBase</code>数据同步、<code>ES</code>数据同步等等。</li>
<li><code>canal-deployer</code>：发布器，核心功能所在，包括<code>binlog</code>解析、转换和发送报文到连接器中等等功能都由此模块提供。</li>
</ul>
<p>一般情况下，<code>canal-deployer</code>部件是必须的，其他两个部件按需选用即可。</p>
<h4 id="部署所需的中间件"><a href="#部署所需的中间件" class="headerlink" title="部署所需的中间件"></a>部署所需的中间件</h4><p>搭建一套可以用的组件需要部署<code>MySQL</code>、<code>Zookeeper</code>、<code>Kafka</code>和<code>Canal</code>四个中间件的实例，下面简单分析一下部署过程。选用的虚拟机系统是<code>CentOS7</code>。</p>
<h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><p>为了简单起见，选用<code>yum</code>源安装（官方链接是<code>https://dev.mysql.com/downloads/repo/yum</code>）：</p>
<p><img src="http://static.cyblogs.com/m-w-c-4.png" alt="img"></p>
<p>mysql80-community-release-el7-3虽然包名带了mysql80关键字，其实已经集成了MySQL主流版本5.6、5.7和8.x等等的最新安装包仓库</p>
<p>选用的是最新版的<code>MySQL8.x</code>社区版，下载<code>CentOS7</code>适用的<code>rpm包</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /data/mysql</span><br><span class="line">wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line">// 下载完毕之后</span><br><span class="line">sudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>此时列举一下<code>yum</code>仓库里面的<code>MySQL</code>相关的包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost mysql]# yum repolist all | grep mysql</span><br><span class="line">mysql-cluster-7.5-community/x86_64 MySQL Cluster 7.5 Community   disabled</span><br><span class="line">mysql-cluster-7.5-community-source MySQL Cluster 7.5 Community - disabled</span><br><span class="line">mysql-cluster-7.6-community/x86_64 MySQL Cluster 7.6 Community   disabled</span><br><span class="line">mysql-cluster-7.6-community-source MySQL Cluster 7.6 Community - disabled</span><br><span class="line">mysql-cluster-8.0-community/x86_64 MySQL Cluster 8.0 Community   disabled</span><br><span class="line">mysql-cluster-8.0-community-source MySQL Cluster 8.0 Community - disabled</span><br><span class="line">mysql-connectors-community/x86_64  MySQL Connectors Community    enabled:    141</span><br><span class="line">mysql-connectors-community-source  MySQL Connectors Community -  disabled</span><br><span class="line">mysql-tools-community/x86_64       MySQL Tools Community         enabled:    105</span><br><span class="line">mysql-tools-community-source       MySQL Tools Community - Sourc disabled</span><br><span class="line">mysql-tools-preview/x86_64         MySQL Tools Preview           disabled</span><br><span class="line">mysql-tools-preview-source         MySQL Tools Preview - Source  disabled</span><br><span class="line">mysql55-community/x86_64           MySQL 5.5 Community Server    disabled</span><br><span class="line">mysql55-community-source           MySQL 5.5 Community Server -  disabled</span><br><span class="line">mysql56-community/x86_64           MySQL 5.6 Community Server    disabled</span><br><span class="line">mysql56-community-source           MySQL 5.6 Community Server -  disabled</span><br><span class="line">mysql57-community/x86_64           MySQL 5.7 Community Server    disabled</span><br><span class="line">mysql57-community-source           MySQL 5.7 Community Server -  disabled</span><br><span class="line">mysql80-community/x86_64           MySQL 8.0 Community Server    enabled:    161</span><br><span class="line">mysql80-community-source           MySQL 8.0 Community Server -  disabled</span><br></pre></td></tr></table></figure>

<p>编辑<code>/etc/yum.repos.d/mysql-community.repo</code>文件（<code>[mysql80-community]</code>块中<code>enabled设置为1</code>，其实默认就是这样子，不用改，如果要选用<code>5.x</code>版本则需要修改对应的块）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[mysql80-community]</span><br><span class="line">name=MySQL 8.0 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-8.0-community/el/7/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></table></figure>

<p>然后安装<code>MySQL</code>服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure>

<p>这个过程比较漫长，因为需要下载和安装5个<code>rpm</code>安装包（或者是所有安装包组合的压缩包<code>mysql-8.0.18-1.el7.x86_64.rpm-bundle.tar</code>）。如果网络比较差，也可以直接从官网手动下载后安装：</p>
<p><img src="http://static.cyblogs.com/m-w-c-5.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 下载下面5个rpm包 common --&gt; libs --&gt; libs-compat --&gt; client --&gt; server</span><br><span class="line">mysql-community-common</span><br><span class="line">mysql-community-libs</span><br><span class="line">mysql-community-libs-compat</span><br><span class="line">mysql-community-client</span><br><span class="line">mysql-community-server</span><br><span class="line"></span><br><span class="line">// 强制安装</span><br><span class="line">rpm -ivh mysql-community-common-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line">rpm -ivh mysql-community-libs-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line">rpm -ivh mysql-community-libs-compat-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line">rpm -ivh mysql-community-client-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br><span class="line">rpm -ivh mysql-community-server-8.0.18-1.el7.x86_64.rpm --force --nodeps</span><br></pre></td></tr></table></figure>

<p>安装完毕之后，启动<code>MySQL</code>服务，然后搜索<code>MySQL</code>服务的<code>root</code>账号的临时密码用于首次登陆（<code>mysql -u root -p</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 启动服务，关闭服务就是service mysqld stop</span><br><span class="line">service mysqld start</span><br><span class="line">// 查看临时密码 cat /var/log/mysqld.log</span><br><span class="line">[root@localhost log]# cat /var/log/mysqld.log </span><br><span class="line">2020-03-02T06:03:53.996423Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.18) initializing of server in progress as process 22780</span><br><span class="line">2020-03-02T06:03:57.321447Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: &gt;kjYaXENK6li</span><br><span class="line">2020-03-02T06:04:00.123845Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.18) starting as process 22834</span><br><span class="line">// 登录临时root用户，使用临时密码</span><br><span class="line">[root@localhost log]# mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>接下来做下面的操作：</p>
<ul>
<li>修改<code>root</code>用户的密码：<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;QWqw12!@&#39;;</code>（注意密码规则必须包含大小写字母、数字和特殊字符）</li>
<li>更新<code>root</code>的<code>host</code>，切换数据库<code>use mysql;</code>，指定<code>host</code>为<code>%</code>以便可以让其他服务器远程访问<code>UPDATE USER SET HOST = &#39;%&#39; WHERE USER = &#39;root&#39;;</code></li>
<li>赋予<code>&#39;root&#39;@&#39;%&#39;</code>用户，所有权限，执行<code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;;</code></li>
<li>改变<code>root&#39;@&#39;%</code>用户的密码校验规则以便可以使用<code>Navicat</code>等工具访问：<code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;QWqw12!@&#39;;</code></li>
</ul>
<p><img src="http://static.cyblogs.com/m-w-c-6.png" alt="http://static.cyblogs.com/m-w-c-6.png"></p>
<p>操作完成之后，就可以使用<code>root</code>用户远程访问此虚拟机上的<code>MySQL</code>服务。最后确认是否开启了<code>binlog</code>（注意一点是<code>MySQL8.x</code>默认开启<code>binlog</code>）<code>SHOW VARIABLES LIKE &#39;%bin%&#39;;</code>：</p>
<p><img src="http://static.cyblogs.com/m-w-c-7.png" alt="http://static.cyblogs.com/m-w-c-7.png"></p>
<p>最后在<code>MySQL</code>的<code>Shell</code>执行下面的命令，新建一个用户名<code>canal</code>密码为<code>QWqw12!@</code>的新用户，赋予<code>REPLICATION SLAVE</code>和 <code>REPLICATION CLIENT</code>权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE USER canal IDENTIFIED BY 'QWqw12!@';</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'canal'@'%';</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">ALTER USER 'canal'@'%' IDENTIFIED WITH mysql_native_password BY 'QWqw12!@';</span><br></pre></td></tr></table></figure>

<p>切换回去<code>root</code>用户，创建一个数据库<code>test</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE `test` CHARSET `utf8mb4` COLLATE `utf8mb4_unicode_ci`;</span><br></pre></td></tr></table></figure>

<h5 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h5><p><code>Canal</code>和<code>Kafka</code>集群都依赖于<code>Zookeeper</code>做服务协调，为了方便管理，一般会独立部署<code>Zookeeper</code>服务或者<code>Zookeeper</code>集群。笔者这里选用<code>2020-03-04</code>发布的<code>3.6.0</code>版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">midkr /data/zk</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建数据目录</span></span><br><span class="line">midkr /data/zk/data</span><br><span class="line">cd /data/zk</span><br><span class="line">wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.6.0/apache-zookeeper-3.6.0-bin.tar.gz</span><br><span class="line">tar -zxvf apache-zookeeper-3.6.0-bin.tar.gz</span><br><span class="line">cd apache-zookeeper-3.6.0-bin/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg &amp;&amp; vim zoo.cfg</span><br></pre></td></tr></table></figure>

<p>把<code>zoo.cfg</code>文件中的<code>dataDir</code>设置为<code>/data/zk/data</code>，然后启动<code>Zookeeper</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]# sh /data/zk/apache-zookeeper-3.6.0-bin/bin/zkServer.sh start</span><br><span class="line">/usr/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /data/zk/apache-zookeeper-3.6.0-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

<p>这里注意一点，要启动此版本的<code>Zookeeper</code>服务必须本地安装好<code>JDK8+</code>，这一点需要自行处理。启动的默认端口是<code>2181</code>，启动成功后的日志如下：</p>
<p><img src="http://static.cyblogs.com/m-w-c-8.png" alt="http://static.cyblogs.com/m-w-c-8.png"></p>
<h5 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h5><p><code>Kafka</code>是一个高性能分布式消息队列中间件，它的部署依赖于<code>Zookeeper</code>。笔者在此选用<code>2.4.0</code>并且<code>Scala</code>版本为<code>2.13</code>的安装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/kafka</span><br><span class="line">mkdir /data/kafka/data</span><br><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.4.0/kafka_2.13-2.4.0.tgz</span><br><span class="line">tar -zxvf kafka_2.13-2.4.0.tgz</span><br></pre></td></tr></table></figure>

<p>由于解压后<code>/data/kafka/kafka_2.13-2.4.0/config/server.properties</code>配置中对应的<code>zookeeper.connect=localhost:2181</code>已经符合需要，不必修改，需要修改日志文件的目录<code>log.dirs</code>为<code>/data/kafka/data</code>。然后启动<code>Kafka</code>服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh /data/kafka/kafka_2.13-2.4.0/bin/kafka-server-start.sh /data/kafka/kafka_2.13-2.4.0/config/server.properties</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/m-w-c-9.png" alt="http://static.cyblogs.com/m-w-c-9.png"></p>
<p>这样启动一旦退出控制台就会结束<code>Kafka</code>进程，可以添加<code>-daemon</code>参数用于控制<code>Kafka</code>进程后台不挂断运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh /data/kafka/kafka_2.13-2.4.0/bin/kafka-server-start.sh -daemon /data/kafka/kafka_2.13-2.4.0/config/server.properties</span><br></pre></td></tr></table></figure>

<h5 id="安装和使用Canal"><a href="#安装和使用Canal" class="headerlink" title="安装和使用Canal"></a>安装和使用Canal</h5><p>终于到了主角登场，这里选用<code>Canal</code>的<code>v1.1.4</code>稳定发布版，只需要下载<code>deployer</code>模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /data/canal</span><br><span class="line">cd /data/canal</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里注意一点，Github在国内被墙，下载速度极慢，可以先用其他下载工具下载完再上传到服务器中</span></span><br><span class="line">wget https://github.com/alibaba/canal/releases/download/canal-1.1.4/canal.deployer-1.1.4.tar.gz</span><br><span class="line">tar -zxvf canal.deployer-1.1.4.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压后的目录如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- bin   # 运维脚本</span><br><span class="line">- conf  # 配置文件</span><br><span class="line">  canal_local.properties  # canal本地配置，一般不需要动</span><br><span class="line">  canal.properties        # canal服务配置</span><br><span class="line">  logback.xml             # logback日志配置</span><br><span class="line">  metrics                 # 度量统计配置</span><br><span class="line">  spring                  # spring-实例配置，主要和binlog位置计算、一些策略配置相关，可以在canal.properties选用其中的任意一个配置文件</span><br><span class="line">  example                 # 实例配置文件夹，一般认为单个数据库对应一个独立的实例配置文件夹</span><br><span class="line">    instance.properties   # 实例配置，一般指单个数据库的配置</span><br><span class="line">- lib   # 服务依赖包</span><br><span class="line">- logs  # 日志文件输出目录</span><br></pre></td></tr></table></figure>

<p>在开发和测试环境建议把<code>logback.xml</code>的日志级别修改为<code>DEBUG</code>方便定位问题。这里需要关注<code>canal.properties</code>和<code>instance.properties</code>两个配置文件。<code>canal.properties</code>文件中，需要修改：</p>
<ul>
<li>去掉<code>canal.instance.parser.parallelThreadSize = 16</code>这个配置项的<strong>注释</strong>，也就是启用此配置项，和实例解析器的线程数相关，不配置会表现为阻塞或者不进行解析。</li>
<li><code>canal.serverMode</code>配置项指定为<code>kafka</code>，可选值有<code>tcp</code>、<code>kafka</code>和<code>rocketmq</code>（<code>master</code>分支或者最新的的<code>v1.1.5-alpha-1</code>版本，可以选用<code>rabbitmq</code>），默认是<code>kafka</code>。</li>
<li><code>canal.mq.servers</code>配置需要指定为<code>Kafka</code>服务或者集群<code>Broker</code>的地址，这里配置为<code>127.0.0.1:9092</code>。</li>
</ul>
<blockquote>
<p>canal.mq.servers在不同的canal.serverMode有不同的意义。<br>kafka模式下，指Kafka服务或者集群Broker的地址，也就是bootstrap.servers<br>rocketmq模式下，指NameServer列表<br>rabbitmq模式下，指RabbitMQ服务的Host和Port</p>
</blockquote>
<p>其他配置项可以参考下面两个官方<code>Wiki</code>的链接：</p>
<ul>
<li><a href="https://github.com/alibaba/canal/wiki/Canal-Kafka-RocketMQ-QuickStart" target="_blank" rel="noopener">Canal-Kafka-RocketMQ-QuickStart</a></li>
<li><a href="https://github.com/alibaba/canal/wiki/AdminGuide" target="_blank" rel="noopener">AdminGuide</a></li>
</ul>
<p><code>instance.properties</code>一般指一个数据库实例的配置，<code>Canal</code>架构支持一个<code>Canal</code>服务实例，处理多个数据库实例的<code>binlog</code>异步解析。<code>instance.properties</code>需要修改的配置项主要包括：</p>
<ul>
<li><p><code>canal.instance.mysql.slaveId</code>需要配置一个和<code>Master</code>节点的服务<code>ID</code>完全不同的值，这里笔者配置为<code>654321</code>。</p>
</li>
<li><p>配置数据源实例，包括地址、用户、密码和目标数据库：</p>
<ul>
<li><code>canal.instance.master.address</code>，这里指定为<code>127.0.0.1:3306</code>。</li>
<li><code>canal.instance.dbUsername</code>，这里指定为<code>canal</code>。</li>
<li><code>canal.instance.dbPassword</code>，这里指定为<code>QWqw12!@</code>。</li>
<li>新增<code>canal.instance.defaultDatabaseName</code>，这里指定为<code>test</code>（需要在<code>MySQL</code>中建立一个<code>test</code>数据库，见前面的流程）。</li>
</ul>
</li>
<li><p><code>Kafka</code>相关配置，这里暂时使用静态<code>topic</code>和单个<code>partition</code>：</p>
</li>
<li><p><code>canal.mq.topic</code>，这里指定为<code>test</code>，<strong>也就是解析完的<code>binlog</code>结构化数据会发送到<code>Kafka</code>的命名为<code>test</code>的<code>topic</code>中</strong>。</p>
<ul>
<li><code>canal.mq.partition</code>，这里指定为<code>0</code>。</li>
</ul>
</li>
</ul>
<p>配置工作做好之后，可以启动<code>Canal</code>服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh /data/canal/bin/startup.sh </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看服务日志</span></span><br><span class="line">tail -100f /data/canal/logs/canal/canal</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看实例日志  -- 一般情况下，关注实例日志即可</span></span><br><span class="line">tail -100f /data/canal/logs/example/example.log</span><br></pre></td></tr></table></figure>

<p>启动正常后，见实例日志如下：</p>
<p><img src="http://static.cyblogs.com/m-w-c-10.png" alt="http://static.cyblogs.com/m-w-c-10.png"></p>
<p>在<code>test</code>数据库创建一个订单表，并且执行几个简单的<code>DML</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="string">`test`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order`</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>          <span class="built_in">BIGINT</span> <span class="keyword">UNIQUE</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">    order_id    <span class="built_in">VARCHAR</span>(<span class="number">64</span>)    <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单ID'</span>,</span><br><span class="line">    amount      <span class="built_in">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'订单金额'</span>,</span><br><span class="line">    create_time DATETIME       <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> uniq_order_id (<span class="string">`order_id`</span>)</span><br><span class="line">) <span class="keyword">COMMENT</span> <span class="string">'订单表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`order`</span>(order_id, amount) <span class="keyword">VALUES</span> (<span class="string">'10086'</span>, <span class="number">999</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="string">`order`</span> <span class="keyword">SET</span> amount = <span class="number">10087</span> <span class="keyword">WHERE</span> order_id = <span class="string">'10086'</span>;</span><br><span class="line"><span class="keyword">DELETE</span>  <span class="keyword">FROM</span> <span class="string">`order`</span> <span class="keyword">WHERE</span> order_id = <span class="string">'10086'</span>;</span><br></pre></td></tr></table></figure>

<p>这个时候，可以利用<code>Kafka</code>的<code>kafka-console-consumer</code>或者<code>Kafka Tools</code>查看<code>test</code>这个<code>topic</code>的数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh /data/kafka/kafka_2.13-2.4.0/bin/kafka-console-consumer.sh --bootstrap-server 127.0.0.1:9092 --from-beginning --topic test</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/m-w-c-11.png" alt="http://static.cyblogs.com/m-w-c-11.png"></p>
<p>具体的数据如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// test数据库建库脚本</span><br><span class="line">&#123;"data":null,"database":"`test`","es":1583143732000,"id":1,"isDdl":false,"mysqlType":null,"old":null,"pkNames":null,"sql":"CREATE DATABASE `test` CHARSET `utf8mb4` COLLATE `utf8mb4_unicode_ci`","sqlType":null,"table":"","ts":1583143930177,"type":"QUERY"&#125;</span><br><span class="line"></span><br><span class="line">// order表建表DDL</span><br><span class="line">&#123;"data":null,"database":"test","es":1583143957000,"id":2,"isDdl":true,"mysqlType":null,"old":null,"pkNames":null,"sql":"CREATE TABLE `order`\n(\n    id          BIGINT UNIQUE PRIMARY KEY AUTO_INCREMENT COMMENT '主键',\n    order_id    VARCHAR(64)    NOT NULL COMMENT '订单ID',\n    amount      DECIMAL(10, 2) NOT NULL DEFAULT 0 COMMENT '订单金额',\n    create_time DATETIME       NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    UNIQUE uniq_order_id (`order_id`)\n) COMMENT '订单表'","sqlType":null,"table":"order","ts":1583143958045,"type":"CREATE"&#125;</span><br><span class="line"></span><br><span class="line">// INSERT</span><br><span class="line">&#123;"data":[&#123;"id":"1","order_id":"10086","amount":"999.0","create_time":"2020-03-02 05:12:49"&#125;],"database":"test","es":1583143969000,"id":3,"isDdl":false,"mysqlType":&#123;"id":"BIGINT","order_id":"VARCHAR(64)","amount":"DECIMAL(10,2)","create_time":"DATETIME"&#125;,"old":null,"pkNames":["id"],"sql":"","sqlType":&#123;"id":-5,"order_id":12,"amount":3,"create_time":93&#125;,"table":"order","ts":1583143969460,"type":"INSERT"&#125;</span><br><span class="line"></span><br><span class="line">// UPDATE</span><br><span class="line">&#123;"data":[&#123;"id":"1","order_id":"10086","amount":"10087.0","create_time":"2020-03-02 05:12:49"&#125;],"database":"test","es":1583143974000,"id":4,"isDdl":false,"mysqlType":&#123;"id":"BIGINT","order_id":"VARCHAR(64)","amount":"DECIMAL(10,2)","create_time":"DATETIME"&#125;,"old":[&#123;"amount":"999.0"&#125;],"pkNames":["id"],"sql":"","sqlType":&#123;"id":-5,"order_id":12,"amount":3,"create_time":93&#125;,"table":"order","ts":1583143974870,"type":"UPDATE"&#125;</span><br><span class="line"></span><br><span class="line">// DELETE</span><br><span class="line">&#123;"data":[&#123;"id":"1","order_id":"10086","amount":"10087.0","create_time":"2020-03-02 05:12:49"&#125;],"database":"test","es":1583143980000,"id":5,"isDdl":false,"mysqlType":&#123;"id":"BIGINT","order_id":"VARCHAR(64)","amount":"DECIMAL(10,2)","create_time":"DATETIME"&#125;,"old":null,"pkNames":["id"],"sql":"","sqlType":&#123;"id":-5,"order_id":12,"amount":3,"create_time":93&#125;,"table":"order","ts":1583143981091,"type":"DELETE"&#125;</span><br></pre></td></tr></table></figure>

<p>可见<code>Kafka</code>的名为<code>test</code>的<code>topic</code>已经写入了对应的结构化<code>binlog</code>事件数据，可以编写消费者监听<code>Kafka</code>对应的<code>topic</code>然后对获取到的数据进行后续处理。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这篇文章大部分篇幅用于介绍其他中间件是怎么部署的，这个问题侧面说明了<code>Canal</code>本身部署并不复杂，它的配置文件属性项比较多，但是实际上需要自定义和改动的配置项是比较少的，也就是说明了它的运维成本和学习成本并不高。后面会分析基于结构化<code>binlog</code>事件做<code>ELT</code>和持久化相关工作以及<code>Canal</code>的生产环境可用级别<code>HA</code>集群的搭建。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="http://www.throwable.club/2020/03/07/canal-kafka-mysql-binlog-sync-guide/" target="_blank" rel="noopener">http://www.throwable.club/2020/03/07/canal-kafka-mysql-binlog-sync-guide/</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Canal</category>
        <category>Kafka</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>Canal</tag>
      </tags>
  </entry>
  <entry>
    <title>理解数据仓库中星型模型和雪花模型</title>
    <url>/2020/03/03/2020/03/%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%AD%E6%98%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B%E5%92%8C%E9%9B%AA%E8%8A%B1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在数据仓库的建设中，一般都会围绕着星型模型和雪花模型来设计表关系或者结构。下面我们先来理解这两种模型的概念。</p>
<h4 id="星型模型"><a href="#星型模型" class="headerlink" title="星型模型"></a>星型模型</h4><p><img src="http://static.cyblogs.com/1345516634_6388.jpg" alt="http://static.cyblogs.com/1345516634_6388.jpg"></p>
<p>​        星型模是一种多维的数据关系，它由一个事实表和一组维表组成。每个维表都有一个维作为主键，所有这些维的主键组合成事实表的主键。强调的是对维度进行预处理，将多个维度集合到一个事实表，形成一个宽表。这也是我们在使用hive时，经常会看到一些大宽表的原因，大宽表一般都是事实表，包含了维度关联的主键和一些度量信息，而维度表则是事实表里面维度的具体信息，使用时候一般通过join来组合数据，相对来说对OLAP的分析比较方便。</p>
<h4 id="雪花模型"><a href="#雪花模型" class="headerlink" title="雪花模型"></a>雪花模型</h4><p><img src="http://static.cyblogs.com/1345516734_4305.jpg" alt="http://static.cyblogs.com/1345516734_4305.jpg"></p>
<p>​        当有一个或多个维表没有直接连接到事实表上，而是通过其他维表连接到事实表上时，其图解就像多个雪花连接在一起，故称雪花模型。雪花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的 “层次 “ 区域，这些被分解的表都连接到主维度表而不是事实表。雪花模型更加符合数据库范式，减少数据冗余，但是在分析数据的时候，操作比较复杂，需要join的表比较多所以其性能并不一定比星型模型高。</p>
<h4 id="星型模型和雪花模型对比"><a href="#星型模型和雪花模型对比" class="headerlink" title="星型模型和雪花模型对比"></a>星型模型和雪花模型对比</h4><table>
<thead>
<tr>
<th>属性</th>
<th>星型模型</th>
<th>雪花模型</th>
</tr>
</thead>
<tbody><tr>
<td>数据总量</td>
<td>多</td>
<td>少</td>
</tr>
<tr>
<td>可读性</td>
<td>容易</td>
<td>差</td>
</tr>
<tr>
<td>表个数</td>
<td>少</td>
<td>多</td>
</tr>
<tr>
<td>查询速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>冗余度</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>对实时表的情况</td>
<td>增加宽度</td>
<td>字段比较少，冗余底</td>
</tr>
<tr>
<td>扩展性</td>
<td>差</td>
<td>好</td>
</tr>
</tbody></table>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>​        星型模型的设计方式主要带来的好处是能够提升查询效率，因为生成的事实表已经经过预处理，主要的数据都在事实表里面，所以只要扫描实时表就能够进行大量的查询，而不必进行大量的join，其次维表数据一般比较少，在join可直接放入内存进行join以提升效率，除此之外，星型模型的事实表可读性比较好，不用关联多个表就能获取大部分核心信息，设计维护相对比较简答。</p>
<p>雪花模型的设计方式是比较符合数据库范式的理念，设计方式比较正规，数据冗余少，但在查询的时候可能需要join多张表从而导致查询效率下降，此外规范化操作在后期维护比较复杂。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        通过上面的对比，我们可以发现数据仓库大多数时候是比较适合使用星型模型构建底层数据Hive表，通过大量的冗余来提升查询效率，星型模型对OLAP的分析引擎支持比较友好，这一点在Kylin中比较能体现。而雪花模型在关系型数据库中如MySQL，Oracle中非常常见，尤其像电商的数据库表。在数据仓库中雪花模型的应用场景比较少，但也不是没有，所以在具体设计的时候，可以考虑是不是能结合两者的优点参与设计，以此达到设计的最优化目的。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/u010454030/article/details/74589791" target="_blank" rel="noopener">https://blog.csdn.net/u010454030/article/details/74589791</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析CMS垃圾收集器原理</title>
    <url>/2020/03/05/2020/03/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>前文已经讲过，<code>CMS</code>是老年代垃圾收集器，在收集过程中可以与用户线程并发操作。它可以与<code>Serial</code>收集器和<code>Parallel New</code>收集器搭配使用。<code>CMS</code>牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。</p>
<h4 id="CMS相关参数"><a href="#CMS相关参数" class="headerlink" title="CMS相关参数"></a>CMS相关参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>默认值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>boolean</td>
<td>false</td>
<td>老年代采用CMS收集器收集</td>
</tr>
<tr>
<td>–XX:ParallelGCThreads=n</td>
<td>int</td>
<td>(ncpus &lt;= 8) ? ncpus : 3 + ((ncpus * 5) / 8)</td>
<td>老年代采用CMS收集器收集</td>
</tr>
<tr>
<td>-XX:CMSInitiatingOccupancyFraction</td>
<td>int</td>
<td>92</td>
<td>年代堆空间的使用率。比如value=75意味着第一次CMS垃圾收集会在老年代被占用75%时被触发。</td>
</tr>
<tr>
<td>-XX：+UseCMSInitiatingOccupancyOnly</td>
<td>boolean</td>
<td>false</td>
<td>只用设定的回收阈值(上面指定的70%),如果不指定,JVM仅在第一次使用设定值,后续则自动调整</td>
</tr>
</tbody></table>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><h5 id="周期性GC"><a href="#周期性GC" class="headerlink" title="周期性GC"></a>周期性GC</h5><p>由后台线程<code>ConcurrentMarkSweepThread</code>循环判断（默认2s）是否需要触发。</p>
<p>如果没有设置<code>-XX:+UseCMSInitiatingOccupancyOnly</code>，虚拟机会根据收集的数据决定是否触发<br>老年代使用率达到阈值 <code>CMSInitiatingOccupancyFraction</code>，默认92%。<br>永久代的使用率达到阈值 <code>CMSInitiatingPermOccupancyFraction</code>，默认92%，前提是开启 <code>CMSClassUnloadingEnabled</code>。<br>新生代的晋升担保失败。</p>
<h5 id="主动触发"><a href="#主动触发" class="headerlink" title="主动触发"></a>主动触发</h5><p><code>YGC</code>过程发生<code>Promotion Failed</code>，进而对老年代进行回收<br>比如执行了<code>System.gc()</code>，前提是没有参数<code>ExplicitGCInvokesConcurrent</code></p>
<h4 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h4><h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><p>这是<code>CMS</code>中两次<code>stop-the-world</code>事件中的一次。这一步的作用是标记存活的对象，有两部分：</p>
<p>标记老年代中所有的<code>GC Roots</code>对象<br>标记年轻代中活着的对象引用到的老年代的对象</p>
<p><code>CMS-initial-mark：961330K（1572864K）</code>指标记时老年代的已用空间和总空间</p>
<h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><p>该阶段<code>GC</code>线程和应用线程并发执行，遍历<code>InitialMarking</code>阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: 2.787/3.329 secs] [Times: user=12.12 sys=0.64, real=3.33 secs]</span><br></pre></td></tr></table></figure>

<p>第一行<code>CMS-concurrent-mark-start</code>标识标记阶段开始。第二行中的“2.787/3.329 secs”表示标记阶段的耗时。<br>表示花费了2.787cpu时间，3.329系统时间。</p>
<h5 id="预清理阶段"><a href="#预清理阶段" class="headerlink" title="预清理阶段"></a>预清理阶段</h5><p>由于在并发标记阶段，应用线程和<code>GC</code>线程是并发执行的，因此可能产生新的对象或对象关系发生变化，例如：</p>
<p>新生代的对象晋升到老年代；<br>直接在老年代分配对象；<br>老年代对象的引用关系发生变更；</p>
<p><img src="http://static.cyblogs.com/20190702174034511.png" alt="http://static.cyblogs.com/20190702174034511.png"></p>
<p>该阶段会把上述对象所在的<code>Card</code>标识为<code>Dirty</code>，后续只需扫描这些<code>Dirty Card</code>的对象，避免扫描整个老年代。<br>标记<code>dirty card</code> 能够到达的对象</p>
<p><img src="http://static.cyblogs.com/20190702180248905.png" alt="http://static.cyblogs.com/20190702180248905.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: 0.342/0.477 secs] [Times: user=1.79 sys=0.10, real=0.48 secs]</span><br></pre></td></tr></table></figure>

<h5 id="可终止的预处理"><a href="#可终止的预处理" class="headerlink" title="可终止的预处理"></a>可终止的预处理</h5><p>该阶段发生的前提是，新生代<code>Eden</code>区的内存使用量大于参数<code>CMSScheduleRemarkEdenSizeThreshold</code> 默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段。<br>在该阶段，主要循环的做两件事：</p>
<p>处理 <code>From</code> 和 <code>To</code> 区的对象，标记可达的老年代对象<br>和上一个阶段一样，扫描处理<code>Dirty Card</code>中的对象</p>
<h5 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h5><p>暂停所有用户线程，重新扫描堆中的对象，进行可达性分析,标记活着的对象。有了前面的基础，这个阶段的工作量被大大减轻，停顿时间因此也会减少。注意这个阶段是多线程的。</p>
<p>遍历新生代对象，重新标记<br>根据<code>GC Roots</code>，重新标记<br>遍历老年代的<code>Dirty Card</code>，重新标记，这里的<code>Dirty Card</code>大部分已经在<code>clean</code>阶段处理过</p>
<h5 id="并发清理"><a href="#并发清理" class="headerlink" title="并发清理"></a>并发清理</h5><p>通过以上5个阶段的标记，老年代所有存活的对象已经被标记并且现在要通过<code>Garbage Collector</code>采用清扫的方式回收那些不能用的对象了。<br>这个阶段主要是清除那些没有标记的对象并且回收空间；<br>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><h5 id="减少remark阶段停顿"><a href="#减少remark阶段停顿" class="headerlink" title="减少remark阶段停顿"></a>减少remark阶段停顿</h5><p>一般<code>CMS</code>的<code>GC</code>耗时80%都在remark阶段，如果发现<code>remark</code>阶段停顿时间很长，可以尝试添加该参数：<br><code>-XX:+CMSScavengeBeforeRemark</code>。在执行<code>remark</code>操作之前先做一次<code>Young GC</code>，目的在于减少年轻代对老年代的无效引用，降低<code>remark</code>时的开销。</p>
</li>
<li><h5 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h5><p><code>CMS</code>是基于标记-清除算法的，<code>CMS</code>只会删除无用对象，不会对内存做压缩，会造成内存碎片，这时候我们需要用到这个参数：<code>-XX:CMSFullGCsBeforeCompaction=n</code><br>意思是说在上一次<code>CMS</code>并发<code>GC</code>执行过后，到底还要再执行多少次<code>full GC</code>才会做压缩。默认是0</p>
</li>
<li><h5 id="Concurrent-mode-failure"><a href="#Concurrent-mode-failure" class="headerlink" title="Concurrent mode failure"></a>Concurrent mode failure</h5><p>这个异常发生在cms正在回收的时候。执行<code>CMS GC</code>的过程中，同时业务线程也在运行，当年轻带空间满了，执行<code>YGC</code>时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时<code>CMS</code>还没有机会回收老年带产生的，或者在做<code>Minor GC</code>的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。</p>
</li>
</ol>
<ul>
<li><p>过早提升与提升失败<br>在 <code>Minor GC</code> 过程中，<code>Survivor Unused</code> 可能不足以容纳 <code>Eden</code> 和另一个 <code>Survivor</code> 中的存活对象， 那么多余的将被移到老年代， 称为过早提升（<code>Premature Promotion</code>）,这会导致老年代中短期存活对象的增长， 可能会引发严重的性能问题。 再进一步，如果老年代满了， <code>Minor GC</code> 后会进行 <code>Full GC</code>， 这将导致遍历整个堆， 称为提升失败（<code>Promotion Failure</code>）。</p>
</li>
<li><p>早提升的原因<br><code>Survivor</code>空间太小，容纳不下全部的运行时短生命周期的对象，如果是这个原因，可以尝试将<code>Survivor</code>调大，否则端生命周期的对象提升过快，导致老年代很快就被占满，从而引起频繁的<code>full gc</code>；<br>对象太大，<code>Survivor</code>和<code>Eden</code>没有足够大的空间来存放这些大对象。</p>
</li>
<li><p>提升失败原因<br>当提升的时候，发现老年代也没有足够的连续空间来容纳该对象。为什么是没有足够的连续空间而不是空闲空间呢？老年代容纳不下提升的对象有两种情况：</p>
<ul>
<li>老年代空闲空间不够用了；</li>
<li>老年代虽然空闲空间很多，但是碎片太多，没有连续的空闲空间存放该对象。</li>
</ul>
</li>
<li><p>解决方法<br>如果是因为内存碎片导致的大对象提升失败，cms需要进行空间整理压缩；<br>如果是因为提升过快导致的，说明Survivor 空闲空间不足，那么可以尝试调大 Survivor；<br>如果是因为老年代空间不够导致的，尝试将CMS触发的阈值调低。</p>
</li>
</ul>
<p>REF：<a href="https://juejin.im/post/5c39920b6fb9a049e82bbf94" target="_blank" rel="noopener">https://juejin.im/post/5c39920b6fb9a049e82bbf94</a></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/TheLudlows/article/details/93140810" target="_blank" rel="noopener">https://blog.csdn.net/TheLudlows/article/details/93140810</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Spring Cloud源码篇之Feign源码</title>
    <url>/2020/03/06/2020/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%20cloud%E6%BA%90%E7%A0%81%E7%AF%87%E4%B9%8BFeign%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h4 id="Feign简介"><a href="#Feign简介" class="headerlink" title="Feign简介"></a>Feign简介</h4><p>​       在上一篇文章中分析了<code>Eureka</code>的注册、续约、服务剔除、服务自我保护等机制，地址在<a href="https://blog.csdn.net/lgq2626/article/details/80288992" target="_blank" rel="noopener">https://blog.csdn.net/lgq2626/article/details/80288992</a> 。这篇分析<code>SpringCloud</code>的<code>feign</code>。<code>SpringCloud</code>微服务项目之间调用是通过httprest请求来进行服务调用的，之前我们会用到<code>HttpClient</code>等工具来进行服务请求，<code>Spring</code>对这种请求进行了处理，封装成了可声明式的<code>web</code>客户端，使得编写web客户端更容易，<code>feign</code>还支持可插拔的编码器和解码器，<code>Spring</code>在用的时候增加了对<code>@requestMapping</code>的处理，同时，<code>SpringCloud</code>还对<code>feign</code>集成了注册中心<code>（eureka）</code>和客户端负载均衡<code>（ribbon）</code>，使得我们拥有一个客户端负载均衡的<code>web</code>请求客户端。</p>
<h4 id="Feign在项目中的配置和使用"><a href="#Feign在项目中的配置和使用" class="headerlink" title="Feign在项目中的配置和使用"></a>Feign在项目中的配置和使用</h4><p>​       在Springcloud中使用feign的时候，需要在配置类中加入一个@EnableFeignClients注解。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span><span class="comment">//springboot 启动类</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span><span class="comment">//开启eureka扫描</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//开启eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>配置feign调用客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"xxx-server"</span>,configuration = FeignConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">ConsumerSmsService</span> <span class="keyword">extends</span> <span class="title">SMSService</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/sms/smsMessage"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function">RespSMSDto <span class="title">sendSms</span><span class="params">(ReqSMSDto smsReqDto)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>经过上面的配置，直接在项目里面注入容器调用接口就可以了。</p>
<h4 id="Feign源码分析"><a href="#Feign源码分析" class="headerlink" title="Feign源码分析"></a>Feign源码分析</h4><p>​       在<code>@EnableFeignClients</code>标签中，<code>import</code>了一个<code>FeignClientsRegistrar</code>类，那么这个<code>FeignClientsRegistrar#registerBeanDefinitions()</code>在什么时候调用的呢？跟着<code>Spring</code>的源码走下去，看过源码的人都会直接看到<code>AbstractApplicationContext#refresh()</code>方法，整体整理一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">				<span class="comment">// 扫描本项目里面的java文件，把bean对象封装成BeanDefinitiaon对象，然后调用DefaultListableBeanFactory#registerBeanDefinition()方法把beanName放到DefaultListableBeanFactory 的 List&lt;String&gt; beanDefinitionNames 中去</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在这里调用到FeignClientsRegistrar对象的registerBeanDefinitions()方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从DefaultListableBeanFactory里面的beanDefinitionNames中找到所有实现了BeanPostProcessor接口的方法，如果有排序进行排序后放到list中</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Spring的国际化</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Spring的IOC、ID处理。Spring的AOP。事务都是在IOC完成之后调用了BeanPostProcessor#postProcessBeforeInitialization()和postProcessBeforeInitialization()方法，AOP(事务)就是在这里处理的</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行完之后调用实现了所有LifecycleProcessor接口的类的onRefresh()方法，同时调用所有观察了ApplicationEvent接口的事件(观察者模式)</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到所有实现了DisposableBean接口的方法，调用了destroy()方法，这就是bean的销毁</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        根据上面整理的代码发现，<code>FeignClientsRegistrar#registerBeanDefinitions()</code>方法是在扫描完<code>bean</code>之后，只放了一个<code>beanname</code>的情况下， 并没有进行<code>IOC</code>注册的时候调用的，这就是<code>Spring</code>动态扩展<code>Bean</code>，实现<code>BeanDefinitionRegistryPostProcessor</code>接口的所有方法也会在这里调用下<code>postProcessBeanDefinitionRegistry()</code>方法。关于<code>Spring</code>的东西就分析到这里。下面回到正题，分析<code>FeignClientsRegistrar#registerBeanDefinitions()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    registerDefaultConfiguration(metadata, registry);<span class="comment">//扫描EnableFeignClients标签里配置的信息，注册到beanDefinitionNames中。</span></span><br><span class="line">    registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(FeignClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//省略代码...根据EnableFeignClients配置的basePackages找到包下所有FeignClient注解的类，Spring的Commponet也是这么干的</span></span><br><span class="line">		<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">				Set&lt;BeanDefinition&gt; candidateComponents = scanner.findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">                    AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                    AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">                    Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">                            <span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line"> 										Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                        .getAnnotationAttributes(</span><br><span class="line">                                FeignClient<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line"></span><br><span class="line">                String name = getClientName(attributes);</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 关键地方：Feign子容器概念：</span></span><br><span class="line"><span class="comment">                 * 在注入FeignAutoConfiguration类的时候，注入了一个FeignContext对象，这个就是Feign的子容器。</span></span><br><span class="line"><span class="comment">                 * 这里面装了List&lt;FeignClientSpecification&gt;对象，FeignClientSpecification对象的实质就是在<span class="doctag">@feignClient</span>上配置的name为key，value为configuration对象的值</span></span><br><span class="line"><span class="comment">                 * 比如feignclient 这样配置的<span class="doctag">@FeignClient</span>(url="https://api.weixin.qq.com",name="$&#123;usercenter.name&#125;", configuration = UserCenterFeignConfiguration.class, primary= false)</span></span><br><span class="line"><span class="comment">                 * 那么在FeignContext中就会出现一个FeignClientSpecification&#123;name='sms-server', configuration=[class com.jfbank.sms.configuration.FeignConfiguration]&#125;这样的数据。</span></span><br><span class="line"><span class="comment">                 *  这个地方比较关键，主要是因为后期对feign客户端的编码解码会用到自定义的类</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//这个方法就是在ioc容器中塞入一个FeignClientSpecification对象，从而构建FeignContext子容器。</span></span><br><span class="line">                registerClientConfiguration(registry, name,</span><br><span class="line">                        attributes.get(<span class="string">"configuration"</span>));       </span><br><span class="line">                <span class="comment">//重点分析这个</span></span><br><span class="line">                registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry, AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    String className = annotationMetadata.getClassName();</span><br><span class="line">    BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//对FeignClientFactoryBean对象生成一个BeanDefinition对象</span></span><br><span class="line">    ...读取配置</span><br><span class="line">    String alias = name + <span class="string">"FeignClient"</span>;</span><br><span class="line">    AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> primary = (Boolean)attributes.get(<span class="string">"primary"</span>); <span class="comment">// has a default, won't be null</span></span><br><span class="line"></span><br><span class="line">    beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">    String qualifier = getQualifier(attributes);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">        alias = qualifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">            <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">    <span class="comment">//注册到beanDefinitionNames中对象</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        读过Dubbo源码的同学都知道，当在<code>DubboNamespaceHandler</code>中解析<code>reference</code>标签的时候，传入了一个<code>ReferenceBean</code>对象，把<code>xml</code>中配置的属性都塞到这个对象上，也是装到了<code>beanDefinitionNames</code>中，然后发现<code>ReferenceBean</code>类和<code>FeignClientFactoryBean</code>都实现了<code>FactoryBean</code>的接口，并且里面都有<code>getObject()</code>和<code>getObjectType()</code>方法。当接口调用到这个<code>feign</code>客户端的时候，会从<code>IOC</code>中读取这个<code>FeignClientFactoryBean</code>并且调用<code>getObject</code>方法。下面就是分析<code>getObject</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FeignContext context = applicationContext.getBean(FeignContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//从上文中的子容器中获取编码器，解码器等自定义类，然后封装一个Feign.Builder类</span></span><br><span class="line">        Feign.Builder builder = feign(context);</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;<span class="comment">//当@FeignClient没有配置url的时候</span></span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">            url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            url = <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">        url += cleanPath();</span><br><span class="line">        <span class="keyword">return</span> loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type,</span><br><span class="line">                <span class="keyword">this</span>.name, url));<span class="comment">//集成了ribbon客户端负载均衡,下一篇分析</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当@FeignClient配置了url的时候</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">    &#125;</span><br><span class="line">    String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">    Client client = getOptional(context, Client<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) &#123;</span><br><span class="line">            <span class="comment">// not lod balancing because we have a url,</span></span><br><span class="line">            <span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">            client = ((LoadBalancerFeignClient)client).getDelegate();</span><br><span class="line">        &#125;</span><br><span class="line">        builder.client(client);</span><br><span class="line">    &#125;</span><br><span class="line">    Targeter targeter = get(context, Targeter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看配置了<code>url</code>的，指定了<code>url</code>的<code>feignclient</code>解析，一直跟着代码跟到了<code>Feign.Builder#target()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Feign <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =</span><br><span class="line">      <span class="keyword">new</span> SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,</span><br><span class="line">                                           logLevel, decode404);</span><br><span class="line">  ParseHandlersByName handlersByName =</span><br><span class="line">      <span class="keyword">new</span> ParseHandlersByName(contract, options, encoder, decoder,</span><br><span class="line">                              errorDecoder, synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveFeign(handlersByName, invocationHandlerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接看<code>ReflectiveFeign#newInstance()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ReflectiveFeign#newInstance()</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//动态代理的handler类目前穿进来的是ParseHandlersByName类，所以这里要看ParseHandlersByName#apply()直接看下一个方法</span></span><br><span class="line">	Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">	Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">	List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Util.isDefault(method)) &#123;<span class="comment">//默认方法会走到这里，比如toString()，hashCode()等方法</span></span><br><span class="line">      DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">      defaultMethodHandlers.add(handler);</span><br><span class="line">      methodToHandler.put(method, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//这里才是装配的调用类，上文分析到计息的handler是SynchronousMethodHandler#invoke()</span></span><br><span class="line">      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);<span class="comment">//jdk动态代理</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">    defaultMethodHandler.bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ParseHandlersByName#apply类，构建动态代理的handler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, MethodHandler&gt; <span class="title">apply</span><span class="params">(Target key)</span> </span>&#123;</span><br><span class="line">    List&lt;MethodMetadata&gt; metadata = contract.parseAndValidatateMetadata(key.type());</span><br><span class="line">    Map&lt;String, MethodHandler&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, MethodHandler&gt;();</span><br><span class="line">    <span class="keyword">for</span> (MethodMetadata md : metadata) &#123;</span><br><span class="line">      BuildTemplateByResolvingArgs buildTemplate;</span><br><span class="line">      <span class="keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> BuildFormEncodedTemplateFromArgs(md, encoder);<span class="comment">//通过自定义的encoder去解析参数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (md.bodyIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> BuildEncodedTemplateFromArgs(md, encoder);<span class="comment">//通过自定义的encoder去解析参数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buildTemplate = <span class="keyword">new</span> BuildTemplateByResolvingArgs(md);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建handler，再看Factory#create()方法，下一个方法</span></span><br><span class="line">      result.put(md.configKey(),factory.create(key, md, buildTemplate, options, decoder, errorDecoder));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//Factory#create(),构建一个SynchronousMethodHandler去处理请求，调用invoke方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodHandler <span class="title">create</span><span class="params">(Target&lt;?&gt; target, MethodMetadata md,</span></span></span><br><span class="line"><span class="function"><span class="params">        RequestTemplate.Factory buildTemplateFromArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        Options options, Decoder decoder, ErrorDecoder errorDecoder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SynchronousMethodHandler(target, client, retryer, requestInterceptors, logger,</span><br><span class="line">                  logLevel, md, buildTemplateFromArgs, options, decoder,</span><br><span class="line">                  errorDecoder, decode404);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SynchronousMethodHandler#invoke()方法：实际调用的方法</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    RequestTemplate template = buildTemplateFromArgs.create(argv);<span class="comment">//构建requestTemplate对象</span></span><br><span class="line">    Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> executeAndDecode(template);<span class="comment">//下面不分析了，就是执行execute方法并且解码饭后返回值</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">        retryer.continueOrPropagate(e);</span><br><span class="line">        <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">          logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Feign源码总结"><a href="#Feign源码总结" class="headerlink" title="Feign源码总结"></a>Feign源码总结</h4><p> 从读取注解到注入IOC容器，再到编码参数，发起请求，解码结果，整个封装过程都对我们开发带来了极大得便利，此文只是分析了feign带有url参数得解析方式，集成eureka和ribbon的在<a href="https://blog.csdn.net/lgq2626/article/details/80481514中做了分析。下面流程图总结下流程：" target="_blank" rel="noopener">https://blog.csdn.net/lgq2626/article/details/80481514中做了分析。下面流程图总结下流程：</a><br><img src="http://static.cyblogs.com/20180525131939613.png" alt="http://static.cyblogs.com/20180525131939613.png"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/lgq2626/article/details/80392914" target="_blank" rel="noopener">https://blog.csdn.net/lgq2626/article/details/80392914</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>聚集索引和非聚集索引简析与对比</title>
    <url>/2020/03/02/2020/03/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%AE%80%E6%9E%90%E4%B8%8E%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h4 id="聚集（clustered）索引，也叫聚簇索引"><a href="#聚集（clustered）索引，也叫聚簇索引" class="headerlink" title="聚集（clustered）索引，也叫聚簇索引"></a>聚集（clustered）索引，也叫聚簇索引</h4><p>定义：数据行的<strong>物理顺序</strong>与列值（一般是主键的那一列）的<strong>逻辑顺序</strong>相同，一个表中只能拥有一个聚集索引。</p>
<p><img src="http://static.cyblogs.com/20181225211503670.png" alt="http://static.cyblogs.com/20181225211503670.png"></p>
<p>注：第一列的地址表示该行数据在<strong>磁盘中的物理地址</strong>，后面三列才是我们SQL里面用的表里的列，其中id是主键，建立了聚集索引。</p>
<p>结合上面的表格就可以理解这句话了吧：数据行的物理顺序与列值的顺序相同，如果我们查询id比较靠后的数据，那么这行数据的地址在磁盘中的物理地址也会比较靠后。而且由于物理排列方式与聚集索引的顺序相同，所以也就只能建立一个聚集索引了。</p>
<p><img src="http://static.cyblogs.com/20181225211504802.png" alt="聚集索引实际存放的示意图"></p>
<p>从上图可以看出聚集索引的好处了，索引的<strong>叶子节点就是对应的数据节点</strong>（MySQL的MyISAM除外，此存储引擎的聚集索引和非聚集索引只多了个唯一约束，其他没什么区别），可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，后面会详细讲。因此在查询方面，聚集索引的速度往往会更占优势。</p>
<h5 id="创建聚集索引"><a href="#创建聚集索引" class="headerlink" title="创建聚集索引"></a>创建聚集索引</h5><p>如果不创建索引，系统会自动创建一个隐含列作为表的聚集索引。</p>
<ul>
<li>创建表的时候指定主键（注意：SQL Sever默认主键为聚集索引，也可以指定为非聚集索引，而MySQL里主键就是聚集索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="keyword">nvarchar</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建表后添加聚集索引</li>
</ul>
<p>MySQL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">alter table table_name add primary <span class="title">key</span><span class="params">(colum_name)</span></span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，最好还是在创建表的时候添加聚集索引，由于聚集索引的物理顺序上的特殊性，因此如果再在上面创建索引的时候会根据索引列的排序移动全部数据行上面的顺序，会非常地耗费时间以及性能。</p>
<h4 id="非聚集（unclustered）索引"><a href="#非聚集（unclustered）索引" class="headerlink" title="非聚集（unclustered）索引"></a>非聚集（unclustered）索引</h4><p>定义：该索引中索引的 <strong>逻辑顺序与磁盘上行的物理存储顺序不同</strong> ，一个表中可以拥有多个非聚集索引。</p>
<p>其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的<strong>偏旁字典</strong>，他结构顺序与实际存放顺序不一定一致。</p>
<p><img src="http://static.cyblogs.com/2018122521150563.png" alt="http://static.cyblogs.com/2018122521150563.png"></p>
<h5 id="非聚集索引的二次查询问题"><a href="#非聚集索引的二次查询问题" class="headerlink" title="非聚集索引的二次查询问题"></a>非聚集索引的二次查询问题</h5><p>非聚集索引<strong>叶节点</strong>仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行<strong>第二次的查询</strong>，查询节点上对应的数据行的数据。</p>
<p>有表t1：</p>
<p><img src="http://static.cyblogs.com/20181225211503873.png" alt="http://static.cyblogs.com/20181225211503873.png"></p>
<p>其中有 聚集索引<code>clustered index(id)</code>，非聚集索引<code>index(username)</code>。</p>
<p>使用以下语句进行查询，不需要进行二次查询，直接就可以从非聚集索引的节点里面就可以获取到查询列的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, username <span class="keyword">from</span> t1 <span class="keyword">where</span> username = <span class="string">'小明'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> t1 <span class="keyword">where</span> username = <span class="string">'小明'</span></span><br></pre></td></tr></table></figure>

<p>但是使用以下语句进行查询，就需要二次的查询去获取原数据行的score：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> username, score <span class="keyword">from</span> t1 <span class="keyword">where</span> username = <span class="string">'小明'</span></span><br></pre></td></tr></table></figure>

<p>在<code>SQL Server</code>里面查询效率如下所示，<code>Index Seek</code>就是索引所花费的时间，<code>Key Lookup</code>就是二次查询所花费的时间。可以看的出二次查询所花费的查询开销占比很大，达到50%。</p>
<p>这篇博客有一个简单示例：<a href="https://blog.csdn.net/jiadajing267/article/details/54581262" target="_blank" rel="noopener">https://blog.csdn.net/jiadajing267/article/details/54581262</a></p>
<p><strong>总结如下：</strong></p>
<table>
<thead>
<tr>
<th>动作描述</th>
<th>使用聚集索引</th>
<th>使用非聚集索引</th>
</tr>
</thead>
<tbody><tr>
<td>列经常被分组排序</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>返回某范围内的数据</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>一个或极少不同值</td>
<td>不应</td>
<td>不应</td>
</tr>
<tr>
<td>小数目的不同值</td>
<td>应</td>
<td>不应</td>
</tr>
<tr>
<td>大数目的不同值</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>频繁更新的列</td>
<td>不应</td>
<td>应</td>
</tr>
<tr>
<td>外键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>主键列</td>
<td>应</td>
<td>应</td>
</tr>
<tr>
<td>频繁修改索引列</td>
<td>不应</td>
<td>应</td>
</tr>
</tbody></table>
<h4 id="我们需要搞清楚以下几个问题"><a href="#我们需要搞清楚以下几个问题" class="headerlink" title="我们需要搞清楚以下几个问题"></a>我们需要搞清楚以下几个问题</h4><p>第一：聚集索引的约束是唯一性，是否要求字段也是唯一的呢？   <strong>不要求唯一！</strong></p>
<p>分析：如果认为是的朋友，可能是受系统默认设置的影响，一般我们指定一个表的主键，如果这个表之前没有聚集索引，同时建立主键时候没有强制指定使用非聚集索引，SQL会默认在此字段上创建一个聚集索引，而主键都是唯一的，所以理所当然的认为创建聚集索引的字段也需要唯一。</p>
<p>结论：聚集索引可以创建在任何一列你想创建的字段上，这是从理论上讲，实际情况并不能随便指定，否则在性能上会是恶梦。</p>
<p>第二：为什么聚集索引可以创建在任何一列上，如果此表没有主键约束，即有可能存在重复行数据呢？</p>
<p>粗一看，这还真是和聚集索引的约束相背，但实际情况真可以创建聚集索引。</p>
<p>分析其原因是：如果未使用 <code>UNIQUE</code> 属性创建聚集索引，数据库引擎将向表自动添加一个四字节 <code>uniqueifier</code> 列。必要时，数据库引擎 将向行自动添加一个 <code>uniqueifier</code> 值，使每个键唯一。此列和列值供内部使用，用户不能查看或访问。</p>
<p>第三：是不是聚集索引就一定要比非聚集索引性能优呢?</p>
<p>如果想查询学分在60-90之间的学生的学分以及姓名，在学分上创建聚集索引是否是最优的呢？</p>
<p>答：否。既然只输出两列，我们可以在学分以及学生姓名上创建联合非聚集索引，此时的索引就形成了覆盖索引，即索引所存储的内容就是最终输出的数据，这种索引在比以学分为聚集索引做查询性能更好。</p>
<p>第四：在数据库中通过什么描述聚集索引与非聚集索引的？</p>
<p>索引是通过二叉树的形式进行描述的，我们可以这样区分聚集与非聚集索引的区别：聚集索引的叶节点就是<strong>最终的数据节点</strong>，而非聚集索引的叶节仍然是<strong>索引节点</strong>，但它有一个指向最终数据的指针。</p>
<p>第五：在主键是创建聚集索引的表在数据插入上为什么比主键上创建非聚集索引表速度要慢？</p>
<p>　　有了上面第四点的认识，我们分析这个问题就有把握了，在有主键的表中插入数据行，由于有主键唯一性的约束，所以需要保证插入的数据没有重复。我们来比较下主键为聚集索引和非聚集索引的查找情况：聚集索引由于索引叶节点就是数据页，所以如果想检查主键的唯一性，需要遍历所有数据节点才行，但非聚集索引不同，由于非聚集索引上已经包含了主键值，所以查找主键唯一性，只需要遍历所有的索引页就行（索引的存储空间比实际数据要少），这比遍历所有数据行减少了不少IO消耗。这就是为什么主键上创建非聚集索引比主键上创建聚集索引在插入数据时要快的真正原因。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/qq_29373285/article/details/85254407" target="_blank" rel="noopener">https://blog.csdn.net/qq_29373285/article/details/85254407</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈JDK堆外内存的创建和回收</title>
    <url>/2020/03/07/2020/03/%E8%B0%88%E8%B0%88JDK%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>堆外内存的优势在于IO操作，相比堆内存可以减少一次copy和gc的次数。下面通过源码去了解堆外内存的分配和回收。一般分配堆外内存通过<code>ByteBuffer allocateDirect(int capacity)</code>方法，其内部是通过如下构造函数来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;               </span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);<span class="comment">// mark, pos, lim, cap</span></span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123; <span class="comment">// 修改内存起始地址</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用父类的构造方法初始化ByteBuffer的四个基本属性，接下来reserveMemory方法是判断堆外剩余内存是否满足。这里的剩余并不是系统真是的剩余内存，参数-XX:MaxDirectMemorySize指定JVM最多可用的堆外内存。</p>
<p>如果堆外内存不足，则触发System.gc,这里有些难已理解，明明是堆外内存不足，System.gc的作用是建议VM进行full gc，再怎么说也是堆内存的回收。这里先保留这个疑问，继续往下看。</p>
<p>根据VM参数判断是否内存页对齐计算真实分配内存的大小,由-XX:+PageAlignDirectMemory控制，默认为false。allocateMemory是真正分配内存如果失败则回收内存。setMemory为填充内存。</p>
<p>接下来根据是否内存页对齐来计算内存的起始地址。我们知道HeapByteBuffer是基于byte数组来实现，不需要我们去考虑回收由JVM去处理。但是堆外内存JVM无法想堆内存那样回收，因此就有了Cleaner和Deallocator的存在。</p>
<p>每一个DirectBytebuffer都对应一个Deallocator和Cleaner对象，而Deallocator是Cleaner的一个属性。Deallocator继承了Runnable接口，当然run方法内部是释放内存的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 修改堆外内存的占用大小</span></span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析Cleaner之前我们先复习下PhantomReference(虚引用)</p>
<p>虚引用，正如其名，对一个对象而言，这个引用形同虚设，有和没有一样。如果一个对象与GC Roots之间仅存在虚引用，则称这个对象为虚可达（phantom reachable）对象。<br>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。</p>
<p>Cleaner继承自PhantomReference,在谈谈Java Reference的原理中介绍了Reference框架的大体逻辑，在PendingHandlerThread会把Pending list的引用对象移入Reference Queue,这个过程中如果Reference是Cleaner类型，那么会执行clean方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.thunk.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        (<span class="keyword">new</span> Error(<span class="string">"Cleaner terminated abnormally"</span>, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>thunk是Deallocator类型，也就是说它run方法最终是由PendingHandlerThread线程执行的。这就是JDK的自动回收堆外内存。</p>
<p>thunk是Deallocator类型，也就是说它run方法最终是由PendingHandlerThread线程执行的。这就是JDK的自动回收堆外内存。</p>
<p>总结一下：DirectByteBuffer对象指向堆外的内存，它保存了一块内存的基本属性和Cleaner和Deallocator对象等。占用的空间相比堆外内存只是冰山一角，当DirectByteBuffer对象被回收，Cleaner对象也就是虚引用被加入到Pending list，PendingHandlerThread线程执行Cleaner的clean方法，最终释放堆外内存。这也就解释了为什么执行gc可以回收堆外内存了。也可以手动释放，首先拿到DirectByteBuffer的Cleaner对象，执行它的clean方法。</p>
<p>由于cleaner是private访问权限，所以自然想到使用反射来实现。<br>DirectByteBuffer实现了DirectBuffer接口，这个接口有cleaner方法可以获取cleaner对象</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/TheLudlows/article/details/101061407" target="_blank" rel="noopener">https://blog.csdn.net/TheLudlows/article/details/101061407</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>三句话理解时区与时间戳</title>
    <url>/2020/04/04/2020/04/%E4%B8%89%E5%8F%A5%E8%AF%9D%E7%90%86%E8%A7%A3%E6%97%B6%E5%8C%BA%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3/</url>
    <content><![CDATA[<h4 id="第一句话：时间戳"><a href="#第一句话：时间戳" class="headerlink" title="第一句话：时间戳"></a>第一句话：时间戳</h4><p>时间不分东西南北、在地球的每一个角落都是相同的。他们都有一个相同的名字，叫<strong>时间戳</strong>。<strong>时间戳</strong> 指的就是<code>Unix</code>时间戳(<code>Unix timestamp)</code>。它也被称为<code>Unix</code>时间(<code>Unix time</code>)、<code>POSIX</code>时间(<code>POSIX time</code>)，是一种时间表示方式，定义为从格林威治时间<code>1970年01月01日00时00分00秒</code>起至现在的总秒数。</p>
<p>关于 <strong>时间戳</strong>， 你可以看在线时间戳 <a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/Tools/unixtime.aspx</a></p>
<h4 id="第二句话：时区"><a href="#第二句话：时区" class="headerlink" title="第二句话：时区"></a>第二句话：时区</h4><p><strong>时间戳</strong> 在地球的每一个角落都是相同的，但是在相同的时间点会有不同的表达方式，所以有了另外一个时间概念，叫<strong>时区</strong>。这里的<strong>时区</strong>与<strong>地区</strong>不是同一个概念，例如我们所在的<strong>时区</strong>叫 <strong>东八区</strong> 。<br> 在设备中,可以自己手动的切换当前的系统时区:</p>
<p><img src="http://static.cyblogs.com/1198135-c33bb659a21ae7d7.jpg" alt="http://static.cyblogs.com/1198135-c33bb659a21ae7d7.jpg"></p>
<p>你会发现：<strong>当你选在不同的时区，你的当前时间是不一样的。</strong></p>
<h4 id="第三句话：时间戳与时区在Code中应用"><a href="#第三句话：时间戳与时区在Code中应用" class="headerlink" title="第三句话：时间戳与时区在Code中应用"></a>第三句话：时间戳与时区在Code中应用</h4><h5 id="格林威治标准时间GMT"><a href="#格林威治标准时间GMT" class="headerlink" title="格林威治标准时间GMT"></a>格林威治标准时间GMT</h5><blockquote>
<p>十七世纪，格林威治皇家天文台为了海上霸权的扩张计画而进行天体观测。1675年旧皇家观测所(Old Royal Observatory) 正式成立，到了1884年决定以通过格林威治的子午线作为划分地球东西两半球的经度零度。观测所门口墙上有一个标志24小时的时钟，显示当下的时间，对全球而言，这里所设定的时间是世界时间参考点，全球都以格林威治的时间作为标准来设定时间，这就是我们耳熟能详的「格林威治标准时间(Greenwich Mean Time，简称G.M.T.)的由来，标示在手表上，则代表此表具有两地时间功能，也就是同时可以显示原居地和另一个国度的时间。</p>
</blockquote>
<h5 id="世界协调时间UTC"><a href="#世界协调时间UTC" class="headerlink" title="世界协调时间UTC"></a>世界协调时间UTC</h5><blockquote>
<p>多数的两地时间表都以GMT来表示，但也有些两地时间表上看不到GMT字样，出现的反而是UTC这3个英文字母，究竟何谓UTC？事实上，UTC指的是Coordinated Universal Time－世界协调时间（又称世界标准时间、世界统一时间），是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说，UTC比GMT来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。所以基本上UTC的本质强调的是比GMT更为精确的世界时间标准，不过对于现行表款来说，GMT与UTC的功能与精确度是没有差别的。</p>
</blockquote>
<h5 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.TimeZone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UTCTimecase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到UTC时间，类型为字符串，格式为"yyyy-MM-dd HH:mm"&lt;br /&gt;</span></span><br><span class="line"><span class="comment">     * 如果获取失败，返回null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUTCTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuffer UTCTimeBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">// 1、取得本地时间：</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 2、取得时间偏移量：</span></span><br><span class="line">        <span class="keyword">int</span> zoneOffset = cal.get(java.util.Calendar.ZONE_OFFSET);</span><br><span class="line">        <span class="comment">// 3、取得夏令时差：</span></span><br><span class="line">        <span class="keyword">int</span> dstOffset = cal.get(java.util.Calendar.DST_OFFSET);</span><br><span class="line">        <span class="comment">// 4、从本地时间里扣除这些差量，即可以取得UTC时间：</span></span><br><span class="line">        cal.add(java.util.Calendar.MILLISECOND, -(zoneOffset + dstOffset));</span><br><span class="line">        <span class="keyword">int</span> year = cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> day = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="keyword">int</span> hour = cal.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">int</span> minute = cal.get(Calendar.MINUTE);</span><br><span class="line">        UTCTimeBuffer.append(year).append(<span class="string">"-"</span>).append(month).append(<span class="string">"-"</span>).append(day);</span><br><span class="line">        UTCTimeBuffer.append(<span class="string">" "</span>).append(hour).append(<span class="string">":"</span>).append(minute);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            format.parse(UTCTimeBuffer.toString());</span><br><span class="line">            <span class="keyword">return</span> UTCTimeBuffer.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将UTC时间转换为东八区时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> UTCTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLocalTimeFromUTC</span><span class="params">(String UTCTime)</span> </span>&#123;</span><br><span class="line">        java.util.Date UTCDate = <span class="keyword">null</span>;</span><br><span class="line">        String localTimeStr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UTCDate = format.parse(UTCTime);</span><br><span class="line">            format.setTimeZone(TimeZone.getTimeZone(<span class="string">"GMT-8"</span>));</span><br><span class="line">            localTimeStr = format.format(UTCDate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> localTimeStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String UTCTimeStr = getUTCTimeStr();</span><br><span class="line">        System.out.println(UTCTimeStr);</span><br><span class="line">        System.out.println(getLocalTimeFromUTC(UTCTimeStr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.TimeZone;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FORMAT_DATETIME = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getOffsetTime</span><span class="params">(<span class="keyword">int</span> offset, Date date)</span> </span>&#123;</span><br><span class="line">        TimeZone timeZone = TimeZone.getTimeZone(<span class="string">"GMT-"</span> + offset + <span class="string">":00"</span>);</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        simpleDateFormat.setTimeZone(timeZone);</span><br><span class="line">        <span class="keyword">return</span> simpleDateFormat.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取得本地时间：</span></span><br><span class="line">        Calendar cal1 = Calendar.getInstance();</span><br><span class="line">        log.info(<span class="string">"cal1=&#123;&#125;"</span>, <span class="keyword">new</span> SimpleDateFormat(FORMAT_DATETIME).format(cal1.getTime()));</span><br><span class="line">        log.info(<span class="string">"cal1=&#123;&#125;"</span>, cal1.getTime().getTime());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"cal2=&#123;&#125;"</span>, getOffsetTime(<span class="number">9</span>, cal1.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果想实现国际化，数据库可以采用存放时间戳的方式，因为没有时区的影响，都是从<code>1970年01月01日00时00分00秒</code>计算的时间。然后根据当前的地区来显示。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.jianshu.com/p/bf47458a0423" target="_blank" rel="noopener">https://www.jianshu.com/p/bf47458a0423</a></li>
<li><a href="https://chenoge.github.io/2018/12/26/时间戳、时区以及时间格式" target="_blank" rel="noopener">https://chenoge.github.io/2018/12/26/时间戳、时区以及时间格式</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>时区</tag>
      </tags>
  </entry>
  <entry>
    <title>十分钟搞懂Lombok使用与原理</title>
    <url>/2020/04/07/2020/04/%E5%8D%81%E5%88%86%E9%92%9F%E6%90%9E%E6%87%82Lombok%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Lombok是一款好用顺手的工具，就像Google Guava一样，在此予以强烈推荐，每一个Java工程师都应该使用它。<strong>Lombok是一种Java™实用工具，可用来帮助开发人员消除Java的冗长代码，尤其是对于简单的Java对象（POJO）。它通过注释实现这一目的</strong>。通过在开发环境中实现Lombok，开发人员可以节省构建诸如hashCode()和equals()这样的方法以及以往用来分类各种accessor和mutator的大量时间。</p>
<h4 id="IntelliJ安装Lombok"><a href="#IntelliJ安装Lombok" class="headerlink" title="IntelliJ安装Lombok"></a>IntelliJ安装Lombok</h4><p>通过IntelliJ的插件中心安装</p>
<p><img src="http://static.cyblogs.com/QQ20200425-164854@2x.jpg" alt="http://static.cyblogs.com/QQ20200425-164854@2x.jpg"></p>
<p>最后需要注意的是，在使用lombok注解的时候记得要导入lombok.jar包到工程，如果使用的是Maven Project，要在pom.xml中添加依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Lombok用法"><a href="#Lombok用法" class="headerlink" title="Lombok用法"></a>Lombok用法</h4><h5 id="Lombok注解说明"><a href="#Lombok注解说明" class="headerlink" title="Lombok注解说明"></a>Lombok注解说明</h5><ul>
<li><p><code>val</code>：用在局部变量前面，相当于将变量声明为final</p>
</li>
<li><p><code>@NonNull</code>：给方法参数增加这个注解会自动在方法内对该参数进行是否为空的校验，如果为空，则抛出NPE（NullPointerException）</p>
</li>
<li><p><code>@Cleanup</code>：自动管理资源，用在局部变量之前，在当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流</p>
</li>
<li><p><code>@Getter/@Setter</code>：用在属性上，再也不用自己手写setter和getter方法了，还可以指定访问范围</p>
</li>
<li><p><code>@ToString</code>：用在类上，可以自动覆写toString方法，当然还可以加其他参数，例如@ToString(exclude=”id”)排除id属性，或者@ToString(callSuper=true, includeFieldNames=true)调用父类的toString方法，包含所有属性</p>
</li>
<li><p><code>@EqualsAndHashCode</code>：用在类上，自动生成equals方法和hashCode方法</p>
</li>
<li><p><code>@NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</code>：用在类上，自动生成无参构造和使用所有参数的构造函数以及把所有@NonNull属性作为参数的构造函数，如果指定staticName = “of”参数，同时还会生成一个返回类对象的静态工厂方法，比使用构造函数方便很多</p>
</li>
<li><p><code>@Data</code>：注解在类上，相当于同时使用了<code>@ToString</code>、<code>@EqualsAndHashCode</code>、<code>@Getter</code>、<code>@Setter</code>和<code>@RequiredArgsConstrutor</code>这些注解，对于<code>POJO类</code>十分有用</p>
</li>
<li><p><code>@Value</code>：用在类上，是@Data的不可变形式，相当于为属性添加final声明，只提供getter方法，而不提供setter方法</p>
</li>
<li><p><code>@Builder</code>：用在类、构造器、方法上，为你提供复杂的builder APIs，让你可以像如下方式一样调用<code>Person.builder().name(&quot;Adam Savage&quot;).city(&quot;San Francisco&quot;).job(&quot;Mythbusters&quot;).job(&quot;Unchained Reaction&quot;).build();</code>更多说明参考<a href="https://projectlombok.org/features/Builder.html" target="_blank" rel="noopener">Builder</a></p>
</li>
<li><p><code>@SneakyThrows</code>：自动抛受检异常，而无需显式在方法上使用throws语句</p>
</li>
<li><p><code>@Synchronized</code>：用在方法上，将方法声明为同步的，并自动加锁，而锁对象是一个私有的属性<code>$lock</code>或<code>$LOCK</code>，而java中的synchronized关键字锁对象是this，锁在this或者自己的类对象上存在副作用，就是你不能阻止非受控代码去锁this或者类对象，这可能会导致竞争条件或者其它线程错误</p>
</li>
<li><p><code>@Getter(lazy=true)</code>：可以替代经典的Double Check Lock样板代码</p>
</li>
<li><p><code>@Log</code>：根据不同的注解生成不同类型的log对象，但是实例名称都是log，有六种可选实现类</p>
<ul>
<li><code>@CommonsLog</code> Creates log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);</li>
<li><code>@Log</code> Creates log = java.util.logging.Logger.getLogger(LogExample.class.getName());</li>
</ul>
</li>
<li><p><code>@Log4j</code> Creates log = org.apache.log4j.Logger.getLogger(LogExample.class);</p>
<ul>
<li><code>@Log4j2</code> Creates log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);</li>
</ul>
</li>
<li><p><code>@Slf4j</code> Creates log = org.slf4j.LoggerFactory.getLogger(LogExample.class);</p>
<ul>
<li><code>@XSlf4j</code> Creates log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);</li>
</ul>
</li>
</ul>
<h5 id="Lombok代码示例"><a href="#Lombok代码示例" class="headerlink" title="Lombok代码示例"></a>Lombok代码示例</h5><h6 id="val示例"><a href="#val示例" class="headerlink" title="val示例"></a>val示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    val sets = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    val lists = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    val maps = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">//=&gt;相当于如下</span></span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; sets2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; lists2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, String&gt; maps2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="NonNull示例"><a href="#NonNull示例" class="headerlink" title="@NonNull示例"></a>@NonNull示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notNullExample</span><span class="params">(@NonNull String string)</span> </span>&#123;</span><br><span class="line">    string.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=&gt;相当于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notNullExample</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string != <span class="keyword">null</span>) &#123;</span><br><span class="line">        string.length();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Cleanup示例"><a href="#Cleanup示例" class="headerlink" title="@Cleanup示例"></a>@Cleanup示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@Cleanup</span> InputStream inputStream = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//=&gt;相当于</span></span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Getter-Setter示例"><a href="#Getter-Setter示例" class="headerlink" title="@Getter/@Setter示例"></a>@Getter/@Setter示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span>(AccessLevel.PUBLIC)</span><br><span class="line"><span class="meta">@Getter</span>(AccessLevel.PROTECTED)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String shap;</span><br></pre></td></tr></table></figure>

<h6 id="ToString示例"><a href="#ToString示例" class="headerlink" title="@ToString示例"></a>@ToString示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span>(exclude = <span class="string">"id"</span>, callSuper = <span class="keyword">true</span>, includeFieldNames = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LombokDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输出LombokDemo(super=LombokDemo@48524010, name=null, age=0)</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> LombokDemo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="EqualsAndHashCode示例"><a href="#EqualsAndHashCode示例" class="headerlink" title="@EqualsAndHashCode示例"></a>@EqualsAndHashCode示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode</span>(exclude = &#123;<span class="string">"id"</span>, <span class="string">"shape"</span>&#125;, callSuper = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LombokDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String shap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor示例"><a href="#NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor示例" class="headerlink" title="@NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor示例"></a>@NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(staticName = <span class="string">"of"</span>)</span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LombokDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String shap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> LombokDemo(<span class="number">1</span>, <span class="string">"circle"</span>);</span><br><span class="line">        <span class="comment">//使用静态工厂方法</span></span><br><span class="line">        LombokDemo.of(<span class="number">2</span>, <span class="string">"circle"</span>);</span><br><span class="line">        <span class="comment">//无参构造</span></span><br><span class="line">        <span class="keyword">new</span> LombokDemo();</span><br><span class="line">        <span class="comment">//包含所有参数</span></span><br><span class="line">        <span class="keyword">new</span> LombokDemo(<span class="number">1</span>, <span class="string">"circle"</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Data示例"><a href="#Data示例" class="headerlink" title="@Data示例"></a>@Data示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String shopId;</span><br><span class="line">    <span class="keyword">private</span> String skuMenuId;</span><br><span class="line">    <span class="keyword">private</span> String skuName;</span><br><span class="line">    <span class="keyword">private</span> String normalizeSkuName;</span><br><span class="line">    <span class="keyword">private</span> String dishMenuId;</span><br><span class="line">    <span class="keyword">private</span> String dishName;</span><br><span class="line">    <span class="keyword">private</span> String dishNum;</span><br><span class="line">    <span class="comment">//默认阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> thresHold = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//新阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> newThresHold = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//总得分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> totalScore = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Value示例"><a href="#Value示例" class="headerlink" title="@Value示例"></a>@Value示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LombokDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String shap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//相当于</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Builder示例"><a href="#Builder示例" class="headerlink" title="@Builder示例"></a>@Builder示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Singular</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; occupations;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuilderExample test = BuilderExample.builder().age(<span class="number">11</span>).name(<span class="string">"test"</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="SneakyThrows示例"><a href="#SneakyThrows示例" class="headerlink" title="@SneakyThrows示例"></a>@SneakyThrows示例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedEncodingException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相当于</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedEncodingException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Synchronized示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相当于</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object $LOCK = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> ($LOCK) &#123;</span><br><span class="line">            System.out.println(<span class="string">"world"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Getter(lazy = true)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetterLazyExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span>(lazy = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] cached = expensive();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] expensive() &#123;</span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">1000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            result[i] = Math.asin(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于如下所示: </span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetterLazyExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;java.lang.Object&gt; cached = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] getCached() &#123;</span><br><span class="line">        java.lang.Object value = <span class="keyword">this</span>.cached.get();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">                value = <span class="keyword">this</span>.cached.get();</span><br><span class="line">                <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">double</span>[] actualValue = expensive();</span><br><span class="line">                    value = actualValue == <span class="keyword">null</span> ? <span class="keyword">this</span>.cached : actualValue;</span><br><span class="line">                    <span class="keyword">this</span>.cached.set(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>[]) (value == <span class="keyword">this</span>.cached ? <span class="keyword">null</span> : value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] expensive() &#123;</span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">1000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            result[i] = Math.asin(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lombok注解原理"><a href="#Lombok注解原理" class="headerlink" title="Lombok注解原理"></a>Lombok注解原理</h4><p>说道 Lombok，我们就得去提到 JSR 269: Pluggable Annotation Processing API (<a href="https://www.jcp.org/en/jsr/detail?id=269" target="_blank" rel="noopener">www.jcp.org/en/jsr/deta…</a>) 。JSR 269 之前我们也有注解这样的神器，可是我们比如想要做什么必须使用反射，反射的方法局限性较大。<strong>首先，它必须定义@Retention为RetentionPolicy.RUNTIME，只能在运行时通过反射来获取注解值，使得运行时代码效率降低</strong>。其次，如果想在编译阶段利用注解来进行一些检查，对用户的某些不合理代码给出错误报告，反射的使用方法就无能为力了。<strong>而 JSR 269 之后我们可以在 Javac的编译期利用注解做这些事情</strong>。所以我们发现<strong>核心的区分是在 运行期 还是 编译期</strong>。</p>
<p><img src="http://static.cyblogs.com/16140d77d8166720.png" alt="http://static.cyblogs.com/16140d77d8166720.png"></p>
<p>从上图可知，<code>Annotation Processing</code> 是在解析和生成之间的一个步骤。具体详细步骤如下：</p>
<p><img src="http://static.cyblogs.com/16140d77d8050b6c.png" alt="http://static.cyblogs.com/16140d77d8050b6c.png"></p>
<p>上图是 Lombok 处理流程，<strong>在Javac 解析成抽象语法树之后(AST), Lombok 根据自己的注解处理器，动态的修改 AST，增加新的节点(所谓代码)，最终通过分析和生成字节码</strong>。</p>
<p><strong>自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”规范，只要程序实现了该API，就能在javac运行的时候得到调用</strong>。</p>
<blockquote>
<ol>
<li>常用的项目管理工具Maven所使用的java编译工具来源于配置的第三方工具，如果我们配置这个第三方工具为Oracle javac的话，那么Maven也就直接支持lombok了;</li>
<li>Intellij Idea配置的编译工具为Oracle javac的话，也就直接支持lombok了;</li>
</ol>
</blockquote>
<p><strong>IDE工具问题解决：</strong></p>
<blockquote>
<p>现在有一个A类，其中有一些字段，没有创建它们的setter和getter方法，使用了lombok的@Data注解，另外有一个B类，它调用了A类实例的相应字段的setter和getter方法</p>
<p>编译A类和B类所在的项目，并不会报错，因为最终生成的A类字节码文件中存在相应字段的setter和getter方法</p>
<p><strong>但是，IDE发现B类源代码中所使用的A类实例的setter和getter方法在A类源代码中找不到定义，IDE会认为这是错误</strong></p>
<p>要解决以上这个不是真正错误的错误，可以下载安装Intellij Idea中的”Lombok plugin”。</p>
</blockquote>
<h4 id="自定义支持JSR269的注解"><a href="#自定义支持JSR269的注解" class="headerlink" title="自定义支持JSR269的注解"></a>自定义支持JSR269的注解</h4><p>一般javac的编译过程，java文件首先通过进行解析构建出一个AST，然后执行注解处理，最后经过分析优化生成二进制的.class文件。<strong>我们能做到的是，在注解处理阶段进行一些相应处理</strong>。首先我们在META-INF.services下创建如下文件：</p>
<p><img src="http://static.cyblogs.com/16140d77d82abad8.png" alt="http://static.cyblogs.com/16140d77d82abad8.png"></p>
<p><strong>文件中指定我们的注解处理器：<code>com.alipay.kris.other.lombok.MyAnnotaionProcessor</code></strong>，然后我们接可以编写自己的注解处理器，一个简单的实例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)</span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"com.alipay.kris.other.lombok.*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotaionProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAnnotaionProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations,RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element elem : roundEnv.getElementsAnnotatedWith(MyAnnotation<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            MyAnnotation annotation = elem.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            String message = <span class="string">"annotation found in "</span> + elem.getSimpleName()</span><br><span class="line">                + <span class="string">" with  "</span> + annotation.value();</span><br><span class="line">            addToString(elem);</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// no further processing of this annotation type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://juejin.im/post/5a6eceb8f265da3e467555fe" target="_blank" rel="noopener">https://juejin.im/post/5a6eceb8f265da3e467555fe</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>如何打通SpringCloud与HSF的调用？</title>
    <url>/2020/04/03/2020/04/%E5%A6%82%E4%BD%95%E6%89%93%E9%80%9ASpringCloud%E4%B8%8EHSF%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>2019年我们经历了一整年的各种迁移，其中包括了一项<code>RPC</code>框架的切换。以前我们用的<code>HSF RPC</code>框架，它是来自于阿里巴巴，经过了多年的<code>双11</code>高并发的洗礼，高性能这块儿毫无疑问没有任何的问题，而且它还同时支持<code>TCP</code>与<code>HTTP</code>的方式，唯一不太好的就是它不开源，如果出现问题定位起来确实有一些问题与风险。</p>
<p>所以，我们为了拥抱开源，全部采用<code>SpringCloud</code>，系统与系统之间调用是通过<code>FeignClient</code>的方式来调用的，但是由于底层的部分系统由于时间、人力、历史等原因，无法在短时间内都像我们一样能积极响应。所以就出现了<code>SpringCloud</code>与HSF服务同时存在的情况，为了大家再编码过程中都能像本地调用（<code>TCP</code>，<code>FeignClient</code>），所以就写了一个代理工具。</p>
<h4 id="交互图"><a href="#交互图" class="headerlink" title="交互图"></a>交互图</h4><p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20200406181706.png" alt="http://static.cyblogs.com/QQ截图20200406181706.png"></p>
<p>如果是上面的方式，我们还是能感受到每次都是通过<code>HttpClient</code>等方式发起一次<code>Http</code>请求，写代码时候的体验不是很好。</p>
<p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20200406182159.png" alt="http://static.cyblogs.com/QQ截图20200406182159.png"></p>
<p>为了解决这个问题，那么我们的任务就是来写一个这个代理封装。</p>
<h4 id="分析功能点"><a href="#分析功能点" class="headerlink" title="分析功能点"></a>分析功能点</h4><h5 id="了解一下FeignClient"><a href="#了解一下FeignClient" class="headerlink" title="了解一下FeignClient"></a>了解一下FeignClient</h5><p>我们参考一下FeignClient的功能一个解析过程，如图：</p>
<p><img src="http://static.cyblogs.com/14126519-4cc483cb15b9dc6d.png" alt="http://static.cyblogs.com/14126519-4cc483cb15b9dc6d.png"></p>
<ul>
<li>生成动态代理类</li>
<li>解析出等的MethodHandler</li>
<li>动态生成Request</li>
<li>Encoder</li>
<li>拦截器处理</li>
<li>日志处理</li>
<li>重试机制</li>
</ul>
<h5 id="代理需要考虑什么？"><a href="#代理需要考虑什么？" class="headerlink" title="代理需要考虑什么？"></a>代理需要考虑什么？</h5><p><img src="http://static.cyblogs.com/QQ%E6%88%AA%E5%9B%BE20200406193343.png" alt="http://static.cyblogs.com/QQ截图20200406193343.png"></p>
<p>那我们不用说写那么完善，我们的第一个目标就是实现扫描 → 代理 → 发送请求。</p>
<p>因为HSF的参数与标准的Http方式不太一致，所以在发起Http请求的时候，需要特殊的构造一下报文的格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d "ArgsTypes=[\"com.cyblogs..QueryConfigReq\"]&amp;ArgsObjects=[&#123;\"relationCode\":\"ABCD\"&#125;]" </span><br><span class="line">http://127.0.0.1:8083/com.cyblogs.api.ConfigServiceV2Api:1.0.0/queryNewConfig</span><br></pre></td></tr></table></figure>

<h4 id="代码框架实现"><a href="#代码框架实现" class="headerlink" title="代码框架实现"></a>代码框架实现</h4><p><code>SpringBoot</code>总入口，打开<code>@EnableHsfClients</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHsfClients</span>(basePackages = <span class="string">"com.cyblogs.client.hsf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(App<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义好需要扫描的包，具体的类等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; HsfClientsRegistrar<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableHsfClients</span> </span>&#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] clients() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<code>Spirng</code>的<code>ImportBeanDefinitionRegistrar</code>来进行自动注入生成Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HsfClientsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        registerHsfClient(importingClassMetadata, registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerHsfClient</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">        scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; attrs = metadata.getAnnotationAttributes(EnableHsfClients<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        AnnotationTypeFilter annotationTypeFilter = <span class="keyword">new</span> AnnotationTypeFilter(HsfClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span> : (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line">        <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">            scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">            basePackages = getBasePackages(metadata);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">                basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            Set&lt;BeanDefinition&gt; candidateComponents = scanner.findCandidateComponents(basePackage);</span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">                <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">                    AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">                    AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">                    Assert.isTrue(annotationMetadata.isInterface(), <span class="string">"@HsfClient can only be specified on an interface"</span>);</span><br><span class="line">                    Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                            .getAnnotationAttributes(HsfClient<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line">                    registerHsfClient(registry, annotationMetadata, attributes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ClassPathScanningCandidateComponentProvider <span class="title">getScanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassPathScanningCandidateComponentProvider(<span class="keyword">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (beanDefinition.getMetadata().isIndependent()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (beanDefinition.getMetadata().isInterface()</span><br><span class="line">                            &amp;&amp; beanDefinition.getMetadata().getInterfaceNames().length == <span class="number">1</span></span><br><span class="line">                            &amp;&amp; Annotation.class.getName().equals(beanDefinition.getMetadata().getInterfaceNames()[0])) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Class&lt;?&gt; target = ClassUtils.forName(beanDefinition.getMetadata().getClassName(),</span><br><span class="line">                                    HsfClientsRegistrar.<span class="keyword">this</span>.classLoader);</span><br><span class="line">                            <span class="keyword">return</span> !target.isAnnotation();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                            log.error(<span class="string">"Could not load target class: "</span> + beanDefinition.getMetadata().getClassName(),</span><br><span class="line">                                    ex);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">getBasePackages</span><span class="params">(AnnotationMetadata importingClassMetadata)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; attributes = importingClassMetadata</span><br><span class="line">                .getAnnotationAttributes(EnableHsfClients<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; basePackages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String pkg : (String[]) attributes.get(<span class="string">"value"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">                basePackages.add(pkg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String pkg : (String[]) attributes.get(<span class="string">"basePackages"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">                basePackages.add(pkg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">            basePackages.add(ClassUtils.getPackageName(importingClassMetadata.getClassName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> basePackages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHsfClient</span><span class="params">(BeanDefinitionRegistry registry, AnnotationMetadata annotationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">        String className = annotationMetadata.getClassName();</span><br><span class="line">        BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(HsfClientFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String version = resolve((String) attributes.get(<span class="string">"version"</span>));</span><br><span class="line">        String interfaceName = resolve((String) attributes.get(<span class="string">"interfaceName"</span>));</span><br><span class="line">        <span class="keyword">if</span> (interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            interfaceName = className;</span><br><span class="line">        &#125;</span><br><span class="line">        definition.addPropertyValue(<span class="string">"url"</span>, String.format(FORMAT, getUrl(attributes), interfaceName, version));</span><br><span class="line">        definition.addPropertyValue(<span class="string">"type"</span>, className);</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_NAME);</span><br><span class="line"></span><br><span class="line">        String alias = interfaceName + <span class="string">"HsfClient"</span>;</span><br><span class="line">        AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</span><br><span class="line">        beanDefinition.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">        BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className, <span class="keyword">new</span> String[] &#123; alias &#125;);</span><br><span class="line">        BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUrl</span><span class="params">(Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">        String url = resolve((String) attributes.get(<span class="string">"url"</span>));</span><br><span class="line">        <span class="keyword">boolean</span> secure = <span class="keyword">false</span>;</span><br><span class="line">        Object securePlaceHolder = attributes.get(<span class="string">"secure"</span>);</span><br><span class="line">        <span class="keyword">if</span> (securePlaceHolder <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            secure = ((Boolean) securePlaceHolder).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Boolean.parseBoolean(resolve((String) attributes.get(<span class="string">"secure"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        String protocol = secure ? <span class="string">"https"</span> : <span class="string">"http"</span>;</span><br><span class="line">        <span class="keyword">if</span> (!url.contains(<span class="string">"://"</span>)) &#123;</span><br><span class="line">            url = protocol + <span class="string">"://"</span> + url;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url.endsWith(<span class="string">"/"</span>)) &#123;<span class="comment">//避免设置的url为'schema:ip:port/'格式</span></span><br><span class="line">            url = url.substring(<span class="number">0</span>, url.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> URL(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(url + <span class="string">" is malformed"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HsfClientFactoryBean</code>定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HsfClientFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;           type;</span><br><span class="line">    <span class="keyword">private</span> String             url;</span><br><span class="line">    <span class="keyword">private</span> RestTemplate       restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Assert.hasText(url, <span class="string">"url must be set"</span>);</span><br><span class="line">        Assert.notNull(type, <span class="string">"type must be set"</span>);</span><br><span class="line">        <span class="keyword">if</span> (restTemplate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">            restTemplate.getMessageConverters().clear();</span><br><span class="line">            restTemplate.getMessageConverters().add(<span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">"UTF-8"</span>)));<span class="comment">//write application/x-www-form-urlencoded request</span></span><br><span class="line">            restTemplate.getMessageConverters().add(<span class="keyword">new</span> FastJsonHttpMessageConverter());<span class="comment">//read and write application/json</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;Method, HsfMethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, HsfMethodHandler&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Method method : type.getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//TODO 暂时忽略</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                methodToHandler.put(method, <span class="keyword">new</span> HsfMethodHandler(restTemplate, type, method, url));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> HsfInvocationHandler(methodToHandler);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(getClass().getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; type &#125;, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SYNTHETIC = <span class="number">0x00001000</span>;</span><br><span class="line">        <span class="keyword">return</span> ((method.getModifiers()</span><br><span class="line">                &amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC | SYNTHETIC)) == Modifier.PUBLIC)</span><br><span class="line">                &amp;&amp; method.getDeclaringClass().isInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HsfInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, HsfMethodHandler&gt; handlers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HsfInvocationHandler</span><span class="params">(Map&lt;Method, HsfMethodHandler&gt; handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handlers = handlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object otherHandler = args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                log.error(e.getMessage(), e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> hashCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handlers.get(method).invoke(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> HsfInvocationHandler) &#123;</span><br><span class="line">            Map&lt;Method, HsfMethodHandler&gt; other = ((HsfInvocationHandler) obj).handlers;</span><br><span class="line">            <span class="keyword">return</span> other.equals(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handlers.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handlers.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是就是<code>HsfMethodHandler</code>的一个具体实现，包括上面所提到的<code>Request</code>参数的构造，一个<code>invoke</code>方法的调用。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>其实通过HttpClient的方式去调用也不是不行，只是说如果通过参考别人的代码，做一个RPC调用底层原理的一个分析，我们是可以做到一些系统层面的封装的，而且这个jar包是可以做成plugin的方式去提供给别人用的。</li>
<li>了解动态代理的原理，可以做到对代码项目无感知或者少感知的作用。</li>
<li>通过该过程举一反三，其他的场景都可以复制该思路去做事情。</li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解RocketMQ的设计</title>
    <url>/2020/04/05/2020/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RocketMQ%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h4><p><img src="http://static.cyblogs.com/rocketmq_architecture_1.jpg" alt="http://static.cyblogs.com/rocketmq_architecture_1.jpg"><code>RocketMQ</code>架构上主要分为四部分，如上图所示:</p>
<ul>
<li><code>Producer</code>：消息发布的角色，支持分布式集群方式部署。<code>Producer</code>通过<code>MQ</code>的负载均衡模块选择相应的<code>Broker</code>集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</li>
<li><code>Consumer</code>：消息消费的角色，支持分布式集群方式部署。支持以<code>push</code>推，<code>pull</code>拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</li>
<li><code>NameServer</code>：<code>NameServer</code>是一个非常简单的<code>Topic</code>路由注册中心，其角色类似<code>Dubbo</code>中的<code>zookeeper</code>，支持<code>Broker</code>的动态注册与发现。主要包括两个功能：<code>Broker</code>管理，<code>NameServer</code>接受<code>Broker</code>集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查<code>Broker</code>是否还存活；路由信息管理，每个<code>NameServer</code>将保存关于<code>Broker</code>集群的整个路由信息和用于客户端查询的队列信息。然后<code>Producer</code>和<code>Conumser</code>通过<code>NameServer</code>就可以知道整个<code>Broker</code>集群的路由信息，从而进行消息的投递和消费。<code>NameServer</code>通常也是集群的方式部署，各实例间相互不进行信息通讯。<code>Broker</code>是向每一台<code>NameServer</code>注册自己的路由信息，所以每一个<code>NameServer</code>实例上面都保存一份完整的路由信息。当某个<code>NameServer</code>因某种原因下线了，<code>Broker</code>仍然可以向其它<code>NameServer</code>同步其路由信息，<code>Producer</code>,<code>Consumer</code>仍然可以动态感知<code>Broker</code>的路由的信息。</li>
<li><code>BrokerServer</code>：<code>Broker</code>主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，<code>Broker</code>包含了以下几个重要子模块。</li>
<li><code>Remoting Module</code>：整个<code>Broker</code>的实体，负责处理来自<code>clients</code>端的请求。</li>
<li><code>Client Manager</code>：负责管理客户端(<code>Producer</code>/<code>Consumer</code>)和维护<code>Consumer</code>的<code>Topic</code>订阅信息</li>
<li><code>Store Service</code>：提供方便简单的<code>API</code>接口处理消息存储到物理硬盘和查询功能。</li>
<li><code>HA Service</code>：高可用服务，提供<code>Master Broker</code> 和 <code>Slave Broker</code>之间的数据同步功能。</li>
<li><code>Index Service</code>：根据特定的<code>Message key</code>对投递到<code>Broker</code>的消息进行索引服务，以提供消息的快速查询。</li>
</ul>
<h4 id="RocketMQ-网络部署特点"><a href="#RocketMQ-网络部署特点" class="headerlink" title="RocketMQ 网络部署特点"></a>RocketMQ 网络部署特点</h4><ul>
<li><code>NameServer</code>是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li>
<li><code>Broker</code>部署相对复杂，<code>Broker</code>分为<code>Master</code>与<code>Slave</code>，一个<code>Master</code>可以对应多个<code>Slave</code>，但是一个<code>Slave</code>只能对应一个<code>Master</code>，<code>Master</code>与<code>Slave</code> 的对应关系通过指定相同的<code>BrokerName</code>，不同的<code>BrokerId</code> 来定义，<code>BrokerId</code>为0表示<code>Master</code>，非0表示<code>Slave</code>。<code>Master</code>也可以部署多个。每个<code>Broker</code>与<code>NameServer</code>集群中的所有节点建立长连接，定时注册<code>Topic</code>信息到所有<code>NameServer</code>。 注意：当前<code>RocketMQ</code>版本在部署架构上支持一<code>Master</code>多<code>Slave</code>，但只有<code>BrokerId=1</code>的从服务器才会参与消息的读负载。</li>
<li><code>Producer</code>与<code>NameServer</code>集群中的其中一个节点（随机选择）建立长连接，定期从<code>NameServer</code>获取<code>Topic</code>路由信息，并向提供<code>Topic</code> 服务的<code>Master</code>建立长连接，且定时向<code>Master</code>发送心跳。<code>Producer</code>完全无状态，可集群部署。</li>
<li><code>Consumer</code>与<code>NameServer</code>集群中的其中一个节点（随机选择）建立长连接，定期从<code>NameServer</code>获取<code>Topic</code>路由信息，并向提供<code>Topic</code>服务的<code>Master</code>、<code>Slave</code>建立长连接，且定时向<code>Master</code>、<code>Slave</code>发送心跳。<code>Consumer</code>既可以从<code>Master</code>订阅消息，也可以从<code>Slave</code>订阅消息，消费者在向<code>Master</code>拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从<code>Master</code>还是<code>Slave</code>拉取。</li>
</ul>
<p>结合部署架构图，描述集群工作流程：</p>
<ul>
<li>启动<code>NameServer</code>，<code>NameServer</code>起来后监听端口，等待<code>Broker</code>、<code>Producer</code>、<code>Consumer</code>连上来，相当于一个路由控制中心。</li>
<li><code>Broker</code>启动，跟所有的<code>NameServer</code>保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有<code>Topic</code>信息。注册成功后，<code>NameServer</code>集群中就有<code>Topic</code>跟<code>Broker</code>的映射关系。</li>
<li>收发消息前，先创建<code>Topic</code>，创建<code>Topic</code>时需要指定该<code>Topic</code>要存储在哪些<code>Broker</code>上，也可以在发送消息时自动创建<code>Topic</code>。</li>
<li><code>Producer</code>发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从<code>NameServer</code>中获取当前发送的<code>Topic</code>存在哪些<code>Broker</code>上，轮询从队列列表中选择一个队列，然后与队列所在的<code>Broker</code>建立长连接从而向<code>Broker</code>发消息。</li>
<li><code>Consumer</code>跟<code>Producer</code>类似，跟其中一台<code>NameServer</code>建立长连接，获取当前订阅<code>Topic</code>存在哪些<code>Broker</code>上，然后直接跟<code>Broker</code>建立连接通道，开始消费消息。</li>
</ul>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>Apache RocketMQ在4.3.0版中已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。</p>
<p><img src="http://static.cyblogs.com/rocketmq_design_10.png" alt="http://static.cyblogs.com/rocketmq_design_10.png"></p>
<p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<h5 id="1-事务消息发送及提交："><a href="#1-事务消息发送及提交：" class="headerlink" title="1.事务消息发送及提交："></a>1.事务消息发送及提交：</h5><p>(1) 发送消息（half消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<h5 id="2-补偿流程："><a href="#2-补偿流程：" class="headerlink" title="2.补偿流程："></a>2.补偿流程：</h5><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="RocketMQ事务消息设计"><a href="#RocketMQ事务消息设计" class="headerlink" title="RocketMQ事务消息设计"></a>RocketMQ事务消息设计</h4><h5 id="1-事务消息在一阶段对用户不可见"><a href="#1-事务消息在一阶段对用户不可见" class="headerlink" title="1.事务消息在一阶段对用户不可见"></a>1.事务消息在一阶段对用户不可见</h5><p>在RocketMQ事务消息的主要流程中，一阶段的消息如何对用户不可见。其中，事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的。那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后改变主题为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>
<p>在RocketMQ中，消息在服务端的存储结构如下，每条消息都会有对应的索引信息，Consumer通过ConsumeQueue这个二级索引来读取消息实体内容，其流程如下：</p>
<p><img src="http://static.cyblogs.com/rocketmq_design_11.png" alt="http://static.cyblogs.com/rocketmq_design_11.png"></p>
<p>RocketMQ的具体实现策略是：写入的如果事务消息，对消息的Topic和Queue等属性进行替换，同时将原来的Topic和Queue信息存储到消息的属性中，正因为消息主题被替换，故消息并不会转发到该原主题的消息消费队列，消费者无法感知消息的存在，不会消费。其实改变消息主题是RocketMQ的常用“套路”，回想一下延时消息的实现机制。</p>
<h5 id="2-Commit和Rollback操作以及Op消息的引入"><a href="#2-Commit和Rollback操作以及Op消息的引入" class="headerlink" title="2.Commit和Rollback操作以及Op消息的引入"></a>2.Commit和Rollback操作以及Op消息的引入</h5><p>在完成一阶段写入一条对用户不可见的消息后，二阶段如果是Commit操作，则需要让消息对用户可见；如果是Rollback则需要撤销一阶段的消息。先说Rollback的情况。对于Rollback，本身一阶段的消息对用户是不可见的，其实不需要真正撤销消息（实际上RocketMQ也无法去真正的删除一条消息，因为是顺序写文件的）。但是区别于这条消息没有确定状态（Pending状态，事务悬而未决），需要一个操作来标识这条消息的最终状态。RocketMQ事务消息方案中引入了Op消息的概念，用Op消息标识事务消息已经确定的状态（Commit或者Rollback）。如果一条事务消息没有对应的Op消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。引入Op消息后，事务消息无论是Commit或者Rollback都会记录一个Op操作。Commit相对于Rollback只是在写入Op消息前创建Half消息的索引。</p>
<h5 id="3-Op消息的存储和对应关系"><a href="#3-Op消息的存储和对应关系" class="headerlink" title="3.Op消息的存储和对应关系"></a>3.Op消息的存储和对应关系</h5><p>RocketMQ将Op消息写入到全局一个特定的Topic中通过源码中的方法—TransactionalMessageUtil.buildOpTopic()；这个Topic是一个内部的Topic（像Half消息的Topic一样），不会被用户消费。Op消息的内容为对应的Half消息的存储的Offset，这样通过Op消息能索引到Half消息进行后续的回查操作。</p>
<p><img src="http://static.cyblogs.com/rocketmq_design_12.png" alt="http://static.cyblogs.com/rocketmq_design_12.png"></p>
<h5 id="4-Half消息的索引构建"><a href="#4-Half消息的索引构建" class="headerlink" title="4.Half消息的索引构建"></a>4.Half消息的索引构建</h5><p>在执行二阶段Commit操作时，需要构建出Half消息的索引。一阶段的Half消息由于是写到一个特殊的Topic，所以二阶段构建索引时需要读取出Half消息，并将Topic和Queue替换成真正的目标的Topic和Queue，之后通过一次普通消息的写入操作来生成一条对用户可见的消息。所以RocketMQ事务消息二阶段其实是利用了一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程。</p>
<h5 id="5-如何处理二阶段失败的消息？"><a href="#5-如何处理二阶段失败的消息？" class="headerlink" title="5.如何处理二阶段失败的消息？"></a>5.如何处理二阶段失败的消息？</h5><p>如果在RocketMQ事务消息的二阶段过程中失败了，例如在做Commit操作时，出现网络问题导致Commit失败，那么需要通过一定的策略使这条消息最终被Commit。RocketMQ采用了一种补偿机制，称为“回查”。Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。Broker端通过对比Half消息和Op消息进行事务消息的回查并且推进CheckPoint（记录那些事务消息的状态是确定的）。</p>
<p>值得注意的是，rocketmq并不会无休止的的信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，rocketmq默认回滚该消息。</p>
<h4 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h4><p>回溯消费是指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker 在吐 Consumer 投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障， 恢复后需要重新消费 1 小时前的数据，那么Broker 要提供一种机制，可以按照时间维度来回退消费进度。 </p>
<p>RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。</p>
<h4 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h4><p>消息中间件的主要功能是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性，这就要求消息中间件具有一定的消息堆积能力，消息堆积分以下两种情况： </p>
<p>(1). 消息堆积在内存 Buffer，一旦超过内存 Buffer，可以根据一定的丢弃策略来丢弃消息，如 CORBA Notification 规范中描述。适合能容忍丢弃消息的业务，这种情况消息的堆积能力主要在于内存 Buffer 大小，而且消息堆积后，性能下降不会太大，因为内存中数据多少对于对外提供的访问能力影响有限。 </p>
<p>Broker 的 Buffer 通常指的是 Broker 中一个队列的内存 Buffer 大小，这类 Buffer 通常大小有限，如果 Buffer 满 了以后怎么办？ 下面是 CORBA Notification 规范中处理方式： </p>
<ul>
<li><p>RejectNewEvents 拒绝新来的消息，向Producer返回RejectNewEvents错误码。 </p>
</li>
<li><p>按照特定策略丢弃已有消息 </p>
<ul>
<li>a) AnyOrder - Any event may be discarded on overflow. This is the default setting for this property. </li>
<li>b) FifoOrder - The first event received will be the first discarded. </li>
<li>c) LifoOrder - The last event received will be the first discarded. </li>
<li>d) PriorityOrder - Events should be discarded in priority order, such that lower priority</li>
</ul>
</li>
</ul>
<p>(2). 消息堆积到持久化存储系统中，例如 DB，KV 存储，文件记录形式。 当消息不能在内存 Cache 命中时，要不可避免的访问磁盘，会产生大量读 IO，读 IO 的吞吏量直接决定了消息堆积后的访问能力。 评估消息堆积能力主要有以下四点：</p>
<ul>
<li><p>消息能堆积多少条，多少字节？即消息的堆积容量。 </p>
</li>
<li><p>消息堆积后，收消息的吞吏量大小，是否会受堆积影响？</p>
</li>
<li><p>消息堆积后，正常消费的 Consumer 是否会受影响？ </p>
</li>
<li><p>消息堆积后，访问堆积在磁盘的消息时，吞吐量有多大？</p>
</li>
</ul>
<h4 id="零拷贝原理"><a href="#零拷贝原理" class="headerlink" title="零拷贝原理"></a>零拷贝原理</h4><p>Consumer 消费消息过程，使用了零拷贝，零拷贝包含以下两种方式 ：</p>
<h5 id="使用-mmap-write-方式"><a href="#使用-mmap-write-方式" class="headerlink" title="使用 mmap + write 方式"></a>使用 mmap + write 方式</h5><p><img src="http://static.cyblogs.com/%E6%B5%85%E6%9E%90%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF-2.png" alt="http://static.cyblogs.com/浅析零拷贝技术-2.png"></p>
<p>优点：即使频繁调用，使用小块文件传输，效率也很高 </p>
<p>缺点：不能很好的利用 DMA 方式，会比 sendfile 多消耗 CPU，内存安全性控制复杂，需要避免 JVM Crash 问题。 </p>
<h5 id="使用-sendfile-方式"><a href="#使用-sendfile-方式" class="headerlink" title="使用 sendfile 方式"></a>使用 sendfile 方式</h5><p><img src="http://static.cyblogs.com/%E6%B5%85%E6%9E%90%E9%9B%B6%E6%8B%B7%E8%B4%9D-03.jpg" alt="http://static.cyblogs.com/浅析零拷贝-03.jpg"></p>
<p>优点：可以利用 DMA 方式，消耗 CPU 较少，大块文件传输效率高，无内存安全新问题。 </p>
<p>缺点：小块文件效率低于mmap 方式，只能是BIO方式传输，不能使用 NIO。 RocketMQ 选择了第一种方式，mmap+write 方式，因为有小块数据传输的需求，效果会比 sendfile 更好。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="http://www.itmuch.com/books/rocketmq/" target="_blank" rel="noopener">http://www.itmuch.com/books/rocketmq/</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解ServiceLoader类与SPI机制</title>
    <url>/2020/04/06/2020/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ServiceLoader%E7%B1%BB%E4%B8%8ESPI%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>最近我们自己在重构项目，系统为了符合<code>82</code>原则（希望是80%的业务能通过穷举的方式固定下来，只有20%的允许特殊的定义），那么在固定一些标准流程以后，比如我们放大了原子服务的能力，当放大原子服务能力的时候，你就会发现，虽然抽象上看做的事情是一个意思，但是到实际去实现的时候发现还是各不相同。</p>
<p>在这里为了解决一个实现不同，但流程相同的问题，以及团队协作上的问题。我们引入的<code>SPI (Service Provider Interface)</code> 。</p>
<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>通常情况下，使用<code>ServiceLoader</code>来实现<code>SPI</code>机制。 <code>SPI</code> 全称为 <code>(Service Provider Interface)</code> ，是<code>JDK</code>内置的一种服务提供发现机制。<code>SPI</code>是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。</p>
<p><code>SPI</code>机制可以归纳为如下的图：</p>
<p><img src="http://static.cyblogs.com/20191111203102234.png" alt="http://static.cyblogs.com/20191111203102234.png"></p>
<p>如果大家看过源代码或者说看过一些博客文章大概都清楚，在一些开源项目中大量的使用了<code>SPI</code>的方式，比如：<code>mysql-connector-java</code>，<code>dubbo</code>等。</p>
<p>我们大概看眼<code>MySQL</code>的一个<code>SPI</code>实现</p>
<p><img src="http://static.cyblogs.com/WechatIMG450.png" alt="http://static.cyblogs.com/WechatIMG450.png"></p>
<p>JDBC中的接口即为：<code>java.sql.Driver</code></p>
<p>SPI机制的实现核心类为：<code>java.util.ServiceLoader</code></p>
<p>Provider则为：<code>com.mysql.jdbc.Driver</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.mysql.jdbc.Driver</span><br><span class="line">com.mysql.fabric.jdbc.FabricMySQLDriver</span><br></pre></td></tr></table></figure>

<h4 id="简单写个SPI"><a href="#简单写个SPI" class="headerlink" title="简单写个SPI"></a>简单写个SPI</h4><p>代码部分，接口与实现类定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.spi;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/4/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 11:08 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(String data)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.vernon.test.spi.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.vernon.test.spi.IRepository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/4/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 11:09 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Save "</span> + data + <span class="string">" to Mongo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.vernon.test.spi.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.vernon.test.spi.IRepository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/4/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 11:08 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlRepository</span> <span class="keyword">implements</span> <span class="title">IRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Save "</span> + data + <span class="string">" to Mysql"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.vernon.test.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/4/2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 11:12 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPIMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;IRepository&gt; serviceLoader = ServiceLoader.load(IRepository<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Iterator&lt;IRepository&gt; it = serviceLoader.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it != <span class="keyword">null</span> &amp;&amp; it.hasNext()) &#123;</span><br><span class="line">            IRepository demoService = it.next();</span><br><span class="line">            System.out.println(<span class="string">"class:"</span> + demoService.getClass().getName());</span><br><span class="line">            demoService.save(<span class="string">"tom"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:58517', transport: 'socket'</span><br><span class="line">class:com.vernon.test.spi.impl.MongoRepository</span><br><span class="line">Save tom to Mongo</span><br><span class="line">class:com.vernon.test.spi.impl.MysqlRepository</span><br><span class="line">Save tom to Mysql</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:58517', transport: 'socket'</span><br></pre></td></tr></table></figure>

<h4 id="ServiceLoader类的内部实现逻辑"><a href="#ServiceLoader类的内部实现逻辑" class="headerlink" title="ServiceLoader类的内部实现逻辑"></a>ServiceLoader类的内部实现逻辑</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">    loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SercviceLoader的初始化跑完如上代码就结束了。但是实际上联系待实现接口和实现接口的类之间的关系并不只是在构造ServiceLoader类的过程中完成的，而是在迭代器的方法<code>hasNext()</code>中实现的。</p>
<h4 id="动态调用的实现"><a href="#动态调用的实现" class="headerlink" title="动态调用的实现"></a>动态调用的实现</h4><p>在使用案例中写的forEach语句内部逻辑就是迭代器，迭代器的重要方法就是<code>hasNext()</code>：</p>
<p>ServiceLoader是一个实现了接口Iterable接口的类。</p>
<p><code>hasNext()</code>方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasNextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出复杂的确保安全的操作，可以将上述代码看作就是调用了方法：<code>hasNextService</code>.</p>
<p><code>hasNextService()</code>方法的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中比较重要的代码块是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br></pre></td></tr></table></figure>

<p>此处PREFIX（前缀）是一个常量字符串(用于规定配置文件放置的目录，使用相对路径，说明其上层目录为以项目名为名的文件夹)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br></pre></td></tr></table></figure>

<p>那么fullName会被赋值为：<code>META-INF/services/com.vernon.test.spi.IRepository</code></p>
<p>然后调用方法<code>getSystemResources</code>或<code>getResources</code>将fullName参数视作为URL，返回配置文件的URL集合 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pending = parse(service, configs.nextElement());</span><br></pre></td></tr></table></figure>

<p><code>parse</code>方法是凭借 参数1：接口的Class对象 和 参数2：配置文件的URL来解析配置文件，返回值是含有配置文件里面的内容，也就是实现类的全名（包名+类名）字符串的迭代器；</p>
<p>最后调用下面的代码，得到下面要加载的类的完成类路径字符串，相对路径。在使用案例中，此值就可以为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.vernon.test.spi.impl.MongoRepository</span><br><span class="line">com.vernon.test.spi.impl.MysqlRepository</span><br></pre></td></tr></table></figure>

<p>这仅仅是迭代器判断是否还有下一个迭代元素的方法，而获取每轮迭代元素的方法为：<code>nextService()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化</span></span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>1、<code>SPI</code>的理念：通过动态加载机制实现面向接口编程，提高了框架和底层实现的分离；<br>2、<code>ServiceLoader</code> 类提供的 <code>SPI</code> 实现方法只能通过遍历迭代的方法实现获得<code>Provider</code>的实例对象，如果要注册了多个接口的实现类，那么显得效率不高；<br>3、虽然通过静态方法返回，但是每一次<code>Service.load</code>方法的调用都会产生一个<code>ServiceLoader</code>实例，不属于单例设计模式；<br>4、<code>ServiceLoader</code>与<code>ClassLoader</code>是类似的，都可以负责一定的类加载工作，但是前者只是单纯地加载特定的类，即要求实现了<code>Service</code>接口的特定实现类；而后者几乎是可以加载所有<code>Java</code>类；<br>5、对于<code>SPi</code>机制的理解有两个要点：</p>
<ul>
<li>理解动态加载的过程，知道配置文件是如何被利用，最终找到相关路径下的类文件，并加载的；</li>
<li>理解 <code>SPI</code> 的设计模式：接口框架 和底层实现代码分离；</li>
</ul>
<p>6、之所以将<code>ServiceLoader</code>类内部的迭代器对象称为<code>LazyInterator</code>，是因为在<code>ServiceLoader</code>对象创建完毕时，迭代器内部并没有相关元素引用，只有真正迭代的时候，才会去解析、加载、最终返回相关类（迭代的元素）；</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/li_xunhuan/article/details/103017286" target="_blank" rel="noopener">https://blog.csdn.net/li_xunhuan/article/details/103017286</a></li>
<li><a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>群里一个转码问题的灵魂拷问</title>
    <url>/2020/04/02/2020/04/%E7%BE%A4%E9%87%8C%E4%B8%80%E4%B8%AA%E8%BD%AC%E7%A0%81%E9%97%AE%E9%A2%98%E7%9A%84%E7%81%B5%E9%AD%82%E6%8B%B7%E9%97%AE/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>这几天确实太忙了，之前是日更，说上班后来个隔日更，还是坚持不了。完成Q1季度的考评后发现群里有人问了一个问题，非常的有意思。当时我也是非常的懵逼，然后想自己尝试的去解决一下。</p>
<p>问题是：<code>0xee 0xb9</code>  转<code>short</code>得到 <code>-4423</code> 为什么？对啊，为什么？我TM也想知道。</p>
<p><img src="http://static.cyblogs.com/QQ20200411-001905@2x.jpg" alt="http://static.cyblogs.com/QQ20200411-001905@2x.jpg"></p>
<p>其实到这里，我先总结一下：</p>
<ul>
<li>计算机为什么能计算你这么快，原因是它只会处理0与1，二级制；</li>
<li>其实到硬件上面表现的就是电流信号、脉冲信号；</li>
<li>计算机虽然支持减法，乘法，除法，实际上底层只会一种算法，那就是加法；</li>
</ul>
<p>这也就是当时大学老师跟我们说的，别以为计算机很厉害，其实它很傻逼。每一步操作都需要设定好逻辑与程序。</p>
<h4 id="恶补基础知识点"><a href="#恶补基础知识点" class="headerlink" title="恶补基础知识点"></a>恶补基础知识点</h4><p>我们还是梳理一下基础知识吧~</p>
<ul>
<li><p>1、<code>byte</code>：有符号（意思是有正和负），在网络传输中都是会用到byte的，它占1个字节，共8位，比如说<a href="https://www.baidu.com/s?wd=1111&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">1111</a>1111就可以用1个byte表示，转化为10进制：- （2的6次+2的5次+2的4次+2的3次+2的2次+2的1次+2的0次） = -127。其中前7位表示数字，最高位表示符号，0为正，1为负。范围是 （-2的7次 ~ 2的7次 - 1），那为什么前面最小是-127，范围最小又是-128呢？因为规定-0（10000000）为-128。</p>
</li>
<li><p>2、<code>short</code>：有符号，占2个字节，共16位。同byte一样，它的取值范围就是 （-2的15次 ~ 2的15次 - 1）。</p>
</li>
<li><p>3、<code>int</code> ：有符号，占4个字节，共32位。它的取值范围就是（-2的31次 ~ 2的31次）。</p>
</li>
<li><p>4、<code>long</code>：有符号，占8个字节，共64位，它的取值范围就是（-2的63次 ~ 2的63次）。</p>
</li>
<li><p>5、<code>^</code>：表示异或位运算，两者相同则为0，两者不同则为1。比如说15^2，15用二进制表示就是1111，2用2进制表示就是0010，两者进行异或运算，结果就是1101，转换为十进制就是13。</p>
</li>
<li><p>6、<code>|</code>：表示或运算，两者只有有一个为1就为1， 比如说13|2，13用二进制表示就是1101，2用二进制表示就是0010，两者进行或运算，那么结果就是1111，转换为十进制就是15。</p>
</li>
<li><p>7、<code>&amp;</code>：表示与运算，两者都为1就为1，其余都为0，比如说15&amp;2， 13用二进制表示就是1111，2用二进制表示就是0010， 两者进行与运算，那么结果就是0010，转换为十进制就是2。</p>
</li>
<li><p>8、<code>~</code>：取反，就是本来是0变成1，本来是1变成0。</p>
</li>
</ul>
<p><strong>计算机中存储是用补码！！，同时注意一下计算省略了高位不变部分</strong></p>
<p>我举个例子，比如说<code>-15|3</code>等于多少呢？有些人会觉得<code>-15</code>转化为二进制就是<code>10001111</code>，而3转化为二进制就是<code>00000011</code>，那么结果应该是<code>10001111</code>呀，转换为十进制就是-15呀？大家可以自己写个<code>demo</code>就会发现是不对的。要注意在计算机中所有的都是用补码的形式存储的，之所以上面介绍两个正数是对的，因为正数的反码和补码都是一样的。而负数求补码应该是出去符号位取反+1，我们再来看看这个题<code>-15|3</code>，其中<code>-15</code>的原码为<code>10001111</code>，反码为<code>11110000</code>，那么补码就是<code>11110001</code>，然后3的补码为<code>00000011</code>，两者进行或操作就是<code>11110011</code>，你以为结束了么？还没有，再又要求它的原码了，原码就是补码再求补码再+1（是不是已经晕掉了？），也就是<code>10001101</code>，结果就是-13。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">求 -<span class="number">15</span>|<span class="number">3</span></span><br><span class="line"></span><br><span class="line">[-<span class="number">15</span>]原码 = <span class="number">10001111</span></span><br><span class="line">[-<span class="number">15</span>]反码 = <span class="number">11110000</span> <span class="comment">//原码求反码符号位不变</span></span><br><span class="line">[-<span class="number">15</span>]补码 = <span class="number">11110001</span> <span class="comment">//反码+1等于补码</span></span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]原码 = <span class="number">00000011</span></span><br><span class="line">[<span class="number">3</span>]反码 = <span class="number">00000011</span> <span class="comment">//正数都一致</span></span><br><span class="line">[<span class="number">3</span>]补码 = <span class="number">00000011</span> <span class="comment">//正数都一致</span></span><br><span class="line"></span><br><span class="line">-<span class="number">15</span>|<span class="number">3</span> = <span class="number">11110011</span> <span class="comment">//两个补码进行或操作</span></span><br><span class="line"></span><br><span class="line">[结果]补码 = <span class="number">11110011</span> <span class="comment">//上面求得的值</span></span><br><span class="line">[结果]反码 = <span class="number">10001100</span> <span class="comment">//符号位不变</span></span><br><span class="line">[结果]原码 = <span class="number">10001101</span> <span class="comment">//反码+1</span></span><br><span class="line"></span><br><span class="line"><span class="number">100001101</span> 转化为十进制就是-<span class="number">13</span>。</span><br></pre></td></tr></table></figure>

<h4 id="开始解他那道题"><a href="#开始解他那道题" class="headerlink" title="开始解他那道题"></a>开始解他那道题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@sophist</span> 其实这个是基础知识，我们在计算机的存储里面<span class="keyword">short</span>：<span class="number">16</span>位，最大数据存储量是<span class="number">65536</span>，数据范围是-<span class="number">32768</span>~<span class="number">32767</span>之间。</span><br><span class="line"></span><br><span class="line"><span class="number">0xee</span> <span class="number">0xb9</span> → -<span class="number">4423</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span>进制对应二进制：<span class="number">11101110</span> <span class="number">10111001</span></span><br><span class="line"></span><br><span class="line">high &lt;&lt; <span class="number">8</span> | low &amp; <span class="number">255</span> 低位保持不变</span><br><span class="line"></span><br><span class="line"><span class="number">11101110</span> <span class="number">00000000</span></span><br><span class="line">或</span><br><span class="line"><span class="number">00000000</span> <span class="number">10111001</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">1110111010111001</span> 第一位代表符号位，这个数字肯定是负数</span><br><span class="line"></span><br><span class="line">取不骂 + <span class="number">1</span></span><br><span class="line"><span class="number">1001000101000110</span> + <span class="number">1</span> = <span class="number">1001000101000111</span> = -<span class="number">4423</span></span><br></pre></td></tr></table></figure>

<p>这样子结果就得到了：-4423。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>自己亲手写一个SpringBoot的事物</title>
    <url>/2020/04/08/2020/04/%E8%87%AA%E5%B7%B1%E4%BA%B2%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AASpringBoot%E7%9A%84%E4%BA%8B%E7%89%A9/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>一直在用SpringBoot中的<code>@Transactional</code>来做事务管理，但是很少没想过SpringBoot是如何实现事务管理的，今天从源码入手，看看<code>@Transactional</code>是如何实现事务的，最后我们结合源码的理解，自己动手写一个类似的注解来实现事务管理，帮助我们加深理解。</p>
<blockquote>
<p>阅读说明：本文假设你具备Java基础，同时对事务有基本的了解和使用。</p>
</blockquote>
<h2 id="2-事务的相关知识"><a href="#2-事务的相关知识" class="headerlink" title="2. 事务的相关知识"></a>2. 事务的相关知识</h2><p>开始看源码之前，我们先回顾下事务的相关知识。</p>
<h3 id="2-1-事务的隔离级别"><a href="#2-1-事务的隔离级别" class="headerlink" title="2.1 事务的隔离级别"></a>2.1 事务的隔离级别</h3><p>事务为什么需要隔离级别呢？这是因为在并发事务情况下，如果没有隔离级别会导致如下问题：</p>
<ul>
<li><strong>脏读(Dirty Read)</strong> ：当A事务对数据进行修改，但是这种修改还没有提交到数据库中，B事务同时在访问这个数据，由于没有隔离，B获取的数据有可能被A事务回滚，这就导致了数据不一致的问题。</li>
<li><strong>丢失修改(Lost To Modify)</strong>: 当A事务访问数据100，并且修改为100-1=99，同时B事务读取数据也是100，修改数据100-1=99，最终两个事务的修改结果为99，但是实际是98。事务A修改的数据被丢失了。</li>
<li><strong>不可重复读(Unrepeatable Read)</strong>：指A事务在读取数据X=100的时候，B事务把数据X=100修改为X=200,这个时候A事务第二次读取数据X的时候，发现X=200了，导致了在整个A事务期间，两次读取数据X不一致了，这就是不可重复读。</li>
<li><strong>幻读(Phantom Read)</strong>：幻读和不可重复读类似。幻读表现在，当A事务读取表数据时候，只有3条数据，这个时候B事务插入了2条数据，当A事务再次读取的时候，发现有5条记录了，平白无故多了2条记录，就像幻觉一样。</li>
</ul>
<p><strong>不可重复读 VS 幻读</strong></p>
<p><strong>不可重复读的重点是修改</strong> <strong>:</strong>  同样的条件 ,  你读取过的数据 ,  再次读取出来发现值不一样了，重点在更新操作。 <strong>幻读的重点在于新增或者删除</strong>：同样的条件 ,  第 1 次和第 2 次读出来的记录数不一样，重点在增删操作。</p>
<p>所以，为了避免上述的问题，事务中就有了隔离级别的概念，在Spring中定义了五种表示隔离级别的常量：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TransactionDefinition.ISOLATION_DEFAULT</td>
<td>数据库默认的隔离级别，MySQL默认采用的 REPEATABLE_READ隔离级别</td>
</tr>
<tr>
<td>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</td>
<td>最低的隔离级别，允许读取未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</td>
</tr>
<tr>
<td>TransactionDefinition.ISOLATION_READ_COMMITTED</td>
<td>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</td>
</tr>
<tr>
<td>TransactionDefinition.ISOLATION_REPEATABLE_READ</td>
<td>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong>MySQL中通过MVCC解决了该隔离级别下出现幻读的可能。</td>
</tr>
<tr>
<td>TransactionDefinition.ISOLATION_SERIALIZABLE</td>
<td>串行化隔离级别，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>，但是串行化会影响性能。</td>
</tr>
</tbody></table>
<h3 id="2-2-Spring中事务的传播机制"><a href="#2-2-Spring中事务的传播机制" class="headerlink" title="2.2 Spring中事务的传播机制"></a>2.2 Spring中事务的传播机制</h3><p>为什么Spring中要搞一套事务的传播机制呢？这是Spring给我们提供的事务增强工具，主要是解决方法之间调用，事务如何处理的问题。比如有方法A、方法B和方法C，在A中调用了方法B和方法C。伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MethodA&#123;</span><br><span class="line">	MethodB；</span><br><span class="line">	MethodC;</span><br><span class="line">&#125;</span><br><span class="line">MethodB&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MethodC&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设三个方法中都开启了自己的事务，那么他们之间是什么关系呢？<code>MethodA</code>的回滚会影响<code>MethodB</code>和<code>MethodC</code>吗？Spring中的事务传播机制就是解决这个问题的。</p>
<p>Spring中定义了七种事务传播行为：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td>
</tr>
</tbody></table>
<p>这七种传播机制是如何影响事务的，感兴趣的同学可以阅读<a href="https://segmentfault.com/a/1190000013341344" target="_blank" rel="noopener">这篇文章</a>。</p>
<h2 id="3-如何实现异常回滚的"><a href="#3-如何实现异常回滚的" class="headerlink" title="3. 如何实现异常回滚的"></a>3. 如何实现异常回滚的</h2><p>回顾完了事务的相关知识，接下来我们正式来研究下Spring Boot中如何通过<code>@Transactional</code>来管理事务的，我们重点看看它是如何实现回滚的。</p>
<p>在Spring中<code>TransactionInterceptor</code>和<code>PlatformTransactionManager</code>这两个类是整个事务模块的核心，<code>TransactionInterceptor</code>负责拦截方法执行，进行判断是否需要提交或者回滚事务。<code>PlatformTransactionManager</code>是Spring 中的事务管理接口，真正定义了事务如何回滚和提交。我们重点研究下这两个类的源码。</p>
<p><code>TransactionInterceptor</code>类中的代码有很多，我简化一下逻辑，方便说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下代码省略部分内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//获取事务调用的目标方法</span></span><br><span class="line">Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//执行带事务调用</span></span><br><span class="line"><span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokeWithinTransaction 简化逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TransactionAspectSupport.class</span></span><br><span class="line"><span class="comment">//省略了部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object retVal;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用真正的方法体</span></span><br><span class="line">        retVal = invocation.proceedWithInvocation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 如果出现异常，执行事务异常处理</span></span><br><span class="line">        completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//最后做一下清理工作，主要是缓存和状态等</span></span><br><span class="line">        cleanupTransactionInfo(txInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有异常，直接提交事务。</span></span><br><span class="line">    commitTransactionAfterReturning(txInfo);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事务出现异常回滚的逻辑<code>completeTransactionAfterThrowing</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//省略部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(@Nullable TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">				<span class="comment">//判断是否需要回滚，判断的逻辑就是看有没有声明事务属性，同时判断是不是在目前的这个异常中执行回滚。</span></span><br><span class="line">			<span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">				<span class="comment">//执行回滚</span></span><br><span class="line">					txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">//否则不需要回滚，直接提交即可。</span></span><br><span class="line">					txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码已经把Spring的事务的基本原理说清楚了，如何进行判断执行事务，如何回滚。下面到了真正执行回滚逻辑的代码中<code>PlatformTransactionManager</code>接口的子类，我们以JDBC的事务为例，<code>DataSourceTransactionManager</code>就是jdbc的事务管理类。跟踪上面的代码<code>rollback(txInfo.getTransactionStatus())</code>可以发现最终执行的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">		DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">		Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">		<span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Rolling back JDBC transaction on Connection ["</span> + con + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//调用jdbc的 rollback进行回滚事务。</span></span><br><span class="line">			con.rollback();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TransactionSystemException(<span class="string">"Could not roll back JDBC transaction"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-小结"><a href="#3-1-小结" class="headerlink" title="3.1 小结"></a>3.1 小结</h3><p>这里小结下Spring 中事务的实现思路，Spring 主要依靠 <code>TransactionInterceptor</code> 来拦截执行方法体，判断是否开启事务，然后执行事务方法体，方法体中<code>catch</code>住异常,接着判断是否需要回滚，如果需要回滚就委托真正的<code>TransactionManager</code> 比如JDBC中的<code>DataSourceTransactionManager</code>来执行回滚逻辑。提交事务也是同样的道理。</p>
<p>这里用个流程图展示下思路：</p>
<p><img src="http://static.cyblogs.com/1712beda531a889a.png" alt="http://static.cyblogs.com/1712beda531a889a.png"></p>
<h2 id="4-手写一个注解实现事务回滚"><a href="#4-手写一个注解实现事务回滚" class="headerlink" title="4. 手写一个注解实现事务回滚"></a>4. 手写一个注解实现事务回滚</h2><p>我们弄清楚了Spring的事务执行流程，那我们可以模仿着自己写一个注解，实现遇到指定异常就回滚的功能。这里持久层就以最简单的JDBC为例。我们先梳理下需求，首先注解我们可以基于Spring 的AOP来实现，接着既然是JDBC,那么我们需要一个类来帮我们管理连接，用来判断异常是否回滚或者提交。梳理完就开干吧。</p>
<h3 id="4-1-首先加入依赖"><a href="#4-1-首先加入依赖" class="headerlink" title="4.1 首先加入依赖"></a>4.1 首先加入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-新增一个注解"><a href="#4-2-新增一个注解" class="headerlink" title="4.2 新增一个注解"></a>4.2 新增一个注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: luozhou </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-29 17:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTransaction &#123;</span><br><span class="line">    <span class="comment">//指定异常回滚</span></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-新增连接管理器"><a href="#4-3-新增连接管理器" class="headerlink" title="4.3 新增连接管理器"></a>4.3 新增连接管理器</h3><p>该类帮助我们管理连接，该类的核心功能是把取出的连接对象绑定到线程上，方便在AOP处理中取出，进行提交或者回滚操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: luozhou </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-29 21:14</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConnectHolder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程绑定对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal&lt;Connection&gt; resources = <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection con = resources.get();</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> con;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = dataSource.getConnection();</span><br><span class="line">            <span class="comment">//为了体现事务，全部设置为手动提交事务</span></span><br><span class="line">            con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        resources.set(con);</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection con = resources.get();</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resources.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-新增一个切面"><a href="#4-4-新增一个切面" class="headerlink" title="4.4 新增一个切面"></a>4.4 新增一个切面</h3><p>这部分是事务处理的核心，先获取注解上的异常类，然后捕获住执行的异常，判断异常是不是注解上的异常或者其子类，如果是就回滚，否则就提交。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: luozhou </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-29 17:08</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransactionAopHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSourceConnectHolder connectHolder;</span><br><span class="line">    Class&lt;? extends Throwable&gt;[] es;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截所有MyTransaction注解的方法</span></span><br><span class="line">    <span class="meta">@org</span>.aspectj.lang.annotation.Pointcut(<span class="string">"@annotation(luozhou.top.annotion.MyTransaction)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Transaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"Transaction()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">TransactionProceed</span><span class="params">(ProceedingJoinPoint proceed)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        Signature signature = proceed.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        MyTransaction transaction = method.getAnnotation(MyTransaction<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">            es = transaction.rollbackFor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = proceed.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">//异常处理</span></span><br><span class="line">            completeTransactionAfterThrowing(throwable);</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接提交</span></span><br><span class="line">        doCommit();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		* 执行回滚，最后关闭连接和清理线程绑定</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRollBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectHolder.getConnection().rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connectHolder.cleanHolder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		*执行提交，最后关闭连接和清理线程绑定</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectHolder.getConnection().commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connectHolder.cleanHolder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		*异常处理，捕获的异常是目标异常或者其子类，就进行回滚，否则就提交事务。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (es != <span class="keyword">null</span> &amp;&amp; es.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;? extends Throwable&gt; e : es) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.isAssignableFrom(throwable.getClass())) &#123;</span><br><span class="line">                    doRollBack();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doCommit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-测试验证"><a href="#4-5-测试验证" class="headerlink" title="4.5 测试验证"></a>4.5 测试验证</h3><p>创建一个tb_test表，表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">NAMES</span> utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for tb_test</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`tb_test`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-1-编写一个Service"><a href="#4-5-1-编写一个Service" class="headerlink" title="4.5.1 编写一个Service"></a>4.5.1 编写一个Service</h4><p><code>saveTest</code>方法调用了2个插入语句，同时声明了<code>@MyTransaction</code>事务注解，遇到<code>NullPointerException</code>就进行回滚，最后我们执行了除以0操作，会抛出<code>ArithmeticException</code>。我们用单元测试看看数据是否会回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: luozhou kinglaw1204@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-29 22:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransactionTest</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSourceConnectHolder holder;</span><br><span class="line">		<span class="comment">//一个事务中执行两个sql插入</span></span><br><span class="line">   <span class="meta">@MyTransaction</span>(rollbackFor = NullPointerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">saveTest</span>(<span class="title">int</span> <span class="title">id</span>) </span>&#123;</span><br><span class="line">        saveWitharamters(id, <span class="string">"luozhou@gmail.com"</span>);</span><br><span class="line">        saveWitharamters(id + <span class="number">10</span>, <span class="string">"luozhou@gmail.com"</span>);</span><br><span class="line">        <span class="keyword">int</span> aa = id / <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//执行sql</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveWitharamters</span><span class="params">(<span class="keyword">int</span> id, String email)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into tb_test values(?,?)"</span>;</span><br><span class="line">        Connection connection = holder.getConnection();</span><br><span class="line">        PreparedStatement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt = connection.prepareStatement(sql);</span><br><span class="line">            stmt.setInt(<span class="number">1</span>, id);</span><br><span class="line">            stmt.setString(<span class="number">2</span>, email);</span><br><span class="line">            stmt.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-2-单元测试"><a href="#4-5-2-单元测试" class="headerlink" title="4.5.2 单元测试"></a>4.5.2 单元测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SpringTransactionApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        service.saveTest(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/1712e8cd12a0b64e.jpg" alt="http://static.cyblogs.com/1712e8cd12a0b64e.jpg"></p>
<p>上图代码声明了事务对<code>NullPointerException</code>异常进行回滚，运行中遇到了<code>ArithmeticException</code>异常，所以是不会回滚的，我们在右边的数据库中刷新发现数据正常插入成功了，说明并没有回滚。</p>
<p><img src="http://static.cyblogs.com/1712e8cd12cd8755.jpg" alt="http://static.cyblogs.com/1712e8cd12cd8755.jpg"></p>
<p>我们把回滚的异常类改为<code>ArithmeticException</code>,把原数据清空再执行一次，出现了<code>ArithmeticException</code>异常，这个时候查看数据库是没有记录新增成功了，这说明事物进行回滚了，表明我们的注解起作用了。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文最开始回顾了事务的相关知识，并发事务会导致<strong>脏读</strong>、<strong>丢失修改</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>，为了解决这些问题，数据库中就引入了事务的隔离级别，隔离级别包括：<strong>读未提交</strong>、<strong>读提交</strong>、<strong>可重复读</strong>和<strong>串行化</strong>。</p>
<p>Spring中增强了事务的概念，为了解决方法A、方法B和方法C之间的事务关系，引入了事务传播机制的概念。</p>
<p>Spring中的<code>@Transactional</code>注解的事务实现主要通过<code>TransactionInterceptor</code>拦截器来进行实现的，拦截目标方法，然后判断异常是不是目标异常，如果是目标异常就行进行回滚，否则就进行事务提交。</p>
<p>最后我们自己通过JDBC结合Spring的AOP自己写了个<code>@MyTransactional</code>的注解，实现了遇到指定异常回滚的功能。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://juejin.im/post/5e7ef0bae51d4546f16bb3fb" target="_blank" rel="noopener">https://juejin.im/post/5e7ef0bae51d4546f16bb3fb</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>配置文件@ConfigurationProperties读取List、Map参数</title>
    <url>/2020/04/01/2020/04/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6@ConfigurationProperties%E8%AF%BB%E5%8F%96List%E3%80%81Map%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在SpringBoot环境中，我们有“使用不完的”注解。这也是SpringBoot替代了传统的Spring项目中的xml配置的原因。在使用这些annotation的时候，我们一定要了解这些注解背后的原理以及约定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.context.properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AliasFor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigurationProperties &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h4><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">custom.config.config1.folders[0]</span>=<span class="string">/root</span></span><br><span class="line"><span class="meta">custom.config.config1.folders[1]</span>=<span class="string">/home/user1</span></span><br><span class="line"><span class="meta">custom.config.config1.folders[2]</span>=<span class="string">/home/user2</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"custom.config.config1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config1Properties</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; folders;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">custom.config.config1.map.key1</span>=<span class="string">value1</span></span><br><span class="line"><span class="meta">custom.config.config1.map.key2</span>=<span class="string">value2</span></span><br><span class="line"><span class="meta">custom.config.config1.map.key3</span>=<span class="string">value3</span></span><br><span class="line"><span class="meta">custom.config.config1.map.key4</span>=<span class="string">value4</span></span><br><span class="line"><span class="meta">custom.config.config1.map.key5</span>=<span class="string">value5</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"custom.config.config1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config1Properties</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">custom.config.config1.server.host</span>=<span class="string">host1</span></span><br><span class="line"><span class="meta">custom.config.config1.server.port</span>=<span class="string">22</span></span><br><span class="line"><span class="meta">custom.config.config1.server.username</span>=<span class="string">username1</span></span><br><span class="line"><span class="meta">custom.config.config1.server.password</span>=<span class="string">password1</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"custom.config.config1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config1Properties</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ServerProperties server;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String host;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">		<span class="keyword">private</span> String username;</span><br><span class="line">		<span class="keyword">private</span> String password;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Object-List"><a href="#Object-List" class="headerlink" title="Object List"></a>Object List</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">custom.config.config1.servers[0].host</span>=<span class="string">host1</span></span><br><span class="line"><span class="meta">custom.config.config1.servers[0].port</span>=<span class="string">22</span></span><br><span class="line"><span class="meta">custom.config.config1.servers[0].username</span>=<span class="string">username1</span></span><br><span class="line"><span class="meta">custom.config.config1.servers[0].password</span>=<span class="string">password1</span></span><br><span class="line"><span class="meta">custom.config.config1.servers[1].host</span>=<span class="string">host2</span></span><br><span class="line"><span class="meta">custom.config.config1.servers[1].port</span>=<span class="string">22</span></span><br><span class="line"><span class="meta">custom.config.config1.servers[1].username</span>=<span class="string">username2</span></span><br><span class="line"><span class="meta">custom.config.config1.servers[1].password</span>=<span class="string">password2</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"custom.config.config1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config1Properties</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;ServerProperties&gt; servers;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String host;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">		<span class="keyword">private</span> String username;</span><br><span class="line">		<span class="keyword">private</span> String password;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map的使用案例"><a href="#Map的使用案例" class="headerlink" title="Map的使用案例"></a>Map的使用案例</h4><p>比如，我们同时需要连接多个OSS（阿里对象存储），那我们就可以利用ConfigurationProperties的方式来配置多个。而且可以通过Spring的加载动态的注入到容器中去。</p>
<p>配置中心的配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># OSS1配置</span></span><br><span class="line"><span class="meta">oss.multi.clients.accout.accessKeyId</span>=<span class="string">xxx</span></span><br><span class="line"><span class="meta">oss.multi.clients.accout.accessKeySecret</span>=<span class="string">xxx</span></span><br><span class="line"><span class="meta">oss.multi.clients.accout.privateEndpoint</span>=<span class="string">xxx</span></span><br><span class="line"><span class="meta">oss.multi.clients.accout.bucketName</span>=<span class="string">bucket-b-test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OSS2配置</span></span><br><span class="line"><span class="meta">oss.multi.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">oss.multi.clients.xdtrans.accessKeyId</span>=<span class="string">xxx</span></span><br><span class="line"><span class="meta">oss.multi.clients.xdtrans.accessKeySecret</span>=<span class="string">xxx</span></span><br><span class="line"><span class="meta">oss.multi.clients.xdtrans.privateEndpoint</span>=<span class="string">xxx</span></span><br><span class="line"><span class="meta">oss.multi.clients.xdtrans.bucketName</span>=<span class="string">bucket-a-test</span></span><br></pre></td></tr></table></figure>

<p>对应的Java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = OssConstants.MULTI_CONFIG_PREFIX)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiOssProperties</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, OssProperties&gt; clients;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OssProperties</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String accessKeyId;</span><br><span class="line">		<span class="keyword">private</span> String accessKeySecret;</span><br><span class="line">		<span class="keyword">private</span> String publicEndpoint;</span><br><span class="line">		<span class="keyword">private</span> String privateEndpoint;</span><br><span class="line">		<span class="keyword">private</span> String bucketName;</span><br><span class="line">		<span class="keyword">private</span> String object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>动态的定义我们需要的BeanDefinition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiOssScannerConfigurer</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Setter</span></span><br><span class="line">	<span class="keyword">private</span> MultiOssProperties multiOssProperties;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"init bean &#123;&#125;"</span>, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Objects.requireNonNull(<span class="keyword">this</span>.multiOssProperties, <span class="string">"multiOssProperties不能为空"</span>);</span><br><span class="line">		Objects.requireNonNull(<span class="keyword">this</span>.applicationContext, <span class="string">"applicationContext不能为空"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 动态的定义Bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		String beanSuffixName = StringUtils.capitalize(OssConstants.BEAN_SUFFIX_NAME);</span><br><span class="line">    <span class="comment">// productCodes实际与oss.multi.clients.xdtrans的xdtrans保持一致</span></span><br><span class="line">		multiOssProperties.getClients().forEach((productCode, ossProperties) -&gt; &#123;</span><br><span class="line">			AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(OssClient<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">					() -&gt; <span class="title">OssClientUtils</span>.<span class="title">buildOssClient</span>(<span class="title">ossProperties</span>))</span></span><br><span class="line"><span class="class">					.<span class="title">getRawBeanDefinition</span>()</span>;</span><br><span class="line">			beanDefinition.setInitMethodName(<span class="string">"init"</span>);</span><br><span class="line">			beanDefinition.setDestroyMethodName(<span class="string">"shutDown"</span>);</span><br><span class="line">			beanDefinitionRegistry.registerBeanDefinition(productCode + beanSuffixName, beanDefinition);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过binder来让配置与对应的Java代码产生关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MultiOssProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= OssConstants.MULTI_CONFIG_PREFIX, value = <span class="string">"enabled"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiOssAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化多个 ossClient 自动配置</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> environment 环境变量属性</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> OssClient 自动扫描注册器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MultiOssScannerConfigurer <span class="title">multiOssScannerConfigurer</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">		Binder binder = Binder.get(environment);</span><br><span class="line">		MultiOssProperties properties = binder.bind(OssConstants.MULTI_CONFIG_PREFIX, MultiOssProperties<span class="class">.<span class="keyword">class</span>).<span class="title">get</span>()</span>;</span><br><span class="line">		MultiOssScannerConfigurer multiOssScannerConfigurer = <span class="keyword">new</span> MultiOssScannerConfigurer();</span><br><span class="line">		multiOssScannerConfigurer.setMultiOssProperties(properties);</span><br><span class="line">		<span class="keyword">return</span> multiOssScannerConfigurer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OssTypeEnum &#123;</span><br><span class="line">		<span class="comment">// 注意一下这里的beanName,要跟上面的postProcessBeanDefinitionRegistry保持一致</span></span><br><span class="line">    XDtransOssClient(<span class="string">"xdtransOssClient"</span>, <span class="string">"oss1"</span>),</span><br><span class="line">    DianDianOssClient(<span class="string">"ddacctOssClient"</span>, <span class="string">"oss2"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据BeanName来Spring容器中获取即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OssClient <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SpringContextHolder.getBean(beanName, OssClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Binder是如何映射的？"><a href="#Binder是如何映射的？" class="headerlink" title="Binder是如何映射的？"></a>Binder是如何映射的？</h4><p>通过上面的代码<code>binder.bind(OssConstants.MULTI_CONFIG_PREFIX, MultiOssProperties.class).get();</code>来进行bind。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, BindHandler handler, Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">		context.clearConfigurationProperty();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			target = handler.onStart(name, target, context);</span><br><span class="line">			<span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Object bound = bindObject(name, target, handler, context,allowRecursiveBinding);</span><br><span class="line">			<span class="keyword">return</span> handleBindResult(name, target, handler, context, bound);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">return</span> handleBindError(name, target, handler, context, ex);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们的key是：oss.multi.clients.accout.xxx</p>
<p>实际上对应的是Map，那么它的引用名字就是clients。具体的key就是accout，那么对应的value就是OssProperties。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">bindBean</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;?&gt; target,</span></span></span><br><span class="line"><span class="function"><span class="params">		BindHandler handler, Context context, <span class="keyword">boolean</span> allowRecursiveBinding)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (containsNoDescendantOf(context.getSources(), name)</span><br><span class="line">			|| isUnbindableBean(name, target, context)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BeanPropertyBinder propertyBinder = (propertyName, propertyTarget) -&gt; bind(</span><br><span class="line">			name.append(propertyName), propertyTarget, handler, context, <span class="keyword">false</span>);</span><br><span class="line">	Class&lt;?&gt; type = target.getType().resolve(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span> (!allowRecursiveBinding &amp;&amp; context.hasBoundBean(type)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> context.withBean(type, () -&gt; &#123;</span><br><span class="line">		Stream&lt;?&gt; boundBeans = BEAN_BINDERS.stream()</span><br><span class="line">				.map((b) -&gt; b.bind(name, target, context, propertyBinder));</span><br><span class="line">		<span class="keyword">return</span> boundBeans.filter(Objects::nonNull).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/QQ20200422-222025@2x.jpg" alt="http://static.cyblogs.com/QQ20200422-222025@2x.jpg"></p>
<p>具体的一个bind情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;BeanBinder&gt; BEAN_BINDERS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	List&lt;BeanBinder&gt; binders = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	binders.add(<span class="keyword">new</span> JavaBeanBinder());</span><br><span class="line">	BEAN_BINDERS = Collections.unmodifiableList(binders);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">bind</span><span class="params">(ConfigurationPropertyName name, Bindable&lt;T&gt; target, Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">		BeanPropertyBinder propertyBinder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> hasKnownBindableProperties = hasKnownBindableProperties(name, context);</span><br><span class="line">	Bean&lt;T&gt; bean = Bean.get(target, hasKnownBindableProperties);</span><br><span class="line">	<span class="keyword">if</span> (bean == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BeanSupplier&lt;T&gt; beanSupplier = bean.getSupplier(target);</span><br><span class="line">	<span class="keyword">boolean</span> bound = bind(propertyBinder, bean, beanSupplier);</span><br><span class="line">	<span class="keyword">return</span> (bound ? beanSupplier.get() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回对应的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanSupplier&lt;T&gt; <span class="title">getSupplier</span><span class="params">(Bindable&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> BeanSupplier&lt;&gt;(() -&gt; &#123;</span><br><span class="line">		T instance = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (target.getValue() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = target.getValue().get();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = (T) BeanUtils.instantiateClass(<span class="keyword">this</span>.resolvedType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/sayyy/article/details/83657119" target="_blank" rel="noopener">https://blog.csdn.net/sayyy/article/details/83657119</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Transaction注解哪些情况不生效？</title>
    <url>/2020/05/01/2020/05/@Transaction%E6%B3%A8%E8%A7%A3%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%9F/</url>
    <content><![CDATA[<p>看一个最简单的<code>CGLIB</code>的例子，感受一下<code>AOP</code>是如何做到的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: chenyuan</span></span><br><span class="line"><span class="comment"> * Date: 16/4/25</span></span><br><span class="line"><span class="comment"> * Time: 上午9:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message = <span class="string">"----------test()----------"</span>;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: chenyuan</span></span><br><span class="line"><span class="comment"> * Date: 16/4/25</span></span><br><span class="line"><span class="comment"> * Time: 上午9:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span>  <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;MethodInterceptor start..."</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;MethodInterceptor ending..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"haha"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * User: chenyuan</span></span><br><span class="line"><span class="comment"> * Date: 16/4/25</span></span><br><span class="line"><span class="comment"> * Time: 上午9:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 第一步</span></span><br><span class="line">       Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">       <span class="comment">// 第二步</span></span><br><span class="line">       enhancer.setSuperclass(targetClass);</span><br><span class="line">       <span class="comment">// 第三步</span></span><br><span class="line">       enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line">       <span class="comment">// 第四步</span></span><br><span class="line">       <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String rags[])</span> </span>&#123;</span><br><span class="line">        CglibProxyTest cglibProxyTest = <span class="keyword">new</span> CglibProxyTest();</span><br><span class="line">        Target proxyTarget = (Target) cglibProxyTest.createProxy(Target<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String res = proxyTarget.execute();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后的结果显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:55868', transport: 'socket'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;MethodInterceptor start...</span></span><br><span class="line">----------test()----------</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;MethodInterceptor ending...</span></span><br><span class="line">haha</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:55868', transport: 'socket'</span><br></pre></td></tr></table></figure>

<p>实际上在执行<code>execute()</code>的前后就各自做了自己想要的操作。其实这个就是<code>Spring AOP</code>对简单的一个原型。</p>
<h4 id="Transaction的工作原理"><a href="#Transaction的工作原理" class="headerlink" title="@Transaction的工作原理"></a>@Transaction的工作原理</h4><p>在<code>Spring</code>中<code>TransactionInterceptor</code>和<code>PlatformTransactionManager</code>这两个类是整个事务模块的核心，<code>TransactionInterceptor</code>负责拦截方法执行，进行判断是否需要提交或者回滚事务。<code>PlatformTransactionManager</code>是Spring 中的事务管理接口，真正定义了事务如何回滚和提交。我们重点研究下这两个类的源码。</p>
<p><code>TransactionInterceptor</code>类中的代码有很多，我简化一下逻辑，方便说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下代码省略部分内容</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//获取事务调用的目标方法</span></span><br><span class="line">Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//执行带事务调用</span></span><br><span class="line"><span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，这里也就是因为用到了动态代理。在事务回滚这个动作的前前后后可以做自己想要的东西。这是一个非常重要的设计思想。如果我们自己要写框架，这个模式可以作为你的第一参考。</p>
<h4 id="基于注解的实现机制"><a href="#基于注解的实现机制" class="headerlink" title="基于注解的实现机制"></a>基于注解的实现机制</h4><ul>
<li>调用注解方法</li>
<li>生成代理对象 -  <code>CglibAopProxy</code>  调用内部类的方法<code>DynamicAdvisedInterceptor.intercept()</code></li>
<li><code>TransactionInterceptor.invoke()</code>拦截器拦截，在目标方法执行之前创建并加入事务</li>
<li><code>AbstractPlatformTransactionManager</code>抽象事务管理器操作数据源<code>DataSource</code>提交或回滚事务</li>
</ul>
<p>我们看了解一下它是如何仿照最上面的<code>code</code>来写的？</p>
<p>仿照上面<code>Demo</code>的第一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Creating CGLIB proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">			Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line"></span><br><span class="line">			Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">			<span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">				proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">				Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">				<span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">					<span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">			validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 第一点：Configure CGLIB Enhancer...</span></span><br><span class="line">			Enhancer enhancer = createEnhancer();</span><br><span class="line">			<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">				enhancer.setClassLoader(classLoader);</span><br><span class="line">				<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">						((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">					enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 第二点：setSuperclass</span></span><br><span class="line">			enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">			enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">			enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">			enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line">			<span class="comment">// 第三点：获取Callback</span></span><br><span class="line">			Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">			Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">				types[x] = callbacks[x].getClass();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">			enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">					<span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">			enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">			<span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of "</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line">					<span class="string">": Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">					ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>仿照上面Demo的第三步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Callback[] getCallbacks(Class&lt;?&gt; rootClass) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// Parameters used for optimization choices...</span></span><br><span class="line">		<span class="keyword">boolean</span> exposeProxy = <span class="keyword">this</span>.advised.isExposeProxy();</span><br><span class="line">		<span class="keyword">boolean</span> isFrozen = <span class="keyword">this</span>.advised.isFrozen();</span><br><span class="line">		<span class="keyword">boolean</span> isStatic = <span class="keyword">this</span>.advised.getTargetSource().isStatic();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Choose an "aop" interceptor (used for AOP calls).</span></span><br><span class="line">		Callback aopInterceptor = <span class="keyword">new</span> DynamicAdvisedInterceptor(<span class="keyword">this</span>.advised);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Choose a "straight to target" interceptor. (used for calls that are</span></span><br><span class="line">		<span class="comment">// unadvised but can return this). May be required to expose the proxy.</span></span><br><span class="line">		Callback targetInterceptor;</span><br><span class="line">		<span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">			targetInterceptor = (isStatic ?</span><br><span class="line">					<span class="keyword">new</span> StaticUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">					<span class="keyword">new</span> DynamicUnadvisedExposedInterceptor(<span class="keyword">this</span>.advised.getTargetSource()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			targetInterceptor = (isStatic ?</span><br><span class="line">					<span class="keyword">new</span> StaticUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) :</span><br><span class="line">					<span class="keyword">new</span> DynamicUnadvisedInterceptor(<span class="keyword">this</span>.advised.getTargetSource()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Choose a "direct to target" dispatcher (used for</span></span><br><span class="line">		<span class="comment">// unadvised calls to static targets that cannot return this).</span></span><br><span class="line">		Callback targetDispatcher = (isStatic ?</span><br><span class="line">				<span class="keyword">new</span> StaticDispatcher(<span class="keyword">this</span>.advised.getTargetSource().getTarget()) : <span class="keyword">new</span> SerializableNoOp());</span><br><span class="line"></span><br><span class="line">		Callback[] mainCallbacks = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">				aopInterceptor,  <span class="comment">// for normal advice</span></span><br><span class="line">				targetInterceptor,  <span class="comment">// invoke target without considering advice, if optimized</span></span><br><span class="line">				<span class="keyword">new</span> SerializableNoOp(),  <span class="comment">// no override for methods mapped to this</span></span><br><span class="line">				targetDispatcher, <span class="keyword">this</span>.advisedDispatcher,</span><br><span class="line">				<span class="keyword">new</span> EqualsInterceptor(<span class="keyword">this</span>.advised),</span><br><span class="line">				<span class="keyword">new</span> HashCodeInterceptor(<span class="keyword">this</span>.advised)</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		Callback[] callbacks;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the target is a static one and the advice chain is frozen,</span></span><br><span class="line">		<span class="comment">// then we can make some optimizations by sending the AOP calls</span></span><br><span class="line">		<span class="comment">// direct to the target using the fixed chain for that method.</span></span><br><span class="line">		<span class="keyword">if</span> (isStatic &amp;&amp; isFrozen) &#123;</span><br><span class="line">			Method[] methods = rootClass.getMethods();</span><br><span class="line">			Callback[] fixedCallbacks = <span class="keyword">new</span> Callback[methods.length];</span><br><span class="line">			<span class="keyword">this</span>.fixedInterceptorMap = <span class="keyword">new</span> HashMap&lt;&gt;(methods.length);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> small memory optimization here (can skip creation for methods with no advice)</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; methods.length; x++) &#123;</span><br><span class="line">				List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);</span><br><span class="line">				fixedCallbacks[x] = <span class="keyword">new</span> FixedChainStaticTargetInterceptor(</span><br><span class="line">						chain, <span class="keyword">this</span>.advised.getTargetSource().getTarget(), <span class="keyword">this</span>.advised.getTargetClass());</span><br><span class="line">				<span class="keyword">this</span>.fixedInterceptorMap.put(methods[x].toString(), x);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Now copy both the callbacks from mainCallbacks</span></span><br><span class="line">			<span class="comment">// and fixedCallbacks into the callbacks array.</span></span><br><span class="line">			callbacks = <span class="keyword">new</span> Callback[mainCallbacks.length + fixedCallbacks.length];</span><br><span class="line">			System.arraycopy(mainCallbacks, <span class="number">0</span>, callbacks, <span class="number">0</span>, mainCallbacks.length);</span><br><span class="line">			System.arraycopy(fixedCallbacks, <span class="number">0</span>, callbacks, mainCallbacks.length, fixedCallbacks.length);</span><br><span class="line">			<span class="keyword">this</span>.fixedInterceptorOffset = mainCallbacks.length;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			callbacks = mainCallbacks;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> callbacks;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>仿照上面Demo的第四步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxyClassAndInstance</span><span class="params">(Enhancer enhancer, Callback[] callbacks)</span> </span>&#123;</span><br><span class="line">		enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span><br><span class="line">		enhancer.setCallbacks(callbacks);</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>.constructorArgs != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.constructorArgTypes != <span class="keyword">null</span> ?</span><br><span class="line">				enhancer.create(<span class="keyword">this</span>.constructorArgTypes, <span class="keyword">this</span>.constructorArgs) :</span><br><span class="line">				enhancer.create());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上面的几步就完成了一个动态代理的流程，就只需要真的发生调用的时候去执行动态代理类了。</p>
<h4 id="哪些场景事物会失效？"><a href="#哪些场景事物会失效？" class="headerlink" title="哪些场景事物会失效？"></a>哪些场景事物会失效？</h4><ul>
<li>1、只对<code>public</code>修饰方法才起作用</li>
<li>2、<code>@Transaction</code>默认检测异常为<code>RuntimeException</code>及其子类 如果有其他异常需要回滚事务的需要自己手动配置，例如：<code>@Transactional(rollbackFor = Exception.class)</code></li>
<li>3、确保异常没有被<code>try-catch{}</code>，<code>catch</code>以后也不会回滚</li>
<li>4、检查下自己的数据库是否支持事务，如<code>mysql</code>的<code>mylsam</code></li>
<li>5、<code>SpringBoot</code>项目默认已经支持事务，不用配置；其他类型项目需要在<code>xml</code>中配置是否开启事务</li>
<li>6、如果在同一个类中，一个非<code>@Transaction</code>的方法调用有<code>@Transaction</code>的方法不会生效，因为代理问题</li>
</ul>
<p>这里说下在同一个类中，一个非<code>@Transaction</code>的方法调用有<code>@Transaction</code>的方法不会生效。如果是在同一个类中的方法调用，则不会被方法拦截器拦截到，因此事务不会起作用，必须将方法放入另外一个类中，并且该类通过Spring注入。</p>
<p><code>Spring</code> 采用动态代理（<code>AOP</code>）实现对<code>Bean</code>的管理和切片，它为我们的每个<code>class</code>生成一个代理对象，只有在代理对象之间进行调用时，可以触发切面逻辑。</p>
<p>而在同一个类中，方法B调用A,调用的事元对象的方法，而不是通过代理对象，所以<code>Spring</code>无法切到这次调用，也就是无法通过注解保证事务性。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/joker8023joker/article/details/103277571" target="_blank" rel="noopener">https://blog.csdn.net/joker8023joker/article/details/103277571</a></li>
<li><a href="https://blog.csdn.net/Dragon_1999/article/details/93059495" target="_blank" rel="noopener">https://blog.csdn.net/Dragon_1999/article/details/93059495</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World调试Hotspot</title>
    <url>/2020/05/12/2020/05/Hello%20World%E8%B0%83%E8%AF%95Hotspot/</url>
    <content><![CDATA[<h4 id="本地安装GDB"><a href="#本地安装GDB" class="headerlink" title="本地安装GDB"></a>本地安装GDB</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install gdb</span><br><span class="line"></span><br><span class="line">➜  ~  gdb --version</span><br><span class="line">GNU gdb (GDB) 9.1</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br></pre></td></tr></table></figure>

<p>除了这个，在Mac系统系统里面还要配置证书相关的操作。</p>
<p>按入下步骤创建代码签名的证书：</p>
<ol>
<li>打开 Keychain Access 应用程序（/Applications/Utilities/Keychain Access.app）</li>
<li>执行菜单 <strong>钥匙串访问</strong> -&gt; <strong>证书助理</strong> -&gt; <strong>创建证书</strong></li>
<li>填写如下信息：<ul>
<li>名称：gdb_codesign</li>
<li>身份类型：自签名根证书</li>
<li>证书类型：代码签名</li>
<li>钩选：<strong>让我覆盖这些默认设置</strong><br><img src="http://static.cyblogs.com/QQ20200524-221553@2x.jpg" alt="http://static.cyblogs.com/QQ20200524-221553@2x.jpg"></li>
</ul>
</li>
<li>一路确定，直到<strong>指定证书位置</strong>的步骤，选择<strong>系统</strong><br><img src="http://static.cyblogs.com/QQ20200524-221644@2x.jpg" alt="http://static.cyblogs.com/QQ20200524-221644@2x.jpg"></li>
<li>点击“创建”，会提示用输入系统登录密码，创建完成</li>
<li>在<strong>钥匙串访问程序</strong>中，选择左侧栏的<strong>系统</strong>和<strong>我的证书</strong>，找到你刚刚创建的<strong>gdb_codesign</strong>证书并双击打开证书信息窗口，展开<strong>信任</strong>项，设置<strong>使用此证书时：</strong>为<strong>始终信任</strong>。</li>
<li>关闭<strong>证书信息</strong>窗口，系统会再次要求输入系统登录密码。</li>
</ol>
<p>因为我现在的系统是MacOS Catania，是在 Mojave (10.14) 之后的系统。所以还需要创建一个配置文件<code>gdb-entitlement.xml</code>，其内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="meta-string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.security.cs.debugger<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Desktop  codesign --entitlements gdb-entitlement.xml -fs gdb_codesign $(which gdb)</span><br></pre></td></tr></table></figure>

<h4 id="终端中-gdb-断点进入源码调试-hotspot"><a href="#终端中-gdb-断点进入源码调试-hotspot" class="headerlink" title="终端中 gdb 断点进入源码调试 hotspot"></a>终端中 gdb 断点进入源码调试 hotspot</h4><h5 id="编译class"><a href="#编译class" class="headerlink" title="编译class"></a>编译class</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 在我的桌面创建一个Test.java文件</span><br><span class="line">vim Test.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到我对应的openjdk8的build地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Users/chenyuan/Workspaces/Openjdk/openjdk8/build/macosx-x86_64-normal-server-release/jdk</span><br></pre></td></tr></table></figure>

<p>利用<code>javac</code>、<code>java</code>命令运行Test.java文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Desktop  /Users/chenyuan/Workspaces/Openjdk/openjdk8/build/macosx-x86_64-normal-server-release/jdk/bin/javac Test.java</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> A fatal error has been detected by the Java Runtime Environment:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  SIGILL (0x4) at pc=0x000000010267c7eb, pid=89116, tid=0x0000000000004f03</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> JRE version: OpenJDK Runtime Environment (8.0) (build 1.8.0-internal-chenyuan_2020_05_24_03_17-b00)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Java VM: OpenJDK 64-Bit Server VM (25.71-b00 mixed mode bsd-amd64 compressed oops)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Problematic frame:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> V  [libjvm.dylib+0x47c7eb]  PerfDataManager::destroy()+0xab</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Failed to write core dump. Core dumps have been disabled. To <span class="built_in">enable</span> core dumping, try <span class="string">"ulimit -c unlimited"</span> before starting Java again</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> An error report file with more information is saved as:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /Users/chenyuan/Desktop/hs_err_pid89116.log</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you would like to submit a bug report, please visit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   http://bugreport.java.com/bugreport/crash.jsp</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line">[error occurred during error reporting , id 0x4]</span><br><span class="line"></span><br><span class="line">[1]    89116 abort       Test.java</span><br><span class="line">➜  Desktop  ll</span><br><span class="line">total 112</span><br><span class="line">-rw-r--r--  1 chenyuan  staff   415B May 24 21:33 Test.class</span><br><span class="line">-rw-r--r--  1 chenyuan  staff   116B May 24 21:31 Test.java</span><br><span class="line">-rw-r--r--  1 chenyuan  staff    46K May 24 21:33 hs_err_pid89116.log</span><br><span class="line">➜  Desktop  /Users/chenyuan/Workspaces/Openjdk/openjdk8/build/macosx-x86_64-normal-server-release/jdk/bin/java Test</span><br><span class="line">hello world !  ------- 牛逼的打印，无敌的HelloWorkd</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> A fatal error has been detected by the Java Runtime Environment:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  SIGILL (0x4) at pc=0x000000010be7c7eb, pid=89512, tid=0x0000000000002403</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> JRE version: OpenJDK Runtime Environment (8.0) (build 1.8.0-internal-chenyuan_2020_05_24_03_17-b00)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Java VM: OpenJDK 64-Bit Server VM (25.71-b00 mixed mode bsd-amd64 compressed oops)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Problematic frame:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> V  [libjvm.dylib+0x47c7eb]  PerfDataManager::destroy()+0xab</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Failed to write core dump. Core dumps have been disabled. To <span class="built_in">enable</span> core dumping, try <span class="string">"ulimit -c unlimited"</span> before starting Java again</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> An error report file with more information is saved as:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /Users/chenyuan/Desktop/hs_err_pid89512.log</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you would like to submit a bug report, please visit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   http://bugreport.java.com/bugreport/crash.jsp</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line">[error occurred during error reporting , id 0x4]</span><br><span class="line"></span><br><span class="line">[1]    89512 abort       Test</span><br></pre></td></tr></table></figure>

<h5 id="gdb测试"><a href="#gdb测试" class="headerlink" title="gdb测试"></a>gdb测试</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Desktop  gdb --args /Users/chenyuan/Workspaces/Openjdk/openjdk8/build/macosx-x86_64-normal-server-release/jdk/bin/java Test</span><br><span class="line">GNU gdb (GDB) 9.1</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type "show copying" and "show warranty" for details.</span><br><span class="line">This GDB was configured as "x86_64-apple-darwin19.3.0".</span><br><span class="line">Type "show configuration" for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For help, type "help".</span><br><span class="line">Type "apropos word" to search for commands related to "word"...</span><br><span class="line">Reading symbols from /Users/chenyuan/Workspaces/Openjdk/openjdk8/build/macosx-x86_64-normal-server-release/jdk/bin/java...</span><br><span class="line">(gdb) break init.cpp:95</span><br><span class="line">No source file named init.cpp.</span><br><span class="line">Make breakpoint pending on future shared library load? (y or [n]) y</span><br><span class="line">Breakpoint 1 (init.cpp:95) pending.</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /Users/chenyuan/Workspaces/Openjdk/openjdk8/build/macosx-x86_64-normal-server-release/jdk/bin/java Test</span><br><span class="line">[New Thread 0x1803 of process 22052]</span><br><span class="line">[New Thread 0x2503 of process 22052]</span><br><span class="line">[New Thread 0x2403 of process 22052]</span><br><span class="line">warning: unhandled dyld version (16)</span><br><span class="line">[New Thread 0x180f of process 22052]</span><br><span class="line">[New Thread 0x2303 of process 22052]</span><br><span class="line"></span><br><span class="line">Thread 4 received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[Switching to Thread 0x180f of process 22052]</span><br><span class="line">0x00000001040002b4 in ?? ()</span><br><span class="line">(gdb) l</span><br><span class="line">111	    // add one more to mark the end</span><br><span class="line">112	    margv = (char **)JLI_MemAlloc((margc + 1) * (sizeof(char *)));</span><br><span class="line">113	    &#123;</span><br><span class="line">114	        int i = 0;</span><br><span class="line">115	        StdArg *stdargs = JLI_GetStdArgs();</span><br><span class="line">116	        for (i = 0 ; i &lt; margc ; i++) &#123;</span><br><span class="line">117	            margv[i] = stdargs[i].arg;</span><br><span class="line">118	        &#125;</span><br><span class="line">119	        margv[i] = NULL;</span><br><span class="line">120	    &#125;</span><br><span class="line">(gdb) quit</span><br><span class="line">A debugging session is active.</span><br><span class="line"></span><br><span class="line">	Inferior 1 [process 22052] will be killed.</span><br><span class="line"></span><br><span class="line">Quit anyway? (y or n) y</span><br></pre></td></tr></table></figure>

<p>我在这里发现l这里查看代码跟我debug的地方并不同，我就看看日志发现日志中当时有一个提示：<code>No source file named init.cpp.</code>  然后又找了一翻文章，找到这个时候当时编译的时候没有添加g参数。详细请看：<a href="https://blog.csdn.net/wenceng9/article/details/21372265" target="_blank" rel="noopener">https://blog.csdn.net/wenceng9/article/details/21372265</a> （我是在不想再重新编译一次了，因为想早点睡觉。哈哈~）</p>
<h4 id="Clion中调试不香吗？"><a href="#Clion中调试不香吗？" class="headerlink" title="Clion中调试不香吗？"></a>Clion中调试不香吗？</h4><p>打开 clion，选择 <code>File-&gt;ImportProject</code>，选择到 <code>/Users/chenyuan/Workspaces/Openjdk/openjdk8/hotspot</code> 作为 jvm 源码的根目录，这里导入的过程无脑点击 <code>next</code> 即可</p>
<p>对于可能遇到的头文件不包含问题，解决如下：</p>
<p>clion 导入源码之后遇到头文件找不到的问题，而实际上这些头文件在源码里面是存在的，只不过在某些源文件里面是以相对路径的方式来搜索，可以在 <code>CMakeLists.txt</code> 里面添加一些根路径。</p>
<p><img src="http://static.cyblogs.com/QQ20200524-223658@2x.jpg" alt="http://static.cyblogs.com/QQ20200524-223658@2x.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include_directories(./src/share/vm)</span><br><span class="line">include_directories(./src/cpu/x86/vm)</span><br><span class="line">include_directories(./src/share/vm/precompiled)</span><br><span class="line">include_directories(./src/share/vm/utilities)</span><br></pre></td></tr></table></figure>

<p>另外，如果某些头文件依然找不到，可以手工导入，然后把导入的头文件加到<br><code>hotspot/src/share/vm/precompiled/precompiled.hpp</code> 里，因为大多数源文件都会包含这个源文件</p>
<p><img src="http://static.cyblogs.com/QQ20200524-223840@2x.jpg" alt="http://static.cyblogs.com/QQ20200524-223840@2x.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"register_x86.hpp"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"assembler_x86.hpp"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"globalDefinitions.hpp"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"globalDefinitions_x86.hpp"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"assembler_x86.hpp"</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stubRoutines_x86.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>进入如下界面，添加 <code>Application：openjdk8</code>，<code>Execuable</code> 中选择<code>/Users/chenyuan/Workspaces/Openjdk/openjdk8/build/macosx-x86_64-normal-server-release/jdk/bin</code></p>
<p><img src="http://static.cyblogs.com/QQ20200524-224033@2x.jpg" alt="http://static.cyblogs.com/QQ20200524-224033@2x.jpg"></p>
<p>配置完成后，就可以执行openjdk8了。</p>
<p><img src="http://static.cyblogs.com/QQ20200524-224305@2x.jpg" alt="http://static.cyblogs.com/QQ20200524-224305@2x.jpg"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://segmentfault.com/q/1010000004136334" target="_blank" rel="noopener">https://segmentfault.com/q/1010000004136334</a></li>
<li><a href="https://rqsir.github.io/2019/04/19/openjdk-8-使用Clion调试源码/" target="_blank" rel="noopener">https://rqsir.github.io/2019/04/19/openjdk-8-使用Clion调试源码/</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>JSR269插件化注解API</title>
    <url>/2020/05/13/2020/05/JSR269%E6%8F%92%E4%BB%B6%E5%8C%96%E6%B3%A8%E8%A7%A3API/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>一直在使用<code>Lombok</code>以及<code>MapStruct</code>，但是对于它们能够在编译阶段直接生成实例代码却没有仔细了解过。最近刚好在部门内做了一次分享，也在这里对具体原理做一个详细阐述。</p>
<h4 id="Lombok以及MapStruct实现大体思路"><a href="#Lombok以及MapStruct实现大体思路" class="headerlink" title="Lombok以及MapStruct实现大体思路"></a>Lombok以及MapStruct实现大体思路</h4><p><code>Lombok</code>以及<code>MapStruct</code>都是通过在目标代码上标记注解，编译器能够根据注解生成对应的实现代码。比如<code>Lombok</code>在属性上标记<code>@Getter</code>，那么在这个<code>Java Bean</code>内就会生成对应属性的<code>get</code>方法。</p>
<p>本质上来说，不管是<code>Lombok</code>或者<code>MapStruct</code>，都是通过<code>Java</code>的一个标准<code>API</code>来实现的；这个<code>API</code>即为<code>Pluggable Annotation Processing API</code>，简称为<code>JSR269</code>。</p>
<h4 id="JSR269"><a href="#JSR269" class="headerlink" title="JSR269"></a>JSR269</h4><p>借用JSR269官方原文定义（附带原文地址：<a href="https://jcp.org/en/jsr/detail?id=269）：" target="_blank" rel="noopener">https://jcp.org/en/jsr/detail?id=269）：</a></p>
<blockquote>
<p>J2SE 1.5 added a new Java language mechanism “annotations” that allows annotation types to be used to annotate classes, fields, and methods. These annotations are typically processed either by build-time tools or by run-time libraries to achieve new semantic effects. In order to support annotation processing at build-time, this JSR will define APIs to allow annotation processors to be created using a standard pluggable API. This will simplify the task of creating annotation processors and will also allow automation of the discovery of appropriate annotation processors for a given source file.<br>The specification will include at least two sections, a section of API modeling the Java programming language and a distinct section for declaring annotation processors and controlling how they are run. Since annotations are placed on program elements, an annotation processing framework needs to reflect program structure. Annotation processors will be able to specify what annotations they process and multiple processors will be able to run cooperatively.<br>The processors and program structure api can be accessed at build-time; i.e. this functionality supplements core reflection support for reading annotations.</p>
</blockquote>
<p>译文如下：</p>
<blockquote>
<p>J2SE 1.5 增加了一种新的Java语言机制”annotations“，它允许注解被用于类、字段以及方法上。这些注解由 <code>build-time</code> 工具以及 <code>run-time</code> 库处理，来达到新的语义效果。为了支持在 <code>build-time</code> 时处理注解，这个JSR定义了通用的插入式API用于创建标准的注解处理器。这将简化创建注解处理器的任务，并且还能够根据源文件自动匹配响应的注解处理器。<br>该规范将至少包含两个部分，一部分用于建模Java编程语言的API，另一部分用于声明注解处理器以及他们的运作机制。由于注解被用于程序元素上，一个注解处理框架需要反映程序结构。注解处理器将能指定哪些注解是它们可以处理的，以及多个注解处理器如何协同工作。<br>注解处理器以及程序框架api可以在 <code>build-time</code> 时访问；举个例子，此功能提供了核心反射支持用于读取注解（注：一般指从源码内读取注解或者只读取标注为<code>source-only</code>的注解）。</p>
</blockquote>
<p>即，在J2SE 1.6版本加入的JSR269的主要点如下：</p>
<ul>
<li>专门用于支持 <code>J2SE 1.5</code> 无法处理的 <code>build-time</code> 注解处理场景，并定义通用注解处理API</li>
<li>引入程序框架api</li>
</ul>
<h4 id="JSR269运行机制"><a href="#JSR269运行机制" class="headerlink" title="JSR269运行机制"></a>JSR269运行机制</h4><p><code>javac/Mainmain/Mainmain/JavaCompilerprocessing/JavaProcessingEnvironmentprocessing/Roundprocessing/DiscoveredProcessorsnew main.Main(&quot;javac)</code>编译参数传递<code>Javac</code>上下文创建<code>JavaFileManager.preRegister</code>预注册执行<code>compile</code>，并传递编译参数以及上下文参数有误显示帮助信息参数解析(获取<code>class</code>以及<code>files</code>并初始化注解处理器路径)无<code>source.files.classesJavaCompiler</code>实例创建传递源文件列表以及类列表不初始化初始化注解设置<code>Processors</code>从参数获取<code>processorsprocessors</code>初始化并赋值给<code>discoveredProcsalt</code>[ PROC为none值 ][ PROC非none值 ]处理注解将需要的<code>package</code>注解以及<code>class</code>注解加入待处理列表传递上下文、待处理的包类注解列表构造<code>Round</code>构造<code>JavacRoundEnvironment</code>，传递包类通过顶层的包类找到所有支持的注解通过变量<code>annotationsPresent</code>判断这个注解是否支持加入待处理列表；</p>
<p><code>matchedNames</code>添加支持的注解名不做处理，继续下一步alt[ 注解支持 ][ 注解不支持 ]调用注解处理器的<code>process</code>方法标记注解处理器已被执行<code>unmatchedAnnotations</code>移除<code>matchedNames</code>内所有匹配的项不做处理，继续下一步alt[ 执行结果是为true ][ 执行结果为false ]不做处理，继续下一步</p>
<ul>
<li>alt[ matchedNames是否不为空且处理器是否已被执行 ]</li>
<li>loop[ 循环discoveredProcs ]</li>
</ul>
<p>一次<code>round</code>循环完成构建下一个<code>roundloop</code>[ 循环直到没有新文件产生(moreToDo方法) ]执行最后一次run方法所有执行过的<code>processor</code>会带上空注解集合参数再次执行一遍完成执行完成最后一次<code>round</code>判断本次是否存在错误，存在则标记<code>errorStatus</code>清理所有包类构建为最终编译使用的<code>JavaCompiler</code>错误数不为0返回编译器错误数为0日志记录无错误+1enterTreesalt[ errorStatus状态为true ][ erroStatus状态为false ]返回编译器执行编译完成执行错误执行正确alt[ 错误数大于0 ][ 为空 ]alt[ 解析的文件为空且含有注解处理参数 ][ 存在文件或者无注解处理参数 ]<code>javac/Mainmain/Mainmain/JavaCompilerprocessing/JavaProcessingEnvironmentprocessing/Roundprocessing/DiscoveredProcessors</code></p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p>构建三个模块：</p>
<ol>
<li>注解处理类以及目标注解类</li>
<li>注解注册为服务</li>
<li>调用方</li>
</ol>
<h5 id="注解类以及处理类"><a href="#注解类以及处理类" class="headerlink" title="注解类以及处理类"></a>注解类以及处理类</h5><p>注解类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解处理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(value = &#123;<span class="string">"com.whatakitty.learn.jsr269.Test"</span>&#125;)</span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(value = SourceVersion.RELEASE_8)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Messager messager;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span> </span>&#123;</span><br><span class="line">        messager = env.getMessager();</span><br><span class="line">        atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">super</span>.init(env);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">"Hello World!"</span> + atomicInteger.incrementAndGet());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h5><p>在文件夹<code>resources/META-INF/services</code>下创建文件<code>javax.annotation.processing.Processor</code>，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.whatakitty.learn.jsr269.AnnotationProcessor</span><br></pre></td></tr></table></figure>

<h5 id="调用方"><a href="#调用方" class="headerlink" title="调用方"></a>调用方</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"success"</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>(<span class="string">"method is test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="http://static.cyblogs.com/191455.jpg" alt="http://static.cyblogs.com/191455.jpg"></p>
<p>可以看到，上图中已经输出两次<strong>Hello World!</strong>。至于为什么会输出两次，是由于第一次是本身注解的处理调用；最后一次是，jdk会在所有注解处理完成后，将所有处理过的注解全部传入空注解再次执行一遍，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Run all remaining processors on the procStateList that</span></span><br><span class="line"><span class="comment">  * have not already run this round with an empty set of</span></span><br><span class="line"><span class="comment">  * annotations.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runContributingProcs</span><span class="params">(RoundEnvironment re)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!onProcInterator) &#123;</span><br><span class="line">    <span class="comment">// 构造空的注解元素集合</span></span><br><span class="line">    Set&lt;TypeElement&gt; emptyTypeElements = Collections.emptySet();</span><br><span class="line">    <span class="comment">// 遍历所有注册的注解处理器</span></span><br><span class="line">    <span class="keyword">while</span>(innerIter.hasNext()) &#123;</span><br><span class="line">        ProcessorState ps = innerIter.next();</span><br><span class="line">        <span class="comment">// 判断该注解处理器是否在之前处理过注解，未参与过的不会调用</span></span><br><span class="line">        <span class="keyword">if</span> (ps.contributed)</span><br><span class="line">          <span class="comment">// 传入空的注解元素集合，重新调用一次注解处理器</span></span><br><span class="line">          callProcessor(ps.processor, emptyTypeElements, re);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lombok原理"><a href="#Lombok原理" class="headerlink" title="Lombok原理"></a>Lombok原理</h4><p><code>Lombok</code>基于<code>JSR269 API</code>实现了通过特定注解生成对应代码的功能。</p>
<p><code>Lombok</code>主要在类<code>LombokProcessor</code>处理了自己的注解通过<code>AST</code>生成代码。如下，主要看两个重写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化本次处理的一些变量等</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment procEnv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.init(procEnv);</span><br><span class="line">  <span class="comment">// 判断lombok是否被禁用</span></span><br><span class="line">  <span class="keyword">if</span> (System.getProperty(<span class="string">"lombok.disable"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    lombokDisabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.processingEnv = procEnv;</span><br><span class="line">  <span class="keyword">this</span>.javacProcessingEnv = getJavacProcessingEnvironment(procEnv);</span><br><span class="line">  <span class="keyword">this</span>.javacFiler = getJavacFiler(procEnv.getFiler());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换类加载器、对netbeans IDE相关hook处理、替换JavaFileManager</span></span><br><span class="line">  placePostCompileAndDontMakeForceRoundDummiesHook();</span><br><span class="line">  trees = Trees.instance(javacProcessingEnv);</span><br><span class="line">  transformer = <span class="keyword">new</span> JavacTransformer(procEnv.getMessager(), trees);</span><br><span class="line">  <span class="comment">// 获取标记HandlerPriority注解的所有优先级</span></span><br><span class="line">  SortedSet&lt;Long&gt; p = transformer.getPriorities();</span><br><span class="line">  <span class="keyword">if</span> (p.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.priorityLevels = <span class="keyword">new</span> <span class="keyword">long</span>[] &#123;<span class="number">0L</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.priorityLevelsRequiringResolutionReset = <span class="keyword">new</span> HashSet&lt;Long&gt;();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.priorityLevels = <span class="keyword">new</span> <span class="keyword">long</span>[p.size()];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环所有获取到的注释或者visit处理优先级</span></span><br><span class="line">    <span class="keyword">for</span> (Long prio : p) <span class="keyword">this</span>.priorityLevels[i++] = prio;</span><br><span class="line">    <span class="keyword">this</span>.priorityLevelsRequiringResolutionReset = transformer.getPrioritiesRequiringResolutionReset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** &#123;<span class="doctag">@inheritDoc</span>&#125; */</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果禁用，则不处理lombok注解</span></span><br><span class="line">  <span class="keyword">if</span> (lombokDisabled) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 是否已经处理结束</span></span><br><span class="line">  <span class="keyword">if</span> (roundEnv.processingOver()) &#123;</span><br><span class="line">    cleanup.run();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// We have: A sorted set of all priority levels: 'priorityLevels'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Step 1: Take all CUs which aren't already in the map. Give them the first priority level.</span></span><br><span class="line">  </span><br><span class="line">  String randomModuleName = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 标记所有编译单元的优先级</span></span><br><span class="line">  <span class="comment">// 如果是第二次循环，因为roots已经包含了这个编译单元，所以会忽略</span></span><br><span class="line">  <span class="keyword">for</span> (Element element : roundEnv.getRootElements()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (randomModuleName == <span class="keyword">null</span>) randomModuleName = getModuleNameFor(element);</span><br><span class="line">    JCCompilationUnit unit = toUnit(element);</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (roots.containsKey(unit)) <span class="keyword">continue</span>;</span><br><span class="line">    roots.put(unit, priorityLevels[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// Step 2: For all CUs (in the map, not the roundEnv!), run them across all handlers at their current prio level.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环优先级列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> prio : priorityLevels) &#123;</span><br><span class="line">      List&lt;JCCompilationUnit&gt; cusForThisRound = <span class="keyword">new</span> ArrayList&lt;JCCompilationUnit&gt;();</span><br><span class="line">      <span class="comment">// 获取在该优先级下的所有编译单元并加入该优先级下需要处理的编译单元列表内</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;JCCompilationUnit, Long&gt; entry : roots.entrySet()) &#123;</span><br><span class="line">        Long prioOfCu = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (prioOfCu == <span class="keyword">null</span> || prioOfCu != prio) <span class="keyword">continue</span>;</span><br><span class="line">        cusForThisRound.add(entry.getKey());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 按照优先级顺序执行编译单元</span></span><br><span class="line">      <span class="comment">// 访问AST树并编译目标注解</span></span><br><span class="line">      transformer.transform(prio, javacProcessingEnv.getContext(), cusForThisRound, cleanup);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 3: Push up all CUs to the next level. Set level to null if there is no next level.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排除掉列表第一个优先级准备执行下一次循环</span></span><br><span class="line">    Set&lt;Long&gt; newLevels = <span class="keyword">new</span> HashSet&lt;Long&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = priorityLevels.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      Long curLevel = priorityLevels[i];</span><br><span class="line">      Long nextLevel = (i == priorityLevels.length - <span class="number">1</span>) ? <span class="keyword">null</span> : priorityLevels[i + <span class="number">1</span>];</span><br><span class="line">      List&lt;JCCompilationUnit&gt; cusToAdvance = <span class="keyword">new</span> ArrayList&lt;JCCompilationUnit&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;JCCompilationUnit, Long&gt; entry : roots.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curLevel.equals(entry.getValue())) &#123;</span><br><span class="line">          cusToAdvance.add(entry.getKey());</span><br><span class="line">          newLevels.add(nextLevel);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (JCCompilationUnit unit : cusToAdvance) &#123;</span><br><span class="line">        roots.put(unit, nextLevel);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newLevels.remove(<span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 4: If ALL values are null, quit. Else, either do another loop right now or force a resolution reset by forcing a new round in the annotation processor.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否将所有优先级排除，优先级列表为空，则结束</span></span><br><span class="line">    <span class="keyword">if</span> (newLevels.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    newLevels.retainAll(priorityLevelsRequiringResolutionReset);</span><br><span class="line">    <span class="keyword">if</span> (!newLevels.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// Force a new round to reset resolution. The next round will cause this method (process) to be called again.</span></span><br><span class="line">      forceNewRound(randomModuleName, javacFiler);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// None of the new levels need resolution, so just keep going.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>init</code>方法主要是做一些初始化；</p>
<p><code>process</code>方法内主要是将注解以及visitor处理器的按照优先级划分，然后每次执行完成后，排除最开始的一个优先级后，重新开始下一轮编译。知道所有优先级排除完毕。这么做的原因，应该是为了在高优先级处理器处理完成生成文件后，能够让低优先级处理器根据高优先级处理器生成的文件重新执行一遍防止遗漏生成的新的代码</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>详细了解了JSR269内部的执行逻辑</li>
<li>了解了JAVAC的编译过程</li>
<li>了解了Lombok内部的执行原理，可以依托现有Lombok处理器，自定义注解</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://juejin.im/post/5a6eceb8f265da3e467555fe" target="_blank" rel="noopener">https://juejin.im/post/5a6eceb8f265da3e467555fe</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM深入理解-内存调优与GC日志</title>
    <url>/2020/05/14/2020/05/JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B8%8EGC%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h6 id="CPU飚高分析"><a href="#CPU飚高分析" class="headerlink" title="CPU飚高分析"></a>CPU飚高分析</h6><p>一般可以使用</p>
<ul>
<li>ps -Lfp pid</li>
<li>ps -mp pid -o THREAD, tid, time</li>
<li>top -Hp pid</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@redis webapps]# top -Hp 22272</span><br><span class="line">top - 10:09:30 up 9 days, 22:10,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks:  30 total,   0 running,  30 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:   3923196k total,  3795588k used,   127608k free,   153056k buffers</span><br><span class="line">Swap:  6160376k total,        0k used,  6160376k free,  3079244k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                                </span><br><span class="line">22272 root      20   0 2286m 122m  11m S  0.0  3.2   0:00.00 java                                                                                                                                                    </span><br><span class="line">22278 root      20   0 2286m 122m  11m S  0.0  3.2   0:00.00 java</span><br></pre></td></tr></table></figure>

<p>TIME列就是各个Java线程耗费的CPU时间，CPU时间最长的是线程ID为22283 的线程。</p>
<p>用 <code>printf &quot;%x\n&quot; 22283</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@redis webapps]# printf ‘%x\n’ 22283</span><br><span class="line">570b得到22283 的十六进制值为570b。</span><br></pre></td></tr></table></figure>

<p>下一步轮到jstack上场了，它用来输出进程22272 的堆栈信息，然后根据线程ID的十六进制值grep，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@redis webapps]# jstack 22272 | grep 570b</span><br><span class="line">“SchedulerThread” prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait()</span><br></pre></td></tr></table></figure>

<p>可以看到CPU消耗在SchedulerThread这个类的Object.wait()，定位到下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Idle wait</span></span><br><span class="line"><span class="keyword">synchronized</span>(sigLock) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!halted.get()) &#123;</span><br><span class="line">      sigLock.wait(timeUntilContinue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是轮询任务的空闲等待代码，上面的sigLock.wait(timeUntilContinue)就对应了前面的Object.wait()。</p>
<p>总结：可以通过PID找到对应的的线程，然后通过JVM的jstack找到栈里对应的线程信息。通过找到对应的代码一般就能分析出CPU占用高的原因。</p>
<h4 id="利用JVM命令分析"><a href="#利用JVM命令分析" class="headerlink" title="利用JVM命令分析"></a>利用JVM命令分析</h4><h5 id="jstat-gcutil"><a href="#jstat-gcutil" class="headerlink" title="jstat -gcutil"></a>jstat -gcutil</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@xxxx-nccz8-b57dd64fc-nt9dj logs]# jstat -gcutil 1 2000 20</span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00   8.64   2.62  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   2.81  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   2.81  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   2.81  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.06  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.10  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.10  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.21  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.22  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.61  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   6.47  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   6.76  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   6.81  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.07  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.08  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.38  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.38  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.62  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.62  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.76  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br></pre></td></tr></table></figure>

<p>S0：Heap上的 Survivor space 0 区已使用空间的百分比<br>S1：Heap上的 Survivor space 1 区已使用空间的百分比<br>E：Heap上的 Eden space 区已使用空间的百分比<br>O：Heap上的 Old space 区已使用空间的百分比<br>M：Metaspace 区已使用空间的百分比<br>YGC：从应用程序启动到采样时发生 Young GC 的次数<br>YGCT：从应用程序启动到采样时 Young GC 所用的时间(单位秒)<br>FGC：从应用程序启动到采样时发生 Full GC 的次数<br>FGCT：从应用程序启动到采样时 Full GC 所用的时间(单位秒)<br>GCT：从应用程序启动到采样时用于垃圾回收的总时间(单位秒)</p>
<h5 id="jmap-heap"><a href="#jmap-heap" class="headerlink" title="jmap -heap"></a>jmap -heap</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@xxxx-nccz8-b57dd64fc-nt9dj startup]# jmap -heap 1</span><br><span class="line">Attaching to process ID 1, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.191-b12</span><br><span class="line"></span><br><span class="line">using parallel threads in the new generation.</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Concurrent Mark-Sweep GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 2147483648 (2048.0MB)</span><br><span class="line">   NewSize                  = 805306368 (768.0MB)</span><br><span class="line">   MaxNewSize               = 805306368 (768.0MB)</span><br><span class="line">   OldSize                  = 1342177280 (1280.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 268435456 (256.0MB)</span><br><span class="line">   CompressedClassSpaceSize = 260046848 (248.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 268435456 (256.0MB)</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 724828160 (691.25MB)</span><br><span class="line">   used     = 284988360 (271.7860794067383MB)</span><br><span class="line">   free     = 439839800 (419.4639205932617MB)</span><br><span class="line">   39.318058503687276% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 644349952 (614.5MB)</span><br><span class="line">   used     = 275398000 (262.63999938964844MB)</span><br><span class="line">   free     = 368951952 (351.86000061035156MB)</span><br><span class="line">   42.74043928228616% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 80478208 (76.75MB)</span><br><span class="line">   used     = 9590360 (9.146080017089844MB)</span><br><span class="line">   free     = 70887848 (67.60391998291016MB)</span><br><span class="line">   11.916716634644748% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 80478208 (76.75MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 80478208 (76.75MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation:</span><br><span class="line">   capacity = 1342177280 (1280.0MB)</span><br></pre></td></tr></table></figure>

<p>通过heap命令能看出当前整个堆的一个使用情况，used与free的一个实际占用比。</p>
<h5 id="jmap-dump"><a href="#jmap-dump" class="headerlink" title="jmap -dump"></a>jmap -dump</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=xxxxxx.20200707.hprof 1</span><br></pre></td></tr></table></figure>

<p>我们一般会在Dockerfile里面配置好如果出现OOM的情况，保留一下现场。<code>-XX:HeapDumpPath=/alidata1/admin/xxxxx/logs</code></p>
<h4 id="利用JProfiler分析"><a href="#利用JProfiler分析" class="headerlink" title="利用JProfiler分析"></a>利用JProfiler分析</h4><p>发现大对象，这里是因为我们用了Jeager链路跟踪，但是用过多线程导致ThreadLocal没有释放掉。</p>
<p><img src="http://static.cyblogs.com/QQ20200507-183901@2x.jpg" alt="http://static.cyblogs.com/QQ20200507-183901@2x.jpg"></p>
<p>发现char[]占用比较多，并且找出是从哪儿产生的？</p>
<p><img src="http://static.cyblogs.com/QQ20200507-194442@2x.jpg" alt="http://static.cyblogs.com/QQ20200507-194442@2x.jpg"></p>
<p>通过Outgoing references找到具体的实例情况。</p>
<p><img src="http://static.cyblogs.com/QQ20200507-194529@2x.jpg" alt="http://static.cyblogs.com/QQ20200507-194529@2x.jpg"></p>
<p>什么是outgoing references与incoming references？让我们通过示例来了解有关 Incoming references 和 Outgoing references 的更多知识。例如，一个应用程序的源代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;     </span><br><span class="line">  <span class="keyword">private</span> C c1 = C.getInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;     </span><br><span class="line">	<span class="keyword">private</span> C c2 = C.getInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;     </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> C myC = <span class="keyword">new</span> C();     </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> C <span class="title">getInstance</span><span class="params">()</span> </span>&#123;             </span><br><span class="line">	<span class="keyword">return</span> myC;     </span><br><span class="line">	&#125;   </span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> D d1 = <span class="keyword">new</span> D();     </span><br><span class="line">	<span class="keyword">private</span> E e1 = <span class="keyword">new</span> E();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExample</span> </span>&#123;     </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String argsp[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           A a = <span class="keyword">new</span> A();</span><br><span class="line">           B b = <span class="keyword">new</span> B();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对象 A 和对象 B 持有对象 C 的引用</li>
<li>对象 C 持有对象 D 和对象 E 的引用</li>
</ul>
<p>在这个示例项目中，让我们具体分析下对象 C 的 Incoming references 和 Outgoing references 。</p>
<p><strong>对象 C 的 Incoming References</strong></p>
<p>拥有对象 C 的引用的所有对象都称为 Incoming references。在此示例中，对象 C 的“Incoming references”是对象 A、对象 B 和 C 的类对象 。</p>
<p><strong>对象 C 的 Outgoing References</strong></p>
<p>对象 C 引用的所有对象都称为 Outgoing References。在此示例中，对象 C 的“outgoing references”是对象 D、对象 E 和 C 的类对象。</p>
<p>然后通过<code>Show in graph</code>的菜单，一层一层的点击。直到你看到你最熟悉的类。</p>
<p><img src="http://static.cyblogs.com/WechatIMG459.png" alt="http://static.cyblogs.com/WechatIMG459.png"></p>
<p><img src="http://static.cyblogs.com/WechatIMG460.png" alt="http://static.cyblogs.com/WechatIMG460.png"></p>
<h4 id="如何看GC日志"><a href="#如何看GC日志" class="headerlink" title="如何看GC日志"></a>如何看GC日志</h4><p>设置gc日志配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGC 输出简要GC日志 </span><br><span class="line">-XX:+PrintGCDetails 输出详细GC日志 </span><br><span class="line">-Xloggc:gc.log  输出GC日志到文件</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以JVM启动到当期的总时长的时间戳形式） </span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 <span class="number">2013</span>-<span class="number">05</span>-<span class="number">04</span>T21:<span class="number">53</span>:<span class="number">59.234</span>+<span class="number">0800</span>） </span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-verbose:gc</span><br><span class="line">-XX:+PrintReferenceGC 打印年轻代各个引用的数量以及时长</span><br></pre></td></tr></table></figure>

<h5 id="XX-PrintGC"><a href="#XX-PrintGC" class="headerlink" title="-XX:+PrintGC"></a>-XX:+PrintGC</h5><p>如果只设置<code>-XX:+PrintGC</code>那么打印的日志如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  61805K-&gt;9849K(256000K), 0.0041139 secs]</span><br><span class="line"></span><br><span class="line">1、GC 表示是一次YGC（Young GC）</span><br><span class="line">2、Allocation Failure 表示是失败的类型</span><br><span class="line">3、61805K-&gt;9849K 表示年轻代从61805K降为9849K</span><br><span class="line">4、256000K表示整个堆的大小</span><br><span class="line">5、0.0041139 secs表示这次GC总计所用的时间</span><br><span class="line">在JDK 8中，-verbose:gc是-XX:+PrintGC一个别称，日志格式等价与：-XX:+PrintGC，。</span><br></pre></td></tr></table></figure>

<h5 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 53248K-&gt;2176K(59392K)] 58161K-&gt;7161K(256000K), 0.0039189 secs] [Times: user&#x3D;0.02 sys&#x3D;0.01, real&#x3D;0.00 secs]</span><br><span class="line">1、GC 表示是一次YGC（Young GC）</span><br><span class="line">2、Allocation Failure 表示是失败的类型</span><br><span class="line">3、PSYoungGen 表示年轻代大小</span><br><span class="line">4、53248K-&gt;2176K 表示年轻代占用从53248K降为2176K</span><br><span class="line">5、59392K表示年轻带的大小</span><br><span class="line">6、58161K-&gt;7161K 表示整个堆占用从53248K降为2176K</span><br><span class="line">7、256000K表示整个堆的大小</span><br><span class="line">8、 0.0039189 secs 表示这次GC总计所用的时间</span><br><span class="line">9、[Times: user&#x3D;0.02 sys&#x3D;0.01, real&#x3D;0.00 secs]  分别表示，用户态占用时长，内核用时，真实用时。</span><br><span class="line">时间保留两位小数，四舍五入。</span><br></pre></td></tr></table></figure>

<h5 id="XX-PrintGCTimeStamps"><a href="#XX-PrintGCTimeStamps" class="headerlink" title="-XX:+PrintGCTimeStamps"></a>-XX:+PrintGCTimeStamps</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.963: [GC (Allocation Failure)  61805K-&gt;9849K(256000K), 0.0041139 secs]</span><br></pre></td></tr></table></figure>

<p>如果加上<code>-XX:+PrintGCTimeStamps</code>那么日志仅仅比1.1介绍的最前面多了一个时间戳： <code>1.963</code>， 表示从JVM启动到打印GC时刻用了1.963秒。</p>
<h5 id="XX-PrintGCDateStamps"><a href="#XX-PrintGCDateStamps" class="headerlink" title="-XX:+PrintGCDateStamps"></a>-XX:+PrintGCDateStamps</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2019-03-05T16:56:15.108+0800: [GC (Allocation Failure)  61805K-&gt;9849K(256000K), 0.0041139 secs]</span><br></pre></td></tr></table></figure>

<p>如果加上<code>-XX:+PrintGCDateStamps</code>那么日志仅仅比1.1介绍的最前面多了一个日期时间： <code>2019-03-05T16:56:15.108+0800</code>， 表示打印GC的时刻的时间是<code>2019-03-05T16:56:15.108+0800</code>。+0800表示是东8区。</p>
<h5 id="CMS-GC日志详细分析"><a href="#CMS-GC日志详细分析" class="headerlink" title="CMS GC日志详细分析"></a>CMS GC日志详细分析</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[GC (CMS Initial Mark) [1 CMS-initial-mark: 19498K(32768K)] 36184K(62272K), 0.0018083 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: 0.011/0.011 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[CMS-concurrent-abortable-preclean-start]</span><br><span class="line"> CMS: abort preclean due to time [CMS-concurrent-abortable-preclean: 0.558/5.093 secs] [Times: user=0.57 sys=0.00, real=5.09 secs] </span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 16817 K (29504 K)][Rescan (parallel) , 0.0021918 secs][weak refs processing, 0.0000245 secs][class unloading, 0.0044098 secs][scrub symbol table, 0.0029752 secs][scrub string table, 0.0006820 secs][1 CMS-remark: 19498K(32768K)] 36316K(62272K), 0.0104997 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: 0.007/0.007 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>

<p>CMS日志分为两个STW(stop the world)</p>
<p>分别是<code>init remark</code>（1） 与 <code>remark</code>（7）两个阶段。一般耗时比YGC长约10倍（个人经验）。</p>
<p>（1）、<code>[GC (CMS Initial Mark) [1 CMS-initial-mark: 19498K(32768K)] 36184K(62272K), 0.0018083 secs][Times: user=0.01 sys=0.00, real=0.01 secs]</code></p>
<p>会STW(Stop The World)，这时候的老年代容量为 32768K， 在使用到 19498K 时开始初始化标记。耗时短。</p>
<p>（2）、<code>[CMS-concurrent-mark-start]</code></p>
<p>并发标记阶段开始</p>
<p>（3）、<code>[CMS-concurrent-mark: 0.011/0.011 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]</code></p>
<p>并发标记阶段花费时间。</p>
<p>（4）、<code>[CMS-concurrent-preclean-start]</code></p>
<p>并发预清理阶段，也是与用户线程并发执行。虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从<a href="https://www.baidu.com/s?wd=新生代&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">新生代</a>晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段”重新标记”的工作，因为下一个阶段会Stop The World。</p>
<p>（5）、<code>[CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</code></p>
<p>并发预清理阶段花费时间。</p>
<p>（6）、<code>[CMS-concurrent-abortable-preclean-start] CMS: abort preclean due to time [CMS-concurrent-abortable-preclean: 0.558/5.093 secs][Times: user=0.57 sys=0.00, real=5.09 secs]</code></p>
<p>并发可中止预清理阶段，运行在并行预清理和重新标记之间，直到获得所期望的eden空间占用率。增加这个阶段是为了避免在重新标记阶段后紧跟着发生一次垃圾清除</p>
<p>（7）、<code>[GC (CMS Final Remark) [YG occupancy: 16817 K (29504 K)][Rescan (parallel) , 0.0021918 secs][weak refs processing, 0.0000245 secs][class unloading, 0.0044098 secs][scrub symbol table, 0.0029752 secs][scrub string table, 0.0006820 secs][1 CMS-remark: 19498K(32768K)] 36316K(62272K), 0.0104997 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</code></p>
<p>会STW(Stop The World)，收集阶段，这个阶段会标记老年代全部的存活对象，包括那些在并发标记阶段更改的或者新创建的引用对象</p>
<p>（8）、<code>[CMS-concurrent-sweep-start]</code></p>
<p>并发清理阶段开始，与用户线程并发执行。</p>
<p>（9）、<code>[CMS-concurrent-sweep: 0.007/0.007 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</code></p>
<p>并发清理阶段结束，所用的时间。</p>
<p>（10）、<code>[CMS-concurrent-reset-start]</code></p>
<p>开始并发重置。在这个阶段，与CMS相关数据结构被重新初始化，这样下一个周期可以正常进行。</p>
<p>（11）、<code>[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></p>
<p>并发重置所用结束，所用的时间。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://mp.weixin.qq.com/s/bSv2YDqOJsWYj6ZjAnf1ew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/bSv2YDqOJsWYj6ZjAnf1ew</a></li>
<li><a href="https://blog.csdn.net/preterhuman_peak/article/details/43674037" target="_blank" rel="noopener">https://blog.csdn.net/preterhuman_peak/article/details/43674037</a></li>
<li><a href="https://juejin.im/post/5c80b0f451882532cd57b541" target="_blank" rel="noopener">https://juejin.im/post/5c80b0f451882532cd57b541</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Rsync 增量同步与快速删除</title>
    <url>/2020/05/15/2020/05/Linux%20Rsync%20%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p><code>rsync [args] SRC [DEST]</code><br>情形：同时维护着两份不同的<code>data_center</code>，但以<code>old_data_center</code>为标准。因为权限的缘故没有开启rsync自动同步，只是每隔一段时间手动同步一下。<code>SRC</code>和<code>DEST</code>都是采用mount形式，如果每一次都完整地<code>copy</code>，耗时很长，这时候就想到采用增量同步的方法，因为两份<code>data_center</code>同时由不同人维护，所以内容略有不同，<code>data_center</code>同步的时候不光要完全同步<code>old_data_center</code>的所有内容，而且要删除自身多余的内容，保持完全一致。</p>
<p><img src="http://static.cyblogs.com/1559267-20190509170938551-832776092.png" alt="http://static.cyblogs.com/1559267-20190509170938551-832776092.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -a </span><br><span class="line">--delete </span><br><span class="line">--progress /old_vip_data_center/test_envs/trainer/resource /vip_data_center/test_envs/trainer/resource/</span><br></pre></td></tr></table></figure>

<p>–delete: 删除<code>DEST</code>端存在但是<code>SRC</code>端不存在的文件，如果不使用此参数，则DEST端会同步SRC端的文件，但DEST端已有的文件不受影响。</p>
<h4 id="快速删除大量文件"><a href="#快速删除大量文件" class="headerlink" title="快速删除大量文件"></a>快速删除大量文件</h4><ol>
<li><p>先建一个空目录，随便位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /local/empty_dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>用rsync删除目标目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync --delete-before -avH --progress /local/empty_dir/ /local/trainer_test/</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>trainer_test</code>清空之后可以再用<code>rm -rf trainer_test</code>删除</p>
<p>注意不要忘了文件夹最后的<code>/</code></p>
<p><code>rsync</code>提供了一些跟删除相关的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync --help | grep delete</span><br><span class="line">--del an alias for --delete-during</span><br><span class="line">--delete-before receiver deletes before transfer (default)</span><br></pre></td></tr></table></figure>

<p>选项说明：<br>-a 递归方式传输文件，并保持文件属性<br>–delete-before 接收者在传输之前进行删除操作<br>–progress 在传输时显示传输过程<br>– 归档模式，表示以递归方式传输文件，并保持所有文件属性<br>-H 保持硬连接的文件<br>-v 详细输出模式<br>-stats 给出某些文件的传输状态</p>
<p>不过在使用上面的命令进行清理时，存在一个问题，清空后，目标目录的权限会和源目录的权限一样。如：<code>/tmp/empty</code>是<code>root：root</code>，而<code>maildrop</code>之前是<code>postfix：postdrop</code> ，执行之后也会<code>maildrop</code>目录的权限也会变成<code>root：root</code> 。由于-a权限是-rlptogD几个参数的集合，所以可以将og（owner:group）两个参数去掉。清空时自动保持之前的目录权限，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync --delete -rlptD /tmp/empty/ /var/spool/postfix/maildrop/</span><br></pre></td></tr></table></figure>

<h4 id="为什么rsync这么快呢？"><a href="#为什么rsync这么快呢？" class="headerlink" title="为什么rsync这么快呢？"></a>为什么rsync这么快呢？</h4><p>rm删除内容时，将目录的每一个条目逐个删除(unlink)，需要循环重复操作很多次；</p>
<p>rsync删除内容时，建立好新的空目录，替换掉老目录，基本没开销。</p>
<blockquote>
<p>If you want to conquer fear, don’t sit home and think about it. Go out and get busy.</p>
</blockquote>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>今天因为用代码生成SQL脚本的时候，本来是说100W的数据生成一个的，结果因为一个运算符的问题导致了生成上百万的小文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; skipHeadCount) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每MAX_SIZE就会生成一个,MAX_SIZE=1000000</span></span><br><span class="line">    <span class="keyword">int</span> fileExtName = (count - skipHeadCount) / MAX_SIZE; <span class="comment">// 当时种类count - skipHeadCount忘记打括号了</span></span><br><span class="line">    <span class="keyword">if</span> (fileExtName &gt; currentFileExtName) &#123;</span><br><span class="line">        bw.flush();</span><br><span class="line">        currentFileExtName = fileExtName;</span><br><span class="line">        bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(String.format(fileOutputPath, currentFileExtName)))));</span><br><span class="line">    &#125;</span><br><span class="line">    String formatStr = genService.format(line);</span><br><span class="line">    bw.write(formatStr);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除的时候会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Argument list too long</span><br></pre></td></tr></table></figure>

<p>实战后发现效率贵高的一种方式：</p>
<p><img src="http://static.cyblogs.com/WechatIMG461.png" alt="http://static.cyblogs.com/WechatIMG461.png"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.cnblogs.com/sayiqiu/p/10816572.html" target="_blank" rel="noopener">https://www.cnblogs.com/sayiqiu/p/10816572.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Next-Key Lock与实测</title>
    <url>/2020/05/03/2020/05/%E6%B5%85%E8%B0%88Next-Key%20Lock%E4%B8%8E%E5%AE%9E%E6%B5%8B/</url>
    <content><![CDATA[<p>数据库使用锁是为了支持更好的并发，提供数据的完整性和一致性。<code>InnoDB</code>是一个支持行锁的存储引擎，锁的类型有：</p>
<ul>
<li><p>共享锁（S）</p>
</li>
<li><p>排他锁（X）</p>
</li>
<li><p>意向共享（IS）</p>
</li>
<li><p>意向排他（IX）</p>
</li>
</ul>
<p>为了提供更好的并发，<code>InnoDB</code>提供了非锁定读：不需要等待访问行上的锁释放，读取行的一个快照。该方法是通过<code>InnoDB</code>的一个特性：<code>MVCC</code>来实现的。</p>
<p><strong>InnoDB有三种行锁的算法：</strong></p>
<p>1、<code>Record Lock</code>：单个行记录上的锁。</p>
<p>2、<code>Gap Lock</code>：间隙锁，锁定一个范围，但不包括记录本身。<code>GAP</code>锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p>
<p>3、<code>Next-Key Lock</code>：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p>
<p><img src="http://static.cyblogs.com/QQ20200529-221058@2x.jpg" alt="http://static.cyblogs.com/QQ20200529-221058@2x.jpg"></p>
<p><strong>为什么section B上面的插入语句会出现锁等待的情况</strong> ？<code>InnoDB</code>是行锁，在<code>section A</code>里面锁住了<code>a=8</code>的行，其他应该不受影响。why？</p>
<p>因为<code>InnoDB</code>对于行的查询都是采用了<code>Next-Key Lock</code>的算法，锁定的不是单个值，而是一个范围<code>（GAP）</code>。上面索引值有<code>1，3，5，8，11</code>，其记录的<code>GAP</code>的区间如下：是一个<strong>左开右闭</strong>的空间（原因是默认主键的有序自增的特性，结合后面的例子说明）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">（-∞,1]，(1,3]，(3,5]，(5,8]，(8,11]，(11,+∞）</span><br></pre></td></tr></table></figure>

<p>特别需要注意的是，<code>InnoDB</code>存储引擎还会对辅助索引下一个键值加上<code>gap lock</code>。如上面分析，那就可以解释了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t where a = 8 for update;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| a    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    8 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>该<code>SQL</code>语句锁定的范围是<code>（5,8]</code>，下个下个键值范围是<code>（8,11]</code>，所以插入<code>5~11</code>之间的值的时候都会被锁定，要求等待。即：插入<code>5，6，7，8，9，10</code> 会被锁住。插入非这个范围内的值都正常。</p>
<p>如果是范围的排它，那是非常的影响性能的，是否可以只让它锁一行呢？</p>
<p><img src="http://static.cyblogs.com/QQ20200529-223123@2x.jpg" alt="http://static.cyblogs.com/QQ20200529-223123@2x.jpg"></p>
<p><strong>分析：</strong>因为会话1已经对<code>id=8</code>的记录加了一个X锁，由于是<code>RR</code>隔离级别，<code>INNODB</code>要防止幻读需要加<code>GAP</code>锁：即<code>id=5</code>（8的左边），<code>id=11</code>（8的右边）之间需要加间隙锁（<code>GAP</code>）。这样<code>[5,e]</code>和<code>[8,g]</code>，<code>[8,g]</code>和<code>[11,j]</code>之间的数据都要被锁。上面测试已经验证了这一点，根据索引的有序性，数据按照主键（<code>name</code>）排序，后面写入的<code>[5,cz]</code>（<code>[5,e]</code>的左边）和<code>[11,ja]</code>（<code>[11,j]</code>的右边）不属于上面的范围从而可以写入。</p>
<p>超时时间的参数：<code>innodb_lock_wait_timeout</code> ，默认是50秒。<br>超时是否回滚参数：<code>innodb_rollback_on_timeout</code> 默认是OFF。</p>
<p><img src="http://static.cyblogs.com/QQ20200529-223803@2x.jpg" alt="http://static.cyblogs.com/QQ20200529-223803@2x.jpg"></p>
<p>经过测试，不会回滚超时引发的异常，当参数<code>innodb_rollback_on_timeout</code> 设置成<code>ON</code>时，则可以回滚，会把插进去的12回滚掉。</p>
<p>那<code>Record Lock</code>什么时候用？还是用上面的列子，把辅助索引改成唯一属性的索引。</p>
<p><img src="http://static.cyblogs.com/QQ20200529-224150@2x.jpg" alt="http://static.cyblogs.com/QQ20200529-224150@2x.jpg"></p>
<p>为什么<code>section B</code>上面的插入语句可以正常，和测试一不一样？</p>
<p><strong>分析：</strong></p>
<p>因为<code>InnoDB</code>对于行的查询都是采用了<code>Next-Key Lock</code>的算法，锁定的不是单个值，而是一个范围，按照这个方法是会和第一次测试结果一样。但是，当查询的索引含有唯一属性的时候，<code>Next-Key Lock</code> 会进行优化，将其降级为<code>Record Lock</code>，即仅锁住索引本身，不是范围。</p>
<p>注意：通过主键或则唯一索引来锁定不存在的值，也会产生<code>GAP</code>锁定。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoujinyi/p/3435982.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深夜里安静的编译一个OpenJDK8，坑太多</title>
    <url>/2020/05/10/2020/05/%E6%B7%B1%E5%A4%9C%E9%87%8C%E5%AE%89%E9%9D%99%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AAOpenJDK8%EF%BC%8C%E5%9D%91%E5%A4%AA%E5%A4%9A/</url>
    <content><![CDATA[<h4 id="Mac系统安装"><a href="#Mac系统安装" class="headerlink" title="Mac系统安装"></a>Mac系统安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">利用brew search查找mercurial</span><br><span class="line">➜  ~  brew search mercurial</span><br><span class="line">安装</span><br><span class="line">➜  ~  brew install mercuria</span><br></pre></td></tr></table></figure>

<h4 id="Linux系统安装"><a href="#Linux系统安装" class="headerlink" title="Linux系统安装"></a>Linux系统安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install mercurial</span><br></pre></td></tr></table></figure>

<h4 id="安装openjdk8"><a href="#安装openjdk8" class="headerlink" title="安装openjdk8"></a>安装openjdk8</h4><h5 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h5><p>一般在下载代码的时候都会很慢，故先配置好代理。我这里是V2Ray。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/etc/mercurial/hgrc</span><br><span class="line"></span><br><span class="line">[http_proxy]</span><br><span class="line">host=127.0.0.1:8001</span><br><span class="line">[https_proxy]</span><br><span class="line">host=127.0.0.1:8001</span><br></pre></td></tr></table></figure>

<h5 id="下载jdk8u的代码"><a href="#下载jdk8u的代码" class="headerlink" title="下载jdk8u的代码"></a>下载jdk8u的代码</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hg clone https://hg.openjdk.java.net/jdk8u/jdk8u openjdk8</span><br><span class="line">chmod u+x get_source.sh</span><br><span class="line">chmod u+x configure</span><br><span class="line">./get_source.sh  # 下载全部源代码  </span><br><span class="line">./configure  --with-freetype-include=/usr/local/include/freetype2 --with-freetype-lib=/usr/local/lib/      # configure 编译环境，若编译报错，需要添加 `--disable-warnings-as-errors`</span><br><span class="line">make all</span><br></pre></td></tr></table></figure>

<h4 id="漫长的等待，终于等到你"><a href="#漫长的等待，终于等到你" class="headerlink" title="漫长的等待，终于等到你"></a>漫长的等待，终于等到你</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Finished docs (build time 00:01:52)</span></span></span><br><span class="line"></span><br><span class="line">----- Build times -------</span><br><span class="line">Start 2020-05-24 03:18:37</span><br><span class="line">End   2020-05-24 03:30:07</span><br><span class="line">00:00:19 corba</span><br><span class="line">00:00:46 demos</span><br><span class="line">00:01:52 docs</span><br><span class="line">00:02:53 hotspot</span><br><span class="line">00:01:28 images</span><br><span class="line">00:00:12 jaxp</span><br><span class="line">00:00:18 jaxws</span><br><span class="line">00:03:07 jdk</span><br><span class="line">00:00:26 langtools</span><br><span class="line">00:00:09 nashorn</span><br><span class="line">00:11:30 TOTAL</span><br><span class="line">-------------------------</span><br><span class="line">Finished building OpenJDK for target 'all'</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/QQ20200524-035223@2x.jpg" alt="http://static.cyblogs.com/QQ20200524-035223@2x.jpg"></p>
<p>如何在CLion里面做调试，后面我再详细的写一篇。敬请期待~</p>
<h4 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h4><h5 id="问题一：Xcode-4-is-required-to-build-JDK-8"><a href="#问题一：Xcode-4-is-required-to-build-JDK-8" class="headerlink" title="问题一：Xcode 4 is required to build JDK 8"></a>问题一：Xcode 4 is required to build JDK 8</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configure: error: Xcode 4 is required to build JDK 8, the version found was 11.4.1. Use --with-xcode-path to specify the location of Xcode 4 or make Xcode 4 active by using xcode-select.</span><br><span class="line">configure exiting with result code 1</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  openjdk8  vim common/autoconf/generated-configure.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> Fail-fast: verify we<span class="string">'re building on Xcode 4, we cannot build with Xcode 5 or later</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">XCODE_VERSION=`<span class="variable">$XCODEBUILD</span> -version | grep <span class="string">'^Xcode '</span> | sed <span class="string">'s/Xcode //'</span>`</span></span><br><span class="line"><span class="meta">#</span><span class="bash">XC_VERSION_PARTS=( <span class="variable">$&#123;XCODE_VERSION//./ &#125;</span> )</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> <span class="built_in">test</span> ! <span class="string">"<span class="variable">$&#123;XC_VERSION_PARTS[0]&#125;</span>"</span> = <span class="string">"4"</span>; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  as_fn_error $? <span class="string">"Xcode 4 is required to build JDK 8, the version found was <span class="variable">$XCODE_VERSION</span>. Use --with-xcode-path to specify the l      ocation of Xcode 4 or make Xcode 4 active by using xcode-select."</span> <span class="string">"<span class="variable">$LINENO</span>"</span> 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">fi</span></span></span><br></pre></td></tr></table></figure>

<h5 id="问题二：A-gcc-compiler-is-required"><a href="#问题二：A-gcc-compiler-is-required" class="headerlink" title="问题二：A gcc compiler is required"></a>问题二：A gcc compiler is required</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configure: error: A gcc compiler is required. Try setting --with-tools-dir.</span><br><span class="line">configure exiting with result code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一处代码 <span class="keyword">elif</span> <span class="built_in">test</span>  <span class="string">"x<span class="variable">$TOOLCHAIN_TYPE</span>"</span> = xgcc; <span class="keyword">then</span></span></span><br><span class="line">    # gcc --version output typically looks like</span><br><span class="line">    #     gcc (Ubuntu/Linaro 4.8.1-10ubuntu9) 4.8.1</span><br><span class="line">    #     Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">    #     This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">    #     warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">    COMPILER_VERSION_OUTPUT=`$COMPILER --version 2&gt;&amp;1`</span><br><span class="line">    # Check that this is likely to be GCC.</span><br><span class="line">    $ECHO "$COMPILER_VERSION_OUTPUT" | $GREP "Free Software Foundation" &gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 条件语句注释掉</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="keyword">if</span> <span class="built_in">test</span> $? -ne 0; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       &#123; <span class="variable">$as_echo</span> <span class="string">"<span class="variable">$as_me</span>:<span class="variable">$&#123;as_lineno-$LINENO&#125;</span>: The <span class="variable">$COMPILER_NAME</span> compiler (located as <span class="variable">$COMPILER</span>) does not seem to be the required <span class="variable">$TOOLCHAIN_TYPE</span> compiler."</span> &gt;&amp;5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$as_echo</span> <span class="string">"<span class="variable">$as_me</span>: The <span class="variable">$COMPILER_NAME</span> compiler (located as <span class="variable">$COMPILER</span>) does not seem to be the required <span class="variable">$TOOLCHAIN_TYPE</span> compiler."</span> &gt;&amp;6;&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       &#123; <span class="variable">$as_echo</span> <span class="string">"<span class="variable">$as_me</span>:<span class="variable">$&#123;as_lineno-$LINENO&#125;</span>: The result from running with --version was: \"<span class="variable">$COMPILER_VERSION</span>\""</span> &gt;&amp;5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$as_echo</span> <span class="string">"<span class="variable">$as_me</span>: The result from running with --version was: \"<span class="variable">$COMPILER_VERSION</span>\""</span> &gt;&amp;6;&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       as_fn_error $? <span class="string">"A <span class="variable">$TOOLCHAIN_TYPE</span> compiler is required. Try setting --with-tools-dir."</span> <span class="string">"<span class="variable">$LINENO</span>"</span> 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="keyword">fi</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二处代码，</span></span><br><span class="line">  elif test  "x$TOOLCHAIN_TYPE" = xgcc; then</span><br><span class="line">    # gcc --version output typically looks like</span><br><span class="line">    #     gcc (Ubuntu/Linaro 4.8.1-10ubuntu9) 4.8.1</span><br><span class="line">    #     Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">    #     This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">    #     warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">    COMPILER_VERSION_OUTPUT=`$COMPILER --version 2&gt;&amp;1`</span><br><span class="line">    # Check that this is likely to be GCC.</span><br><span class="line">    $ECHO "$COMPILER_VERSION_OUTPUT" | $GREP "Free Software Foundation" &gt; /dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 条件语句注释掉</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     <span class="keyword">if</span> <span class="built_in">test</span> $? -ne 0; <span class="keyword">then</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       &#123; <span class="variable">$as_echo</span> <span class="string">"<span class="variable">$as_me</span>:<span class="variable">$&#123;as_lineno-$LINENO&#125;</span>: The <span class="variable">$COMPILER_NAME</span> compiler (located as <span class="variable">$COMPILER</span>) does not seem to be the required <span class="variable">$TOOLCHAIN_TYPE</span> compiler."</span> &gt;&amp;5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$as_echo</span> <span class="string">"<span class="variable">$as_me</span>: The <span class="variable">$COMPILER_NAME</span> compiler (located as <span class="variable">$COMPILER</span>) does not seem to be the required <span class="variable">$TOOLCHAIN_TYPE</span> compiler."</span> &gt;&amp;6;&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       &#123; <span class="variable">$as_echo</span> <span class="string">"<span class="variable">$as_me</span>:<span class="variable">$&#123;as_lineno-$LINENO&#125;</span>: The result from running with --version was: \"<span class="variable">$COMPILER_VERSION</span>\""</span> &gt;&amp;5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$as_echo</span> <span class="string">"<span class="variable">$as_me</span>: The result from running with --version was: \"<span class="variable">$COMPILER_VERSION</span>\""</span> &gt;&amp;6;&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       as_fn_error $? <span class="string">"A <span class="variable">$TOOLCHAIN_TYPE</span> compiler is required. Try setting --with-tools-dir."</span> <span class="string">"<span class="variable">$LINENO</span>"</span> 5</span></span><br></pre></td></tr></table></figure>

<p>最后执行<code>sh configure</code>终于成功： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">====================================================</span><br><span class="line">A new configuration has been successfully created in</span><br><span class="line">/Users/chenyuan/Workspaces/Openjdk/openjdk8/build/macosx-x86_64-normal-server-release</span><br><span class="line">using default settings.</span><br><span class="line"></span><br><span class="line">Configuration summary:</span><br><span class="line">* Debug level:    release</span><br><span class="line">* JDK variant:    normal</span><br><span class="line">* JVM variants:   server</span><br><span class="line">* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64</span><br><span class="line"></span><br><span class="line">Tools summary:</span><br><span class="line">* Boot JDK:       java version "1.8.0_162" Java(TM) SE Runtime Environment (build 1.8.0_162-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)  (at /Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home)</span><br><span class="line">* Toolchain:      gcc (GNU Compiler Collection)</span><br><span class="line">* C Compiler:     Version 11.0.3 (at /usr/bin/gcc)</span><br><span class="line">* C++ Compiler:   Version 11.0.3 (at /usr/bin/g++)</span><br><span class="line"></span><br><span class="line">Build performance summary:</span><br><span class="line">* Cores to use:   4</span><br><span class="line">* Memory limit:   16384 MB</span><br></pre></td></tr></table></figure>

<h5 id="问题三：include-path-for-libstdc-headers-not-found"><a href="#问题三：include-path-for-libstdc-headers-not-found" class="headerlink" title="问题三：include path for libstdc++ headers not found"></a>问题三：include path for libstdc++ headers not found</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang: clangerror: include path for libstdc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead [-Werror,-Wstdlibcxx-not-found]</span><br><span class="line">: error: include path for libstdc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead [-Werror,-Wstdlibcxx-not-found]</span><br><span class="line">make[6]: *** [../generated/adfiles/archDesc.o] Error 1</span><br><span class="line">make[6]: *** Waiting for unfinished jobs....</span><br><span class="line">make[6]: *** [../generated/adfiles/adlparse.o] Error 1</span><br><span class="line">clang: error: include path for libstdc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead [-Werror,-Wstdlibcxx-not-found]</span><br><span class="line">make[6]: *** [../generated/adfiles/arena.o] Error 1</span><br><span class="line">make[5]: *** [ad_stuff] Error 2</span><br><span class="line">make[4]: *** [product] Error 2</span><br><span class="line">make[3]: *** [generic_build2] Error 2</span><br><span class="line">make[2]: *** [product] Error 2</span><br><span class="line">make[1]: *** [/Users/chenyuan/Workspaces/Openjdk/openjdk8/build/macosx-x86_64-normal-server-release/hotspot/_hotspot.timestamp] Error 2</span><br><span class="line">make: *** [hotspot-only] Error 2</span><br></pre></td></tr></table></figure>

<p>解决方法</p>
<p>原因：这个原因是Xcode升级到10以后就没有包含lstdc++库了。而 hotspot 居然还一直用着这个，于是编译器找不到 libstdc++ 的头文件就罢工了<br>解决办法：<br>打开:<a href="https://github.com/imkiwa/xcode-missing-libstdc-" target="_blank" rel="noopener">https://github.com/imkiwa/xcode-missing-libstdc-</a> , clone 到本地，参考 install.sh 将文件链接或者复制到对应位置（慎重直接执行，请一定事先核对路径是否正确)！</p>
<h5 id="问题四：fatal-error-‘iostream’-file-not-found"><a href="#问题四：fatal-error-‘iostream’-file-not-found" class="headerlink" title="问题四：fatal error: ‘iostream’ file not found"></a>问题四：fatal error: ‘iostream’ file not found</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Users/chenyuan/Workspaces/Openjdk/openjdk8/hotspot/src/share/vm/adlc/archDesc.cpp:#include &lt;iostream&gt;/Users/chenyuan/Workspaces/Openjdk/openjdk8/hotspot/src/share/vm/adlc/adlc.hpp</span><br><span class="line">:         ^~~~~~~~~~35:10:27</span><br><span class="line">:</span><br><span class="line"> fatal error/Users/chenyuan/Workspaces/Openjdk/openjdk8/hotspot/src/share/vm/adlc/adlc.hpp: :35'iostream' file not found:</span><br><span class="line">10: fatal error: 'iostream' file not found</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;iostream&gt;</span></span><br><span class="line">         ^~~~~~~~~~</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;iostream&gt;</span></span><br><span class="line">         ^~~~~~~~~~</span><br><span class="line">In file included from /Users/chenyuan/Workspaces/Openjdk/openjdk8/hotspot/src/share/vm/adlc/adlparse.cpp:27:</span><br><span class="line">/Users/chenyuan/Workspaces/Openjdk/openjdk8/hotspot/src/share/vm/adlc/adlc.hpp:35:10: fatal error: 'iostream' file not found</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;iostream&gt;</span></span><br><span class="line">         ^~~~~~~~~~</span><br><span class="line">1 error generated.</span><br><span class="line">make[6]: *** [../generated/adfiles/arena.o] Error 1</span><br><span class="line">make[6]: *** Waiting for unfinished jobs....</span><br></pre></td></tr></table></figure>

<p>解决方案</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<h5 id="问题五：unknown-argument-‘-fpch-deps’"><a href="#问题五：unknown-argument-‘-fpch-deps’" class="headerlink" title="问题五：unknown argument: ‘-fpch-deps’"></a>问题五：unknown argument: ‘-fpch-deps’</h5><p>解决方案：</p>
<p>hotspot/make/bsd/makefiles/gcc.make</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># Compiler warnings are treated as errors</span><br><span class="line">ifneq ($(COMPILER_WARNINGS_FATAL),<span class="literal">false</span>)</span><br><span class="line">  WARNINGS_ARE_ERRORS = -Werror</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>这一段也要干掉，否则在后续编译中可能会出现<code>clang: error: unknown argument: &#39;-fpch-deps&#39;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifeq ($(USE_CLANG),)</span><br><span class="line">  ifneq ($(CC_VER_MAJOR), <span class="number">2</span>)</span><br><span class="line">    DEPFLAGS += -fpch-deps</span><br><span class="line">  endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<h5 id="问题六：invalid-argument-‘-std-gnu-98’-not-allowed-with-‘C’"><a href="#问题六：invalid-argument-‘-std-gnu-98’-not-allowed-with-‘C’" class="headerlink" title="问题六：invalid argument ‘-std=gnu++98’ not allowed with ‘C’"></a>问题六：invalid argument ‘-std=gnu++98’ not allowed with ‘C’</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Making signal interposition lib...</span><br><span class="line">error: invalid argument '-std=gnu++98' not allowed with 'C'</span><br><span class="line">make[6]: *** [libjsig.dylib] Error 1</span><br></pre></td></tr></table></figure>

<p>解决方案</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> test <span class="string">"x$TOOLCHAIN_TYPE"</span> = xsolstudio; then</span><br><span class="line">    <span class="keyword">if</span> test <span class="string">"x$OPENJDK_TARGET_CPU_ARCH"</span> = <span class="string">"xsparc"</span>; then</span><br><span class="line">      CFLAGS_JDKLIB_EXTRA=<span class="string">"$&#123;CFLAGS_JDKLIB_EXTRA&#125; -xregs=no%appl"</span></span><br><span class="line">      CXXFLAGS_JDKLIB_EXTRA=<span class="string">"$&#123;CXXFLAGS_JDKLIB_EXTRA&#125; -xregs=no%appl"</span></span><br><span class="line">    fi</span><br><span class="line">  elif test <span class="string">"x$TOOLCHAIN_TYPE"</span> = xxlc; then</span><br><span class="line">    LDFLAGS_JDK=<span class="string">"$&#123;LDFLAGS_JDK&#125; -q64 -brtl -bnolibpath -liconv -bexpall"</span></span><br><span class="line">    CFLAGS_JDK=<span class="string">"$&#123;CFLAGS_JDK&#125; -qchars=signed -q64 -qfullpath -qsaveopt"</span></span><br><span class="line">    CXXFLAGS_JDK=<span class="string">"$&#123;CXXFLAGS_JDK&#125; -qchars=signed -q64 -qfullpath -qsaveopt"</span></span><br><span class="line">  elif test <span class="string">"x$TOOLCHAIN_TYPE"</span> = xgcc; then</span><br><span class="line">    LEGACY_EXTRA_CFLAGS=<span class="string">"$LEGACY_EXTRA_CFLAGS -fstack-protector"</span></span><br><span class="line">    LEGACY_EXTRA_CXXFLAGS=<span class="string">"$LEGACY_EXTRA_CXXFLAGS -fstack-protector"</span></span><br><span class="line">    <span class="keyword">if</span> test <span class="string">"x$OPENJDK_TARGET_OS"</span> != xmacosx; then</span><br><span class="line">      LDFLAGS_JDK=<span class="string">"$LDFLAGS_JDK -Wl,-z,relro"</span></span><br><span class="line">      LEGACY_EXTRA_LDFLAGS=<span class="string">"$LEGACY_EXTRA_LDFLAGS -Wl,-z,relro"</span></span><br><span class="line">    fi</span><br><span class="line">#    CXXSTD_CXXFLAG=<span class="string">"-std=gnu++98"</span> # 注释掉这行</span><br></pre></td></tr></table></figure>

<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://zhuanlan.zhihu.com/p/50220757" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50220757</a></li>
<li><a href="https://www.jianshu.com/p/d9a1e1072f37" target="_blank" rel="noopener">https://www.jianshu.com/p/d9a1e1072f37</a></li>
<li><a href="https://www.cnblogs.com/zhengshuangxi/p/11063938.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengshuangxi/p/11063938.html</a></li>
<li><a href="https://juejin.im/entry/5a6c36af6fb9a01cb64f05b8" target="_blank" rel="noopener">https://juejin.im/entry/5a6c36af6fb9a01cb64f05b8</a></li>
<li><a href="https://www.zhoujunwen.com/2019/building-openjdk-8-on-mac-osx-catalina-10-15" target="_blank" rel="noopener">https://www.zhoujunwen.com/2019/building-openjdk-8-on-mac-osx-catalina-10-15</a></li>
<li><a href="https://www.cnblogs.com/micrari/p/7018474.html" target="_blank" rel="noopener">https://www.cnblogs.com/micrari/p/7018474.html</a></li>
<li><a href="https://rqsir.github.io/2019/04/19/openjdk-8-使用Clion调试源码/" target="_blank" rel="noopener">https://rqsir.github.io/2019/04/19/openjdk-8-使用Clion调试源码/</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
      </tags>
  </entry>
  <entry>
    <title>一次性把多线程搞吐</title>
    <url>/2020/05/11/2020/05/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%8A%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%90%9E%E5%90%90/</url>
    <content><![CDATA[<h4 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1.什么是进程?"></a>1.什么是进程?</h4><p>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</p>
<p>进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道，文件，套接字等。</p>
<h4 id="2-什么是线程？"><a href="#2-什么是线程？" class="headerlink" title="2.什么是线程？"></a>2.什么是线程？</h4><p>是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<h4 id="3-线程的实现方式"><a href="#3-线程的实现方式" class="headerlink" title="3.线程的实现方式?"></a>3.线程的实现方式?</h4><p>1.继承Thread类</p>
<p>2.实现Runnable接口</p>
<p>3.使用Callable和Future</p>
<h4 id="4-Thread-类中的start-和-run-方法有什么区别"><a href="#4-Thread-类中的start-和-run-方法有什么区别" class="headerlink" title="4.Thread 类中的start() 和 run() 方法有什么区别?"></a>4.<strong>Thread 类中的start() 和 run() 方法有什么区别</strong>?</h4><p>1.start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 2.run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。</p>
<h4 id="5-线程NEW状态"><a href="#5-线程NEW状态" class="headerlink" title="5.线程NEW状态"></a>5.线程NEW状态</h4><p>new创建一个Thread对象时，并没处于执行状态，因为没有调用start方法启动改线程，那么此时的状态就是新建状态。</p>
<h4 id="6-线程RUNNABLE状态"><a href="#6-线程RUNNABLE状态" class="headerlink" title="6.线程RUNNABLE状态"></a>6.线程RUNNABLE状态</h4><p>线程对象通过start方法进入runnable状态，启动的线程不一定会立即得到执行，线程的运行与否要看cpu的调度，我们把这个中间状态叫可执行状态（RUNNABLE)。</p>
<h4 id="7-线程的RUNNING状态"><a href="#7-线程的RUNNING状态" class="headerlink" title="7.线程的RUNNING状态"></a>7.线程的RUNNING状态</h4><p>一旦cpu通过轮询货其他方式从任务可以执行队列中选中了线程，此时它才能真正的执行自己的逻辑代码。</p>
<h4 id="8-线程的BLOCKED状态"><a href="#8-线程的BLOCKED状态" class="headerlink" title="8.线程的BLOCKED状态"></a>8.线程的BLOCKED状态</h4><p>线程正在等待获取锁。</p>
<ul>
<li>进入BLOCKED状态，比如调用了sleep,或者wait方法</li>
<li>进行某个阻塞的io操作，比如因网络数据的读写进入BLOCKED状态</li>
<li>获取某个锁资源，从而加入到该锁的阻塞队列中而进入BLOCKED状态</li>
</ul>
<h4 id="9-线程的TERMINATED状态"><a href="#9-线程的TERMINATED状态" class="headerlink" title="9.线程的TERMINATED状态"></a>9.线程的TERMINATED状态</h4><p>TERMINATED是一个线程的最终状态，在该状态下线程不会再切换到其他任何状态了，代表整个生命周期都结束了。</p>
<p>下面几种情况会进入TERMINATED状态:</p>
<ul>
<li>线程运行正常结束，结束生命周期</li>
<li>线程运行出错意外结束</li>
<li>JVM Crash 导致所有的线程都结束</li>
</ul>
<h4 id="10-线程状态转化图"><a href="#10-线程状态转化图" class="headerlink" title="10.线程状态转化图"></a>10.线程状态转化图</h4><p><img src="http://static.cyblogs.com/171dad791bf589b8.png" alt="http://static.cyblogs.com/171dad791bf589b8.png"></p>
<h4 id="11-i–与System-out-println-的异常"><a href="#11-i–与System-out-println-的异常" class="headerlink" title="11.i–与System.out.println()的异常"></a>11.i–与System.out.println()的异常</h4><p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"i="</span> + (i——) + <span class="string">" threadName="</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XkThread xk = <span class="keyword">new</span> XkThread();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(xk);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(xk);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(xk);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(xk);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(xk);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i=5 threadName=Thread-1</span><br><span class="line">i=2 threadName=Thread-5</span><br><span class="line">i=5 threadName=Thread-2</span><br><span class="line">i=4 threadName=Thread-3</span><br><span class="line">i=3 threadName=Thread-4</span><br></pre></td></tr></table></figure>

<p>虽然println()方法在内部是同步的，但i–的操作却是在进入println()之前发生的，所以有发生非线程安全的概率。</p>
<p>println()源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-如何知道代码段被哪个线程调用？"><a href="#12-如何知道代码段被哪个线程调用？" class="headerlink" title="12.如何知道代码段被哪个线程调用？"></a>12.如何知道代码段被哪个线程调用？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName());</span><br></pre></td></tr></table></figure>

<h4 id="13-线程活动状态？"><a href="#13-线程活动状态？" class="headerlink" title="13.线程活动状态？"></a>13.线程活动状态？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XKThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run run run is "</span>  + <span class="keyword">this</span>.isAlive() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XKThread xk = <span class="keyword">new</span> XKThread();</span><br><span class="line">        System.out.println(<span class="string">"begin ——— "</span> + xk.isAlive());</span><br><span class="line">        xk.start();</span><br><span class="line">        System.out.println(<span class="string">"end ————— "</span> + xk.isAlive());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-sleep-方法"><a href="#14-sleep-方法" class="headerlink" title="14.sleep()方法"></a>14.sleep()方法</h4><p>方法sleep()的作用是在指定的毫秒数内让当前的“正在执行的线程”休眠（暂停执行）。</p>
<h4 id="15-如何优雅的设置睡眠时间"><a href="#15-如何优雅的设置睡眠时间" class="headerlink" title="15.如何优雅的设置睡眠时间?"></a>15.如何优雅的设置睡眠时间?</h4><p>jdk1.5 后，引入了一个枚举TimeUnit,对sleep方法提供了很好的封装。</p>
<p>比如要表达2小时22分55秒899毫秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="number">8575899L</span>);</span><br><span class="line">TimeUnit.HOURS.sleep(<span class="number">3</span>);</span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">22</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">55</span>);</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">899</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到表达的含义更清晰，更优雅。</p>
<h4 id="16-停止线程"><a href="#16-停止线程" class="headerlink" title="16.停止线程"></a>16.停止线程</h4><p>run方法执行完成，自然终止。</p>
<p>stop()方法，suspend()以及resume()都是过期作废方法，使用它们结果不可预期。</p>
<p>大多数停止一个线程的操作使用<code>Thread.interrupt()</code>等于说给线程打一个停止的标记, 此方法不回去终止一个正在运行的线程，需要加入一个判断才能可以完成线程的停止。</p>
<h4 id="17-interrupted-和-isInterrupted"><a href="#17-interrupted-和-isInterrupted" class="headerlink" title="17.interrupted 和 isInterrupted"></a>17.interrupted 和 isInterrupted</h4><p>interrupted :  判断当前线程是否已经中断,会清除状态。</p>
<p>isInterrupted ：判断线程是否已经中断，不会清除状态。</p>
<h4 id="18-yield"><a href="#18-yield" class="headerlink" title="18.yield"></a>18.yield</h4><p>放弃当前cpu资源，将它让给其他的任务占用cpu执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得cpu时间片。</p>
<p>测试代码:(cpu独占时间片)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XKThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; i++) &#123;</span><br><span class="line">            count = count + (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"用时 = "</span> + (endTime - beginTime) + <span class="string">" 毫秒! "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XKThread xkThread = <span class="keyword">new</span> XKThread();</span><br><span class="line">        xkThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用时 = <span class="number">20</span> 毫秒!</span><br></pre></td></tr></table></figure>

<p>加入yield，再来测试。(cpu让给其他资源导致速度变慢)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XKThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; i++) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            count = count + (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"用时 = "</span> + (endTime - beginTime) + <span class="string">" 毫秒! "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XKThread xkThread = <span class="keyword">new</span> XKThread();</span><br><span class="line">        xkThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">用时 = <span class="number">38424</span> 毫秒!</span><br></pre></td></tr></table></figure>

<h4 id="19-线程的优先级"><a href="#19-线程的优先级" class="headerlink" title="19.线程的优先级"></a>19.线程的优先级</h4><p>在操作系统中，线程可以划分优先级，优先级较高的线程得到cpu资源比较多，也就是cpu有限执行优先级较高的线程对象中的任务，但是不能保证一定优先级高，就先执行。</p>
<p>Java的优先级分为1～10个等级，数字越大优先级越高，默认优先级大小为5。超出范围则抛出：java.lang.IllegalArgumentException。</p>
<h4 id="20-优先级继承特性"><a href="#20-优先级继承特性" class="headerlink" title="20.优先级继承特性"></a>20.优先级继承特性</h4><p>线程的优先级具有继承性，比如a线程启动b线程，b线程与a优先级是一样的。</p>
<h4 id="21-谁跑的更快？"><a href="#21-谁跑的更快？" class="headerlink" title="21.谁跑的更快？"></a>21.谁跑的更快？</h4><p>设置优先级高低两个线程，累加数字，看谁跑的快，上代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ThreadLow low = <span class="keyword">new</span> ThreadLow();</span><br><span class="line">            low.setPriority(<span class="number">2</span>);</span><br><span class="line">            low.start();</span><br><span class="line"></span><br><span class="line">            ThreadHigh high = <span class="keyword">new</span> ThreadHigh();</span><br><span class="line">            high.setPriority(<span class="number">8</span>);</span><br><span class="line">            high.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            low.stop();</span><br><span class="line">            high.stop();</span><br><span class="line">            System.out.println(<span class="string">"low  = "</span> + low.getCount());</span><br><span class="line">            System.out.println(<span class="string">"high = "</span> + high.getCount());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadHigh</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLow</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">low  = 1193854568</span><br><span class="line">high = 1204372373</span><br></pre></td></tr></table></figure>

<h4 id="22-线程种类"><a href="#22-线程种类" class="headerlink" title="22.线程种类"></a>22.线程种类</h4><p>Java线程有两种，一种是用户线程，一种是守护线程。</p>
<h4 id="23-守护线程的特点"><a href="#23-守护线程的特点" class="headerlink" title="23.守护线程的特点"></a>23.守护线程的特点</h4><p>守护线程是一个比较特殊的线程，主要被用做程序中后台调度以及支持性工作。当Java虚拟机中不存在非守护线程时，守护线程才会随着JVM一同结束工作。</p>
<h4 id="24-Java中典型的守护线程"><a href="#24-Java中典型的守护线程" class="headerlink" title="24.Java中典型的守护线程"></a>24.Java中典型的守护线程</h4><p>GC（垃圾回收器）</p>
<h4 id="25-如何设置守护线程"><a href="#25-如何设置守护线程" class="headerlink" title="25.如何设置守护线程"></a>25.如何设置守护线程</h4><p>Thread.setDaemon(true)</p>
<p>PS:Daemon属性需要再启动线程之前设置，不能再启动后设置。</p>
<h4 id="25-Java虚拟机退出时Daemon线程中的finally块一定会执行？"><a href="#25-Java虚拟机退出时Daemon线程中的finally块一定会执行？" class="headerlink" title="25.Java虚拟机退出时Daemon线程中的finally块一定会执行？"></a>25.Java虚拟机退出时Daemon线程中的finally块一定会执行？</h4><p>Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</p>
<p>代码示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class XKDaemon &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread &#x3D; new Thread(new DaemonRunner(),&quot;xkDaemonRunner&quot;);</span><br><span class="line">        thread.setDaemon(true);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class DaemonRunner implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                SleepUtils.sleep(10);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                System.out.println(&quot;Java小咖秀 daemonThread finally run …&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>没有任何的输出，说明没有执行finally。</p>
<h4 id="26-设置线程上下文类加载器"><a href="#26-设置线程上下文类加载器" class="headerlink" title="26.设置线程上下文类加载器"></a>26.设置线程上下文类加载器</h4><p>​    获取线程上下文类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>​    设置线程类加载器（可以打破Java类加载器的父类委托机制）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextClassLoader</span><span class="params">(ClassLoader cl)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="27-join"><a href="#27-join" class="headerlink" title="27.join"></a>27.join</h4><p>join是指把指定的线程加入到当前线程，比如join某个线程a,会让当前线程b进入等待,直到a的生命周期结束，此期间b线程是处于blocked状态。</p>
<h4 id="28-什么是synchronized"><a href="#28-什么是synchronized" class="headerlink" title="28.什么是synchronized?"></a>28.什么是synchronized?</h4><p>synchronized关键字可以时间一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象是对多个线程可见的，那么对该对想的所有读写都将通过同步的方式来进行。</p>
<h4 id="29-synchronized包括哪两个jvm重要的指令？"><a href="#29-synchronized包括哪两个jvm重要的指令？" class="headerlink" title="29.synchronized包括哪两个jvm重要的指令？"></a>29.synchronized包括哪两个jvm重要的指令？</h4><p>monitor enter 和 monitor exit</p>
<h4 id="30-synchronized关键字用法"><a href="#30-synchronized关键字用法" class="headerlink" title="30.synchronized关键字用法?"></a>30.synchronized关键字用法?</h4><p>可以用于对代码块或方法的修饰</p>
<h4 id="31-synchronized锁的是什么"><a href="#31-synchronized锁的是什么" class="headerlink" title="31.synchronized锁的是什么?"></a>31.synchronized锁的是什么?</h4><p>普通同步方法 —————&gt; 锁的是当前实力对象。</p>
<p>静态同步方法—————&gt; 锁的是当前类的Class对象。</p>
<p>同步方法快 —————&gt; 锁的是synchonized括号里配置的对象。</p>
<h4 id="32-Java对象头"><a href="#32-Java对象头" class="headerlink" title="32.Java对象头"></a>32.Java对象头</h4><p>synchronized用的锁是存在Java对象头里的。对象如果是数组类型，虚拟机用3个字宽(Word)存储对象头，如果对象是非数组类型，用2字宽存储对象头。</p>
<p>Tips:32位虚拟机中一个字宽等于4字节。</p>
<h4 id="33-Java对象头长度"><a href="#33-Java对象头长度" class="headerlink" title="33.Java对象头长度"></a>33.Java对象头长度</h4><p><img src="http://static.cyblogs.com/QQ20200506-230203@2x.jpg" alt="http://static.cyblogs.com/QQ20200506-230203@2x.jpg"></p>
<h4 id="34-Java对象头的存储结构"><a href="#34-Java对象头的存储结构" class="headerlink" title="34.Java对象头的存储结构"></a>34.Java对象头的存储结构</h4><p>32位JVM的Mark Word 默认存储结构</p>
<p><img src="http://static.cyblogs.com/QQ20200506-230326@2x.jpg" alt="http://static.cyblogs.com/QQ20200506-230326@2x.jpg"></p>
<h4 id="35-Mark-Word的状态变化"><a href="#35-Mark-Word的状态变化" class="headerlink" title="35.Mark Word的状态变化"></a>35.Mark Word的状态变化</h4><p>Mark Word 存储的数据会随着锁标志为的变化而变化。</p>
<p><img src="http://static.cyblogs.com/QQ20200506-230421@2x.jpg" alt="http://static.cyblogs.com/QQ20200506-230421@2x.jpg"></p>
<p>64位虚拟机下，Mark Word是64bit大小的</p>
<p><img src="http://static.cyblogs.com/QQ20200506-230503@2x.jpg" alt="http://static.cyblogs.com/QQ20200506-230503@2x.jpg"></p>
<h4 id="36-锁的升降级规则"><a href="#36-锁的升降级规则" class="headerlink" title="36.锁的升降级规则"></a>36.锁的升降级规则</h4><p>Java SE 1.6 为了提高锁的性能。引入了“偏向锁”和轻量级锁“。</p>
<p>Java SE 1.6 中锁有4种状态。级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</p>
<p>锁只能升级不能降级。</p>
<h4 id="37-偏向锁"><a href="#37-偏向锁" class="headerlink" title="37.偏向锁"></a>37.偏向锁</h4><p>大多数情况，锁不仅不存在多线程竞争，而且总由同一线程多次获得。当一个线程访问同步块并获取锁时，会在对象头和栈帧中记录存储锁偏向的线程ID,以后该线程在进入和退出同步块时不需要进行 cas操作来加锁和解锁，只需测试一下对象头 Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁，如果失败，则需要测试下Mark Word中偏向锁的标示是否已经设置成1（表示当前时偏向锁),如果没有设置，则使用cas竞争锁，如果设置了，则尝试使用cas将对象头的偏向锁只想当前线程。</p>
<h4 id="38-关闭偏向锁延迟"><a href="#38-关闭偏向锁延迟" class="headerlink" title="38.关闭偏向锁延迟"></a>38.关闭偏向锁延迟</h4><p>java6和7中默认启用，但是会在程序启动几秒后才激活，如果需要关闭延迟，</p>
<p>-XX:BiasedLockingStartupDelay=0。</p>
<h4 id="39-如何关闭偏向锁"><a href="#39-如何关闭偏向锁" class="headerlink" title="39.如何关闭偏向锁"></a>39.如何关闭偏向锁</h4><p>JVM参数关闭偏向锁:-XX:-UseBiasedLocking=false,那么程序默认会进入轻量级锁状态。</p>
<p>Tips:如果你可以确定程序的所有锁通常情况处于竞态，则可以选择关闭。</p>
<h4 id="40-轻量级锁"><a href="#40-轻量级锁" class="headerlink" title="40.轻量级锁"></a>40.轻量级锁</h4><p>线程在执行同步块，jvm会现在当前线程的栈帧中创建用于储存锁记录的空间。并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用cas将对象头中的Mark Word替换为之乡锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h4 id="41-轻量锁的解锁"><a href="#41-轻量锁的解锁" class="headerlink" title="41.轻量锁的解锁"></a>41.轻量锁的解锁</h4><p>轻量锁解锁时，会使原子操作cas将 displaced Mark Word 替换回对象头，如果成功则表示没有竞争发生，如果失败，表示存在竞争，此时锁就会膨胀为重量级锁。</p>
<h4 id="42-锁的优缺点对比"><a href="#42-锁的优缺点对比" class="headerlink" title="42.锁的优缺点对比"></a>42.锁的优缺点对比</h4><p><img src="http://static.cyblogs.com/QQ20200506-230547@2x.jpg" alt="http://static.cyblogs.com/QQ20200506-230547@2x.jpg"></p>
<h4 id="43-什么是原子操作"><a href="#43-什么是原子操作" class="headerlink" title="43.什么是原子操作"></a>43.什么是原子操作</h4><p>不可被中断的一个或一系列操作</p>
<h4 id="44-Java如何实现原子操作"><a href="#44-Java如何实现原子操作" class="headerlink" title="44.Java如何实现原子操作"></a>44.Java如何实现原子操作</h4><p>Java中通过锁和循环cas的方式来实现原子操作，JVM的CAS操作利用了处理器提供的CMPXCHG指令来实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</p>
<h4 id="45-CAS实现原子操作的3大问题"><a href="#45-CAS实现原子操作的3大问题" class="headerlink" title="45.CAS实现原子操作的3大问题"></a>45.CAS实现原子操作的3大问题</h4><p>ABA问题，循环时间长消耗资源大，只能保证一个共享变量的原子操作</p>
<h4 id="46-什么是ABA问题"><a href="#46-什么是ABA问题" class="headerlink" title="46.什么是ABA问题"></a>46.什么是ABA问题</h4><p>问题：</p>
<p>因为cas需要在操作值的时候，检查值有没有变化，如果没有变化则更新，如果一个值原来是A,变成了B,又变成了A,那么使用cas进行检测时会发现发的值没有发生变化，其实是变过的。</p>
<p>解决：</p>
<p>添加版本号，每次更新的时候追加版本号，A-B-A —&gt; 1A-2B-3A。</p>
<p>从jdk1.5开始,Atomic包提供了一个类AtomicStampedReference来解决ABA的问题。</p>
<h4 id="47-CAS循环时间长占用资源大问题"><a href="#47-CAS循环时间长占用资源大问题" class="headerlink" title="47.CAS循环时间长占用资源大问题"></a>47.CAS循环时间长占用资源大问题</h4><p>如果jvm能支持处理器提供的pause指令，那么效率会有一定的提升。</p>
<p>一、它可以延迟流水线执行指令(de-pipeline),使cpu不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，有些处理器延迟时间是0。</p>
<p>二、它可以避免在退出循环的时候因内存顺序冲突而引起的cpu流水线被清空，从而提高cpu执行效率。</p>
<h4 id="48-CAS只能保证一个共享变量原子操作"><a href="#48-CAS只能保证一个共享变量原子操作" class="headerlink" title="48.CAS只能保证一个共享变量原子操作"></a>48.CAS只能保证一个共享变量原子操作</h4><p>一、对多个共享变量操作时，可以用锁。</p>
<p>二、可以把多个共享变量合并成一个共享变量来操作。比如,x=1,k=a,合并xk=1a，然后用cas操作xk。</p>
<p>Tips:java 1.5开始,jdk提供了AtomicReference类来保证饮用对象之间的原子性，就可以把多个变量放在一个对象来进行cas操作。</p>
<h4 id="49-volatile关键字"><a href="#49-volatile关键字" class="headerlink" title="49.volatile关键字"></a>49.volatile关键字</h4><p>volatile 是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性“。</p>
<p>Java语言规范第3版对volatile定义如下，Java允许线程访问共享变量，为了保证共享变量能准确和一致的更新，线程应该确保排它锁单独获得这个变量。如果一个字段被声明为volatile,Java线程内存模型所有线程看到这个变量的值是一致的。</p>
<h4 id="50-等待-通知机制"><a href="#50-等待-通知机制" class="headerlink" title="50.等待/通知机制"></a>50.等待/通知机制</h4><p>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</p>
<h4 id="51-wait"><a href="#51-wait" class="headerlink" title="51.wait"></a>51.wait</h4><p>方法wait()的作用是使当前执行代码的线程进行等待，wait()是Object类通用的方法，该方法用来将当前线程置入“预执行队列”中，并在 wait()所在的代码处停止执行，直到接到通知或中断为止。</p>
<p>在调用wait之前线程需要获得该对象的对象级别的锁。代码体现上，即只能是同步方法或同步代码块内。调用wait()后当前线程释放锁。</p>
<h4 id="52-notify"><a href="#52-notify" class="headerlink" title="52.notify"></a>52.notify</h4><p>notify()也是Object类的通用方法，也要在同步方法或同步代码块内调用，该方法用来通知哪些可能灯光该对象的对象锁的其他线程，如果有多个线程等待，则随机挑选出其中一个呈wait状态的线程，对其发出 通知 notify，并让它等待获取该对象的对象锁。</p>
<h4 id="53-notify-notifyAll"><a href="#53-notify-notifyAll" class="headerlink" title="53.notify/notifyAll"></a>53.notify/notifyAll</h4><p>notify等于说将等待队列中的一个线程移动到同步队列中，而notifyAll是将等待队列中的所有线程全部移动到同步队列中。</p>
<h4 id="54-等待-通知经典范式"><a href="#54-等待-通知经典范式" class="headerlink" title="54.等待/通知经典范式"></a>54.等待/通知经典范式</h4><p>等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">		<span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">				obj.wait();</span><br><span class="line">		&#125;</span><br><span class="line">		执行对应逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">	  改变条件</span><br><span class="line">		obj.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="55-ThreadLocal"><a href="#55-ThreadLocal" class="headerlink" title="55.ThreadLocal"></a>55.ThreadLocal</h4><p>主要解决每一个线程想绑定自己的值，存放线程的私有数据。</p>
<h4 id="56-ThreadLocal使用"><a href="#56-ThreadLocal使用" class="headerlink" title="56.ThreadLocal使用"></a>56.ThreadLocal使用</h4><p>获取当前的线程的值通过get(),设置set(T) 方式来设置值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XKThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadLocal.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"未设置过值"</span>);</span><br><span class="line">            threadLocal.set(<span class="string">"Java小咖秀"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">未设置过值</span><br><span class="line">Java小咖秀</span><br></pre></td></tr></table></figure>

<p>Tips:默认值为null</p>
<h4 id="57-解决get-返回null问题"><a href="#57-解决get-返回null问题" class="headerlink" title="57.解决get()返回null问题"></a>57.解决get()返回null问题</h4><p>通过继承重写initialValue()方法即可。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExt</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocalExt threadLocalExt = <span class="keyword">new</span> ThreadLocalExt();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Java小咖秀"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(threadLocalExt.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java小咖秀</span><br></pre></td></tr></table></figure>

<h4 id="58-Lock接口"><a href="#58-Lock接口" class="headerlink" title="58.Lock接口"></a>58.Lock接口</h4><p>锁可以防止多个线程同时共享资源。Java5前程序是靠synchronized实现锁功能。Java5之后，并发包新增Lock接口来实现锁功能。</p>
<h4 id="59-Lock接口提供-synchronized不具备的主要特性"><a href="#59-Lock接口提供-synchronized不具备的主要特性" class="headerlink" title="59.Lock接口提供 synchronized不具备的主要特性"></a>59.Lock接口提供 synchronized不具备的主要特性</h4><p><img src="http://static.cyblogs.com/QQ20200506-230803@2x.jpg" alt="http://static.cyblogs.com/QQ20200506-230803@2x.jpg"></p>
<h4 id="60-重入锁-ReentrantLock"><a href="#60-重入锁-ReentrantLock" class="headerlink" title="60.重入锁 ReentrantLock"></a>60.重入锁 ReentrantLock</h4><p>支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p>
<h4 id="61-重进入是什么意思？"><a href="#61-重进入是什么意思？" class="headerlink" title="61.重进入是什么意思？"></a>61.重进入是什么意思？</h4><p>重进入是指任意线程在获取到锁之后能够再次获锁而不被锁阻塞。</p>
<p>该特性主要解决以下两个问题：</p>
<p>一、锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是则再次成功获取。</p>
<p>二、所得最终释放。线程重复n次是获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。</p>
<h4 id="62-ReentrantLock默认锁？"><a href="#62-ReentrantLock默认锁？" class="headerlink" title="62.ReentrantLock默认锁？"></a>62.ReentrantLock默认锁？</h4><p>默认非公平锁</p>
<p>代码为证:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="63-公平锁和非公平锁的区别"><a href="#63-公平锁和非公平锁的区别" class="headerlink" title="63.公平锁和非公平锁的区别"></a>63.公平锁和非公平锁的区别</h4><p>公平性与否针对获取锁来说的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。</p>
<h4 id="64-读写锁"><a href="#64-读写锁" class="headerlink" title="64.读写锁"></a>64.读写锁</h4><h4 id="读写锁允许同一时刻多个读线程访问，但是写线程和其他写线程均被阻塞。读写锁维护一个读锁一个写锁，读写分离，并发性得到了提升。"><a href="#读写锁允许同一时刻多个读线程访问，但是写线程和其他写线程均被阻塞。读写锁维护一个读锁一个写锁，读写分离，并发性得到了提升。" class="headerlink" title="读写锁允许同一时刻多个读线程访问，但是写线程和其他写线程均被阻塞。读写锁维护一个读锁一个写锁，读写分离，并发性得到了提升。"></a>读写锁允许同一时刻多个读线程访问，但是写线程和其他写线程均被阻塞。读写锁维护一个读锁一个写锁，读写分离，并发性得到了提升。</h4><p>Java中提供读写锁的实现类是ReentrantReadWriteLock。</p>
<h4 id="65-LockSupport工具"><a href="#65-LockSupport工具" class="headerlink" title="65.LockSupport工具"></a>65.LockSupport工具</h4><p>定义了一组公共静态方法，提供了最基本的线程阻塞和唤醒功能。</p>
<p><img src="http://static.cyblogs.com/QQ20200506-230912@2x.jpg" alt="http://static.cyblogs.com/QQ20200506-230912@2x.jpg"></p>
<h4 id="66-Condition接口"><a href="#66-Condition接口" class="headerlink" title="66.Condition接口"></a>66.Condition接口</h4><p>提供了类似Object监视器方法，与 Lock配合使用实现等待/通知模式。</p>
<h4 id="67-Condition使用"><a href="#67-Condition使用" class="headerlink" title="67.Condition使用"></a>67.Condition使用</h4><p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XKCondition</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition cd = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cd.await();<span class="comment">//相当于Object 方法中的wait()</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cd.signal(); <span class="comment">//相当于Object 方法中的notify()</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="68-ArrayBlockingQueue"><a href="#68-ArrayBlockingQueue" class="headerlink" title="68.ArrayBlockingQueue?"></a>68.ArrayBlockingQueue?</h4><p>一个由数据支持的有界阻塞队列，此队列FIFO原则对元素进行排序。队列头部在队列中存在的时间最长，队列尾部存在时间最短。</p>
<h4 id="69-PriorityBlockingQueue"><a href="#69-PriorityBlockingQueue" class="headerlink" title="69.PriorityBlockingQueue?"></a>69.PriorityBlockingQueue?</h4><p>一个支持优先级排序的无界阻塞队列，但它不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。</p>
<h4 id="70-DelayQueue"><a href="#70-DelayQueue" class="headerlink" title="70.DelayQueue?"></a>70.DelayQueue?</h4><p>是一个支持延时获取元素的使用优先级队列的实现的无界阻塞队列。队列中的元素必须实现Delayed接口和 Comparable接口，在创建元素时可以指定多久才能从队列中获取当前元素。</p>
<h4 id="71-Java并发容器，你知道几个？"><a href="#71-Java并发容器，你知道几个？" class="headerlink" title="71.Java并发容器，你知道几个？"></a>71.Java并发容器，你知道几个？</h4><p>ConcurrentHashMap、CopyOnWriteArrayList 、CopyOnWriteArraySet 、ConcurrentLinkedQueue、</p>
<p>ConcurrentLinkedDeque、ConcurrentSkipListMap、ConcurrentSkipListSet、ArrayBlockingQueue、</p>
<p>LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue、SynchronousQueue、</p>
<p>LinkedTransferQueue、DelayQueue</p>
<h4 id="72-ConcurrentHashMap"><a href="#72-ConcurrentHashMap" class="headerlink" title="72.ConcurrentHashMap"></a>72.ConcurrentHashMap</h4><p>并发安全版HashMap,java7中采用分段锁技术来提高并发效率，默认分16段。Java8放弃了分段锁，采用CAS，同时当哈希冲突时，当链表的长度到8时，会转化成红黑树。（如需了解细节，见jdk中代码）</p>
<h4 id="73-ConcurrentLinkedQueue"><a href="#73-ConcurrentLinkedQueue" class="headerlink" title="73.ConcurrentLinkedQueue"></a>73.ConcurrentLinkedQueue</h4><p>基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用cas算法来实现。（如需了解细节，见jdk中代码）</p>
<h4 id="74-什么是阻塞队列？"><a href="#74-什么是阻塞队列？" class="headerlink" title="74.什么是阻塞队列？"></a>74.什么是阻塞队列？</h4><p>阻塞队列是一个支持两个附加操作的队列，这两个附加操作支持阻塞的插入和移除方法。</p>
<p>1、支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
<p>2、支持阻塞的移除方法：当队列空时，获取元素的线程会等待队列变为非空。</p>
<h4 id="75-阻塞队列常用的应用场景？"><a href="#75-阻塞队列常用的应用场景？" class="headerlink" title="75.阻塞队列常用的应用场景？"></a>75.阻塞队列常用的应用场景？</h4><p>常用于生产者和消费者场景，生产者是往队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列正好是生产者存放、消费者来获取的容器。</p>
<h4 id="76-Java里的阻塞的队列"><a href="#76-Java里的阻塞的队列" class="headerlink" title="76.Java里的阻塞的队列"></a>76.Java里的阻塞的队列</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue：    数组结构组成的 |有界阻塞队列</span><br><span class="line">LinkedBlockingQueue：   链表结构组成的|有界阻塞队列</span><br><span class="line">PriorityBlockingQueue:  支持优先级排序|无界阻塞队列</span><br><span class="line">DelayQueue：            优先级队列实现|无界阻塞队列</span><br><span class="line">SynchronousQueue：      不存储元素| 阻塞队列</span><br><span class="line">LinkedTransferQueue：   链表结构组成|无界阻塞队列</span><br><span class="line">LinkedBlockingDeque：   链表结构组成|双向阻塞队列</span><br></pre></td></tr></table></figure>

<h4 id="77-Fork-Join"><a href="#77-Fork-Join" class="headerlink" title="77.Fork/Join"></a>77.Fork/Join</h4><p>java7提供的一个用于并行执行任务的框架，把一个大任务分割成若干个小任务，最终汇总每个小任务结果的后得到大任务结果的框架。</p>
<h4 id="78-工作窃取算法"><a href="#78-工作窃取算法" class="headerlink" title="78.工作窃取算法"></a>78.工作窃取算法</h4><p>是指某个线程从其他队列里窃取任务来执行。当大任务被分割成小任务时，有的线程可能提前完成任务，此时闲着不如去帮其他没完成工作线程。此时可以去其他队列窃取任务，为了减少竞争，通常使用双端队列，被窃取的线程从头部拿，窃取的线程从尾部拿任务执行。</p>
<h4 id="79-工作窃取算法的有缺点"><a href="#79-工作窃取算法的有缺点" class="headerlink" title="79.工作窃取算法的有缺点"></a>79.工作窃取算法的有缺点</h4><p>优点：充分利用线程进行并行计算，减少了线程间的竞争。</p>
<p>缺点：有些情况下还是存在竞争，比如双端队列中只有一个任务。这样就消耗了更多资源。</p>
<h4 id="80-Java中原子操作更新基本类型，Atomic包提供了哪几个类"><a href="#80-Java中原子操作更新基本类型，Atomic包提供了哪几个类" class="headerlink" title="80.Java中原子操作更新基本类型，Atomic包提供了哪几个类?"></a>80.Java中原子操作更新基本类型，Atomic包提供了哪几个类?</h4><p>AtomicBoolean:原子更新布尔类型</p>
<p>AtomicInteger:原子更新整形</p>
<p>AtomicLong:原子更新长整形</p>
<h4 id="81-Java中原子操作更新数组，Atomic包提供了哪几个类"><a href="#81-Java中原子操作更新数组，Atomic包提供了哪几个类" class="headerlink" title="81.Java中原子操作更新数组，Atomic包提供了哪几个类?"></a>81.Java中原子操作更新数组，Atomic包提供了哪几个类?</h4><p>AtomicIntegerArray:       原子更新整形数据里的元素</p>
<p>AtomicLongArray:          原子更新长整形数组里的元素</p>
<p>AtomicReferenceArray:  原子更新饮用类型数组里的元素</p>
<p>AtomicIntegerArray:      主要提供原子方式更新数组里的整形</p>
<h4 id="82-Java中原子操作更新引用类型，Atomic包提供了哪几个类"><a href="#82-Java中原子操作更新引用类型，Atomic包提供了哪几个类" class="headerlink" title="82.Java中原子操作更新引用类型，Atomic包提供了哪几个类?"></a>82.Java中原子操作更新引用类型，Atomic包提供了哪几个类?</h4><p>如果原子需要更新多个变量，就需要用引用类型了。</p>
<p>AtomicReference :  原子更新引用类型</p>
<p>AtomicReferenceFieldUpdater: 原子更新引用类型里的字段。</p>
<p>AtomicMarkableReference: 原子更新带有标记位的引用类型。标记位用boolean类型表示，构造方法时AtomicMarkableReference(V initialRef,boolean initialMark)</p>
<h4 id="83-Java中原子操作更新字段类，Atomic包提供了哪几个类"><a href="#83-Java中原子操作更新字段类，Atomic包提供了哪几个类" class="headerlink" title="83.Java中原子操作更新字段类，Atomic包提供了哪几个类?"></a>83.Java中原子操作更新字段类，Atomic包提供了哪几个类?</h4><p>AtomiceIntegerFieldUpdater:      原子更新整形字段的更新器</p>
<p>AtomiceLongFieldUpdater:         原子更新长整形字段的更新器</p>
<p>AtomiceStampedFieldUpdater:   原子更新带有版本号的引用类型，将整数值</p>
<h4 id="84-JDK并发包中提供了哪几个比较常见的处理并发的工具类？"><a href="#84-JDK并发包中提供了哪几个比较常见的处理并发的工具类？" class="headerlink" title="84.JDK并发包中提供了哪几个比较常见的处理并发的工具类？"></a>84.JDK并发包中提供了哪几个比较常见的处理并发的工具类？</h4><p>提供并发控制手段: CountDownLatch、CyclicBarrier、Semaphore</p>
<p>线程间数据交换:     Exchanger</p>
<h4 id="85-CountDownLatch"><a href="#85-CountDownLatch" class="headerlink" title="85.CountDownLatch"></a>85.CountDownLatch</h4><p>允许一个或多个线程等待其他线程完成操作。</p>
<p>CountDownLatch的构造函数接受一个int类型的参数作为计数器，你想等待n个点完成，就传入n。</p>
<p>两个重要的方法:</p>
<p>countDown() : 调用时，n会减1。</p>
<p>await() : 调用会阻塞当前线程，直到n变成0。</p>
<p>await(long time,TimeUnit unit) : 等待特定时间后，就不会继续阻塞当前线程。</p>
<p>tips:计数器必须大于等于0，当为0时，await就不会阻塞当前线程。</p>
<p>不提供重新初始化或修改内部计数器的值的功能。</p>
<h4 id="86-CyclicBarrier"><a href="#86-CyclicBarrier" class="headerlink" title="86.CyclicBarrier"></a>86.CyclicBarrier</h4><p>可循环使用的屏障。</p>
<p>让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>CyclicBarrier默认构造放时CyclicBarrier(int parities) ,其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达屏障，然后当前线程被阻塞。</p>
<h4 id="87-CountDownLatch与CyclicBarrier区别"><a href="#87-CountDownLatch与CyclicBarrier区别" class="headerlink" title="87.CountDownLatch与CyclicBarrier区别"></a>87.CountDownLatch与CyclicBarrier区别</h4><p>CountDownLatch：</p>
<p>计数器：计数器只能使用一次。</p>
<p>等待： 一个线程或多个等待另外n个线程完成之后才能执行。</p>
<p>CyclicBarrier：</p>
<p>计数器：计数器可以重置（通过reset()方法)。</p>
<p>等待： n个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</p>
<h4 id="88-Semaphore"><a href="#88-Semaphore" class="headerlink" title="88.Semaphore"></a>88.Semaphore</h4><p>用来控制同时访问资源的线程数量，通过协调各个线程，来保证合理的公共资源的访问。</p>
<p>应用场景：流量控制，特别是公共资源有限的应用场景，比如数据链接，限流等。</p>
<h4 id="89-Exchanger"><a href="#89-Exchanger" class="headerlink" title="89.Exchanger"></a>89.Exchanger</h4><p>Exchanger是一个用于线程间协作的工具类，它提供一个同步点，在这个同步点上，两个线程可以交换彼此的数据。比如第一个线程执行exchange()方法，它会一直等待第二个线程也执行exchange，当两个线程都到同步点，就可以交换数据了。</p>
<p>一般来说为了避免一直等待的情况，可以使用exchange(V x,long timeout,TimeUnit unit),设置最大等待时间。</p>
<p>Exchanger可以用于遗传算法。</p>
<h4 id="90-为什么使用线程池"><a href="#90-为什么使用线程池" class="headerlink" title="90.为什么使用线程池"></a>90.为什么使用线程池</h4><p>几乎所有需要异步或者并发执行任务的程序都可以使用线程池。合理使用会给我们带来以下好处。</p>
<ul>
<li>降低系统消耗：重复利用已经创建的线程降低线程创建和销毁造成的资源消耗。</li>
<li>提高响应速度： 当任务到达时，任务不需要等到线程创建就可以立即执行。</li>
<li>提供线程可以管理性： 可以通过设置合理分配、调优、监控。</li>
</ul>
<h4 id="91-线程池工作流程"><a href="#91-线程池工作流程" class="headerlink" title="91.线程池工作流程"></a>91.线程池工作流程</h4><p>1、判断核心线程池里的线程是否都有在执行任务，否-&gt;创建一个新工作线程来执行任务。是-&gt;走下个流程。</p>
<p>2、判断工作队列是否已满，否-&gt;新任务存储在这个工作队列里，是-&gt;走下个流程。</p>
<p>3、判断线程池里的线程是否都在工作状态，否-&gt;创建一个新的工作线程来执行任务，</p>
<p>是-&gt;走下个流程。</p>
<p>4、按照设置的策略来处理无法执行的任务。</p>
<h4 id="92-创建线程池参数有哪些，作用？"><a href="#92-创建线程池参数有哪些，作用？" class="headerlink" title="92.创建线程池参数有哪些，作用？"></a>92.创建线程池参数有哪些，作用？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(   <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>1.corePoolSize:核心线程池大小，当提交一个任务时，线程池会创建一个线程来执行任务，即使其他空闲的核心线程能够执行新任务也会创建，等待需要执行的任务数大于线程核心大小就不会继续创建。</p>
<p>2.maximumPoolSize:线程池最大数，允许创建的最大线程数，如果队列满了，并且已经创建的线程数小于最大线程数，则会创建新的线程执行任务。如果是无界队列，这个参数基本没用。</p>
<p>3.keepAliveTime: 线程保持活动时间，线程池工作线程空闲后，保持存活的时间，所以如果任务很多，并且每个任务执行时间较短，可以调大时间，提高线程利用率。</p>
<p>4.unit: 线程保持活动时间单位，天（DAYS)、小时(HOURS)、分钟(MINUTES、毫秒MILLISECONDS)、微秒(MICROSECONDS)、纳秒(NANOSECONDS)</p>
<p>5.workQueue: 任务队列，保存等待执行的任务的阻塞队列。</p>
<p>一般来说可以选择如下阻塞队列：</p>
<p>ArrayBlockingQueue:基于数组的有界阻塞队列。</p>
<p>LinkedBlockingQueue:基于链表的阻塞队列。</p>
<p>SynchronizedQueue:一个不存储元素的阻塞队列。</p>
<p>PriorityBlockingQueue:一个具有优先级的阻塞队列。</p>
<p>6.threadFactory：设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p>
<ol>
<li><p>handler: 饱和策略也叫拒绝策略。当队列和线程池都满了，即达到饱和状态。所以需要采取策略来处理新的任务。默认策略是AbortPolicy。</p>
<p>AbortPolicy:直接抛出异常。</p>
<p>CallerRunsPolicy: 调用者所在的线程来运行任务。</p>
<p>DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。</p>
<p>DiscardPolicy:不处理，直接丢掉。</p>
<p>当然可以根据自己的应用场景，实现RejectedExecutionHandler接口自定义策略。</p>
</li>
</ol>
<h4 id="93-向线程池提交任务"><a href="#93-向线程池提交任务" class="headerlink" title="93.向线程池提交任务"></a>93.向线程池提交任务</h4><p>可以使用execute()和submit() 两种方式提交任务。</p>
<p>execute():无返回值，所以无法判断任务是否被执行成功。</p>
<p>submit():用于提交需要有返回值的任务。线程池返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()来获取返回值，get()方法会阻塞当前线程知道任务完成。get(long timeout,TimeUnit unit)可以设置超市时间。</p>
<h4 id="94-关闭线程池"><a href="#94-关闭线程池" class="headerlink" title="94.关闭线程池"></a>94.关闭线程池</h4><p>可以通过shutdown()或shutdownNow()来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt来中断线程，所以无法响应终端的任务可以能永远无法停止。</p>
<p>shutdownNow首先将线程池状态设置成STOP,然后尝试停止所有的正在执行或者暂停的线程，并返回等待执行任务的列表。</p>
<p>shutdown只是将线程池的状态设置成shutdown状态，然后中断所有没有正在执行任务的线程。</p>
<p>只要调用两者之一，isShutdown就会返回true,当所有任务都已关闭，isTerminaed就会返回true。</p>
<p>一般来说调用shutdown方法来关闭线程池，如果任务不一定要执行完，可以直接调用shutdownNow方法。</p>
<h4 id="95-线程池如何合理设置"><a href="#95-线程池如何合理设置" class="headerlink" title="95.线程池如何合理设置"></a>95.线程池如何合理设置</h4><p>配置线程池可以从以下几个方面考虑。</p>
<ul>
<li><p>任务是cpu密集型、IO密集型或者混合型</p>
</li>
<li><p>任务优先级，高中低。</p>
</li>
<li><p>任务时间执行长短。</p>
</li>
<li><p>任务依赖性：是否依赖其他系统资源。</p>
<p>cpu密集型可以配置可能小的线程,比如 n + 1个线程。</p>
<p>io密集型可以配置较多的线程，如 2n个线程。</p>
<p>混合型可以拆成io密集型任务和cpu密集型任务，</p>
<p>如果两个任务执行时间相差大，否-&gt;分解后执行吞吐量将高于串行执行吞吐量。</p>
<p>否-&gt;没必要分解。</p>
<p>可以通过Runtime.getRuntime().availableProcessors()来获取cpu个数。</p>
<p>建议使用有界队列，增加系统的预警能力和稳定性。</p>
</li>
</ul>
<h4 id="96-Executor"><a href="#96-Executor" class="headerlink" title="96.Executor"></a>96.Executor</h4><p>从JDK5开始，把工作单元和执行机制分开。工作单元包括Runnable和Callable,而执行机制由Executor框架提供。</p>
<h4 id="97-Executor框架的主要成员"><a href="#97-Executor框架的主要成员" class="headerlink" title="97.Executor框架的主要成员"></a>97.Executor框架的主要成员</h4><p>ThreadPoolExecutor  :可以通过工厂类Executors来创建。</p>
<p>可以创建3种类型的ThreadPoolExecutor：SingleThreadExecutor、FixedThreadPool、CachedThreadPool。</p>
<p>ScheduledThreadPoolExecutor ：可以通过工厂类Executors来创建。</p>
<p>可以创建2中类型的ScheduledThreadPoolExecutor：ScheduledThreadPoolExecutor、SingleThreadScheduledExecutor</p>
<p>Future接口:Future和实现Future接口的FutureTask类来表示异步计算的结果。</p>
<p>Runnable和Callable:它们的接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。Runnable不能返回结果，Callable可以返回结果。</p>
<h4 id="98-FixedThreadPool"><a href="#98-FixedThreadPool" class="headerlink" title="98.FixedThreadPool"></a>98.FixedThreadPool</h4><p>可重用固定线程数的线程池。</p>
<p>查看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>corePoolSize 和maxPoolSize都被设置成我们设置的nThreads。</p>
<p>当线程池中的线程数大于corePoolSize ,keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止，如果设为0，表示多余的空闲线程会立即终止。</p>
<p>工作流程：</p>
<p>1.当前线程少于corePoolSize,创建新线程执行任务。</p>
<p>2.当前运行线程等于corePoolSize,将任务加入LinkedBlockingQueue。</p>
<p>3.线程执行完1中的任务，会循环反复从LinkedBlockingQueue获取任务来执行。</p>
<p>LinkedBlockingQueue作为线程池工作队列（默认容量Integer.MAX_VALUE)。因此可能会造成如下赢下。</p>
<p>1.当线程数等于corePoolSize时，新任务将在队列中等待，因为线程池中的线程不会超过corePoolSize。</p>
<p>2.maxnumPoolSize等于说是一个无效参数。</p>
<p>3.keepAliveTime等于说也是一个无效参数。</p>
<p>4.运行中的FixedThreadPool(未执行shundown或shundownNow))则不会调用拒绝策略。</p>
<p>5.由于任务可以不停的加到队列，当任务越来越多时很容易造成OOM。</p>
<h4 id="99-SingleThreadExecutor"><a href="#99-SingleThreadExecutor" class="headerlink" title="99.SingleThreadExecutor"></a>99.SingleThreadExecutor</h4><p>是使用单个worker线程的Executor。</p>
<p>查看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>corePoolSize和maxnumPoolSize被设置为1。其他参数和FixedThreadPool相同。</p>
<p>执行流程以及造成的影响同FixedThreadPool.</p>
<h4 id="100-CachedThreadPool"><a href="#100-CachedThreadPool" class="headerlink" title="100.CachedThreadPool"></a>100.CachedThreadPool</h4><p>根据需要创建新线程的线程池。</p>
<p>查看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<p>corePoolSize设置为0，maxmumPoolSize为Integer.MAX_VALUE。keepAliveTime为60秒。</p>
<p>工作流程：</p>
<p>1.首先执行SynchronousQueue.offer (Runnable task)。如果当前maximumPool 中有空闲线程正在执行S ynchronousQueue.poll(keepAliveTIme,TimeUnit.NANOSECONDS)，那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行,execute方 法执行完成;否则执行下面的步骤2。</p>
<ol>
<li>当初始maximumPool为空或者maximumPool中当前没有空闲线程时，将没有线程执行 SynchronousQueue.poll (keepAliveTime，TimeUnit.NANOSECONDS)。这种情况下，步骤 1将失 败。此时CachedThreadPool会创建一个新线程执行任务，execute()方法执行完成。</li>
</ol>
<p>3.在步骤2中新创建的线程将任务执行完后，会执行SynchronousQueue.poll (keepAliveTime，TimeUnit.NANOSECONDS)。这个poll操作会让空闲线程最多在SynchronousQueue中等待60秒钟。如果60秒钟内主线程提交了一个新任务(主线程执行步骤1)，那么这个空闲线程将执行主线程提交的新任务;否则，这个空闲线程将终止。由于空闲60秒的空闲线程会被终止,因此长时间保持空闲的CachedThreadPool不会使用任何资源。</p>
<p>一般来说它适合处理时间短、大量的任务。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://juejin.im/post/5eaecf326fb9a043856f33d5" target="_blank" rel="noopener">https://juejin.im/post/5eaecf326fb9a043856f33d5</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈ElasticSearch架构以及集成</title>
    <url>/2020/05/02/2020/05/%E6%B5%85%E8%B0%88ElasticSearch%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8A%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>Elasticsearch</code>是一个高度可扩展的开源的分布式<code>Restful</code>全文搜索和分析引擎。它允许用户快速的（近实时的）存储、搜索和分析海量数据。它通常用作底层引擎技术，为具有复杂搜索功能和要求的应用程序提供支持。<br>以下是<code>ES</code>可用于的一些场景：</p>
<ol>
<li>电商网站提供搜索功能：可使用<code>ES</code>来存储产品的目录和库存，并为它们提供搜索和自动填充建议。</li>
<li>收集日志和交易数据，并进行分析：可使用<code>Logstash</code>来收集、聚合和解析数据， 然后让<code>Logstash</code>将此数据提供给<code>ES</code>。然后可在<code>ES</code>中搜索和聚合开发者感兴趣的信息。</li>
<li>需要快速调查、分析、可视化查询大量数据的特定问题：可以使用ES存储数据，然后使用<code>Kibana</code>构建自定义仪表板，来可视化展示数据。还可以使用ES的聚合功能针对这些数据进行复杂的商业分析。</li>
</ol>
<h4 id="我们要认识一个人Doug-Cutting"><a href="#我们要认识一个人Doug-Cutting" class="headerlink" title="我们要认识一个人Doug Cutting"></a>我们要认识一个人Doug Cutting</h4><p>为什么要提<code>Doug Cutting</code>，因为Elasticsearch的底层是Lucene，而Lucene就是<code>Doug Cutting</code>大神写的。</p>
<p>引用来自于： 鲜枣课堂</p>
<blockquote>
<p>1998年9月4日，Google公司在美国硅谷成立。正如大家所知，它是一家做搜索引擎起家的公司。</p>
<p><img src="http://static.cyblogs.com/640.jpg" alt="http://static.cyblogs.com/640.jpg"></p>
<p>无独有偶，一位名叫<strong>Doug Cutting</strong>的美国工程师，也迷上了搜索引擎。他做了一个用于文本搜索的函数库（姑且理解为软件的功能组件），命名为<strong>Lucene</strong>。</p>
<p><img src="http://static.cyblogs.com/pUm6Hxkd434Mk1VTAruKa8.jpg" alt="http://static.cyblogs.com/pUm6Hxkd434Mk1VTAruKa8.jpg"></p>
<p>左为Doug Cutting，右为Lucene的LOGO</p>
<p>Lucene是用JAVA写成的，目标是为各种中小型应用软件加入全文检索功能。因为好用而且开源（代码公开），非常受程序员们的欢迎。</p>
<p>早期的时候，这个项目被发布在Doug Cutting的个人网站和SourceForge（一个开源软件网站）。后来，2001年底，Lucene成为<strong>Apache软件基金会</strong>jakarta项目的一个子项目。</p>
<p><img src="http://static.cyblogs.com/iaqYeVeXiaLwMxssVyfyV0f69tfVMod6.jpg" alt="http://static.cyblogs.com/iaqYeVeXiaLwMxssVyfyV0f69tfVMod6.jpg"></p>
<p>Apache软件基金会，搞IT的应该都认识</p>
<p>2004年，Doug Cutting再接再励，在Lucene的基础上，和Apache开源伙伴Mike Cafarella合作，开发了一款可以代替当时的主流搜索的开源搜索引擎，命名为<strong>Nutch</strong>。</p>
<p><img src="http://static.cyblogs.com/aqYeVeXiaLwMxssV.png" alt="http://static.cyblogs.com/aqYeVeXiaLwMxssV.png"></p>
<p>Nutch是一个建立在Lucene核心之上的网页搜索应用程序，可以下载下来直接使用。它在Lucene的基础上加了网络爬虫和一些网页相关的功能，目的就是从一个简单的站内检索推广到全球网络的搜索上，就像Google一样。</p>
<p>Nutch在业界的影响力比Lucene更大。</p>
<p>大批网站采用了Nutch平台，大大降低了技术门槛，使低成本的普通计算机取代高价的Web服务器成为可能。甚至有一段时间，在硅谷有了一股用Nutch低成本创业的潮流。</p>
<p>随着时间的推移，无论是Google还是Nutch，都面临搜索对象“体积”不断增大的问题。</p>
<p>尤其是Google，作为互联网搜索引擎，需要存储大量的网页，并不断优化自己的搜索算法，提升搜索效率。</p>
<p><img src="http://static.cyblogs.com/TAruKa8WKbr3qDia9ba.jpg" alt="http://static.cyblogs.com/TAruKa8WKbr3qDia9ba.jpg"></p>
<p>Google搜索栏</p>
<p>在这个过程中，Google确实找到了不少好办法，并且无私地分享了出来。</p>
<p>2003年，Google发表了一篇技术学术论文，公开介绍了自己的谷歌文件系统<strong>GFS（Google File System）</strong>。这是Google公司为了存储海量搜索数据而设计的专用文件系统。</p>
<p>第二年，也就是2004年，Doug Cutting基于Google的GFS论文，实现了<strong>分布式文件存储系统</strong>，并将它命名为<strong>NDFS（Nutch Distributed File System）</strong>。</p>
<p><img src="http://static.cyblogs.com/google_gfs_ndfs.jpg" alt="http://static.cyblogs.com/google_gfs_ndfs.jpg"></p>
<p>还是2004年，Google又发表了一篇技术学术论文，介绍自己的<strong>MapReduce编程模型</strong>。这个编程模型，用于大规模数据集（大于1TB）的并行分析运算。</p>
<p>第二年（2005年），Doug Cutting又基于MapReduce，在Nutch搜索引擎实现了该功能。</p>
<p><img src="http://static.cyblogs.com/goole_mapreduce.jpg" alt="http://static.cyblogs.com/goole_mapreduce.jpg"></p>
<p>2006年，当时依然很厉害的<strong>Yahoo（雅虎）公司</strong>，招安了Doug Cutting。</p>
<p><img src="http://static.cyblogs.com/goole_mapreduce_002.jpg" alt="http://static.cyblogs.com/goole_mapreduce_002.jpg"></p>
<p>这里要补充说明一下雅虎招安Doug的背景：2004年之前，作为互联网开拓者的雅虎，是使用Google搜索引擎作为自家搜索服务的。在2004年开始，雅虎放弃了Google，开始自己研发搜索引擎。所以。。。</p>
<p>加盟Yahoo之后，Doug Cutting将NDFS和MapReduce进行了升级改造，并重新命名为<strong>Hadoop</strong>（NDFS也改名为HDFS，Hadoop Distributed File System）。</p>
<p>这个，就是后来大名鼎鼎的大数据框架系统——Hadoop的由来。而Doug Cutting，则被人们称为<strong>Hadoop之父</strong>。</p>
<p><img src="http://static.cyblogs.com/goole_mapreduce_003.jpg" alt="http://static.cyblogs.com/goole_mapreduce_003.jpg"></p>
<p>Hadoop这个名字，实际上是Doug Cutting他儿子的黄色玩具大象的名字。所以，Hadoop的Logo，就是一只奔跑的黄色大象。</p>
<p><img src="http://static.cyblogs.com/goole_mapreduce_004.jpg" alt="http://static.cyblogs.com/goole_mapreduce_004.jpg"></p>
<p>我们继续往下说。</p>
<p>还是2006年，Google又发论文了。</p>
<p>这次，它们介绍了自己的<strong>BigTable</strong>。这是一种分布式数据存储系统，一种用来处理海量数据的非关系型数据库。</p>
<p>Doug Cutting当然没有放过，在自己的hadoop系统里面，引入了BigTable，并命名为<strong>HBase</strong>。</p>
<p><img src="http://static.cyblogs.com/goole_mapreduce_005.jpg" alt="http://static.cyblogs.com/goole_mapreduce_005.jpg"></p>
<p>好吧，反正就是紧跟Google时代步伐，你出什么，我学什么。</p>
<p>所以，Hadoop的核心部分，基本上都有Google的影子。</p>
<p><img src="http://static.cyblogs.com/goole_mapreduce_006.png" alt="http://static.cyblogs.com/goole_mapreduce_006.png"></p>
</blockquote>
<p>其实从这里也能看到，站在巨人肩膀上或者仿照强者，也可以走出一条属于自己的道路。</p>
<h4 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Tools  brew search elasticsearch</span><br><span class="line">==&gt; Formulae</span><br><span class="line">elasticsearch                                  elasticsearch@2.4                              elasticsearch@5.6</span><br><span class="line"></span><br><span class="line">➜  Tools  brew install elasticsearch@5.6</span><br><span class="line">==&gt; Downloading https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.16.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">Warning: elasticsearch@5.6 has been deprecated!</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Data:    /usr/local/var/elasticsearch/elasticsearch_chenyuan/</span><br><span class="line">Logs:    /usr/local/var/log/elasticsearch/elasticsearch_chenyuan.log</span><br><span class="line">Plugins: /usr/local/opt/elasticsearch@5.6/libexec/plugins/</span><br><span class="line">Config:  /usr/local/etc/elasticsearch/</span><br><span class="line">plugin script: /usr/local/opt/elasticsearch@5.6/libexec/bin/elasticsearch-plugin</span><br><span class="line"></span><br><span class="line">elasticsearch@5.6 is keg-only, which means it was not symlinked into /usr/local,</span><br><span class="line">because this is an alternate version of another formula.</span><br><span class="line"></span><br><span class="line">If you need to have elasticsearch@5.6 first in your PATH run:</span><br><span class="line">  echo 'export PATH="/usr/local/opt/elasticsearch@5.6/bin:$PATH"' &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">To have launchd start elasticsearch@5.6 now and restart at login:</span><br><span class="line">  brew services start elasticsearch@5.6</span><br><span class="line">Or, if you don't want/need a background service you can just run:</span><br><span class="line">  /usr/local/opt/elasticsearch@5.6/bin/elasticsearch</span><br><span class="line">==&gt; Summary</span><br><span class="line">/usr/local/Cellar/elasticsearch@5.6/5.6.16: 106 files, 36.0MB, built in 10 seconds</span><br><span class="line">==&gt; `brew cleanup` has not been run in 30 days, running now...</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/erlang--22.1.2.mojave.bottle.tar.gz... (77.3MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/gettext--0.20.1.catalina.bottle.tar.gz... (8.3MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/icu4c--64.2.catalina.bottle.tar.gz... (26.1MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/jpeg--9c.mojave.bottle.tar.gz... (300.8KB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/libpng--1.6.37.mojave.bottle.tar.gz... (442.2KB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/libtiff--4.0.10_1.mojave.bottle.tar.gz... (1MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/node--12.11.1.catalina.bottle.tar.gz... (14.8MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/openssl@1.1--1.1.1d.mojave.bottle.tar.gz... (5.2MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/perl--5.30.0.catalina.bottle.tar.gz... (16.3MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/rabbitmq--3.8.0.tar.xz... (11MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/subversion--1.12.2_1.catalina.bottle.1.tar.gz... (10MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/utf8proc--2.4.0.catalina.bottle.tar.gz... (152.2KB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Caches/Homebrew/wxmac--3.0.4_2.mojave.bottle.tar.gz... (7.4MB)</span><br><span class="line">Removing: /Users/chenyuan/Library/Logs/Homebrew/icu4c... (64B)</span><br><span class="line">Removing: /Users/chenyuan/Library/Logs/Homebrew/node... (64B)</span><br><span class="line">Pruned 0 symbolic links and 2 directories from /usr/local</span><br></pre></td></tr></table></figure>

<p>查看一下版本号，结果没有结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~  elasticsearch --version</span><br><span class="line">zsh: command not found: elasticsearch</span><br></pre></td></tr></table></figure>

<p>然后看之前的日志，需要你手动配置一下环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 'export PATH="/usr/local/opt/elasticsearch@5.6/bin:$PATH"' &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载环境变量</span></span><br><span class="line">➜  ~  source ~/.zshrc</span><br><span class="line">➜  ~  elasticsearch --version</span><br><span class="line">Version: 5.6.16, Build: 3a740d1/2019-03-13T15:33:36.565Z, JVM: 1.8.0_162</span><br></pre></td></tr></table></figure>

<p>启动ElasticSearch</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~  elasticsearch</span><br><span class="line">[2020-05-14T21:47:06,301][INFO ][o.e.n.Node               ] [] initializing ...</span><br><span class="line">[2020-05-14T21:47:06,403][INFO ][o.e.e.NodeEnvironment    ] [vXW29Yn] using [1] data paths, mounts [[/ (/dev/disk1s5)]], net usable_space [42.5gb], net total_space [465.7gb], spins? [unknown], types [apfs]</span><br><span class="line">[2020-05-14T21:47:06,404][INFO ][o.e.e.NodeEnvironment    ] [vXW29Yn] heap size [1.9gb], compressed ordinary object pointers [true]</span><br><span class="line">[2020-05-14T21:47:06,406][INFO ][o.e.n.Node               ] node name [vXW29Yn] derived from node ID [vXW29YnkRDaIb8XuGeKRxQ]; set [node.name] to override</span><br><span class="line">[2020-05-14T21:47:06,406][INFO ][o.e.n.Node               ] version[5.6.16], pid[75858], build[3a740d1/2019-03-13T15:33:36.565Z], OS[Mac OS X/10.15.4/x86_64], JVM[Oracle Corporation/Java HotSpot(TM) 64-Bit Server VM/1.8.0_162/25.162-b12]</span><br><span class="line">[2020-05-14T21:47:06,406][INFO ][o.e.n.Node               ] JVM arguments [-Xms2g, -Xmx2g, -XX:+UseConcMarkSweepGC, -XX:CMSInitiatingOccupancyFraction=75, -XX:+UseCMSInitiatingOccupancyOnly, -XX:+AlwaysPreTouch, -Xss1m, -Djava.awt.headless=true, -Dfile.encoding=UTF-8, -Djna.nosys=true, -Djdk.io.permissionsUseCanonicalPath=true, -Dio.netty.noUnsafe=true, -Dio.netty.noKeySetOptimization=true, -Dio.netty.recycler.maxCapacityPerThread=0, -Dlog4j.shutdownHookEnabled=false, -Dlog4j2.disable.jmx=true, -Dlog4j.skipJansi=true, -XX:+HeapDumpOnOutOfMemoryError, -Des.path.home=/usr/local/Cellar/elasticsearch@5.6/5.6.16/libexec]</span><br><span class="line">[2020-05-14T21:47:07,237][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [aggs-matrix-stats]</span><br><span class="line">[2020-05-14T21:47:07,237][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [ingest-common]</span><br><span class="line">[2020-05-14T21:47:07,237][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [lang-expression]</span><br><span class="line">[2020-05-14T21:47:07,238][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [lang-groovy]</span><br><span class="line">[2020-05-14T21:47:07,238][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [lang-mustache]</span><br><span class="line">[2020-05-14T21:47:07,238][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [lang-painless]</span><br><span class="line">[2020-05-14T21:47:07,238][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [parent-join]</span><br><span class="line">[2020-05-14T21:47:07,238][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [percolator]</span><br><span class="line">[2020-05-14T21:47:07,238][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [reindex]</span><br><span class="line">[2020-05-14T21:47:07,238][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [transport-netty3]</span><br><span class="line">[2020-05-14T21:47:07,238][INFO ][o.e.p.PluginsService     ] [vXW29Yn] loaded module [transport-netty4]</span><br><span class="line">[2020-05-14T21:47:07,239][INFO ][o.e.p.PluginsService     ] [vXW29Yn] no plugins loaded</span><br><span class="line">[2020-05-14T21:47:08,643][INFO ][o.e.d.DiscoveryModule    ] [vXW29Yn] using discovery type [zen]</span><br><span class="line">[2020-05-14T21:47:09,099][INFO ][o.e.n.Node               ] initialized</span><br><span class="line">[2020-05-14T21:47:09,099][INFO ][o.e.n.Node               ] [vXW29Yn] starting ...</span><br><span class="line">[2020-05-14T21:47:09,347][INFO ][o.e.t.TransportService   ] [vXW29Yn] publish_address &#123;127.0.0.1:9300&#125;, bound_addresses &#123;[::1]:9300&#125;, &#123;127.0.0.1:9300&#125;</span><br><span class="line">[2020-05-14T21:47:12,405][INFO ][o.e.c.s.ClusterService   ] [vXW29Yn] new_master &#123;vXW29Yn&#125;&#123;vXW29YnkRDaIb8XuGeKRxQ&#125;&#123;0aNOjaAGSGGLSXHQUS-lyg&#125;&#123;127.0.0.1&#125;&#123;127.0.0.1:9300&#125;, reason: zen-disco-elected-as-master ([0] nodes joined)</span><br><span class="line">[2020-05-14T21:47:12,425][INFO ][o.e.h.n.Netty4HttpServerTransport] [vXW29Yn] publish_address &#123;127.0.0.1:9200&#125;, bound_addresses &#123;[::1]:9200&#125;, &#123;127.0.0.1:9200&#125;</span><br><span class="line">[2020-05-14T21:47:12,425][INFO ][o.e.n.Node               ] [vXW29Yn] started</span><br><span class="line">[2020-05-14T21:47:12,431][INFO ][o.e.g.GatewayService     ] [vXW29Yn] recovered [0] indices into cluster_state</span><br></pre></td></tr></table></figure>

<p>直接在浏览器输入：<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a></p>
<p><img src="http://static.cyblogs.com/QQ20200514-214940@2x.jpg" alt="http://static.cyblogs.com/QQ20200514-214940@2x.jpg"></p>
<h4 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~  brew search kibana</span><br><span class="line">==&gt; Formulae</span><br><span class="line">kibana                                                                 kibana@5.6</span><br><span class="line">➜  ~  brew install kibana@5.6</span><br><span class="line">==&gt; Downloading https://mirrors.ustc.edu.cn/homebrew-bottles/bottles/kibana%405.6-5.6.16.catalina.bottle.1.tar.gz</span><br><span class="line">==&gt; Downloading from https://akamai.bintray.com/f4/f451a8784dc52182670152d040f6533d4dc2f1b251ef3797eed6c6ff565db8af?__gda__=exp=1589465020~hm</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">Warning: kibana@5.6 has been deprecated!</span><br><span class="line">==&gt; Pouring kibana@5.6-5.6.16.catalina.bottle.1.tar.gz</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Config: /usr/local/etc/kibana/</span><br><span class="line">If you wish to preserve your plugins upon upgrade, make a copy of</span><br><span class="line">/usr/local/opt/kibana@5.6/plugins before upgrading, and copy it into the</span><br><span class="line">new keg location after upgrading.</span><br><span class="line"></span><br><span class="line">kibana@5.6 is keg-only, which means it was not symlinked into /usr/local,</span><br><span class="line">because this is an alternate version of another formula.</span><br><span class="line"></span><br><span class="line">If you need to have kibana@5.6 first in your PATH run:</span><br><span class="line">  echo 'export PATH="/usr/local/opt/kibana@5.6/bin:$PATH"' &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">To have launchd start kibana@5.6 now and restart at login:</span><br><span class="line">  brew services start kibana@5.6</span><br><span class="line">Or, if you don't want/need a background service you can just run:</span><br><span class="line">  /usr/local/opt/kibana@5.6/bin/kibana</span><br><span class="line">==&gt; Summary</span><br><span class="line">/usr/local/Cellar/kibana@5.6/5.6.16: 37,391 files, 200MB</span><br></pre></td></tr></table></figure>

<p>同样的道理，配置好环境变量。</p>
<p>启动kibana</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~  kibana</span><br><span class="line">  log   [13:56:55.842] [info][status][plugin:kibana@5.6.16] Status changed from uninitialized to green - Ready</span><br><span class="line">  log   [13:56:55.901] [info][status][plugin:elasticsearch@5.6.16] Status changed from uninitialized to yellow - Waiting for Elasticsearch</span><br><span class="line">  log   [13:56:55.923] [info][status][plugin:console@5.6.16] Status changed from uninitialized to green - Ready</span><br><span class="line">  log   [13:56:55.952] [info][status][plugin:metrics@5.6.16] Status changed from uninitialized to green - Ready</span><br><span class="line">  log   [13:56:56.158] [info][status][plugin:timelion@5.6.16] Status changed from uninitialized to green - Ready</span><br><span class="line">  log   [13:56:56.162] [info][listening] Server running at http://localhost:5601</span><br><span class="line">  log   [13:56:56.163] [info][status][ui settings] Status changed from uninitialized to yellow - Elasticsearch plugin is yellow</span><br><span class="line">  log   [13:57:01.165] [info][status][plugin:elasticsearch@5.6.16] Status changed from yellow to yellow - No existing Kibana index found</span><br><span class="line">  log   [13:57:02.456] [info][status][plugin:elasticsearch@5.6.16] Status changed from yellow to green - Kibana index ready</span><br><span class="line">  log   [13:57:02.457] [info][status][ui settings] Status changed from yellow to green - Ready</span><br></pre></td></tr></table></figure>

<p>直接在浏览器输入：<a href="http://localhost:5601/" target="_blank" rel="noopener">http://localhost:5601/</a></p>
<p><img src="http://static.cyblogs.com/QQ20200514-215814@2x.jpg" alt="http://static.cyblogs.com/QQ20200514-215814@2x.jpg"></p>
<h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"first_name"</span> : <span class="string">"John"</span>,</span><br><span class="line">    <span class="attr">"last_name"</span> :  <span class="string">"Smith"</span>,</span><br><span class="line">    <span class="attr">"age"</span> :        <span class="number">25</span>,</span><br><span class="line">    <span class="attr">"about"</span> :      <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">    <span class="attr">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/QQ20200514-220241@2x.jpg" alt="http://static.cyblogs.com/QQ20200514-220241@2x.jpg"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"megacorp"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"employee"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">1</span>, <span class="comment">// 版本</span></span><br><span class="line">  <span class="attr">"result"</span>: <span class="string">"created"</span>, <span class="comment">// 是新增还是修改</span></span><br><span class="line">  <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">    <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>对着官方文档一一的研究了一下它的一些语法与介绍。我个人觉得ElasticSearch的官方文档还算比较过关的：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html</a> 学习起来基本毫无障碍。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /my_store/products/_bulk</span><br><span class="line">&#123; "index": &#123; "_id": 1 &#125;&#125;</span><br><span class="line">&#123; "price" : 10, "productID" : "XHDK-A-1293-#fJ3" &#125;</span><br><span class="line">&#123; "index": &#123; "_id": 2 &#125;&#125;</span><br><span class="line">&#123; "price" : 20, "productID" : "KDKE-B-9947-#kL5" &#125;</span><br><span class="line">&#123; "index": &#123; "_id": 3 &#125;&#125;</span><br><span class="line">&#123; "price" : 30, "productID" : "JODL-X-1937-#pV7" &#125;</span><br><span class="line">&#123; "index": &#123; "_id": 4 &#125;&#125;</span><br><span class="line">&#123; "price" : 30, "productID" : "QQPX-R-3956-#aD8" &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "constant_score" : &#123; </span><br><span class="line">            "filter" : &#123;</span><br><span class="line">                "term" : &#123; </span><br><span class="line">                    "price" : 20</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "constant_score" : &#123;</span><br><span class="line">            "filter" : &#123;</span><br><span class="line">                "term" : &#123;</span><br><span class="line">                    "productID" : "XHDK-A-1293-#fJ3"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_store/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  "field": "productID",</span><br><span class="line">  "text": "XHDK-A-1293-#fJ3"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE /my_store</span><br><span class="line"></span><br><span class="line">PUT /my_store </span><br><span class="line">&#123;</span><br><span class="line">    "mappings" : &#123;</span><br><span class="line">        "products" : &#123;</span><br><span class="line">            "properties" : &#123;</span><br><span class="line">                "productID" : &#123;</span><br><span class="line">                    "type" : "string",</span><br><span class="line">                    "index" : "not_analyzed" </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">   "query" : &#123;</span><br><span class="line">      "filtered" : &#123; </span><br><span class="line">         "filter" : &#123;</span><br><span class="line">            "bool" : &#123;</span><br><span class="line">              "should" : [</span><br><span class="line">                 &#123; "term" : &#123;"price" : 20&#125;&#125;, </span><br><span class="line">                 &#123; "term" : &#123;"productID" : "XHDK-A-1293-#fJ3"&#125;&#125; </span><br><span class="line">              ],</span><br><span class="line">              "must_not" : &#123;</span><br><span class="line">                 "term" : &#123;"price" : 30&#125; </span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "constant_score" : &#123;</span><br><span class="line">            "filter" : &#123;</span><br><span class="line">                "terms" : &#123; </span><br><span class="line">                    "price" : [20, 30]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "constant_score" : &#123;</span><br><span class="line">            "filter" : &#123;</span><br><span class="line">                "range" : &#123;</span><br><span class="line">                    "price" : &#123;</span><br><span class="line">                        "gte" : 20,</span><br><span class="line">                        "lt"  : 40</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST /my_index/posts/_bulk</span><br><span class="line">&#123; "index": &#123; "_id": "1"              &#125;&#125;</span><br><span class="line">&#123; "tags" : ["search"]                &#125;  </span><br><span class="line">&#123; "index": &#123; "_id": "2"              &#125;&#125;</span><br><span class="line">&#123; "tags" : ["search", "open_source"] &#125;  </span><br><span class="line">&#123; "index": &#123; "_id": "3"              &#125;&#125;</span><br><span class="line">&#123; "other_field" : "some data"        &#125;  </span><br><span class="line">&#123; "index": &#123; "_id": "4"              &#125;&#125;</span><br><span class="line">&#123; "tags" : null                      &#125;  </span><br><span class="line">&#123; "index": &#123; "_id": "5"              &#125;&#125;</span><br><span class="line">&#123; "tags" : ["search", null]          &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /my_index/posts/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "constant_score" : &#123;</span><br><span class="line">            "filter" : &#123;</span><br><span class="line">                "exists" : &#123; "field" : "tags" &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /my_index/posts/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "constant_score" : &#123;</span><br><span class="line">            "filter": &#123;</span><br><span class="line">                "missing" : &#123; "field" : "tags" &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST /cars/transactions/_bulk</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" &#125;</span><br><span class="line">&#123; "index": &#123;&#125;&#125;</span><br><span class="line">&#123; "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    "size" : 0,</span><br><span class="line">    "aggs" : &#123; </span><br><span class="line">        "popular_colors111" : &#123; </span><br><span class="line">            "terms" : &#123; </span><br><span class="line">              "field" : "color.keyword"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   "size" : 0,</span><br><span class="line">   "aggs": &#123;</span><br><span class="line">      "colors": &#123;</span><br><span class="line">         "terms": &#123;</span><br><span class="line">            "field": "color.keyword"</span><br><span class="line">         &#125;,</span><br><span class="line">         "aggs": &#123; </span><br><span class="line">            "avg_price": &#123; </span><br><span class="line">               "avg": &#123;</span><br><span class="line">                  "field": "price" </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   "size" : 0,</span><br><span class="line">   "aggs": &#123;</span><br><span class="line">      "colors": &#123;</span><br><span class="line">         "terms": &#123;</span><br><span class="line">            "field": "color.keyword"</span><br><span class="line">         &#125;,</span><br><span class="line">         "aggs": &#123;</span><br><span class="line">            "avg_price": &#123; </span><br><span class="line">               "avg": &#123;</span><br><span class="line">                  "field": "price"</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "make": &#123; </span><br><span class="line">                "terms": &#123;</span><br><span class="line">                    "field": "make.keyword" </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   "size" : 0,</span><br><span class="line">   "aggs": &#123;</span><br><span class="line">      "colors": &#123;</span><br><span class="line">         "terms": &#123;</span><br><span class="line">            "field": "color.keyword"</span><br><span class="line">         &#125;,</span><br><span class="line">         "aggs": &#123;</span><br><span class="line">            "avg_price": &#123; "avg": &#123; "field": "price" &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "make" : &#123;</span><br><span class="line">                "terms" : &#123;</span><br><span class="line">                    "field" : "make.keyword"</span><br><span class="line">                &#125;,</span><br><span class="line">                "aggs" : &#123; </span><br><span class="line">                    "min_price" : &#123; "min": &#123; "field": "price"&#125; &#125;, </span><br><span class="line">                    "max_price" : &#123; "max": &#123; "field": "price"&#125; &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   "size" : 0,</span><br><span class="line">   "aggs":&#123;</span><br><span class="line">      "price":&#123;</span><br><span class="line">         "histogram":&#123; </span><br><span class="line">            "field": "price",</span><br><span class="line">            "interval": 20000</span><br><span class="line">         &#125;,</span><br><span class="line">         "aggs":&#123;</span><br><span class="line">            "revenue": &#123;</span><br><span class="line">               "sum": &#123; </span><br><span class="line">                 "field" : "price"</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  "size" : 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "makes": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "make.keyword",</span><br><span class="line">        "size": 10</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "stats": &#123;</span><br><span class="line">          "extended_stats": &#123;</span><br><span class="line">            "field": "price"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   "size" : 0,</span><br><span class="line">   "aggs": &#123;</span><br><span class="line">      "sales": &#123;</span><br><span class="line">         "date_histogram": &#123;</span><br><span class="line">            "field": "sold",</span><br><span class="line">            "interval": "month",</span><br><span class="line">            "format": "yyyy-MM-dd",</span><br><span class="line">            "min_doc_count" : 0, </span><br><span class="line">            "extended_bounds" : &#123; </span><br><span class="line">                "min" : "2014-01-01",</span><br><span class="line">                "max" : "2014-12-31"</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   "size" : 0,</span><br><span class="line">   "aggs": &#123;</span><br><span class="line">      "sales": &#123;</span><br><span class="line">         "date_histogram": &#123;</span><br><span class="line">            "field": "sold",</span><br><span class="line">            "interval": "quarter", </span><br><span class="line">            "format": "yyyy-MM-dd",</span><br><span class="line">            "min_doc_count" : 0,</span><br><span class="line">            "extended_bounds" : &#123;</span><br><span class="line">                "min" : "2014-01-01",</span><br><span class="line">                "max" : "2014-12-31"</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         "aggs": &#123;</span><br><span class="line">            "per_make_sum": &#123;</span><br><span class="line">               "terms": &#123;</span><br><span class="line">                  "field": "make.keyword"</span><br><span class="line">               &#125;,</span><br><span class="line">               "aggs": &#123;</span><br><span class="line">                  "sum_price": &#123;</span><br><span class="line">                     "sum": &#123; "field": "price" &#125; </span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            "total_sum": &#123;</span><br><span class="line">               "sum": &#123; "field": "price" &#125; </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match" : &#123;</span><br><span class="line">            "make" : "ford"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "aggs" : &#123;</span><br><span class="line">        "colors" : &#123;</span><br><span class="line">            "terms" : &#123;</span><br><span class="line">              "field" : "color.keyword"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    "size" : 0,</span><br><span class="line">    "query" : &#123;</span><br><span class="line">        "match" : &#123;</span><br><span class="line">            "make" : "ford"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "aggs" : &#123;</span><br><span class="line">        "single_avg_price": &#123;</span><br><span class="line">            "avg" : &#123; "field" : "price" &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        "all": &#123;</span><br><span class="line">            "global" : &#123;&#125;, </span><br><span class="line">            "aggs" : &#123;</span><br><span class="line">                "avg_price": &#123;</span><br><span class="line">                    "avg" : &#123; "field" : "price" &#125; </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="布尔过滤器"><a href="#布尔过滤器" class="headerlink" title="布尔过滤器"></a>布尔过滤器</h5><p>一个 <code>bool</code> 过滤器由三部分组成：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"bool"</span> : &#123;</span><br><span class="line">      <span class="attr">"must"</span> :     [],</span><br><span class="line">      <span class="attr">"should"</span> :   [],</span><br><span class="line">      <span class="attr">"must_not"</span> : [],</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>must</code></strong></p>
<p>所有的语句都 <em>必须（must）</em> 匹配，与 <code>AND</code> 等价。</p>
</li>
<li><p><strong><code>must_not</code></strong></p>
<p>所有的语句都 <em>不能（must not）</em> 匹配，与 <code>NOT</code> 等价。</p>
</li>
<li><p><strong><code>should</code></strong></p>
<p>至少有一个语句要匹配，与 <code>OR</code> 等价。</p>
</li>
</ul>
<p>就这么简单！ 当我们需要多个过滤器时，只须将它们置入 <code>bool</code> 过滤器的不同部分即可。</p>
<h4 id="几个核心概念"><a href="#几个核心概念" class="headerlink" title="几个核心概念"></a>几个核心概念</h4><ul>
<li>集群（Cluster）一组拥有共同的 cluster name 的节点。</li>
<li>节点（Node) 集群中的一个 Elasticearch 实例。</li>
<li>索引（Index) 相当于关系数据库中的database概念，一个集群中可以包含多个索引。这个是个逻辑概念。</li>
<li>主分片（Primary shard） 索引的子集，索引可以切分成多个分片，分布到不同的集群节点上。分片对应的是 Lucene 中的索引。</li>
<li>副本分片（Replica shard）每个主分片可以有一个或者多个副本。</li>
<li>类型（Type）相当于数据库中的table概念，mapping是针对 Type 的。同一个索引里可以包含多个 Type。</li>
<li>Mapping 相当于数据库中的schema，用来约束字段的类型，不过 Elasticsearch 的 mapping 可以自动根据数据创建。</li>
<li>文档（Document) 相当于数据库中的row。</li>
<li>字段（Field）相当于数据库中的column。</li>
<li>分配（Allocation） 将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。</li>
<li>gateway: 代表es索引快照的存储方式，es默认是先把索引存放到内存中，当内存满了时再持久化到本地硬盘。gateway对索引快照进行存储，当这个es集群关闭再重新启动时就会从gateway中读取索引备份数据。es支持多种类型的gateway，有本地文件系统（默认），分布式文件系统，Hadoop的HDFS和amazon的s3云存储服务。</li>
</ul>
<h4 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h4><p>传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。Elasticsearch和Lucene使用倒排索引(inverted index)来达到相同目的，倒排索引中用到的数据结构是FST树。</p>
<h4 id="它的优点"><a href="#它的优点" class="headerlink" title="它的优点"></a>它的优点</h4><ul>
<li><p>Elasticsearch主要优势是：速度快，使用方便，分布式的，检索，功能强大。</p>
</li>
<li><p>ES官方的想做的是ELK结合起来做日志分析等工作。估计这也是它最多的应用场景。</p>
</li>
<li><p>Elasticsearch 现在的主要目标市场已经从站内搜索转移到了监控与日志数据的收集存储和分析，也就是大家常谈论的ELK。</p>
</li>
<li><p>Elasticsearch 现在主要的应用场景有三块。站内搜索，主要和 Solr 竞争，属于后起之秀。NoSQL json文档数据库，主要抢占 Mongo 的市场，它在读写性能上优于 Mongo，同时也支持地理位置查询，还方便地理位置和文本混合查询，属于歪打正着。监控，统计以及日志类时间序的数据的存储和分析以及可视化，这方面是引领者。</p>
</li>
</ul>
<h4 id="如何实现Master选举的？"><a href="#如何实现Master选举的？" class="headerlink" title="如何实现Master选举的？"></a>如何实现Master选举的？</h4><p>Elasticsearch的选举是ZenDiscovery模块负责的，通过多播或单播技术来发现同一个集群中的其他节点并与它们连接。</p>
<p>一个节点如何选取它自己认为的master节点？</p>
<p>它会对所有可以成为master的节点（node.master: true）根据nodeId字典排序，，然后选出第一个（第0位）节点，暂且认为它是master节点。</p>
<p>如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。</p>
<p>集群分片的读写操作流程</p>
<h4 id="集群分片的读写操作流程"><a href="#集群分片的读写操作流程" class="headerlink" title="集群分片的读写操作流程"></a>集群分片的读写操作流程</h4><p>第一：路由计算(routing)和副本一致性（replica）</p>
<ul>
<li>routing</li>
</ul>
<p>Elasticsearch针对路由计算选择了一个很简单的方法，计算如下：</p>
<p>routing = hash(routing) % number_of_primary_shards</p>
<p>每个数据都有一个routing参数，默认情况下，就使用其_id值，将其_id值计算hash后，对索引的主分片数取余，就是数据实际应该存储到的分片ID</p>
<p>由于取余这个计算，完全依赖于分母，所以导致Elasticsearch索引有一个限制，索引的主分片数，不可以随意修改。因为一旦主分片数不一样，索引数据不可读。</p>
<ul>
<li>副本一致性(replica)</li>
</ul>
<p>作为分布式系统，数据副本可算是一个标配。Elasticsearch数据写入流程。自然涉及副本，在有副本配置的情况下，数据从发向Elasticsearch节点，到接到Elasticsearch节点响应返回，流向如下</p>
<ul>
<li><p>客户端请求发送给master Node1节点，这里也可以发送给其他节点</p>
</li>
<li><p>Node1节点用数据的_id计算出数据应该存储在shard0上，通过cluster state信息发现shard0的主分片在Node3节点上，Node1转发请求数据给Node3,Node3完成数据的索引，索引过程在上篇博客中详细介绍了。</p>
</li>
<li><p>Node3并行转发数据给分配有shard0的副本分片Node1和Node2上。当收到任一节点汇报副本分片数据写入成功以后，Node3即返回给初始的接受节点Node1，宣布数据写入成功。Node1成功返回给客户端。</p>
</li>
</ul>
<p>第二：shard的allocate配置</p>
<p>上文介绍了分片的索引过程，通过路由计算可以确定文本所在的分片id，那么分片在集群中的分配策略是如何确定的？</p>
<p>一般来说，某个shard分配在哪个节点上，是由Elasticsearch自动决定的。以下几种情况会触发分配动作：</p>
<ul>
<li>新索引生成</li>
<li>索引的删除</li>
<li>新增副本分片</li>
<li>节点增减引发的数据均衡</li>
</ul>
<h4 id="如何集成Bboss-Echart？"><a href="#如何集成Bboss-Echart？" class="headerlink" title="如何集成Bboss+Echart？"></a>如何集成Bboss+Echart？</h4><p>如何更高效的集成一些已经成型的开源框架呢？推荐一个比较好用的es+spring的框架，而且是基于Restful方式的，支持像mybatis的写法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ES start --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bbossgroups.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bboss-elasticsearch-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- ES end --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 让你轻松的搞定ECharts各种域对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.abel533<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ECharts<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>后面专门来用一篇描述对于<code>bboss-elasticsearch-spring-boot-starter</code>的集成以及改造。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ElasticSearch 配置</span></span><br><span class="line"><span class="meta">spring.elasticsearch.bboss.elasticsearch.rest.hostNames</span>=<span class="string">elasticsearch-test.za.net:9200</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pieLoanSuccessAndGroupByProduct"</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">        &#123;</span><br><span class="line">          "query": &#123;</span><br><span class="line">            "bool": &#123;</span><br><span class="line">              "filter": &#123;</span><br><span class="line">                "range": &#123;</span><br><span class="line">                  "gmt_created": &#123;</span><br><span class="line">                    "include_lower": true,</span><br><span class="line">                    "include_upper": true,</span><br><span class="line">                    "from": #[from],</span><br><span class="line">                    "to": #[to]</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              "must": &#123;</span><br><span class="line">                "match": &#123;</span><br><span class="line">                  "status": 5</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          "size": 0,</span><br><span class="line">          "aggs": &#123;</span><br><span class="line">            "list": &#123;</span><br><span class="line">              "terms": &#123;</span><br><span class="line">                "field": "product_code"</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSearchAgg</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String mappath = <span class="string">"esmapper/LoanApply.xml"</span>;</span><br><span class="line">    <span class="comment">//创建加载配置文件的客户端工具，用来检索文档，单实例多线程安全</span></span><br><span class="line">    ClientInterface clientInterface = bbossESStarter.getConfigRestClient(mappath);</span><br><span class="line">    Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    params.put(<span class="string">"from"</span>, <span class="string">"2017-01-14 12:14:09"</span>);</span><br><span class="line">    params.put(<span class="string">"to"</span>, <span class="string">"2018-05-14 12:14:09"</span>);</span><br><span class="line">    String path = index + <span class="string">"/"</span> + type + <span class="string">"/_search"</span>;</span><br><span class="line">    ESAggDatas&lt;LongAggHit&gt; response = clientInterface.searchAgg(path,</span><br><span class="line">            <span class="string">"pieLoanSuccessAndGroupByProduct"</span>,</span><br><span class="line">            params,</span><br><span class="line">            LongAggHit<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">            "list");</span><br><span class="line">    log.info(<span class="string">"response=&#123;&#125;"</span>, JSONUtils.toFormatJsonString(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是一个简单的例子，后面可以专门为这个开源项目做一个详细的介绍，不过人家的文档写的也是非常的Nice的。<a href="https://esdoc.bbossgroups.com/#/quickstart" target="_blank" rel="noopener">https://esdoc.bbossgroups.com/#/quickstart</a> </p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://zhuanlan.zhihu.com/p/33671444" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33671444</a></li>
<li><a href="https://yq.aliyun.com/articles/581877" target="_blank" rel="noopener">https://yq.aliyun.com/articles/581877</a></li>
<li><a href="https://www.cnblogs.com/LBSer/p/4119841.html" target="_blank" rel="noopener">https://www.cnblogs.com/LBSer/p/4119841.html</a></li>
<li><a href="https://my.oschina.net/u/2935389/blog/754674" target="_blank" rel="noopener">https://my.oschina.net/u/2935389/blog/754674</a></li>
<li><a href="https://blog.csdn.net/yangwenbo214/article/details/77802331" target="_blank" rel="noopener">https://blog.csdn.net/yangwenbo214/article/details/77802331</a></li>
<li><a href="https://www.jianshu.com/p/2cac077e05cf" target="_blank" rel="noopener">https://www.jianshu.com/p/2cac077e05cf</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>请别再问Spring Bean的生命周期了</title>
    <url>/2020/05/04/2020/05/%E8%AF%B7%E5%88%AB%E5%86%8D%E9%97%AESpring%20Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86/</url>
    <content><![CDATA[<p>我们用<code>Spring</code>就是因为它能帮我们很好的管理<code>Bean</code>，如果我们能充分的理解<code>Bean</code>的生命周期，就能在想要的环节去做想做的事情。</p>
<h4 id="周期只有四个！"><a href="#周期只有四个！" class="headerlink" title="周期只有四个！"></a>周期只有四个！</h4><p>是的，<code>Spring Bean</code>的生命周期只有这四个阶段。把这四个阶段和每个阶段对应的扩展点糅合在一起虽然没有问题，但是这样非常凌乱，难以记忆。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段。在这四步之间穿插的各种扩展点，稍后会讲。</p>
<ul>
<li><ol>
<li>实例化 <code>Instantiation</code></li>
</ol>
</li>
<li><ol start="2">
<li>属性赋值 <code>Populate</code></li>
</ol>
</li>
<li><ol start="3">
<li>初始化 <code>Initialization</code></li>
</ol>
</li>
<li><ol start="4">
<li>销毁 <code>Destruction</code></li>
</ol>
</li>
</ul>
<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<p>主要逻辑都在<code>doCreate()</code>方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。</p>
<ul>
<li><ol>
<li><code>createBeanInstance()</code> -&gt; 实例化</li>
</ol>
</li>
<li><ol start="2">
<li><code>populateBean()</code> -&gt; 属性赋值</li>
</ol>
</li>
<li><ol start="3">
<li><code>initializeBean()</code> -&gt; 初始化</li>
</ol>
</li>
</ul>
<p>源码如下，能证明实例化，属性赋值和初始化这三个生命周期的存在。关于本文的<code>Spring</code>源码都将忽略无关部分，便于理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略了无关代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 实例化阶段！</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 属性赋值阶段！</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">       <span class="comment">// 初始化阶段！</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于销毁，是在容器关闭时调用的，详见<code>ConfigurableApplicationContext#close()</code></p>
<h4 id="常用扩展点"><a href="#常用扩展点" class="headerlink" title="常用扩展点"></a>常用扩展点</h4><p><code>Spring</code>生命周期相关的常用扩展点非常多，所以问题不是不知道，而是记不住或者记不牢。其实记不住的根本原因还是不够了解，这里通过源码+分类的方式帮大家记忆。</p>
<h5 id="第一大类：影响多个Bean的接口"><a href="#第一大类：影响多个Bean的接口" class="headerlink" title="第一大类：影响多个Bean的接口"></a>第一大类：影响多个Bean的接口</h5><p>实现了这些接口的<code>Bean</code>会切入到多个<code>Bean</code>的生命周期中。正因为如此，这些接口的功能非常强大，<code>Spring</code>内部扩展也经常使用这些接口，例如自动注入以及<code>AOP</code>的实现都和他们有关。</p>
<ul>
<li><code>BeanPostProcessor</code></li>
<li><code>InstantiationAwareBeanPostProcessor</code></li>
</ul>
<p>这两兄弟可能是<code>Spring</code>扩展中<strong>最重要</strong>的两个接口！<code>InstantiationAwareBeanPostProcessor</code>作用于<strong>实例化</strong>阶段的前后，<code>BeanPostProcessor</code>作用于<strong>初始化</strong>阶段的前后。正好和第一、第三个生命周期阶段对应。通过图能更好理解：</p>
<p><img src="http://static.cyblogs.com/SpringBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="http://static.cyblogs.com/SpringBean的生命周期.jpg"></p>
<p><code>InstantiationAwareBeanPostProcessor</code>实际上继承了<code>BeanPostProcessor</code>接口，严格意义上来看他们不是两兄弟，而是两父子。但是从生命周期角度我们重点关注其特有的对实例化阶段的影响，图中省略了从<code>BeanPostProcessor</code>继承的方法。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">InstantiationAwareBeanPostProcessor extends BeanPostProcessor</span><br></pre></td></tr></table></figure>

<h6 id="InstantiationAwareBeanPostProcessor源码分析："><a href="#InstantiationAwareBeanPostProcessor源码分析：" class="headerlink" title="InstantiationAwareBeanPostProcessor源码分析："></a>InstantiationAwareBeanPostProcessor源码分析：</h6><ul>
<li><code>postProcessBeforeInstantiation</code>调用点，忽略无关代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        <span class="comment">// postProcessBeforeInstantiation方法调用点，这里就不跟进了，</span></span><br><span class="line">        <span class="comment">// 有兴趣的同学可以自己看下，就是for循环调用所有的InstantiationAwareBeanPostProcessor</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;   </span><br><span class="line">        <span class="comment">// 上文提到的doCreateBean方法，可以看到</span></span><br><span class="line">        <span class="comment">// postProcessBeforeInstantiation方法在创建Bean之前调用</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>postProcessBeforeInstantiation</code>在<code>doCreateBean</code>之前调用，也就是在<code>bean</code>实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的<code>Bean</code>作为代理，这也是<code>Aop</code>等功能实现的关键点。</p>
<ul>
<li><code>postProcessAfterInstantiation</code>调用点，忽略无关代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">   <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">   <span class="comment">// to support styles of field injection.</span></span><br><span class="line">   <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation()</span></span><br><span class="line">    <span class="comment">// 方法作为属性赋值的前置检查条件，在属性赋值之前执行，能够影响是否进行属性赋值！</span></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 忽略后续的属性赋值操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法在属性赋值方法内，但是在真正执行赋值操作之前。其返回值为<code>boolean</code>，返回<code>false</code>时可以阻断属性赋值阶段（<code>continueWithPropertyPopulation = false;</code>）。</p>
<p>关于<code>BeanPostProcessor</code>执行阶段的源码穿插在下文<code>Aware</code>接口的调用时机分析中，因为部分Aware功能的就是通过他实现的!只需要先记住<code>BeanPostProcessor</code>在初始化前后调用就可以了。</p>
<h5 id="第二大类：只调用一次的接口"><a href="#第二大类：只调用一次的接口" class="headerlink" title="第二大类：只调用一次的接口"></a>第二大类：只调用一次的接口</h5><p>这一大类接口的特点是功能丰富，常用于用户自定义扩展。<br> 第二大类中又可以分为两类：</p>
<ol>
<li><code>Aware</code>类型的接口</li>
<li>生命周期接口</li>
</ol>
<h6 id="无所不知的Aware"><a href="#无所不知的Aware" class="headerlink" title="无所不知的Aware"></a>无所不知的Aware</h6><p><code>Aware</code>类型的接口的作用就是让我们能够拿到<code>Spring</code>容器中的一些资源。基本都能够见名知意，<code>Aware</code>之前的名字就是可以拿到什么资源，例如<code>BeanNameAware</code>可以拿到<code>BeanName</code>，以此类推。调用时机需要注意：所有的<code>Aware</code>方法都是在初始化阶段之前调用的！<br> <code>Aware</code>接口众多，这里同样通过分类的方式帮助大家记忆。<br> <code>Aware</code>接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是<code>Aware</code>接口的执行顺序，能够见名知意的接口不再解释。</p>
<p><strong>Aware Group1</strong></p>
<ol>
<li><code>BeanNameAware</code></li>
<li><code>BeanClassLoaderAware</code></li>
<li><code>BeanFactoryAware</code></li>
</ol>
<p><strong>Aware Group2</strong></p>
<ol>
<li><code>EnvironmentAware</code></li>
<li><code>EmbeddedValueResolverAware</code> 这个知道的人可能不多，实现该接口能够获取<code>Spring EL</code>解析器，用户的自定义注解需要支持<code>spel</code>表达式的时候可以使用，非常方便。</li>
<li><code>ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)</code> 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的<code>ApplicationContext</code>对象，因为<code>ApplicationContext</code>是一个复合接口，如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到另一道面试题，<code>ApplicationContext</code>和<code>BeanFactory</code>的区别，可以从<code>ApplicationContext</code>继承的这几个接口入手，除去<code>BeanFactory</code>相关的两个接口就是<code>ApplicationContext</code>独有的功能，这里不详细说明。</p>
<h6 id="Aware调用时机源码分析"><a href="#Aware调用时机源码分析" class="headerlink" title="Aware调用时机源码分析"></a>Aware调用时机源码分析</h6><p>详情如下，忽略了部分无关代码。代码位置就是我们上文提到的initializeBean方法详情，这也说明了Aware都是在初始化阶段之前调用的！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 见名知意，初始化阶段调用的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里调用的是Group1中的三个Bean开头的Aware</span></span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里调用的是Group2中的几个Aware，</span></span><br><span class="line">    <span class="comment">// 而实质上这里就是前面所说的BeanPostProcessor的调用点！</span></span><br><span class="line">    <span class="comment">// 也就是说与Group1中的Aware不同，这里是通过BeanPostProcessor（ApplicationContextAwareProcessor）实现的。</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">// 下文即将介绍的InitializingBean调用点</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    <span class="comment">// BeanPostProcessor的另一个调用点</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到并不是所有的<code>Aware</code>接口都使用同样的方式调用。<code>Bean××Aware</code>都是在代码中直接调用的，而<code>ApplicationContext</code>相关的<code>Aware</code>都是通过<code>BeanPostProcessor#postProcessBeforeInitialization()</code>实现的。感兴趣的可以自己看一下<code>ApplicationContextAwareProcessor</code>这个类的源码，就是判断当前创建的<code>Bean</code>是否实现了相关的<code>Aware</code>方法，如果实现了会调用回调方法将资源传递给<code>Bean</code>。<br> 至于<code>Spring</code>为什么这么实现，应该没什么特殊的考量。也许和<code>Spring</code>的版本升级有关。基于对修改关闭，对扩展开放的原则，<code>Spring</code>对一些新的<code>Aware</code>采用了扩展的方式添加。</p>
<p><code>BeanPostProcessor</code>的调用时机也能在这里体现，包围住<code>invokeInitMethods</code>方法，也就说明了在初始化阶段的前后执行。</p>
<p>关于<code>Aware</code>接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了。每组中各个<code>Aware</code>方法的调用顺序其实没有必要记，有需要的时候点进源码一看便知。</p>
<h6 id="简单的两个生命周期接口"><a href="#简单的两个生命周期接口" class="headerlink" title="简单的两个生命周期接口"></a>简单的两个生命周期接口</h6><p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是<code>Spring</code>帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p>
<ol>
<li><code>InitializingBean</code> 对应生命周期的初始化阶段，在上面源码的<code>invokeInitMethods(beanName, wrappedBean, mbd);</code>方法中调用。<br> 有一点需要注意，因为<code>Aware</code>方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用<code>Aware</code>接口获取的资源，这也是我们自定义扩展<code>Spring</code>的常用方式。<br> 除了实现<code>InitializingBean</code>接口之外还能通过注解或者xml配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</li>
<li><code>DisposableBean</code> 类似于<code>InitializingBean</code>，对应生命周期的销毁阶段，以<code>ConfigurableApplicationContext#close()</code>方法作为入口，实现是通过循环取所有实现了<code>DisposableBean</code>接口的<code>Bean</code>然后调用其<code>destroy()</code>方法 。感兴趣的可以自行跟一下源码。</li>
</ol>
<h4 id="扩展阅读-BeanPostProcessor-注册时机与执行顺序"><a href="#扩展阅读-BeanPostProcessor-注册时机与执行顺序" class="headerlink" title="扩展阅读: BeanPostProcessor 注册时机与执行顺序"></a>扩展阅读: BeanPostProcessor 注册时机与执行顺序</h4><p><code>Spring</code>所做的事情就是把各种方式定义的<code>Java</code>类变成它的<code>BeanDefinition</code>，然后通过<code>Bean工厂</code>变成<code>Bean</code>放入到它的各种容器中，这样子就被<code>Spring</code>所管理了。</p>
<p><img src="http://static.cyblogs.com/Spring%20Bean%E5%AE%9A%E4%B9%89.jpg" alt="http://static.cyblogs.com/Spring%20Bean定义.jpg"></p>
<h5 id="注册时机"><a href="#注册时机" class="headerlink" title="注册时机"></a>注册时机</h5><p>我们知道<code>BeanPostProcessor</code>也会注册为<code>Bean</code>，那么<code>Spring</code>是如何保证<code>BeanPostProcessor</code>在我们的业务Bean之前初始化完成呢？<br> 请看我们熟悉的refresh()方法的源码，省略部分无关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 所有BeanPostProcesser初始化的调用点</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 所有单例非懒加载Bean的调用点</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>Spring</code>是先执行<code>registerBeanPostProcessors()</code>进行<code>BeanPostProcessors</code>的注册，然后再执行<code>finishBeanFactoryInitialization</code>初始化我们的单例非懒加载的<code>Bean</code>。</p>
<h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p><code>BeanPostProcessor</code>有很多个，而且每个<code>BeanPostProcessor</code>都影响多个<code>Bean</code>，其执行顺序至关重要，必须能够控制其执行顺序才行。关于执行顺序这里需要引入两个排序相关的接口：<code>PriorityOrdered、Ordered</code></p>
<ul>
<li><code>PriorityOrdered</code>是一等公民，首先被执行，<code>PriorityOrdered</code>公民之间通过接口返回值排序</li>
<li><code>Ordered</code>是二等公民，然后执行，<code>Ordered</code>公民之间通过接口返回值排序</li>
<li>都没有实现是三等公民，最后执行</li>
</ul>
<p>在以下源码中，可以很清晰的看到<code>Spring</code>注册各种类型<code>BeanPostProcessor</code>的逻辑，根据实现不同排序接口进行分组。优先级高的先加入，优先级低的后加入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">// 首先，加入实现了PriorityOrdered接口的BeanPostProcessors，顺便根据PriorityOrdered排了序</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">// 然后，加入实现了Ordered接口的BeanPostProcessors，顺便根据Ordered排了序</span></span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line"><span class="comment">// 最后加入其他常规的BeanPostProcessors</span></span><br><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">    reiterate = <span class="keyword">false</span>;</span><br><span class="line">    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">            reiterate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据排序接口返回值排序，默认升序排序，返回值越低优先级越高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Useful constant for the highest precedence value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer#MIN_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> HIGHEST_PRECEDENCE = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Useful constant for the lowest precedence value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.lang.Integer#MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> LOWEST_PRECEDENCE = Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure>

<p><code>PriorityOrdered</code>、<code>Ordered</code>接口作为<code>Spring</code>整个框架通用的排序接口，在<code>Spring</code>中应用广泛，也是非常重要的接口。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>Spring Bean</code>的生命周期分为<code>四个阶段</code>和<code>多个扩展点</code>。扩展点又可以分为<code>影响多个Bean</code>和<code>影响单个Bean</code>。整理如下：<br> 四个阶段</p>
<ul>
<li>实例化 <code>Instantiation</code></li>
<li>属性赋值 <code>Populate</code></li>
<li>初始化 <code>Initialization</code></li>
<li>销毁 <code>Destruction</code></li>
</ul>
<p>多个扩展点</p>
<ul>
<li>影响多个<code>Bean</code><ul>
<li><code>BeanPostProcessor</code></li>
<li><code>InstantiationAwareBeanPostProcessor</code></li>
</ul>
</li>
<li>影响单个<code>Bean</code><ul>
<li>Aware<ul>
<li>Aware Group1<ul>
<li>BeanNameAware</li>
<li>BeanClassLoaderAware</li>
<li>BeanFactoryAware</li>
</ul>
</li>
<li>Aware Group2<ul>
<li>EnvironmentAware</li>
<li>EmbeddedValueResolverAware</li>
<li>ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)</li>
</ul>
</li>
</ul>
</li>
<li>生命周期<ul>
<li>InitializingBean</li>
<li>DisposableBean</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>至此，<code>Spring Bean</code>的生命周期介绍完毕，由于作者水平有限难免有疏漏，欢迎留言纠错。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.jianshu.com/p/1dec08d290c1" target="_blank" rel="noopener">https://www.jianshu.com/p/1dec08d290c1</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>3种web会话管理的方式</title>
    <url>/2020/06/07/2020/06/3%E7%A7%8Dweb%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><code>http</code> 是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道 <code>http</code> 请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。本文总结了 3 种常见的实现 <code>web</code> 应用会话管理的方式：</p>
<p>1）基于 <code>server</code> 端 <code>session</code> 的管理方式</p>
<p>2）<code>cookie-base</code> 的管理方式</p>
<p>3）<code>token-base</code> 的管理方式</p>
<p>这些内容可以帮助加深对 <code>web</code> 中用户登录机制的理解，对实际项目开发也有参考价值，欢迎阅读与指正。</p>
<h4 id="1-基于-server-端-session-的管理"><a href="#1-基于-server-端-session-的管理" class="headerlink" title="1. 基于 server 端 session 的管理"></a>1. 基于 server 端 session 的管理</h4><p>在早期 <code>web</code> 应用中，通常使用服务端 <code>session</code> 来管理用户的会话。快速了解服务端 <code>session</code>:</p>
<p>1) 服务端 <code>session</code> 是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个 <code>session</code> 都分配一个唯一的 <code>sessionid</code>，以保证每个用户都有一个不同的 <code>session</code> 对象。</p>
<p>2）服务器在创建完 <code>session</code> 后，会把 <code>sessionid</code> 通过 <code>cookie</code> 返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过 <code>cookie</code> 把 <code>sessionid</code> 传回给服务器，以便服务器能够根据 <code>sessionid</code> 找到与该用户对应的 <code>session</code> 对象。</p>
<p>3）<code>session</code> 通常有失效时间的设定，比如 2 个小时。当失效时间到，服务器会销毁之前的 <code>session</code>，并创建新的 <code>session</code> 返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的 <code>session</code> 的失效时间根据当前的请求时间再延长 2 个小时。</p>
<p>4）<code>session</code> 在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往 <code>sesssion</code> 对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的 <code>session</code> 对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的 <code>session</code> 对象里的登录凭证清掉。所以在用户登录前或退出后或者 <code>session</code> 对象失效时，肯定都是拿不到需要的登录凭证的。</p>
<p>以上过程可简单使用流程图描述如下：</p>
<p><img src="http://static.cyblogs.com/459873-20161115231400951-1095594983.png" alt="http://static.cyblogs.com/459873-20161115231400951-1095594983.png"></p>
<p>主流的 <code>web</code> 开发平台（<code>java</code>,<code>.net</code>,<code>php</code>）都原生支持这种会话管理的方式，而且开发起来很简单，相信大部分后端开发人员在入门的时候都了解并使用过它。它还有一个比较大的优点就是安全性好，因为在浏览器端与服务器端保持会话状态的媒介始终只是一个 <code>sessionid</code> 串，只要这个串够随机，攻击者就不能轻易冒充他人的 <code>sessionid</code> 进行操作；除非通过 <code>CSRF</code> 或 <code>http</code> 劫持的方式，才有可能冒充别人进行操作；即使冒充成功，也必须被冒充的用户 <code>session</code> 里面包含有效的登录凭证才行。但是在真正决定用它管理会话之前，也得根据自己的应用情况考虑以下几个问题：</p>
<p>1）这种方式将会话信息存储在 <code>web</code> 服务器里面，所以在用户同时在线量比较多时，这些会话信息会占据比较多的内存；</p>
<p>2）当应用采用集群部署的时候，会遇到多台 <code>web</code> 服务器之间如何做 <code>session</code> 共享的问题。因为 <code>session</code> 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 <code>session</code> 的服务器，这样他就拿不到之前已经放入到 <code>session</code> 中的登录凭证之类的信息了；</p>
<p>3）多个应用要共享 <code>session</code> 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 <code>cookie</code> 跨域的处理。</p>
<p>针对问题 1 和问题 2，我见过的解决方案是采用 <code>redis</code> 这种中间服务器来管理 <code>session</code> 的增删改查，一来减轻 <code>web</code> 服务器的负担，二来解决不同 web 服务器共享 <code>session</code> 的问题。针对问题 3，由于服务端的 <code>session</code> 依赖 <code>cookie</code> 来传递 <code>sessionid</code>，所以在实际项目中，只要解决各个项目里面如何实现 <code>sessionid</code> 的 <code>cookie</code> 跨域访问即可，这个是可以实现的，就是比较麻烦，前后端有可能都要做处理。</p>
<p>如果不考虑以上三个问题，这种管理方式比较值得使用，尤其是一些小型的 <code>web</code> 应用。但是一旦应用将来有扩展的必要，那就得谨慎对待前面的三个问题。如果真要在项目中使用这种方式，推荐结合单点登录框架如 <code>CAS</code> 一起用，这样会使应用的扩展性更强。</p>
<h4 id="2-cookie-based-的管理方式"><a href="#2-cookie-based-的管理方式" class="headerlink" title="2. cookie-based 的管理方式"></a>2. cookie-based 的管理方式</h4><p>由于前一种方式会增加服务器的负担和架构的复杂性，所以后来就有人想出直接把用户的登录凭证直接存到客户端的方案，当用户登录成功之后，把登录凭证写到 <code>cookie</code> 里面，并给 <code>cookie</code> 设置有效期，后续请求直接验证存有登录凭证的 <code>cookie</code> 是否存在以及凭证是否有效，即可判断用户的登录状态。使用它来实现会话管理的整体流程如下：</p>
<p>1）用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户 id，凭证创建时间和过期时间三个值。</p>
<p>2）服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入 <code>cookie</code>。<code>cookie</code> 的名字必须固定（如 <code>ticket</code>），因为后面再获取的时候，还得根据这个名字来获取 cookie 值。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止 <code>cookie</code> 被别人截取的时候，无法轻易读到其中的用户信息。</p>
<p>3）用户登录后发起后续请求，服务端根据上一步存登录凭证的 <code>cookie</code> 名字，获取到相关的 <code>cookie</code> 值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。</p>
<p><img src="http://static.cyblogs.com/459873-20161120210043123-760641758.png" alt="http://static.cyblogs.com/459873-20161120210043123-760641758.png"></p>
<p>这种方式最大的优点就是实现了服务端的无状态化，彻底移除了服务端对会话的管理的逻辑，服务端只需要负责创建和验证登录 <code>cookie</code> 即可，无需保持用户的状态信息。对于第一种方式的第二个问题，用户会话信息共享的问题，它也能很好解决：因为如果只是同一个应用做集群部署，由于验证登录凭证的代码都是一样的，所以不管是哪个服务器处理用户请求，总能拿到 <code>cookie</code> 中的登录凭证来进行验证；如果是不同的应用，只要每个应用都包含相同的登录逻辑，那么他们也是能轻易实现会话共享的，不过这种情况下，登录逻辑里面数字签名以及加密解密要用到的密钥文件或者密钥串，需要在不同的应用里面共享，总而言之，就是需要算法完全保持一致。</p>
<p>这种方式由于把登录凭证直接存放客户端，并且需要 <code>cookie</code> 传来传去，所以它的缺点也比较明显：</p>
<p>1）<code>cookie</code> 有大小限制，存储不了太多数据，所以要是登录凭证存的消息过多，导致加密签名后的串太长，就会引发别的问题，比如其它业务场景需要 <code>cookie</code> 的时候，就有可能没那么多空间可用了；所以用的时候得谨慎，得观察实际的登录 <code>cookie</code> 的大小；比如太长，就要考虑是非是数字签名的算法太严格，导致签名后的串太长，那就适当调整签名逻辑；比如如果一开始用 <code>4096</code> 位的 <code>RSA</code> 算法做数字签名，可以考虑换成 <code>1024</code>、<code>2048</code> 位；</p>
<p>2）每次传送 <code>cookie</code>，增加了请求的数量，对访问性能也有影响；</p>
<p>3）也有跨域问题，毕竟还是要用 <code>cookie</code>。</p>
<p>相比起第一种方式，<code>cookie-based</code> 方案明显还是要好一些，目前好多 <code>web</code> 开发平台或框架都默认使用这种方式来做会话管理，比如 <code>php</code> 里面 <code>yii</code> 框架，这是我们团队后端目前用的，它用的就是这个方案，以上提到的那些登录逻辑，框架也都已经封装好了，实际用起来也很简单；<code>asp.net</code> 里面 <code>forms</code> 身份认证，也是这个思路，这里有一篇好文章把它的实现细节都说的很清楚：</p>
<p><a href="http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html" target="_blank" rel="noopener">http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html</a></p>
<p>前面两种会话管理方式因为都用到 <code>cookie</code>，不适合用在 <code>native app</code> 里面：<code>native app</code> 不好管理 <code>cookie</code>，毕竟它不是浏览器。这两种方案都不适合用来做纯 <code>api</code> 服务的登录认证。要实现 api 服务的登录认证，就要考虑下面要介绍的第三种会话管理方式。</p>
<h4 id="3-token-based-的管理方式"><a href="#3-token-based-的管理方式" class="headerlink" title="3. token-based 的管理方式"></a>3. token-based 的管理方式</h4><p>这种方式从流程和实现上来说，跟 <code>cookie-based</code> 的方式没有太多区别，只不过 <code>cookie-based</code> 里面写到 <code>cookie</code> 里面的 <code>ticket</code> 在这种方式下称为 <code>token</code>，这个 <code>token</code> 在返回给客户端之后，后续请求都必须通过 <code>url</code> 参数或者是 <code>http header</code> 的形式，主动带上 <code>token</code>，这样服务端接收到请求之后就能直接从 <code>http header</code> 或者 <code>url</code> 里面取到 <code>token</code> 进行验证：</p>
<p><img src="http://static.cyblogs.com/459873-20161120210044154-648255641.png" alt="http://static.cyblogs.com/459873-20161120210044154-648255641.png"></p>
<p>这种方式不通过 <code>cookie</code> 进行 <code>token</code> 的传递，而是每次请求的时候，主动把 <code>token</code> 加到 <code>http header</code> 里面或者 <code>url</code> 后面，所以即使在 <code>native app</code> 里面也能使用它来调用我们通过 <code>web</code> 发布的 <code>api</code> 接口。<code>app</code> 里面还要做两件事情：</p>
<p>1）有效存储 <code>token</code>，得保证每次调接口的时候都能从同一个位置拿到同一个 <code>token</code>；</p>
<p>2）每次调接口的的代码里都得把 <code>token</code> 加到 <code>header</code> 或者接口地址里面。</p>
<p>看起来麻烦，其实也不麻烦，这两件事情，对于 <code>app</code> 来说，很容易做到，只要对接口调用的模块稍加封装即可。</p>
<p>这种方式同样适用于网页应用，<code>token</code> 可以存于 <code>localStorage</code> 或者 <code>sessionStorage</code> 里面，然后每发 <code>ajax</code> 请求的时候，都把 <code>token</code> 拿出来放到 <code>ajax</code> 请求的 <code>header</code> 里即可。不过如果是非接口的请求，比如直接通过点击链接请求一个页面这种，是无法自动带上 <code>token</code> 的。所以这种方式也仅限于走纯接口的 <code>web</code> 应用。</p>
<p>这种方式用在 <code>web</code> 应用里也有跨域的问题，比如应用如果部署在 <code>a.com</code>，<code>api</code> 服务部署在 <code>b.com</code>，从 <code>a.com</code> 里面发出 <code>ajax</code> 请求到 <code>b.com</code>，默认情况下是会报跨域错误的，这种问题可以用 <code>CORS</code>（<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享</a>）的方式来快速解决，相关细节可去阅读前面给出的 <code>CORS</code> 文章详细了解。</p>
<p>这种方式跟 <code>cookie-based</code> 的方式同样都还有的一个问题就是 <code>ticket</code> 或者 <code>token</code> 刷新的问题。有的产品里面，你肯定不希望用户登录后，操作了半个小时，结果 <code>ticket</code> 或者 <code>token</code> 到了过期时间，然后用户又得去重新登录的情况出现。这个时候就得考虑 <code>ticket</code> 或 <code>token</code> 的自动刷新的问题，简单来说，可以在验证 <code>ticket</code> 或 <code>token</code> 有效之后，自动把 <code>ticket</code> 或 <code>token</code> 的失效时间延长，然后把它再返回给客户端；客户端如果检测到服务器有返回新的 <code>ticket</code> 或 <code>token</code>，就替换原来的 <code>ticket</code> 或 <code>token</code>。</p>
<h4 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4. 安全问题"></a>4. 安全问题</h4><p>在 <code>web</code> 应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。</p>
<p>首先从会话管理凭证来说，第一种方式的会话凭证仅仅是一个 <code>session id</code>，所以只要这个 <code>session id</code> 足够随机，而不是一个自增的数字 <code>id</code> 值，那么其它人就不可能轻易地冒充别人的 <code>session id</code> 进行操作；第二种方式的凭证（ticket）以及第三种方式的凭证（<code>token</code>）都是一个在服务端做了数字签名，和加密处理的串，所以只要密钥不泄露，别人也无法轻易地拿到这个串中的有效信息并对它进行篡改。总之，这三种会话管理方式的凭证本身是比较安全的。</p>
<p>然后从客户端和服务端的 <code>http</code> 过程来说，当别人截获到客户端请求中的会话凭证，就能拿这个凭证冒充原用户，做一些非法操作，而服务器也认不出来。这种安全问题，可以简单采用 <code>https</code> 来解决，虽然可能还有 <code>http</code> 劫持这种更高程度的威胁存在，但是我们从代码能做的防范，确实也就是这个层次了。</p>
<p>最后的安全问题就是 <code>CSRF</code>（跨站请求伪造）。这个跟代码有很大关系，本质上它就是代码的漏洞，只不过一般情况下这些漏洞，作为开发人员都不容易发现，只有那些一门心思想搞些事情的人才会专门去找这些漏洞，所以这种问题的防范更多地还是依赖于开发人员对这种攻击方式的了解，包括常见的攻击形式和应对方法。不管凭证信息本身多么安全，别人利用 <code>CSRF</code>，就能拿到别人的凭证，然后用它冒充别人进行非法操作，所以有时间还真得多去了解下它的相关资料才行。举例来说，假如我们把凭证直接放到 url 后面进行传递，就有可能成为一个 <code>CSRF</code> 的漏洞：当恶意用户在我们的应用内上传了 1 张引用了他自己网站的图片，当正常的用户登录之后访问的页面里面包含这个图片的时候，由于这个图片加载的时候会向恶意网站发送 <code>get</code> 请求；当恶意网站收到请求的时候，就会从这个请求的 <code>Reffer header</code> 里面看到包含这个图片的页面地址，而这个地址正好包含了正常用户的会话凭证；于是恶意用户就拿到了正常用户的凭证；只要这个凭证还没失效，他就能用它冒充用户进行非法操作。</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p>前面这三种方式，各自有各自的优点及使用场景，我觉得没有哪个是最好的，做项目的时候，根据项目将来的扩展情况和架构情况，才能决定用哪个是最合适的。本文的目的也就是想介绍这几种方式的原理，以便掌握 web 应用中登录验证的关键因素。</p>
<p>作为一个前端开发人员，本文虽然介绍了 3 种会话管理的方式，但是与前端关系最紧密的还是第三种方式，毕竟现在前端开发 <code>SPA</code> 应用以及 <code>hybrid</code> 应用已经非常流行了，所以掌握好这个方式的认证过程和使用方式，对前端来说，显然是很有帮助的。好在这个方式的技术其实早就有很多实现了，而且还有现成的标准可用，这个标准就是 <code>JWT(json-web-token)</code>。</p>
<p><code>JWT</code> 本身并没有做任何技术实现，它只是定义了 <code>token-based</code> 的管理方式该如何实现，它规定了 <code>token</code> 的应该包含的标准内容以及 <code>token</code> 的生成过程和方法。目前实现了这个标准的技术已经有非常多：</p>
<p><img src="http://static.cyblogs.com/459873-20161120210045904-1163191341.png" alt="http://static.cyblogs.com/459873-20161120210045904-1163191341.png"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.cnblogs.com/lyzg/p/6067766.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyzg/p/6067766.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>会话</tag>
      </tags>
  </entry>
  <entry>
    <title>Java4种引用类型到底如何用？</title>
    <url>/2020/06/05/2020/06/Java4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>在 <code>JDK.1.2</code> 之后，<code>Java</code> 对引用的概念进行了扩充，将引用分为了：</p>
<ul>
<li>强引用<code>（Strong Reference）</code></li>
<li>软引用<code>（Soft Reference）</code></li>
<li>弱引用<code>（Weak Reference）</code></li>
<li>虚引用<code>（Phantom Reference）</code>4 种，这 4 种引用的强度依次减弱。不同的引用在垃圾回收中体现也是不一样~</li>
</ul>
<h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p>我们先创建一个M对象，后面为了方便的感受GC的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:30 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"finalize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>finalize</code>函数是对象在<code>gc</code>的时候，一定会调用该方法。我们重写一下该方法并且打印一行日志。</p>
<h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，<code>JVM</code>也会直接抛出<code>OutOfMemoryError</code>，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为<code>null</code>，这样一来，<code>JVM</code>就可以适时的回收对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 正常引用/强引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C001_01_NormalReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        M m = <span class="keyword">new</span> M();</span><br><span class="line">        <span class="comment">// 将对象复制为空</span></span><br><span class="line">        m = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 手动触发GC</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为不是触发gc就一定会立马gc，所以让线程阻塞一下</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台日志输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:53621', transport: 'socket'</span><br><span class="line">finalize</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:53621', transport: 'socket'</span><br></pre></td></tr></table></figure>

<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 软引用：当内存不足的时候，gc才会回收。非常适合做缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C001_02_SoftReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 开辟一个20M的空间</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; m = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]);</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 手动GC一下，看是否可以GC掉</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 避免gc不会立马触发，尝试休眠1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 然后再尝试获取</span></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 重新开辟一个空间</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">15</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为它是在内存不足的时候才会触发，所以我们在跑之前需要设置一下最大堆。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xmx20M</span><br></pre></td></tr></table></figure>

<p>控制台日志输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:54335', transport: 'socket'</span><br><span class="line">[B@4c3e4790</span><br><span class="line">[B@4c3e4790</span><br><span class="line">null</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:54335', transport: 'socket'</span><br></pre></td></tr></table></figure>

<p>你会发现就算我们<code>gc</code>了，后面还是会<code>get</code>得到，因为空间还足够。当后面<code>byte[] b</code>再继续申请空间的时候，发现空间不足了，这个时候就会触发<code>gc</code>动作，把软引用的部分清除掉。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 弱引用：是为了解决某些地方的内存泄露问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:32 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C001_03_WeakReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakReference&lt;M&gt; m = <span class="keyword">new</span> WeakReference&lt;M&gt;(<span class="keyword">new</span> M());</span><br><span class="line"></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;M&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;M&gt;();</span><br><span class="line">        tl.set(<span class="keyword">new</span> M());</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台日志输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:55151', transport: 'socket'</span><br><span class="line">com.cyblogs.java.learning.C001_ReferenceType.M@38cccef</span><br><span class="line">null</span><br><span class="line">finalize</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:55151', transport: 'socket'</span><br></pre></td></tr></table></figure>

<p>我们看一下<code>ThreadLocal</code>的<code>set</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/QQ20200616-225739@2x.jpg" alt="http://static.cyblogs.com/QQ20200616-225739@2x.jpg"></p>
<p>为什么<code>Entry</code>要使用弱引用？</p>
<ul>
<li><p>若是强引用，即使<code>tl=null</code>，但是<code>key</code>的引用还是指向<code>ThreadLocal</code>。所以内存会泄露~而弱引用不会</p>
</li>
<li><p>但是还会有内存泄露的问题，<code>ThreadLocal</code>被回收。<code>key</code>的值变成了<code>null</code>，则导致<code>value</code>的值再也无法被访问到，因此依然存在内存泄露问题。</p>
</li>
</ul>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 虚引用：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:33 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C001_04_PhantomReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;M&gt; QUEUE = <span class="keyword">new</span> ReferenceQueue&lt;M&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; LIST = <span class="keyword">new</span> LinkedList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PhantomReference&lt;M&gt; m = <span class="keyword">new</span> PhantomReference&lt;M&gt;(<span class="keyword">new</span> M(), QUEUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                LIST.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(m.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Reference&lt;? extends M&gt; poll = QUEUE.poll();</span><br><span class="line">                <span class="keyword">if</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"虚引用对象被JVM回收了"</span> + poll);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在零拷贝中就会使用到虚引用，但我们又无法去操作对外的内存。因为太弱了，我们也无法感知到~ 这里就需要利用到<code>ReferenceQueue</code>。</p>
<p><img src="http://static.cyblogs.com/QQ20200616-222909@2x.jpg" alt="http://static.cyblogs.com/QQ20200616-222909@2x.jpg"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.bilibili.com/video/BV1iK4y1x7tj" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iK4y1x7tj</a></li>
<li><a href="https://www.cnblogs.com/liyutian/p/9690974.html" target="_blank" rel="noopener">https://www.cnblogs.com/liyutian/p/9690974.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean解决循环依赖为什么是三级缓存？</title>
    <url>/2020/06/06/2020/06/Spring%20Bean%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>循环依赖：就是N个类循环(嵌套)引用</strong>。 通俗的讲就是N个Bean互相引用对方，最终形成<code>闭环</code>。用一副经典的图示可以表示成这样（A、B、C都代表对象，虚线代表引用关系）： </p>
<p><img src="http://static.cyblogs.com/mxuio3xfqc.png" alt="http://static.cyblogs.com/mxuio3xfqc.png"></p>
<blockquote>
<p> 注意：其实可以N=1，也就是极限情况的循环依赖：<code>自己依赖自己</code> </p>
<p> 另需注意：这里指的循环引用不是方法之间的循环调用，<strong>而是对象的相互依赖关系</strong>。（方法之间循环调用若有出口也是能够正常work的） </p>
</blockquote>
<p>可以设想一下这个场景：如果在日常开发中我们用new对象的方式，若构造函数之间发生这种<strong>循环依赖</strong>的话，程序会在运行时一直循环调用<strong>最终导致内存溢出</strong>，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>

<p>这是一个典型的循环依赖问题。本文说一下<code>Spring</code>是如果巧妙的解决平时我们会遇到的<code>三大循环依赖问题</code>的~</p>
<h4 id="Spring-Bean的循环依赖"><a href="#Spring-Bean的循环依赖" class="headerlink" title="Spring Bean的循环依赖"></a>Spring Bean的循环依赖</h4><p>谈到<code>Spring Bean</code>的循环依赖，有的小伙伴可能比较陌生，毕竟开发过程中好像对<code>循环依赖</code>这个概念<strong>无感知</strong>。其实不然，你有这种错觉，权是因为你工作在Spring的<code>襁褓</code>中，从而让你“高枕无忧”~ <strong>我十分坚信，小伙伴们在平时业务开发中一定一定写过如下结构的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl</span> <span class="keyword">implements</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServiceImpl</span> <span class="keyword">implements</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其实就是Spring环境下典型的循环依赖场景。但是很显然，这种循环依赖场景，Spring已经完美的帮我们解决和规避了问题。所以即使平时我们这样循环引用，也能够整成进行我们的coding之旅~</p>
<h5 id="Spring中三大循环依赖场景演示"><a href="#Spring中三大循环依赖场景演示" class="headerlink" title="Spring中三大循环依赖场景演示"></a>Spring中<code>三大循环依赖场景</code>演示</h5><p>在Spring环境中，因为我们的Bean的实例化、初始化都是交给了容器，因此它的循环依赖主要表现为下面三种场景。为了方便演示，我准备了如下两个类： </p>
<h6 id="1、构造器注入循环依赖"><a href="#1、构造器注入循环依赖" class="headerlink" title="1、构造器注入循环依赖"></a>1、构造器注入循环依赖</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：项目启动失败抛出异常<code>BeanCurrentlyInCreationException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">'a'</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.beforeSingletonCreation(DefaultSingletonBeanRegistry.java:<span class="number">339</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">215</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">318</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">199</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 构造器注入构成的循环依赖，此种循环依赖方式<strong>是无法解决的</strong>，只能抛出<code>BeanCurrentlyInCreationException</code>异常表示循环依赖。这也是构造器注入的最大劣势（它有很多独特的优势，请小伙伴自行发掘） </p>
<p> <code>根本原因</code>：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是<code>已经实例化</code>，但还没初始化的状态。而构造器是完成实例化的东东，所以构造器的循环依赖无法解决<del>~</del> </p>
</blockquote>
<h6 id="2、field属性注入（setter方法注入）循环依赖"><a href="#2、field属性注入（setter方法注入）循环依赖" class="headerlink" title="2、field属性注入（setter方法注入）循环依赖"></a>2、field属性注入（setter方法注入）循环依赖</h6><p>这种方式是我们<strong>最最最最</strong>为常用的依赖注入方式（所以猜都能猜到它肯定不会有问题啦）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：项目启动成功，能够正常work</strong></p>
<blockquote>
<p> 备注：setter方法注入方式因为原理和字段注入方式类似，此处不多加演示 </p>
</blockquote>
<h6 id="3、prototype-field属性注入循环依赖"><a href="#3、prototype-field属性注入循环依赖" class="headerlink" title="3、prototype field属性注入循环依赖"></a>3、<code>prototype</code> field属性注入循环依赖</h6><p><code>prototype</code>在平时使用情况较少，但是也并不是不会使用到，因此此种方式也需要引起重视。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<strong>需要注意的是</strong>本例中<strong>启动时是不会报错的</strong>（因为非单例Bean<code>默认</code>不会初始化，而是使用时才会初始化），所以很简单咱们只需要手动<code>getBean()</code>或者在一个单例Bean内<code>@Autowired</code>一下它即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在单例Bean内注入</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> A a;</span><br></pre></td></tr></table></figure>

<p>这样子启动就报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'mytest.TestSpringBean'</span>: Unsatisfied dependency expressed through field <span class="string">'a'</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'a'</span>: Unsatisfied dependency expressed through field <span class="string">'b'</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'b'</span>: Unsatisfied dependency expressed through field <span class="string">'a'</span>; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">'a'</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line"></span><br><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:<span class="number">596</span>)</span><br><span class="line">	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:<span class="number">90</span>)</span><br><span class="line">	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:<span class="number">374</span>)</span><br></pre></td></tr></table></figure>

<p>如何解决？？？ 可能有的小伙伴看到网上有说使用<code>@Lazy</code>注解解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> A a;</span><br></pre></td></tr></table></figure>

<p>此处负责任的告诉你这样是解决不了问题的(<strong>可能会掩盖问题</strong>)，<code>@Lazy</code>只是延迟初始化而已，当你真正使用到它（初始化）的时候，依旧会报如上异常。</p>
<p>对于Spring循环依赖的情况总结如下：</p>
<ol>
<li>不能解决的情况： 1. 构造器注入循环依赖 2. <code>prototype</code> field属性注入循环依赖</li>
<li>能解决的情况： 1. field属性注入（setter方法注入）循环依赖</li>
</ol>
<h4 id="Spring解决循环依赖的原理分析"><a href="#Spring解决循环依赖的原理分析" class="headerlink" title="Spring解决循环依赖的原理分析"></a>Spring解决循环依赖的原理分析</h4><p>在这之前需要明白java中所谓的<code>引用传递</code>和<code>值传递</code>的区别。</p>
<blockquote>
<p> 说明：看到这句话可能有小伙伴就想喷我了。java中明明都是传递啊，这是我初学java时背了100遍的面试题，怎么可能有错？？？ 这就是我做这个申明的必要性：伙计，你的说法是正确的，<code>java中只有值传递</code>。但是本文借用<code>引用传递</code>来辅助讲解，希望小伙伴明白我想表达的意思~ </p>
</blockquote>
<p><strong><code>Spring的循环依赖的理论依据基于Java的引用传递</code></strong>，当获得对象的引用时，<strong>对象的属性是可以延后设置的</strong>。（但是构造器必须是在获取引用之前，毕竟你的引用是靠构造器给你生成的，儿子能先于爹出生？哈哈）</p>
<h5 id="Spring创建Bean的流程"><a href="#Spring创建Bean的流程" class="headerlink" title="Spring创建Bean的流程"></a>Spring创建Bean的流程</h5><p>首先需要了解是Spring它创建Bean的流程，我把它的大致调用栈绘图如下： </p>
<p><img src="http://static.cyblogs.com/oepgq3cnb0.png" alt="http://static.cyblogs.com/oepgq3cnb0.png"></p>
<p> 对Bean的创建最为核心三个方法解释如下：</p>
<ul>
<li><code>createBeanInstance</code>：例化，其实也就是调用对象的<strong>构造方法</strong>实例化对象</li>
<li><code>populateBean</code>：填充属性，这一步主要是对bean的依赖属性进行注入(<code>@Autowired</code>)</li>
<li><code>initializeBean</code>：回到一些形如<code>initMethod</code>、<code>InitializingBean</code>等方法</li>
</ul>
<p>从对<code>单例Bean</code>的初始化可以看出，循环依赖主要发生在<strong>第二步（populateBean）</strong>，也就是field属性注入的处理。</p>
<h5 id="Spring容器的-39-三级缓存-39"><a href="#Spring容器的-39-三级缓存-39" class="headerlink" title="Spring容器的&#39;三级缓存&#39;"></a>Spring容器的<code>&#39;三级缓存&#39;</code></h5><p>在Spring容器的整个声明周期中，单例Bean有且仅有一个对象。这很容易让人想到可以用缓存来加速访问。 从源码中也可以看出Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至不惜使用了“三级缓存”，这也便是它设计的精妙之处~</p>
<p><code>三级缓存</code>其实它更像是Spring容器工厂的内的<code>术语</code>，采用三级缓存模式来解决循环依赖问题，这三级缓存分别指：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 从上至下 分表代表这“三级缓存”</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>); <span class="comment">//一级缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>); <span class="comment">// 二级缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>); <span class="comment">// 三级缓存</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line">	<span class="comment">// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~</span></span><br><span class="line">	<span class="comment">// 它在Bean开始创建时放值，创建完成时会将其移出~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Names of beans that have already been created at least once. */</span></span><br><span class="line">	<span class="comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span></span><br><span class="line">	<span class="comment">// 至少被创建了一次的  都会放进这里~~~~</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：<code>AbstractBeanFactory</code>继承自<code>DefaultSingletonBeanRegistry</code>~</p>
<ol>
<li><code>singletonObjects</code>：用于存放完全初始化好的 bean，<strong>从该缓存中取出的 bean 可以直接使用</strong></li>
<li><code>earlySingletonObjects</code>：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</li>
<li><code>singletonFactories</code>：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</li>
</ol>
<p><strong>获取单例Bean的源码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">				singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isActuallyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先从<code>一级缓存singletonObjects</code>中去获取。（如果获取到就直接return）</li>
<li>如果获取不到或者对象正在创建中（<code>isSingletonCurrentlyInCreation()</code>），那就再从<code>二级缓存earlySingletonObjects</code>中获取。（如果获取到就直接return）</li>
<li>如果还是获取不到，且允许singletonFactories（allowEarlyReference=true）通过<code>getObject()</code>获取。就从<code>三级缓存singletonFactory</code>.getObject()获取。<strong>（如果获取到了就从</strong><code>**singletonFactories**</code><strong>中移除，并且放进</strong><code>**earlySingletonObjects**</code><strong>。其实也就是从三级缓存</strong><code>**移动（是剪切、不是复制哦~）**</code><strong>到了二级缓存）</strong></li>
</ol>
<blockquote>
<p> <strong>加入<code>singletonFactories</code>三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</strong> </p>
</blockquote>
<p><code>getSingleton()</code>从缓存里获取单例对象步骤分析可知，Spring解决循环依赖的诀窍：<strong>就在于singletonFactories这个三级缓存</strong>。这个Cache里面都是<code>ObjectFactory</code>，它是解决问题的关键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它可以将创建对象的步骤封装到ObjectFactory中 交给自定义的Scope来选择是否需要创建对象来灵活的实现scope。  具体参见Scope接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 经过ObjectFactory.getObject()后，此时放进了二级缓存<code>earlySingletonObjects</code>内。这个时候对象已经实例化了，<code>虽然还不完美</code>，但是对象的引用已经可以被其它引用了。 </p>
</blockquote>
<p><strong>此处说一下二级缓存<code>earlySingletonObjects</code>它里面的数据什么时候添加什么移除？？?</strong></p>
<p><strong>添加</strong>：向里面添加数据只有一个地方，就是上面说的<code>getSingleton()</code>里从三级缓存里挪过来 <strong>移除</strong>：<code>addSingleton、addSingletonFactory、removeSingleton</code>从语义中可以看出添加单例、添加单例工厂<code>ObjectFactory</code>的时候都会删除二级缓存里面对应的缓存值，是互斥的</p>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p><code>Spring</code>容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，而对于创建完毕的Bean将从<code>当前创建Bean池</code>中清除掉。 这个“当前创建Bean池”指的是上面提到的<code>singletonsCurrentlyInCreation</code>那个集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType, @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">		<span class="comment">// 先去获取一次，如果不为null，此处就会走缓存了~~</span></span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池</span></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// Create bean instance.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">// 这个getSingleton方法不是SingletonBeanRegistry的接口方法  属于实现类DefaultSingletonBeanRegistry的一个public重载方法~~~</span></span><br><span class="line">			<span class="comment">// 它的特点是在执行singletonFactory.getObject();前后会执行beforeSingletonCreation(beanName);和afterSingletonCreation(beanName);  </span></span><br><span class="line">			<span class="comment">// 也就是保证这个Bean在创建过程中，放入正在创建的缓存池里  可以看到它实际创建bean调用的是我们的createBean方法~~~~</span></span><br><span class="line">			sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					destroySingleton(beanName);</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法createBean所在地  这个接口方法是属于抽象父类AbstractBeanFactory的   实现在这个抽象类里</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 创建Bean对象，并且将对象包裹在BeanWrapper 中</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		<span class="comment">// 再从Wrapper中把Bean原始对象（非代理~~~）  这个时候这个Bean就有地址值了，就能被引用了~~~</span></span><br><span class="line">		<span class="comment">// 注意：此处是原始对象，这点非常的重要</span></span><br><span class="line">		<span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// earlySingletonExposure 用于表示是否”提前暴露“原始对象的引用，用于解决循环依赖。</span></span><br><span class="line">		<span class="comment">// 对于单例Bean，该变量一般为 true   但你也可以通过属性allowCircularReferences = false来关闭循环引用</span></span><br><span class="line">		<span class="comment">// isSingletonCurrentlyInCreation(beanName) 表示当前bean必须在创建中才行</span></span><br><span class="line">		<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName + <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 上面讲过调用此方法放进一个ObjectFactory，二级缓存会对应删除的</span></span><br><span class="line">			<span class="comment">// getEarlyBeanReference的作用：调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference()这个方法  否则啥都不做</span></span><br><span class="line">			<span class="comment">// 也就是给调用者个机会，自己去实现暴露这个bean的应用的逻辑~~~</span></span><br><span class="line">			<span class="comment">// 比如在getEarlyBeanReference()里可以实现AOP的逻辑~~~  参考自动代理创建器AbstractAutoProxyCreator  实现了这个方法来创建代理对象</span></span><br><span class="line">			<span class="comment">// 若不需要执行AOP的逻辑，直接返回Bean</span></span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">		&#125;</span><br><span class="line">		Object exposedObject = bean; <span class="comment">//exposedObject 是最终返回的对象</span></span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 填充属于，解决@Autowired依赖~</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		<span class="comment">// 执行初始化回调方法们~~~</span></span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查</span></span><br><span class="line">		<span class="comment">// 此段代码非常重要~~~~~但大多数人都忽略了它</span></span><br><span class="line">		<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">			<span class="comment">// 此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span></span><br><span class="line">			<span class="comment">//注意，注意：第二参数为false  表示不会再去三级缓存里查了~~~</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 此处非常巧妙的一点：：：因为上面各式各样的实例化、初始化的后置处理器都执行了，如果你在上面执行了这一句</span></span><br><span class="line">			<span class="comment">//  ((ConfigurableListableBeanFactory)this.beanFactory).registerSingleton(beanName, bean);</span></span><br><span class="line">			<span class="comment">// 那么此处得到的earlySingletonReference 的引用最终会是你手动放进去的Bean最终返回，完美的实现了"偷天换日" 特别适合中间件的设计</span></span><br><span class="line">			<span class="comment">// 我们知道，执行完此doCreateBean后执行addSingleton()  其实就是把自己再添加一次  **再一次强调，完美实现偷天换日**</span></span><br><span class="line">			Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">			</span><br><span class="line">				<span class="comment">// 这个意思是如果经过了initializeBean()后，exposedObject还是木有变，那就可以大胆放心的返回了</span></span><br><span class="line">				<span class="comment">// initializeBean会调用后置处理器，这个时候可以生成一个代理对象，那这个时候它哥俩就不会相等了 走else去判断吧</span></span><br><span class="line">				<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125; </span><br><span class="line"></span><br><span class="line">				<span class="comment">// allowRawInjectionDespiteWrapping这个值默认是false</span></span><br><span class="line">				<span class="comment">// hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					<span class="comment">// 拿到它所依赖的Bean们~~~~ 下面会遍历一个一个的去看~~</span></span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">					</span><br><span class="line">					<span class="comment">// 一个个检查它所以Bean</span></span><br><span class="line">					<span class="comment">// removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面</span></span><br><span class="line">					<span class="comment">// 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true</span></span><br><span class="line">					<span class="comment">// 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖</span></span><br><span class="line">					<span class="comment">//（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）</span></span><br><span class="line">					<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 若存在真正依赖，那就报错（不要等到内存移除你才报错，那是非常不友好的） </span></span><br><span class="line">					<span class="comment">// 这个异常是BeanCurrentlyInCreationException，报错日志也稍微留意一下，方便定位错误~~~~</span></span><br><span class="line">					<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								<span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">								<span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">								<span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">								<span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">								<span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 虽然是remove方法 但是它的返回值也非常重要</span></span><br><span class="line">	<span class="comment">// 该方法唯一调用的地方就是循环依赖的最后检查处~~~~~</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeSingletonIfCreatedForTypeCheckOnly</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">			removeSingleton(beanName);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里举例：例如是<code>field</code>属性依赖注入，在<code>populateBean</code>时它就会先去完成它所依赖注入的那个bean的实例化、初始化过程，最终返回到本流程继续处理，<strong>因此Spring这样处理是不存在任何问题的。</strong></p>
<p>这里有个小细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">	exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一句如果<code>exposedObject == bean</code>表示最终返回的对象就是原始对象，说明在<code>populateBean</code>和<code>initializeBean</code>没对他代理过，那就啥话都不说了<code>exposedObject = earlySingletonReference</code>，最终把二级缓存里的引用返回即可~</p>
<h4 id="流程总结（非常重要）"><a href="#流程总结（非常重要）" class="headerlink" title="流程总结（非常重要）"></a>流程总结（<code>非常重要</code>）</h4><p>此处以如上的A、B类的互相依赖注入为例，在这里表达出<strong>关键代码</strong>的走势：</p>
<p>1、入口处即是<strong>实例化、初始化A这个单例Bean</strong>。<code>AbstractBeanFactory.doGetBean(&quot;a&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">	... </span><br><span class="line">	<span class="comment">// 标记beanName a是已经创建过至少一次的~~~ 它会一直存留在缓存里不会被移除（除非抛出了异常）</span></span><br><span class="line">	<span class="comment">// 参见缓存Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256))</span></span><br><span class="line">	<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">		markBeanAsCreated(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此时a不存在任何一级缓存中，且不是在创建中  所以此处返回null</span></span><br><span class="line">	<span class="comment">// 此处若不为null，然后从缓存里拿就可以了(主要处理FactoryBean和BeanFactory情况吧)</span></span><br><span class="line">	Object beanInstance = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这个getSingleton方法非常关键。</span></span><br><span class="line">	<span class="comment">//1、标注a正在创建中~</span></span><br><span class="line">	<span class="comment">//2、调用singletonObject = singletonFactory.getObject();（实际上调用的是createBean()方法）  因此这一步最为关键</span></span><br><span class="line">	<span class="comment">//3、此时实例已经创建完成  会把a移除整整创建的缓存中</span></span><br><span class="line">	<span class="comment">//4、执行addSingleton()添加进去。（备注：注册bean的接口方法为registerSingleton，它依赖于addSingleton方法）</span></span><br><span class="line">	sharedInstance = getSingleton(beanName, () -&gt; &#123; ... <span class="keyword">return</span> createBean(beanName, mbd, args); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、下面进入到最为复杂的<code>AbstractAutowireCapableBeanFactory.createBean/doCreateBean()</code>环节，创建A的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 使用构造器/工厂方法   instanceWrapper是一个BeanWrapper</span></span><br><span class="line">	instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	<span class="comment">// 此处bean为"原始Bean"   也就是这里的A实例对象：A@1234</span></span><br><span class="line">	<span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 是否要提前暴露（允许循环依赖）  现在此处A是被允许的</span></span><br><span class="line">	<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 允许暴露，就把A绑定在ObjectFactory上，注册到三级缓存`singletonFactories`里面去保存着</span></span><br><span class="line">	<span class="comment">// Tips:这里后置处理器的getEarlyBeanReference方法会被促发，自动代理创建器在此处创建代理对象（注意执行时机 为执行三级缓存的时候）</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// exposedObject 为最终返回的对象，此处为原始对象bean也就是A@1234,下面会有用处</span></span><br><span class="line">	Object exposedObject = bean; </span><br><span class="line">	<span class="comment">// 给A@1234属性完成赋值，@Autowired在此处起作用~</span></span><br><span class="line">	<span class="comment">// 因此此处会调用getBean("b")，so 会重复上面步骤创建B类的实例</span></span><br><span class="line">	<span class="comment">// 此处我们假设B已经创建好了 为B@5678</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 需要注意的是在populateBean("b")的时候依赖有beanA，所以此时候调用getBean("a")最终会调用getSingleton("a")，</span></span><br><span class="line">	<span class="comment">//此时候上面说到的getEarlyBeanReference方法就会被执行。这也解释为何我们@Autowired是个代理对象，而不是普通对象的根本原因</span></span><br><span class="line">	</span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="comment">// 实例化。这里会执行后置处理器BeanPostProcessor的两个方法</span></span><br><span class="line">	<span class="comment">// 此处注意：postProcessAfterInitialization()是有可能返回一个代理对象的，这样exposedObject 就不再是原始对象了  特备注意哦~~~</span></span><br><span class="line">	<span class="comment">// 比如处理@Aysnc的AsyncAnnotationBeanPostProcessor它就是在这个时间里生成代理对象的（有坑，请小心使用@Aysnc）</span></span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 至此，相当于A@1234已经实例化完成、初始化完成（属性也全部赋值了~）</span></span><br><span class="line">	<span class="comment">// 这一步我把它理解为校验：校验：校验是否有循环引用问题~~~~~</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 注意此处第二个参数传的false，表示不去三级缓存里singletonFactories再去调用一次getObject()方法了~~~</span></span><br><span class="line">		<span class="comment">// 上面建讲到了由于B在初始化的时候，会触发A的ObjectFactory.getObject()  所以a此处已经在二级缓存earlySingletonObjects里了</span></span><br><span class="line">		<span class="comment">// 因此此处返回A的实例：A@1234</span></span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">		</span><br><span class="line">			<span class="comment">// 这个等式表示，exposedObject若没有再被代理过，这里就是相等的</span></span><br><span class="line">			<span class="comment">// 显然此处我们的a对象的exposedObject它是没有被代理过的  所以if会进去~</span></span><br><span class="line">			<span class="comment">// 这种情况至此，就全部结束了~~~</span></span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 继续以A为例，比如方法标注了@Aysnc注解，exposedObject此时候就是一个代理对象，因此就会进到这里来</span></span><br><span class="line">			<span class="comment">//hasDependentBean(beanName)是肯定为true，因为getDependentBeans(beanName)得到的是["b"]这个依赖</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// A@1234依赖的是["b"]，所以此处去检查b</span></span><br><span class="line">				<span class="comment">// 如果最终存在实际依赖的bean：actualDependentBeans不为空 那就抛出异常  证明循环引用了~</span></span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="comment">// 这个判断原则是：如果此时候b并还没有创建好，this.alreadyCreated.contains(beanName)=true表示此bean已经被创建过，就返回false</span></span><br><span class="line">					<span class="comment">// 若该bean没有在alreadyCreated缓存里，就是说没被创建过(其实只有CreatedForTypeCheckOnly才会是此仓库)</span></span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">							<span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							<span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">							<span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">							<span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">							<span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于关键代码部分的步骤不太好拆分，为了更具象表达，那么使用下面一副图示帮助小伙伴们理解： </p>
<p><img src="http://static.cyblogs.com/qv40e3auxf.png" alt="http://static.cyblogs.com/qv40e3auxf.png"></p>
<p><strong>最后的最后，由于我太暖心了_，再来个纯文字版的总结。</strong> 依旧以上面<code>A</code>、<code>B</code>类使用属性<code>field</code>注入循环依赖的例子为例，对整个流程做文字步骤总结如下：</p>
<ol>
<li>使用<code>context.getBean(A.class)</code>，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走<strong>A的创建之路~</strong></li>
<li><code>实例化</code>A（注意此处仅仅是实例化），并将它放进<code>缓存</code>（此时A已经实例化完成，已经可以被引用了）</li>
<li><code>初始化</code>A：<code>@Autowired</code>依赖注入B（此时需要去容器内获取B）</li>
<li>为了完成依赖注入B，会通过<code>getBean(B)</code>去容器内找B。但此时B在容器内不存在，就走向<strong>B的创建之路~</strong></li>
<li><code>实例化</code>B，并将其放入缓存。（此时B也能够被引用了）</li>
<li><code>初始化</code>B，<code>@Autowired</code>依赖注入A（此时需要去容器内获取A）</li>
<li><code>此处重要</code>：初始化B时会调用<code>getBean(A)</code>去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以<code>getBean(A)</code>能够正常返回</li>
<li><strong>B初始化成功</strong>（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的<code>getBean(B)</code>这句代码，回到了初始化A的流程中~）。</li>
<li>因为B实例已经成功返回了，因此最终<strong>A也初始化成功</strong></li>
<li><strong>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~</strong></li>
</ol>
<p>站的角度高一点，宏观上看Spring处理循环依赖的整个流程就是如此。希望这个宏观层面的总结能更加有助于小伙伴们对Spring解决循环依赖的原理的了解，<strong>同时也顺便能解释为何构造器循环依赖就不好使的原因。</strong></p>
<h5 id="循环依赖对AOP代理对象创建流程和结果的影响"><a href="#循环依赖对AOP代理对象创建流程和结果的影响" class="headerlink" title="循环依赖对AOP代理对象创建流程和结果的影响"></a>循环依赖对AOP代理对象创建<code>流程和结果</code>的影响</h5><p>我们都知道<strong>Spring AOP、事务</strong>等都是通过代理对象来实现的，而<strong>事务</strong>的代理对象是由自动代理创建器来自动完成的。也就是说Spring最终给我们放进容器里面的是一个代理对象，<strong>而非原始对象</strong>。</p>
<p>本文结合<code>循环依赖</code>，回头再看AOP代理对象的创建过程，和最终放进容器内的动作，非常有意思。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"service hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此<code>Service</code>类使用到了事务，所以最终会生成一个JDK动态代理对象<code>Proxy</code>。刚好它又存在<code>自己引用自己</code>的循环依赖。看看这个Bean的创建概要描述如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">( ... )</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这段告诉我们：如果允许循环依赖的话，此处会添加一个ObjectFactory到三级缓存里面，以备创建对象并且提前暴露引用~</span></span><br><span class="line">	<span class="comment">// 此处Tips：getEarlyBeanReference是后置处理器SmartInstantiationAwareBeanPostProcessor的一个方法，它的功效为：</span></span><br><span class="line">	<span class="comment">// 保证自己被循环依赖的时候，即使被别的Bean @Autowire进去的也是代理对象~~~~  AOP自动代理创建器此方法里会创建的代理对象~~~</span></span><br><span class="line">	<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">	<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">	<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123; <span class="comment">// 需要提前暴露（支持循环依赖），就注册一个ObjectFactory到三级缓存</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 此处注意：如果此处自己被循环依赖了  那它会走上面的getEarlyBeanReference，从而创建一个代理对象从三级缓存转移到二级缓存里</span></span><br><span class="line">	<span class="comment">// 注意此时候对象还在二级缓存里，并没有在一级缓存。并且此时可以知道exposedObject仍旧是原始对象~~~</span></span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 经过这两大步后，exposedObject还是原始对象（注意此处以事务的AOP为例子的，</span></span><br><span class="line">	<span class="comment">// 因为事务的AOP自动代理创建器在getEarlyBeanReference创建代理后，initializeBean就不会再重复创建了，二选一的，下面会有描述~~~）</span></span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 循环依赖校验（非常重要）~~~~</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 前面说了因为自己被循环依赖了，所以此时候代理对象还在二级缓存里~~~（备注：本利讲解的是自己被循环依赖了的情况）</span></span><br><span class="line">		<span class="comment">// so，此处getSingleton，就会把里面的对象拿出来，我们知道此时候它已经是个Proxy代理对象~~~</span></span><br><span class="line">		<span class="comment">// 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  </span></span><br><span class="line">		<span class="comment">// 这样就保证了我们容器里**最终实际上是代理对象**，而非原始对象~~~~~</span></span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上演示的是<code>代理对象+自己存在循环依赖</code>的case：Spring用三级缓存很巧妙的进行解决了。 若是这种case：代理对象，但是自己并<strong>不存在循环依赖</strong>，过程稍微有点不一样儿了，如下描述：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">( ... )</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 这些语句依旧会执行，三级缓存里是会加入的  表示它支持被循环引用嘛~~~</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此处注意，因为它没有被其它Bean循环引用（注意是循环引用，而不是直接引用~）,所以上面getEarlyBeanReference不会执行~</span></span><br><span class="line">	<span class="comment">// 也就是说此时二级缓存里并不会存在它~~~ 知晓这点特别的重要</span></span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="comment">// 重点在这：AnnotationAwareAspectJAutoProxyCreator自动代理创建器此处的postProcessAfterInitialization方法里，会给创建一个代理对象返回</span></span><br><span class="line">	<span class="comment">// 所以此部分执行完成后，exposedObject **已经是个代理对象**而不再是个原始对象了~~~~ 此时二级缓存里依旧无它，更别提一级缓存了</span></span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 循环依赖校验</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="comment">// 前面说了一级、二级缓存里都木有它，然后这里传的又是false（表示不看三级缓存~~）</span></span><br><span class="line">		<span class="comment">// 所以毋庸置疑earlySingletonReference = null  so下面的逻辑就不用看了，直接return出去~~</span></span><br><span class="line">		<span class="comment">// 然后执行addSingleton()方法，由此可知  容器里最终存在的也还是代理对象~~~~~~</span></span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;...</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析可知，即使自己只需要代理，并不被循环引用，最终存在Spring容器里的<strong>仍旧是</strong>代理对象。（so此时别人直接<code>@Autowired</code>进去的也是代理对象呀<del>~</del>）</p>
<p><strong>终极case：如果我关闭Spring容器的循环依赖能力，也就是把<code>allowCircularReferences</code>设值为false，那么会不会造成什么问题呢？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它用于关闭循环引用（关闭后只要有循环引用现象就直接报错~~）</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若关闭了循环依赖后，还存在上面A、B的循环依赖现象，启动便会报错如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">'a'</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.beforeSingletonCreation(DefaultSingletonBeanRegistry.java:<span class="number">339</span>)</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">215</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意此处异常类型也是<code>BeanCurrentlyInCreationException</code>异常，但是文案内容和上面强调的有所区别<del>~ 它报错位置在：<code>DefaultSingletonBeanRegistry.beforeSingletonCreation</code>这个位置</del> </p>
</blockquote>
<p><code>报错浅析</code>：在实例化A后给其属性赋值时，会去实例化B。B实例化完成后会继续给B属性赋值，这时由于此时我们<code>关闭了循环依赖</code>，所以不存在<code>提前暴露</code>引用这么一说来给实用。因此B无法直接拿到A的引用地址，因此只能又去创建A的实例。<strong>而此时我们知道A其实已经正在创建中了</strong>，不能再创建了。so，就报错了~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为管理了循环依赖，所以此处不能再依赖自己的</span></span><br><span class="line">	<span class="comment">// 但是：我们的此bean还是需要AOP代理的~~~</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//private HelloService helloService;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"service hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样它的大致运行如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">( ... )</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 毫无疑问此时候earlySingletonExposure = false  也就是Bean都不会提前暴露引用了  显然就不能被循环依赖了~</span></span><br><span class="line">	<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	...</span><br><span class="line">	populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">	<span class="comment">// 若是事务的AOP  在这里会为源生Bean创建代理对象（因为上面没有提前暴露这个代理）</span></span><br><span class="line">	exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		... 这里更不用说，因为earlySingletonExposure=<span class="keyword">false</span>  所以上面的代理对象exposedObject 直接<span class="keyword">return</span>了~</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到即使把这个开关给关了，最终放进容器了的仍旧是代理对象，显然<code>@Autowired</code>给属性赋值的也一定是代理对象。</p>
<p>最后，以<code>AbstractAutoProxyCreator</code>为例看看自动代理创建器是怎么配合实现：循环依赖+创建代理</p>
<blockquote>
<p> <code>AbstractAutoProxyCreator</code>是抽象类，它的三大实现子类<code>InfrastructureAdvisorAutoProxyCreator</code>、<code>AspectJAwareAdvisorAutoProxyCreator</code>、<code>AnnotationAwareAspectJAutoProxyCreator</code>小伙伴们应该会更加的熟悉些 </p>
</blockquote>
<p>该抽象类实现了创建代理的动作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @since 13.10.2003  它实现代理创建的方法有如下两个</span></span><br><span class="line"><span class="comment">// 实现了SmartInstantiationAwareBeanPostProcessor 所以有方法getEarlyBeanReference来只能的解决循环引用问题：提前把代理对象暴露出去~</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 下面两个方法是自动代理创建器创建代理对象的唯二的两个节点~</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提前暴露代理对象的引用  它肯定在postProcessAfterInitialization之前执行</span></span><br><span class="line">	<span class="comment">// 所以它并不需要判断啥的~~~~  创建好后放进缓存earlyProxyReferences里  注意此处value是原始Bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">		Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">		<span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">		<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为它会在getEarlyBeanReference之后执行，所以此处的重要逻辑是下面的判断</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">			<span class="comment">// remove方法返回被移除的value，上面说了它记录的是原始bean</span></span><br><span class="line">			<span class="comment">// 若被循环引用了，那就是执行了上面的`getEarlyBeanReference`方法，所以此时remove返回值肯定是==bean的（注意此时方法入参的bean还是原始对象）</span></span><br><span class="line">			<span class="comment">// 若没有被循环引用，getEarlyBeanReference()不执行 所以remove方法返回null，所以就进入if执行此处的创建代理对象方法~~~</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">				<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知，自动代理创建器它保证了代理对象只会被创建一次，而且支持循环依赖的自动注入的依旧是代理对象。</p>
<p><strong><code>上面分析了三种case，现给出结论如下：</code></strong> 不管是自己被循环依赖了还是没有，<strong>甚至是把Spring容器的循环依赖给关了</strong>，它对AOP代理的创建流程有影响，<strong>但对结果是无影响的。</strong> 也就是说Spring很好的对调用者屏蔽了这些实现细节，使得使用者使用起来完全的无感知~</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>解决此类问题的关键是要对<code>SpringIOC</code>和<code>DI</code>的整个流程做到心中有数，要理解好本文章，建议有【相关阅读】里文章的大量知识的铺垫，同时呢本文又能<strong>进一步</strong>的帮助小伙伴理解到Spring Bean的实例化、初始化流程。</p>
<p>本文还是花了我一番心思的，个人觉得对Spring这部分的处理流程描述得还是比较详细的，希望我的总结能够给大家带来帮助。 <strong>另外为了避免循环依赖导致启动问题而又不会解决，有如下建议：</strong></p>
<ol>
<li><code>业务代码中</code>尽量不要使用构造器注入，即使它有很多优点。</li>
<li><code>业务代码中</code>为了简洁，尽量使用field注入而非setter方法注入</li>
<li>若你注入的同时，立马需要处理一些逻辑（一般见于框架设计中，业务代码中不太可能出现），可以使用setter方法注入辅助完成</li>
</ol>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://cloud.tencent.com/developer/article/1497692" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1497692</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>你是否真的能把单例模式给写好？</title>
    <url>/2020/06/02/2020/06/%E4%BD%A0%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E8%83%BD%E6%8A%8A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%99%E5%86%99%E5%A5%BD%EF%BC%9F/</url>
    <content><![CDATA[<p>当你看到这个标题的时候，以为我是一个标题党？（其实也是…）</p>
<p>但是你真的不能小瞧这个单例模式，不信的话，你可以继续往下看。</p>
<h4 id="小白些单例模式"><a href="#小白些单例模式" class="headerlink" title="小白些单例模式"></a>小白些单例模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            System.out.println(<span class="string">"我开始new对象了~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种单例估计是我们第一眼就能想到的，咋一眼看没问题，因为我们的大脑一眼反应我们的程序都是单线程的。实际上我们系统在初始化的时候就有可能存在多线程的情况。我们模拟并发写一个小程序来验证下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:27 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Singleton instance = Singleton.getInstance();</span><br><span class="line">                    System.out.println(instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一眼运行的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">我开始new对象了~</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@a963d08</span><br><span class="line">我开始new对象了~</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br></pre></td></tr></table></figure>

<p>很明显，new了2次对象，看打印的对象地址也是不对的。</p>
<p>那我们如何去改进呢？– 加锁</p>
<h4 id="加synchronized锁"><a href="#加synchronized锁" class="headerlink" title="加synchronized锁"></a>加synchronized锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">		 </span><br><span class="line">    <span class="comment">// 加锁不就搞定了吗？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">            System.out.println(<span class="string">"我开始new对象了~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个确实能解决掉问题，但是后续每次获取它的时候每次都要加锁排队，性能存在一定的问题。</p>
<h4 id="Double-Check"><a href="#Double-Check" class="headerlink" title="Double Check"></a>Double Check</h4><p>那是不是在方法里面做2次校验就能解决掉问题呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// double check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                    System.out.println(<span class="string">"我开始new对象了~"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码看上去，不管是单线程还是多线程，起码在<code>instance==null</code>的时候都能被hold住。但是表现懵逼了我们的双眼。如果这里发生了重排序，就会存在问题。</p>
<p>创建一个对象可以划分为3步：</p>
<ul>
<li>1、分配内存空间；</li>
<li>2、初始化对象；</li>
<li>3、将内存空间的地址赋值给对象的引用；</li>
</ul>
<p>如果发生重排序的话，步骤2~3有可能颠倒过来。</p>
<h4 id="防止重排序"><a href="#防止重排序" class="headerlink" title="防止重排序"></a>防止重排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">// 加上volatile关键字，防止重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                    System.out.println(<span class="string">"我开始new对象了~"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里加上volatile关键字就可以很好的解决了。传送门：<a href="https://mp.weixin.qq.com/s/HtMphMK8lyrieg-663q9og" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HtMphMK8lyrieg-663q9og</a></p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法采用内部类来解决，加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。 </p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.bilibili.com/video/BV1DK4y1t7MY" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1DK4y1t7MY</a></li>
<li><a href="https://blog.csdn.net/zmx729618/article/details/69227762" target="_blank" rel="noopener">https://blog.csdn.net/zmx729618/article/details/69227762</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁用Redis还是Zookeeper？</title>
    <url>/2020/06/01/2020/06/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%94%A8Redis%E8%BF%98%E6%98%AFZookeeper%EF%BC%9F/</url>
    <content><![CDATA[<p>为什么用分布式锁？在讨论这个问题之前，我们先来看一个业务场景。</p>
<h4 id="为什么用分布式锁？"><a href="#为什么用分布式锁？" class="headerlink" title="为什么用分布式锁？"></a>为什么用分布式锁？</h4><p>系统 A 是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。</p>
<p>由于系统有一定的并发，所以会预先将商品的库存保存在 Redis 中，用户下单的时候会更新 Redis 的库存。</p>
<p>此时系统架构如下：</p>
<p><img src="https://s5.51cto.com/oss/201907/16/3e9e699864efd973960054445fbc67f4.jpg" alt="img"></p>
<p>但是这样一来会产生一个问题：假如某个时刻，Redis 里面的某个商品库存为 1。</p>
<p>此时两个请求同时到来，其中一个请求执行到上图的第 3 步，更新数据库的库存为 0，但是第 4 步还没有执行。</p>
<p>而另外一个请求执行到了第 2 步，发现库存还是 1，就继续执行第 3 步。这样的结果，是导致卖出了 2 个商品，然而其实库存只有 1 个。</p>
<p>很明显不对啊！这就是典型的库存超卖问题。此时，我们很容易想到解决方案：用锁把 2、3、4 步锁住，让他们执行完之后，另一个线程才能进来执行第 2 步。</p>
<p><img src="http://static.cyblogs.com/ce0fee95ef6880c9ac5ba670fe5be268.jpg" alt="http://static.cyblogs.com/ce0fee95ef6880c9ac5ba670fe5be268.jpg"></p>
<p>按照上面的图，在执行第 2 步时，使用 Java 提供的 Synchronized 或者 ReentrantLock 来锁住，然后在第 4 步执行完之后才释放锁。</p>
<p>这样一来，2、3、4 这 3 个步骤就被“锁”住了，多个线程之间只能串行化执行。</p>
<p>但是好景不长，整个系统的并发飙升，一台机器扛不住了。现在要增加一台机器，如下图：</p>
<p><img src="http://static.cyblogs.com/99f3874bd484b4ea8000ca41023be3dc.jpg-wh_600x-s_592420448.jpg" alt="http://static.cyblogs.com/99f3874bd484b4ea8000ca41023be3dc.jpg-wh_600x-s_592420448.jpg"></p>
<p>增加机器之后，系统变成上图所示，我的天！假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现库存超卖的问题。</p>
<p>为什么呢？因为上图中的两个 A 系统，运行在两个不同的 JVM 里面，他们加的锁只对属于自己 JVM 里面的线程有效，对于其他 JVM 的线程是无效的。</p>
<p>因此，这里的问题是：Java 提供的原生锁机制在多机部署场景下失效了，这是因为两台机器加的锁不是同一个锁（两个锁在不同的 JVM 里面）。</p>
<p>那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？此时，就该分布式锁隆重登场了。</p>
<p>分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。</p>
<p>至于这个“东西”，可以是 Redis、Zookeeper，也可以是数据库。文字描述不太直观，我们来看下图：</p>
<p><img src="http://static.cyblogs.com/3667d7cff8435d47f5a187ad596bdb09.jpg-wh_600x-s_1198484587.jpg" alt="http://static.cyblogs.com/3667d7cff8435d47f5a187ad596bdb09.jpg-wh_600x-s_1198484587.jpg"></p>
<p>通过上面的分析，我们知道了库存超卖场景在分布式部署系统的情况下使用 Java 原生的锁机制无法保证线程安全，所以我们需要用到分布式锁的方案。</p>
<p>那么，如何实现分布式锁呢？接着往下看！</p>
<h4 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h4><p>上面分析为啥要使用分布式锁了，这里我们来具体看看分布式锁落地的时候应该怎么样处理。</p>
<p><strong>①常见的一种方案就是使用 Redis 做分布式锁</strong></p>
<p>使用 Redis 做分布式锁的思路大概是这样的：在 Redis 中设置一个值表示加了锁，然后释放锁的时候就把这个 Key 删除。</p>
<p>具体代码是这样的：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">// 获取锁 </span><br><span class="line">// NX是指如果key不存在就成功，key存在返回<span class="literal">false</span>，PX可以指定过期时间 </span><br><span class="line">SET anyLock unique_value NX PX <span class="number">30000</span> </span><br><span class="line"> </span><br><span class="line">// 释放锁：通过执行一段lua脚本 </span><br><span class="line">// 释放锁涉及到两条指令，这两条指令不是原子性的 </span><br><span class="line">// 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的 </span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这种方式有几大要点：</p>
<ul>
<li>一定要用 SET key value NX PX milliseconds 命令。如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(Key ***存在)</li>
<li>Value 要具有唯一性。这个是为了在解锁的时候，需要验证 Value 是和加锁的一致才删除 Key。</li>
</ul>
<p>这时避免了一种情况：假设 A 获取了锁，过期时间 30s，此时 35s 之后，锁已经自动释放了，A 去释放锁，但是此时可能 B 获取了锁。A 客户端就不能删除 B 的锁了。</p>
<p>除了要考虑客户端要怎么实现分布式锁之外，还需要考虑 Redis 的部署问题。</p>
<p>Redis 有 3 种部署方式：</p>
<ul>
<li>单机模式</li>
<li>Master-Slave+Sentinel 选举模式</li>
<li>Redis Cluster 模式</li>
</ul>
<p>使用 Redis 做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要 Redis 故障了。加锁就不行了。</p>
<p>采用 Master-Slave 模式，加锁的时候只对一个节点加锁，即便通过 Sentinel 做了高可用，但是如果 Master 节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。</p>
<p>基于以上的考虑，Redis 的作者也考虑到这个问题，他提出了一个 RedLock 的算法。</p>
<p>这个算法的意思大概是这样的：假设 Redis 的部署模式是 Redis Cluster，总共有 5 个 Master 节点。</p>
<p>通过以下步骤获取一把锁：</p>
<ul>
<li>获取当前时间戳，单位是毫秒。</li>
<li>轮流尝试在每个 Master 节点上创建锁，过期时间设置较短，一般就几十毫秒。</li>
<li>尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点（n / 2 +1）。</li>
<li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了。</li>
<li>要是锁建立失败了，那么就依次删除这个锁。</li>
<li>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。</li>
</ul>
<p>但是这样的这种算法还是颇具争议的，可能还会存在不少的问题，无法保证加锁的过程一定正确。</p>
<p><img src="http://static.cyblogs.com/da6b5468501519f5688e47824b56ba21.jpg-wh_600x-s_4091681668.jpg" alt="http://static.cyblogs.com/da6b5468501519f5688e47824b56ba21.jpg-wh_600x-s_4091681668.jpg"></p>
<p><strong>②另一种方式：Redisson</strong></p>
<p>此外，实现 Redis 的分布式锁，除了自己基于 Redis Client 原生 API 来实现之外，还可以使用开源框架：Redission。</p>
<p>Redisson 是一个企业级的开源 Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？</p>
<p>回想一下上面说的，如果自己写代码来通过 Redis 设置一个值，是通过下面这个命令设置的：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">SET anyLock unique_value NX PX <span class="number">30000</span></span><br></pre></td></tr></table></figure>

<p>这里设置的超时时间是 30s，假如我超过 30s 都还没有完成业务逻辑的情况下，Key 会过期，其他线程有可能会获取到锁。</p>
<p>这样一来的话，***个线程还没执行完业务逻辑，第二个线程进来了也会出现线程安全问题。</p>
<p>所以我们还需要额外的去维护这个过期时间，太麻烦了~我们来看看 Redisson 是怎么实现的？</p>
<p>先感受一下使用 Redission 的爽：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config(); </span><br><span class="line">config.useClusterServers() </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7001"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7002"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7003"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7001"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7002"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7003"</span>); </span><br><span class="line"> </span><br><span class="line">RedissonClient redisson = Redisson.create(config); </span><br><span class="line"></span><br><span class="line">RLock lock = redisson.getLock(<span class="string">"anyLock"</span>); </span><br><span class="line">lock.lock(); </span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>就是这么简单，我们只需要通过它的 API 中的 Lock 和 Unlock 即可完成分布式锁，他帮我们考虑了很多细节：</p>
<ul>
<li>Redisson 所有指令都通过 Lua 脚本执行，Redis 支持 Lua 脚本原子性执行。</li>
<li>Redisson 设置一个 Key 的默认过期时间为 30s，如果某个客户端持有一个锁超过了 30s 怎么办？</li>
<li>Redisson 中有一个 Watchdog 的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔 10s 帮你把 Key 的超时时间设为 30s。</li>
</ul>
<p>这样的话，就算一直持有锁也不会出现 Key 过期了，其他线程获取到锁的问题了。</p>
<ul>
<li>Redisson 的“看门狗”逻辑保证了没有死锁发生。(如果机器宕机了，看门狗也就没了。此时就不会延长 Key 的过期时间，到了 30s 之后就会自动过期了，其他线程可以获取到锁)</li>
</ul>
<p><img src="http://static.cyblogs.com/a7fbd80edbe1bc035e0a6e1c3c691ed7.jpg-wh_600x-s_1313345474.jpg" alt="http://static.cyblogs.com/a7fbd80edbe1bc035e0a6e1c3c691ed7.jpg-wh_600x-s_1313345474.jpg"></p>
<p>这里稍微贴出来其实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁逻辑 </span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 调用一段lua脚本，设置一些key、过期时间 </span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG); </span><br><span class="line">    ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) &#123; </span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            Long ttlRemaining = future.getNow(); </span><br><span class="line">            <span class="comment">// lock acquired </span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="comment">// 看门狗逻辑 </span></span><br><span class="line">                scheduleExpirationRenewal(threadId); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123; </span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command, </span><br><span class="line">              <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> + </span><br><span class="line">                  <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> + </span><br><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> + </span><br><span class="line">                  <span class="string">"return nil; "</span> + </span><br><span class="line">              <span class="string">"end; "</span> + </span><br><span class="line">              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> + </span><br><span class="line">                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> + </span><br><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> + </span><br><span class="line">                  <span class="string">"return nil; "</span> + </span><br><span class="line">              <span class="string">"end; "</span> + </span><br><span class="line">              <span class="string">"return redis.call('pttl', KEYS[1]);"</span>, </span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId)); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 看门狗最终会调用了这里 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.containsKey(getEntryName())) &#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 这个任务会延迟10s执行 </span></span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这个操作会将key的过期时间重新设置为30s </span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId); </span><br><span class="line"> </span><br><span class="line">            future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() &#123; </span><br><span class="line">                <span class="meta">@Override</span> </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">                    expirationRenewalMap.remove(getEntryName()); </span><br><span class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123; </span><br><span class="line">                        log.error(<span class="string">"Can't update lock "</span> + getName() + <span class="string">" expiration"</span>, future.cause()); </span><br><span class="line">                        <span class="keyword">return</span>; </span><br><span class="line">                    &#125; </span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (future.getNow()) &#123; </span><br><span class="line">                        <span class="comment">// reschedule itself </span></span><br><span class="line">                        <span class="comment">// 通过递归调用本方法，***循环延长过期时间 </span></span><br><span class="line">                        scheduleExpirationRenewal(threadId); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.putIfAbsent(getEntryName(), <span class="keyword">new</span> ExpirationEntry(threadId, task)) != <span class="keyword">null</span>) &#123; </span><br><span class="line">        task.cancel(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，Redisson 还提供了对 Redlock 算法的支持，它的用法也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RedissonClient redisson = Redisson.create(config); </span><br><span class="line">RLock lock1 = redisson.getFairLock(<span class="string">"lock1"</span>); </span><br><span class="line">RLock lock2 = redisson.getFairLock(<span class="string">"lock2"</span>); </span><br><span class="line">RLock lock3 = redisson.getFairLock(<span class="string">"lock3"</span>); </span><br><span class="line">RedissonRedLock multiLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3); </span><br><span class="line">multiLock.lock(); </span><br><span class="line">multiLock.unlock();</span><br></pre></td></tr></table></figure>

<p>小结：本节分析了使用 Redis 作为分布式锁的具体落地方案以及其一些局限性，然后介绍了一个 Redis 的客户端框架 Redisson，这也是我推荐大家使用的，比自己写代码实现会少 Care 很多细节。</p>
<h4 id="基于-Zookeeper-实现分布式锁"><a href="#基于-Zookeeper-实现分布式锁" class="headerlink" title="基于 Zookeeper 实现分布式锁"></a>基于 Zookeeper 实现分布式锁</h4><p>常见的分布式锁实现方案里面，除了使用 Redis 来实现之外，使用 Zookeeper 也可以实现分布式锁。</p>
<p>在介绍 Zookeeper(下文用 ZK 代替)实现分布式锁的机制之前，先粗略介绍一下 ZK 是什么东西：ZK 是一种提供配置管理、分布式协同以及命名的中心化服务。</p>
<p>ZK 的模型是这样的：ZK 包含一系列的节点，叫做 Znode，就好像文件系统一样，每个 Znode 表示一个目录。</p>
<p>然后 Znode 有一些特性：</p>
<ul>
<li>有序节点：假如当前有一个父节点为 /lock，我们可以在这个父节点下面创建子节点，ZK 提供了一个可选的有序特性。</li>
</ul>
<p>例如我们可以创建子节点“/lock/node-”并且指明有序，那么 ZK 在生成子节点时会根据当前的子节点数量自动添加整数序号。</p>
<p>也就是说，如果是***个创建的子节点，那么生成的子节点为 /lock/node-0000000000，下一个节点则为 /lock/node-0000000001，依次类推。</p>
<ul>
<li>临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，ZK 会自动删除该节点。</li>
<li>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，ZK 会通知客户端。</li>
</ul>
<p>当前 ZK 有如下四种事件：</p>
<ul>
<li>节点创建</li>
<li>节点删除</li>
<li>节点数据修改</li>
<li>子节点变更</li>
</ul>
<p>基于以上的一些 ZK 的特性，我们很容易得出使用 ZK 实现分布式锁的落地方案：</p>
<ul>
<li>使用 ZK 的临时节点和有序节点，每个线程获取锁就是在 ZK 创建一个临时有序的节点，比如在 /lock/ 目录下。</li>
<li>创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点。</li>
<li>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。</li>
<li>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</li>
</ul>
<p>比如当前线程获取到的节点序号为 /lock/003，然后所有的节点列表为[/lock/001，/lock/002，/lock/003]，则对 /lock/002 这个节点添加一个事件监听器。</p>
<p>如果锁释放了，会唤醒下一个序号的节点，然后重新执行第 3 步，判断是否自己的节点序号是最小。</p>
<p>比如 /lock/001 释放了，/lock/002 监听到时间，此时节点集合为[/lock/002，/lock/003]，则 /lock/002 为最小序号节点，获取到锁。</p>
<p>整个过程如下：</p>
<p><img src="http://static.cyblogs.com/fb6c27bb22de93cbeb965718156f578f.jpg" alt="http://static.cyblogs.com/fb6c27bb22de93cbeb965718156f578f.jpg"></p>
<p>具体的实现思路就是这样，至于代码怎么写，这里比较复杂就不贴出来了。</p>
<p><strong>Curator 介绍</strong></p>
<p>Curator 是一个 ZK 的开源客户端，也提供了分布式锁的实现。它的使用方式也比较简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client,<span class="string">"/anyLock"</span>); </span><br><span class="line">interProcessMutex.acquire(); </span><br><span class="line">interProcessMutex.release();</span><br></pre></td></tr></table></figure>

<p>其实现分布式锁的核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">boolean</span>  haveTheLock = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">boolean</span>  doDelete = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> ( revocable.get() != <span class="keyword">null</span> ) &#123; </span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock ) &#123; </span><br><span class="line">            <span class="comment">// 获取当前所有节点排序后的集合 </span></span><br><span class="line">            List&lt;String&gt;        children = getSortedChildren(); </span><br><span class="line">            <span class="comment">// 获取当前节点的名称 </span></span><br><span class="line">            String              sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// +1 to include the slash </span></span><br><span class="line">            <span class="comment">// 判断当前节点是否是最小的节点 </span></span><br><span class="line">            PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases); </span><br><span class="line">            <span class="keyword">if</span> ( predicateResults.getsTheLock() ) &#123; </span><br><span class="line">                <span class="comment">// 获取到锁 </span></span><br><span class="line">                haveTheLock = <span class="keyword">true</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 没获取到锁，对当前节点的上一个节点注册一个监听器 </span></span><br><span class="line">                String  previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch(); </span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123; </span><br><span class="line">                    Stat stat = client.checkExists().usingWatcher(watcher).forPath(previousSequencePath); </span><br><span class="line">                    <span class="keyword">if</span> ( stat != <span class="keyword">null</span> )&#123; </span><br><span class="line">                        <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )&#123; </span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis); </span><br><span class="line">                            startMillis = System.currentTimeMillis(); </span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )&#123; </span><br><span class="line">                                doDelete = <span class="keyword">true</span>;    <span class="comment">// timed out - delete our node </span></span><br><span class="line">                                <span class="keyword">break</span>; </span><br><span class="line">                            &#125; </span><br><span class="line">                            wait(millisToWait); </span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                            wait(); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// else it may have been deleted (i.e. lock released). Try to acquire again </span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> ( Exception e ) &#123; </span><br><span class="line">        doDelete = <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">throw</span> e; </span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123; </span><br><span class="line">        <span class="keyword">if</span> ( doDelete )&#123; </span><br><span class="line">            deleteOurPath(ourPath); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> haveTheLock; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 Curator 实现分布式锁的底层原理和上面分析的是差不多的。这里我们用一张图详细描述其原理：</p>
<p><img src="https://s5.51cto.com/oss/201907/16/84636c96585ff2611ff55e284a57c6ab.jpg-wh_600x-s_3685227374.jpg" alt="https://s5.51cto.com/oss/201907/16/84636c96585ff2611ff55e284a57c6ab.jpg-wh_600x-s_3685227374.jpg"></p>
<p>小结：本节介绍了 ZK 实现分布式锁的方案以及 ZK 的开源客户端的基本使用，简要的介绍了其实现原理。</p>
<h4 id="两种方案的优缺点比较"><a href="#两种方案的优缺点比较" class="headerlink" title="两种方案的优缺点比较"></a>两种方案的优缺点比较</h4><p>学完了两种分布式锁的实现方案之后，本节需要讨论的是 Redis 和 ZK 的实现方案中各自的优缺点。</p>
<p>对于 Redis 的分布式锁而言，它有以下缺点：</p>
<ul>
<li>它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。</li>
<li>另外来说的话，Redis 的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮。</li>
<li>即便使用 Redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100% 没有问题，关于 Redlock 的讨论可以看 How to do distributed locking。</li>
<li>Redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。</li>
</ul>
<p>但是另一方面使用 Redis 实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”。</p>
<p>所以使用 Redis 作为分布式锁也不失为一种好的方案，最重要的一点是 Redis 的性能很高，可以支撑高并发的获取、释放锁操作。</p>
<p>对于 ZK 分布式锁而言:</p>
<ul>
<li>ZK 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</li>
<li>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</li>
</ul>
<p>但是 ZK 也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。</p>
<p>小结：综上所述，Redis 和 ZK 都有其优缺点。我们在做技术选型的时候可以根据这些问题作为参考因素。</p>
<h4 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h4><p>通过前面的分析，实现分布式锁的两种常见方案：Redis 和 ZK，他们各有千秋。应该如何选型呢？</p>
<p>就个人而言的话，我比较推崇 ZK 实现的锁：因为 Redis 是有可能存在隐患的，可能会导致数据不对的情况。但是，怎么选用要看具体在公司的场景了。</p>
<p>如果公司里面有 ZK 集群条件，优先选用 ZK 实现，但是如果说公司里面只有 Redis 集群，没有条件搭建 ZK 集群。</p>
<p>那么其实用 Redis 来实现也可以，另外还可能是系统设计者考虑到了系统已经有 Redis，但是又不希望再次引入一些外部依赖的情况下，可以选用 Redis。这个是要系统设计者基于架构来考虑了。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://developer.51cto.com/art/201907/599642.htm" target="_blank" rel="noopener">https://developer.51cto.com/art/201907/599642.htm</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>四张图带你了解Tomcat系统架构</title>
    <url>/2020/06/04/2020/06/%E5%9B%9B%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，<code>Tomcat</code>的结构很复杂，但是 <code>Tomcat</code> 非常的模块化，找到了 <code>Tomcat</code>最核心的模块，问题才可以游刃而解，了解了<code>Tomcat</code>的整体架构对以后深入了解<code>Tomcat</code>来说至关重要！</p>
<h4 id="一、Tomcat顶层架构"><a href="#一、Tomcat顶层架构" class="headerlink" title="一、Tomcat顶层架构"></a><strong>一、Tomcat顶层架构</strong></h4><p>先上一张<code>Tomcat</code>的顶层结构图（图A），如下：</p>
<p><img src="http://static.cyblogs.com/5j8j72c1yz.jpg" alt="http://static.cyblogs.com/5j8j72c1yz.jpg"></p>
<p><code>Tomcat</code>中最顶层的容器是<code>Server</code>，代表着整个服务器，从上图中可以看出，一个<code>Server</code>可以包含至少一个<code>Service</code>，用于具体提供服务。</p>
<p><code>Service</code>主要包含两个部分：<code>Connector</code>和<code>Container</code>。从上图中可以看出 <code>Tomcat</code> 的心脏就是这两个组件，他们的作用如下：</p>
<p>1、<code>Connector</code>用于处理连接相关的事情，并提供<code>Socket</code>与<code>Request</code>和<code>Response</code>相关的转化; </p>
<p>2、<code>Container</code>用于封装和管理Servlet，以及具体处理<code>Request</code>请求；</p>
<p>一个<code>Tomcat</code>中只有一个<code>Server</code>，一个<code>Server</code>可以包含多个<code>Service</code>，一个<code>Service</code>只有一个<code>Container</code>，但是可以有多个<code>Connectors</code>，这是因为一个服务可以有多个连接，如同时提供<code>Http</code>和<code>Https</code>链接，也可以提供向相同协议不同端口的连接,示意图如下（<code>Engine</code>、<code>Host</code>、<code>Context</code>下边会说到）：</p>
<p><img src="http://static.cyblogs.com/q0q4dy3ioh.jpg" alt="img"></p>
<p>多个 <code>Connector</code> 和一个 <code>Container</code> 就形成了一个 <code>Service</code>，有了 <code>Service</code> 就可以对外提供服务了，但是 <code>Service</code> 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 <code>Server</code> 莫属了！所以整个 <code>Tomcat</code> 的生命周期由 <code>Server</code> 控制。</p>
<p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的<code>server.xml</code>配置文件中看出，下图是删除了注释内容之后的一个完整的<code>server.xml</code>配置文件（Tomcat版本为8.0）</p>
<p><img src="http://static.cyblogs.com/ruzbrbmp9e.jpg" alt="img"></p>
<p>详细的配置文件文件内容可以到<code>Tomcat</code>官网查看：<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-8.0-doc/index.html</a></p>
<p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p>
<p><img src="http://static.cyblogs.com/pwsqbf6laq.png" alt="img"></p>
<p><code>Server</code>标签设置的端口号为<code>8005</code>，<code>shutdown=”SHUTDOWN”</code> ，表示在<code>8005</code>端口监听“<code>SHUTDOWN</code>”命令，如果接收到了就会关闭<code>Tomcat</code>。一个<code>Server</code>有一个<code>Service</code>，当然还可以进行配置，一个<code>Service</code>有多个，<code>Service</code>左边的内容都属于<code>Container</code>的，<code>Service</code>下边是<code>Connector</code>。</p>
<h4 id="二、Tomcat顶层架构小结："><a href="#二、Tomcat顶层架构小结：" class="headerlink" title="二、Tomcat顶层架构小结："></a><strong>二、Tomcat顶层架构小结：</strong></h4><p>（1）<code>Tomcat</code>中只有一个<code>Server</code>，一个<code>Server</code>可以有多个<code>Service</code>，一个<code>Service</code>可以有多个<code>Connector</code>和一个<code>Container</code>；  </p>
<p>（2） <code>Server</code>掌管着整个<code>Tomcat</code>的生死大权；  </p>
<p>（3）<code>Service</code> 是对外提供服务的；  </p>
<p>（4）<code>Connector</code>用于接受请求并将请求封装成<code>Request</code>和<code>Response</code>来具体处理；  </p>
<p>（5）<code>Container</code>用于封装和管理<code>Servlet</code>，以及具体处理<code>request</code>请求；</p>
<p>知道了整个<code>Tomcat</code>顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说<code>Server</code>和<code>Service</code>对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于<code>Connector</code>和<code>Container</code>的，所以接下来介绍一下<code>Connector</code>和<code>Container</code>。</p>
<h4 id="三、Connector和Container的微妙关系"><a href="#三、Connector和Container的微妙关系" class="headerlink" title="三、Connector和Container的微妙关系"></a><strong>三、Connector和Container的微妙关系</strong></h4><p>由上述内容我们大致可以知道一个请求发送到<code>Tomcat</code>之后，首先经过<code>Service</code>然后会交给我们的<code>Connector</code>，<code>Connector</code>用于接收请求并将接收的请求封装为<code>Request</code>和<code>Response</code>来具体处理，<code>Request</code>和<code>Response</code>封装完之后再交由<code>Container</code>进行处理，<code>Container</code>处理完请求之后再返回给<code>Connector</code>，最后在由<code>Connector</code>通过<code>Socket</code>将处理的结果返回给客户端，这样整个请求的就处理完了！</p>
<p><code>Connector</code>最底层使用的是<code>Socket</code>来进行连接的，<code>Request</code>和<code>Response</code>是按照HTTP协议来封装的，所以<code>Connector</code>同时需要实现<code>TCP/IP</code>协议和<code>HTTP</code>协议！</p>
<p><code>Tomcat</code>既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下<code>Connector</code>！</p>
<h4 id="四、Connector架构分析"><a href="#四、Connector架构分析" class="headerlink" title="四、Connector架构分析"></a><strong>四、Connector架构分析</strong></h4><p><code>Connector</code>用于接受请求并将请求封装成<code>Request</code>和<code>Response</code>，然后交给<code>Container</code>进行处理，<code>Container</code>处理完之后在交给<code>Connector</code>返回给客户端。</p>
<p>因此，我们可以把<code>Connector</code>分为四个方面进行理解：</p>
<p>（1）<code>Connector</code>如何接受请求的？ </p>
<p>（2）如何将请求封装成<code>Request</code>和<code>Response</code>的？ </p>
<p>（3）封装完之后的<code>Request</code>和<code>Response</code>如何交给<code>Container</code>进行处理的？ </p>
<p>（4）<code>Container</code>处理完之后如何交给<code>Connector</code>并返回给客户端的？</p>
<p>首先看一下<code>Connector</code>的结构图（图B），如下所示：</p>
<p><img src="http://static.cyblogs.com/b3o0gef7y5.png" alt="img"></p>
<p><code>Connector</code>就是使用<code>ProtocolHandler</code>来处理请求的，不同的<code>ProtocolHandler</code>代表不同的连接类型，比如：<code>Http11Protocol</code>使用的是普通<code>Socket</code>来连接的，<code>Http11NioProtocol</code>使用的是<code>NioSocket</code>来连接的。</p>
<p>其中<code>ProtocolHandler</code>由包含了三个部件：<code>Endpoint</code>、<code>Processor</code>、<code>Adapter</code>。</p>
<p>（1）<code>Endpoint</code>用来处理底层<code>Socket</code>的网络连接，<code>Processor</code>用于将<code>Endpoint</code>接收到的<code>Socket</code>封装成<code>Request</code>，<code>Adapter</code>用于将<code>Request</code>交给<code>Container</code>进行具体的处理。</p>
<p>（2）<code>Endpoint</code>由于是处理底层的<code>Socket</code>网络连接，因此<code>Endpoint</code>是用来实现<code>TCP/IP</code>协议的，而<code>Processor</code>用来实现<code>HTTP</code>协议的，<code>Adapter</code>将请求适配到<code>Servlet</code>容器进行具体的处理。</p>
<p>（3）<code>Endpoint</code>的抽象实现<code>AbstractEndpoint</code>里面定义的<code>Acceptor</code>和<code>AsyncTimeout</code>两个内部类和一个<code>Handler</code>接口。<code>Acceptor</code>用于监听请求，<code>AsyncTimeout</code>用于检查异步<code>Request</code>的超时，<code>Handler</code>用于处理接收到的<code>Socket</code>，在内部调用<code>Processor</code>进行处理。</p>
<p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下<code>Container</code>是如何进行处理的以及处理完之后是如何将处理完的结果返回给<code>Connector</code>的？</p>
<h4 id="五、Container架构分析"><a href="#五、Container架构分析" class="headerlink" title="五、Container架构分析"></a><strong>五、Container架构分析</strong></h4><p><code>Container</code>用于封装和管理<code>Servlet</code>，以及具体处理<code>Request</code>请求，在<code>Connector</code>内部包含了4个子容器，结构图如下（图C）：</p>
<p><img src="http://static.cyblogs.com/fk1p1et9di.png" alt="img"></p>
<p>4个子容器的作用分别是：</p>
<p>（1）<code>Engine</code>：引擎，用来管理多个站点，一个<code>Service</code>最多只能有一个<code>Engine</code>； </p>
<p>（2）<code>Host</code>：代表一个站点，也可以叫虚拟主机，通过配置<code>Host</code>就可以添加站点； </p>
<p>（3）<code>Context</code>：代表一个应用程序，对应着平时开发的一套程序，或者一个<code>WEB-INF</code>目录以及下面的<code>web.xml</code>文件； </p>
<p>（4）<code>Wrapper</code>：每一<code>Wrapper</code>封装着一个<code>Servlet</code>；</p>
<p>下面找一个<code>Tomcat</code>的文件目录对照一下，如下图所示：</p>
<p><img src="http://static.cyblogs.com/w37kwebdoy.png" alt="img"></p>
<p><code>Context</code>和<code>Host</code>的区别是<code>Context</code>表示一个应用，我们的<code>Tomcat</code>中默认的配置下<code>webapps</code>下的每一个文件夹目录都是一个<code>Context</code>，其中<code>ROOT</code>目录中存放着主应用，其他目录存放着子应用，而整个<code>webapps</code>就是一个<code>Host</code>站点。</p>
<p>我们访问应用<code>Context</code>的时候，如果是<code>ROOT</code>下的则直接使用域名就可以访问，例如：<a href="http://www.ledouit.com,如果是`Host（webapps）`下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。" target="_blank" rel="noopener">www.ledouit.com,如果是`Host（webapps）`下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</a></p>
<p>看到这里我们知道<code>Container</code>是什么，但是还是不知道<code>Container</code>是如何进行处理的以及处理完之后是如何将处理完的结果返回给<code>Connector</code>的？别急！下边就开始探讨一下<code>Container</code>是如何进行处理的！</p>
<h4 id="六、Container如何处理请求的"><a href="#六、Container如何处理请求的" class="headerlink" title="六、Container如何处理请求的"></a><strong>六、Container如何处理请求的</strong></h4><p><code>Container</code>处理请求是使用<code>Pipeline-Value</code>管道来处理的！</p>
<p><code>Pipeline-Value</code>是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。</p>
<p><img src="http://static.cyblogs.com/y6ugeww863.jpg" alt="img"></p>
<p>但是！<code>Pipeline-Value</code>使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p>
<p>（1）每个<code>Pipeline</code>都有特定的<code>Value</code>，而且是在管道的最后一个执行，这个<code>Value</code>叫做<code>BaseValue</code>，<code>BaseValue</code>是不可删除的；</p>
<p>（2）在上层容器的管道的<code>BaseValue</code>中会调用下层容器的管道。</p>
<p>我们知道<code>Container</code>包含四个子容器，而这四个子容器对应的<code>BaseValue</code>分别在：<code>StandardEngineValue</code>、<code>StandardHostValue</code>、<code>StandardContextValue</code>、<code>StandardWrapperValue</code>。</p>
<p><code>Pipeline</code>的处理流程图如下（图D）：</p>
<p><img src="http://static.cyblogs.com/6bewzizid7.png" alt="img"></p>
<p>（1）<code>Connector</code>在接收到请求后会首先调用最顶层容器的<code>Pipeline</code>来处理，这里的最顶层容器的<code>Pipeline</code>就是<code>EnginePipeline</code>（<code>Engine</code>的管道）；</p>
<p>（2）在<code>Engine</code>的管道中依次会执行<code>EngineValue1</code>、<code>EngineValue2</code>等等，最后会执行<code>StandardEngineValue</code>，在<code>StandardEngineValue</code>中会调用<code>Host</code>管道，然后再依次执行<code>Host</code>的<code>HostValue1</code>、<code>HostValue2</code>等，最后在执行<code>StandardHostValue</code>，然后再依次调用<code>Context</code>的管道和<code>Wrapper</code>的管道，最后执行到<code>StandardWrapperValue</code>。</p>
<p>（3）当执行到<code>StandardWrapperValue</code>的时候，会在<code>StandardWrapperValue</code>中创建<code>FilterChain</code>，并调用其<code>doFilter</code>方法来处理请求，这个<code>FilterChain</code>包含着我们配置的与请求相匹配的<code>Filter</code>和<code>Servlet</code>，其<code>doFilter</code>方法会依次调用所有的<code>Filter</code>的<code>doFilter</code>方法和<code>Servlet</code>的<code>service</code>方法，这样请求就得到了处理！</p>
<p>（4）当所有的<code>Pipeline-Value</code>都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给<code>Connector</code>了，<code>Connector</code>在通过<code>Socket</code>的方式将结果返回给客户端。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>至此，我们已经对<code>Tomcat</code>的整体架构有了大致的了解，从图<code>A、B、C、D</code>可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下<code>Tomcat</code>，上面的内容你能脱口而出吗？当你能够脱口而出的时候，这位面试官一定会对你刮目相看的！</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://cloud.tencent.com/developer/article/1181587" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1181587</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员<code>Vernon</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/Vernon.jpeg" alt="Vernon"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>神器的布隆过滤器</title>
    <url>/2020/06/03/2020/06/%E7%A5%9E%E5%99%A8%E7%9A%84%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h4 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a><strong>什么是布隆过滤器</strong></h4><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构<code>（probabilistic data structure）</code>，特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p>
<p>相比于传统的 <code>List</code>、<code>Set</code>、<code>Map</code> 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h4><h5 id="HashMap-的问题"><a href="#HashMap-的问题" class="headerlink" title="HashMap 的问题"></a>HashMap 的问题</h5><p>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 <code>HashMap</code> 吧，确实可以将值映射到 <code>HashMap</code> 的 <code>Key</code>，然后可以在 <code>O(1)</code> 的时间复杂度内返回结果，效率奇高。但是 <code>HashMap</code> 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 <code>HashMap</code> 占据的内存大小就变得很可观了。</p>
<p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 <code>HashMap</code> 的时候，也会存在问题。</p>
<p><strong>布隆过滤器数据结构</strong></p>
<p>布隆过滤器是一个 <code>bit</code> 向量或者说 <code>bit</code> 数组，长这样：</p>
<p><img src="http://static.cyblogs.com/QQ20200618-210117@2x.jpg" alt="http://static.cyblogs.com/QQ20200618-210117@2x.jpg"></p>
<p>数组里面的值就只会存在<code>true</code>与<code>false</code>。</p>
<p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 <code>bit</code> 位置 <code>1</code>，例如针对值 “<code>baidu</code>” 和三个不同的哈希函数分别生成了哈希值则上图转变为：</p>
<p><img src="http://static.cyblogs.com/QQ20200618-210604@2x.jpg" alt="http://static.cyblogs.com/QQ20200618-210604@2x.jpg"></p>
<p>而当我们需要查询 “<code>baidu</code>” 这个值是否存在的话，那么哈希函数必然会返回图中的<code>3</code>个<code>bit</code>位，然后我们检查发现这三个 <code>bit</code> 位上的值均为 <code>1</code>，那么我们可以说 “<code>baidu</code>” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p>
<p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 <code>1</code> 的 <code>bit</code> 位也会越来越多，这样某个值 “<code>taobao</code>” 即使没有被存储过，但是万一哈希函数返回的三个 <code>bit</code> 位都被其他值置为了 <code>1</code> ，那么程序还是会判断 “<code>taobao</code>” 这个值存在。</p>
<h4 id="支持删除么"><a href="#支持删除么" class="headerlink" title="支持删除么"></a>支持删除么</h4><p>传统的布隆过滤器并不支持删除操作。但是名为 Counting Bloom filter 的变种可以用来测试元素计数个数是否绝对小于某个阈值，它支持元素删除。可以参考文章 Counting Bloom Filter 的原理和实现：<a href="https://cloud.tencent.com/developer/article/1136056" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1136056</a></p>
<p>Guava里的布隆过滤器：com.google.common.hash.BloomFilter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可能存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategy.mightContain(object, funnel, numHashFunctions, bits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放入值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategy.put(object, funnel, numHashFunctions, bits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何选择哈希函数个数和布隆过滤器长度"><a href="#如何选择哈希函数个数和布隆过滤器长度" class="headerlink" title="如何选择哈希函数个数和布隆过滤器长度"></a>如何选择哈希函数个数和布隆过滤器长度</h4><p>很显然，过小的布隆过滤器很快所有的 <code>bit</code> 位均为 <code>1</code>，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p>
<p>另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 <code>bit</code> 位置位 <code>1</code> 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p>
<p><img src="http://static.cyblogs.com/QQ20200618-212220@2x.jpg" alt="http://static.cyblogs.com/QQ20200618-212220@2x.jpg"></p>
<p>我们可以参考网站给的一个参考值：<a href="https://krisives.github.io/bloom-calculator/" target="_blank" rel="noopener">https://krisives.github.io/bloom-calculator/</a></p>
<p><img src="http://static.cyblogs.com/QQ20200618-212520@2x.jpg" alt="http://static.cyblogs.com/QQ20200618-212520@2x.jpg"></p>
<p>比如：我们有<code>1000</code>的数量，误判率是<code>0.1</code>，那么需要<code>3.32</code>个<code>hash</code>函数，位的长度为<code>4793</code>。</p>
<h4 id="Redis-BloomFilter实践"><a href="#Redis-BloomFilter实践" class="headerlink" title="Redis-BloomFilter实践"></a>Redis-BloomFilter实践</h4><p><code>Redis</code>在<code>4.0</code>版本推出了 <code>module</code> 的形式，可以将 <code>module</code> 作为插件额外实现<code>Redis</code>的一些功能。官网推荐了一个 <code>RedisBloom</code> 作为 <code>Redis</code> 布隆过滤器的 <code>Module</code>。</p>
<p><code>RedisBloom</code>需要先进行安装，推荐使用<code>Docker</code>进行安装，简单方便:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redislabs/rebloom:latest</span><br><span class="line">docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span><br><span class="line">docker exec -it redis-redisbloom bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-cli</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 127.0.0.1:6379&gt; bf.add tiancheng hello</span></span><br></pre></td></tr></table></figure>

<p>熟悉一下布隆过滤器基本指令:</p>
<ul>
<li><code>bf.add</code> 添加元素到布隆过滤器</li>
<li><code>bf.exists</code> 判断元素是否在布隆过滤器</li>
<li><code>bf.madd</code> 添加多个元素到布隆过滤器，<code>bf.add</code>只能添加一个</li>
<li><code>bf.mexists</code> 判断多个元素是否在布隆过滤器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bf.add tiancheng tc01</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add tiancheng tc02</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add tiancheng tc03</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists tiancheng tc01</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists tiancheng tc02</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists tiancheng tc03</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists tiancheng tc04</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bf.madd tiancheng tc05 tc06 tc07</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br><span class="line">3) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.mexists tiancheng tc05 tc06 tc07 tc08</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br><span class="line">3) (integer) 1</span><br><span class="line">4) (integer) 0</span><br></pre></td></tr></table></figure>

<h4 id="Redis-Bitmap实现简单的布隆过滤器"><a href="#Redis-Bitmap实现简单的布隆过滤器" class="headerlink" title="Redis Bitmap实现简单的布隆过滤器"></a>Redis Bitmap实现简单的布隆过滤器</h4><p><code>Bitmap</code>在<code>Redis</code>中并不是一个单独的数据类型，而是由字符串类型（<code>Redis</code>内部称<code>Simple Dynamic String，SDS</code>）之上定义的与比特相关的操作实现的，此时<code>SDS</code>就被当做位数组了。下面是在<code>redis-cli</code>中使用<code>getbit</code>和<code>setbit</code>指令的操作示例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 字符串<span class="string">"meow"</span>的二进制表示：01101101 01100101 01101111 01110111</span></span><br><span class="line">es1:19000&gt; set bitmap_cat "meow"</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最低位下标为0。取得第3位的比特（0）</span></span><br><span class="line">es1:19000&gt; getbit bitmap_cat 3</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得第23位的比特（1）</span></span><br><span class="line">es1:19000&gt; getbit bitmap_cat 23</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将第7位设为0</span></span><br><span class="line">es1:19000&gt; setbit bitmap_cat 7 0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将第14位设为1</span></span><br><span class="line">es1:19000&gt; setbit bitmap_cat 14 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改过后的字符串变成了<span class="string">"lgow"</span></span></span><br><span class="line">es1:19000&gt; get bitmap_cat</span><br><span class="line">"lgow"</span><br></pre></td></tr></table></figure>

<p><code>Redis</code>的<code>Bitmap</code>是自动扩容的，亦即<code>get/set</code>到高位时，就会主动填充<code>0</code>。此外，还有<code>bitcount</code>指令用于计算特定字节范围内<code>1</code>的个数，<code>bitop</code>指令用来执行位运算（支持<code>and</code>、<code>or</code>、<code>xor</code>和<code>not</code>）。相应的用法可以查询<code>Redis</code>官方文档等。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.jasondavies.com/bloomfilter/" target="_blank" rel="noopener">https://www.jasondavies.com/bloomfilter/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/43263751" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43263751</a></li>
<li><a href="https://www.jianshu.com/p/c2defe549b40" target="_blank" rel="noopener">https://www.jianshu.com/p/c2defe549b40</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>布隆过滤器</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>什么能力很重要，但大多数人却没有？</title>
    <url>/2020/07/30/2020/07/%E4%BB%80%E4%B9%88%E8%83%BD%E5%8A%9B%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%BD%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E5%8D%B4%E6%B2%A1%E6%9C%89%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="深度阅读的能力"><a href="#深度阅读的能力" class="headerlink" title="深度阅读的能力"></a>深度阅读的能力</h4><p>我敢保证，看完这个回答之前，就有很多人会划走。</p>
<p>这绝逼不是因为我这个回答写的太无趣，或者他们不同意我的某些观点，而是因为——<strong>他们看什么东西都是这样。</strong></p>
<p>他们根本不能沉浸式的阅读什么东西，一般超过几百字的内容就很少看了，除非是小黄文和超能力爽文。他们做的最多的是浮皮潦草的刷刷抖音、看看段子，稍微有点复杂的电影都看不下去，更何况那些晦涩枯燥的工具书了。</p>
<p>我不能说知乎用户就比抖音用户牛逼，但是经过我这些年的学习和生活，我发现能够全神贯注的阅读长篇文字，本身就是很强的一种能力，它能够轻而易举的影响到我们的学习效果和工作效果，它关乎到我们的注意力、记忆力、逻辑思维能力和理解能力。</p>
<p>你信也好，你不信也罢，越看书就会越聪明，一直看爽文、肥皂剧、抖音就会变得不善思考。</p>
<h4 id="自我认知能力"><a href="#自我认知能力" class="headerlink" title="自我认知能力"></a>自我认知能力</h4><p>不要觉得这个能力很菜，真没几个人有。</p>
<p>不服你可以冷静下来想想，你真的了解你自己么？你真的知道你自己在这个社会中处于怎样的一个阶层和水平么？如果你觉得你都了解，那我再问你一句，<strong>你的这些认知，都来源于哪里？</strong></p>
<p>其实你对自己的评价往往都来源于他人对你的反馈，所以人其实是很容易被环境和他人的评价所左右的，不要觉得你不可能进入传销，当你周围的环境和人全都变了，你得到的反馈就完全乱了，你自己就会失去对自己的认知。</p>
<p>而更值得注意的是，很多人并没有进入什么传销组织，但是却在他人的吹捧之中失去了对自己的判断，很多商家就是利用这一点，忽悠了不知多少人前赴后继的去送钱。</p>
<h4 id="持久且专注的坚持做一件事的能力"><a href="#持久且专注的坚持做一件事的能力" class="headerlink" title="持久且专注的坚持做一件事的能力"></a>持久且专注的坚持做一件事的能力</h4><p>其实这世界上绝大多数对未来很有意义的事情，短期内往往不会看到成效。比如健身、读书、早睡早起。你健身一天不会有八块腹肌，读一本书不能洞悉人性，早睡早起一天也不能容光焕发。</p>
<p>这些从长期看来对一个人有利的行为，不会像你刷抖音、看段子一样，短短一两分钟内就能够带给你刺激的感觉。</p>
<p>而且我相信所有的人都知道读书有好处，但问题就是读一本往往看不到效果，所以我一直觉得牛逼的人和普通人之间最大的差距就是——<strong>牛逼的人能在看不到回馈的情况下继续坚持下去，持续且专注的坚持下去。</strong></p>
<p>对于99%的普通人来说，长期执着于一件事，持续深耕，五年十年后，你就会得到巨大的回报，并且成为这个领域的专家。</p>
<h4 id="控制情绪的能力"><a href="#控制情绪的能力" class="headerlink" title="控制情绪的能力"></a>控制情绪的能力</h4><p>每个人的生活中，都有一大半决策是在情绪的影响下做出的，而且往往这样做出的决策都不是最佳决策。只要你能在情绪失控的时候，提醒自己不要做出决策，让自己平复一下，就能解决很多麻烦事儿。</p>
<p>生而为人，必然有很多事情让你很愤怒、很悲伤、很焦躁，但是我想说的是，你要学会别跟自己过不去，让自己活的轻松点！</p>
<p>这本身就是很强悍的一种能力，会影响自己的生活，并影响身边人对你的看法。</p>
<h4 id="掌控自己欲望的能力"><a href="#掌控自己欲望的能力" class="headerlink" title="掌控自己欲望的能力"></a>掌控自己欲望的能力</h4><p>很多人都以为自律是限制自己的欲望，据我所知，恰恰相反，自律应该是更好的分配自己的欲望。</p>
<p>你觉得健身的人是没有食欲的人么？错了，他们只是为了满足自己“拥有好身材”的长期欲望而放弃了满足眼前美食的欲望而已。</p>
<p>所以一个真正长期自律的人实际上就是对自己欲望进行更好的规划的分配的人。</p>
<h4 id="用语言表达自己思想的能力"><a href="#用语言表达自己思想的能力" class="headerlink" title="用语言表达自己思想的能力"></a>用语言表达自己思想的能力</h4><p>知乎有一个很重要的特点就是会把质量好的回答都排在前面，你看多了就会觉得所有的人都很牛逼，但是你可以做这么一个实验：</p>
<p>先给我这个回答点个赞（别走丢了），然后随便翻几个情感、生活类的大问题，几千个回答的那种，按时间排序，再找找那些0赞的回答看一下，长长一段文字，要么在写自己家里的琐事，要么是生活中遇到的不良情绪，要么试图用自己蹩脚的生活经验来总结人生的大道理，读完以后再回来看看我这个回答我自己都觉得我是个大文豪。</p>
<p>不光如此，就连一个简单的提问，很多人也能问的乱七八糟，完全没有逻辑顺序，描述抓不住重点，最后连自己想要问什么都说不明白。</p>
<p>连话都说不明白，你说还谈什么能力？</p>
<h4 id="共情能力"><a href="#共情能力" class="headerlink" title="共情能力"></a>共情能力</h4><p>为什么经常有人会被说情商低？据我所知不是因为他们脑子笨或者不会说话，本质上是因为<strong>他不能体会到对方的情绪和感觉</strong>，不能通过对方的描述、表情、动作而产生共情。</p>
<p>你说人家在那儿跟你诉着苦，说的就差哭出来了，你突然get到了笑点，对着别人哈哈大笑，你说这是不是缺？</p>
<p>你女朋友含情脉脉的看着你，说她冷，结果你说，“活该，谁让你穿那么点，瞅你冻得那逼出”，我就问你抗不抗揍吧。</p>
<h4 id="不要脸的能力"><a href="#不要脸的能力" class="headerlink" title="不要脸的能力"></a>不要脸的能力</h4><p>别觉得这不算什么能力，我很严肃的告诉你，这能力特别牛逼，而且非常重要。</p>
<p>不要脸这个词，表面上是骂人，其实你仔细想想，这里面还包含了一个人对外界评判的不在意，对别人眼光的不care，甚至还能够体现出一个人的大局观。</p>
<p>你有多少次想跟领导去提要求最后却打了退堂鼓？你有多少次内心一万只草泥马奔腾而过但是嘴上却答应了别人的请求？你有多少次因为对方说咱们这么好的交情而抹不开面子？</p>
<p>多少因为面子天天加班的，因为面子【顺路】帮别人送东西的，因为面子给别人办事儿丢了饭碗的，还有因为面子借给别人钱要不回来的。</p>
<h4 id="接纳不同观点的能力"><a href="#接纳不同观点的能力" class="headerlink" title="接纳不同观点的能力"></a>接纳不同观点的能力</h4><p>你有没有想过，为什么现在满大街都是教别人说话的和提高情商的书籍？但是却没有多少书是教人说大实话的？</p>
<p><strong>因为很多人根本就听不下那些难听的大实话！</strong></p>
<p>哪怕你是真的为他好，他也不爱听。</p>
<p>比如一个女生要买一件衣服，你觉得很难看，她穿上以后像块被马蹄子踩了的奶油蛋糕，但是她自己还觉得自己美美哒。</p>
<p>如果她能心平气和的接纳你的不同观点，显然对她有好处，她就不至于买那么难看的衣服，不至于乱花钱。</p>
<p>但事实是大部分人总是先入为主，根本听不进去不同观点，别人的好言相劝大多都被当做情商低和柠檬精。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.zhihu.com/question/305507128/answer/1073167931" target="_blank" rel="noopener">https://www.zhihu.com/question/305507128/answer/1073167931</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>随感</category>
      </categories>
      <tags>
        <tag>随感</tag>
      </tags>
  </entry>
  <entry>
    <title>了解Eureka工作原理</title>
    <url>/2020/08/03/2020/08/%E4%BA%86%E8%A7%A3Eureka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="Eureka-工作原理"><a href="#Eureka-工作原理" class="headerlink" title="Eureka 工作原理"></a>Eureka 工作原理</h4><p><code>Eureka</code> 作为 <code>Spring Cloud</code> 体系中最核心、默认的注册中心组件，研究它的运行机制，有助于我们在工作中更好地使用它。</p>
<h4 id="Eureka-核心概念"><a href="#Eureka-核心概念" class="headerlink" title="Eureka 核心概念"></a>Eureka 核心概念</h4><p>回到上节的服务注册调用示意图，服务提供者和服务的消费者，本质上也是 <code>Eureka Client</code> 角色。整体上可以分为两个主体：<code>Eureka Server</code> 和 <code>Eureka Client</code>。<br><img src="http://static.cyblogs.com/20190703102014756.png" alt="http://static.cyblogs.com/20190703102014756.png"></p>
<p><strong>Eureka Server：注册中心服务端</strong></p>
<p>注册中心服务端主要对外提供了三个功能：</p>
<p><strong>服务注册</strong><br>服务提供者启动时，会通过 <code>Eureka Client</code> 向 <code>Eureka Server</code> 注册信息，<code>Eureka Server</code> 会存储该服务的信息，<code>Eureka Server</code> 内部有二层缓存机制来维护整个注册表</p>
<p><strong>提供注册表</strong><br>服务消费者在调用服务时，如果 <code>Eureka Client</code> 没有缓存注册表的话，会从 <code>Eureka Server</code> 获取最新的注册表</p>
<p><strong>同步状态</strong><br><code>Eureka Client</code> 通过注册、心跳机制和 <code>Eureka Server</code> 同步当前客户端的状态。</p>
<p><strong>Eureka Client：注册中心客户端</strong><br><code>Eureka Client</code> 是一个 <code>Java</code> 客户端，用于简化与 <code>Eureka Server</code> 的交互。<code>Eureka Client</code> 会拉取、更新和缓存 <code>Eureka Server</code> 中的信息。因此当所有的 <code>Eureka Server</code> 节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者，但是当服务有更改的时候会出现信息不一致。</p>
<p><strong>Register: 服务注册</strong><br>服务的提供者，将自身注册到注册中心，服务提供者也是一个 <code>Eureka Client</code>。当 <code>Eureka Client</code> 向 <code>Eureka Server</code> 注册时，它提供自身的元数据，比如 IP 地址、端口，运行状况指示符 URL，主页等。</p>
<p><strong>Renew: 服务续约</strong><br><code>Eureka Client</code> 会每隔 30 秒发送一次心跳来续约。 通过续约来告知 <code>Eureka Server</code> 该 <code>Eureka Client</code> 运行正常，没有出现问题。 默认情况下，如果 <code>Eureka Server</code> 在 90 秒内没有收到 <code>Eureka Client</code> 的续约，<code>Server</code> 端会将实例从其注册表中删除，此时间可配置，一般情况不建议更改。</p>
<p><strong>服务续约的两个重要属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">服务续约任务的调用间隔时间，默认为<span class="number">30</span>秒</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=<span class="number">30</span></span><br><span class="line"></span><br><span class="line">服务失效的时间，默认为<span class="number">90</span>秒。</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=<span class="number">90</span></span><br></pre></td></tr></table></figure>

<p><strong>Eviction 服务剔除</strong><br>当 <code>Eureka Client</code> 和 <code>Eureka Server</code> 不再有心跳时，<code>Eureka Server</code> 会将该服务实例从服务注册列表中删除，即服务剔除。</p>
<p><strong>Cancel: 服务下线</strong><br><code>Eureka Client</code> 在程序关闭时向 <code>Eureka Server</code> 发送取消请求。 发送请求后，该客户端实例信息将从 <code>Eureka Server</code> 的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiscoveryManager.getInstance().shutdownComponent()；</span><br></pre></td></tr></table></figure>

<p><strong>GetRegisty: 获取注册列表信息</strong><br><code>Eureka Client</code> 从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 <code>Eureka Client</code> 的缓存信息不同，<code>Eureka Client</code> 自动处理。</p>
<p>如果由于某种原因导致注册列表信息不能及时匹配，<code>Eureka Client</code> 则会重新获取整个注册表信息。 <code>Eureka Server</code> 缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。<code>Eureka Client</code> 和 <code>Eureka Server</code> 可以使用 <code>JSON/XML</code> 格式进行通讯。在默认情况下 <code>Eureka Client</code> 使用压缩 <code>JSON</code> 格式来获取注册列表的信息。</p>
<p><strong>获取服务是服务消费者的基础，所以必有两个重要参数需要注意：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 启用服务消费者从注册中心拉取服务列表的功能</span><br><span class="line">eureka.client.fetch-registry=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"># 设置服务消费者从注册中心拉取服务列表的间隔</span><br><span class="line">eureka.client.registry-fetch-interval-seconds=<span class="number">30</span></span><br></pre></td></tr></table></figure>

<p><strong>Remote Call: 远程调用</strong><br>当 <code>Eureka Client</code> 从注册中心获取到服务提供者信息后，就可以通过 <code>Http</code> 请求调用对应的服务；服务提供者有多个时，<code>Eureka Client</code> 客户端会通过 <code>Ribbon</code> 自动进行负载均衡。</p>
<h4 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h4><p>默认情况下，如果 <code>Eureka Server</code> 在一定的 90s 内没有接收到某个微服务实例的心跳，会注销该实例。但是在微服务架构下服务之间通常都是跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，网络分区故障，导致此实例被注销。</p>
<p>固定时间内大量实例被注销，可能会严重威胁整个微服务架构的可用性。为了解决这个问题，<code>Eureka</code> 开发了自我保护机制，那么什么是自我保护机制呢？</p>
<p><code>Eureka Server</code> 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，<code>Eureka Server</code> 即会进入自我保护机制。</p>
<p><strong>Eureka Server 触发自我保护机制后，页面会出现提示：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190703103514416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F3ZTg2MzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>Eureka Server 进入自我保护机制，会出现以下几种情况：</strong></p>
<ul>
<li>(1) <code>Eureka</code> 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li>
<li>(2)<code>Eureka</code> 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</li>
<li>(3)当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li>
</ul>
<p><code>Eureka</code> 自我保护机制是为了防止误杀服务而提供的一个机制。当个别客户端出现心跳失联时，则认为是客户端的问题，剔除掉客户端；当 <code>Eureka</code> 捕获到大量的心跳失败时，则认为可能是网络问题，进入自我保护机制；当客户端心跳恢复时，<code>Eureka</code> 会自动退出自我保护机制。</p>
<p>如果在保护期内刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，即会调用失败。对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。</p>
<p><strong>通过在 Eureka Server 配置如下参数，开启或者关闭保护机制，生产环境建议打开：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka.server.enable-self-preservation=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h4 id="Eureka-集群原理"><a href="#Eureka-集群原理" class="headerlink" title="Eureka 集群原理"></a>Eureka 集群原理</h4><p>再来看看 Eureka 集群的工作原理。我们假设有三台 <code>Eureka Server</code> 组成的集群，第一台 <code>Eureka Server</code> 在北京机房，另外两台 <code>Eureka Server</code> 在深圳和西安机房。这样三台 <code>Eureka Server</code> 就组建成了一个跨区域的高可用集群，只要三个地方的任意一个机房不出现问题，都不会影响整个架构的稳定性。</p>
<p><img src="http://static.cyblogs.com/20190703103823398.png" alt="http://static.cyblogs.com/20190703103823398.png"></p>
<p>从图中可以看出 <code>Eureka Server</code> 集群相互之间通过 <code>Replicate</code> 来同步数据，相互之间不区分主节点和从节点，所有的节点都是平等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的 <code>serviceUrl</code> 指向其他节点。</p>
<p>如果某台 <code>Eureka Server</code> 宕机，<code>Eureka Client</code> 的请求会自动切换到新的 <code>Eureka Server</code> 节点。当宕机的服务器重新恢复后，<code>Eureka</code> 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它 <code>Eureka Server</code> 当前所知的所有节点中。</p>
<p>另外 <code>Eureka Server</code> 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个 <code>Eureka Server</code> 同时也是 <code>Eureka Client</code>，多个 <code>Eureka Server</code> 之间通过 <code>P2P</code> 的方式完成服务注册表的同步。</p>
<p><code>Eureka Server</code> 集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。</p>
<p><strong>Eureka 分区</strong><br><code>Eureka</code> 提供了 <code>Region</code> 和 <code>Zone</code> 两个概念来进行分区，这两个概念均来自于亚马逊的 <code>AWS</code>:</p>
<ul>
<li>region：可以理解为地理上的不同区域，比如亚洲地区，中国区或者深圳等等。没有具体大小的限制。根据项目具体的情况，可以自行合理划分 region。</li>
<li>zone：可以简单理解为 region 内的具体机房，比如说 region 划分为深圳，然后深圳有两个机房，就可以在此 region 之下划分出 zone1、zone2 两个 zone。</li>
</ul>
<p>上图中的 <code>us-east-1c</code>、<code>us-east-1d</code>、<code>us-east-1e</code> 就代表了不同的 <code>Zone</code>。<code>Zone</code> 内的 <code>Eureka Client</code> 优先和 <code>Zone</code> 内的 <code>Eureka Server</code> 进行心跳同步，同样调用端优先在 <code>Zone</code> 内的 <code>Eureka Server</code> 获取服务列表，当 <code>Zone</code> 内的 <code>Eureka Server</code> 挂掉之后，才会从别的 <code>Zone</code> 中获取信息。</p>
<p><strong>Eurka 保证 AP</strong></p>
<p><code>Eureka Server</code> 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 <code>Eureka Client</code> 在向某个 <code>Eureka</code> 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台 <code>Eureka Server</code> 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p>
<h4 id="Eurka-工作流程"><a href="#Eurka-工作流程" class="headerlink" title="Eurka 工作流程"></a>Eurka 工作流程</h4><p>了解完 <code>Eureka</code> 核心概念，自我保护机制，以及集群内的工作原理后，我们来整体梳理一下 <code>Eureka</code> 的工作流程：</p>
<p>1、<code>Eureka Server</code> 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 <code>Replicate</code> 同步注册表，每个 <code>Eureka Server</code> 都存在独立完整的服务注册表信息</p>
<p>2、<code>Eureka Client</code> 启动时根据配置的 <code>Eureka Server</code> 地址去注册中心注册服务</p>
<p>3、<code>Eureka Client</code> 会每 30s 向 <code>Eureka Server</code> 发送一次心跳请求，证明客户端服务正常</p>
<p>4、当 <code>Eureka Server</code> 90s 内没有收到 <code>Eureka Client</code> 的心跳，注册中心则认为该节点失效，会注销该实例</p>
<p>5、单位时间内 <code>Eureka Server</code> 统计到有大量的 <code>Eureka Client</code> 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端</p>
<p>6、当 <code>Eureka Client</code> 心跳请求恢复正常之后，<code>Eureka Server</code> 自动退出自我保护模式</p>
<p>7、<code>Eureka Client</code> 定时全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地</p>
<p>8、服务调用时，<code>Eureka Client</code> 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存</p>
<p>9、<code>Eureka Client</code> 获取到目标服务器信息，发起服务调用</p>
<p>10、<code>Eureka Client</code> 程序关闭时向 <code>Eureka Server</code> 发送取消请求，<code>Eureka Server</code> 将实例从注册表中删除</p>
<p>讲了 <code>Eureka</code> 核心概念、<code>Eureka</code> 自我保护机制和 <code>Eureka</code> 集群原理。通过分析 <code>Eureka</code> 工作原理，我可以明显地感觉到 <code>Eureka</code> 的设计之巧妙，通过一些列的机制，完美地解决了注册中心的稳定性和高可用性。</p>
<p><code>Eureka</code> 为了保障注册中心的高可用性，容忍了数据的非强一致性，服务节点间的数据可能不一致， <code>Client-Server</code> 间的数据可能不一致。比较适合跨越多机房、对注册中心服务可用性要求较高的使用场景。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/qwe86314/article/details/94552801" target="_blank" rel="noopener">https://blog.csdn.net/qwe86314/article/details/94552801</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>注册中心</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>注册中心</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis保存一个用户信息是用String还是Hash？</title>
    <url>/2020/08/14/2020/08/Redis%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%98%AF%E7%94%A8String%E8%BF%98%E6%98%AFHash%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>如果用普通的<code>key/value</code>结构来存储，主要有以下2种存储方式：</p>
<p>第一种方式将用户<code>ID</code>作为查找<code>key</code>,把其他信息封装成一个对象以序列化的方式存储，</p>
<p> 如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set u001 "李三,18,20010101" </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get u001</span><br><span class="line">"\xe6\x9d\x8e\xe4\xb8\x89,18,20010101"</span><br></pre></td></tr></table></figure>

<p> 这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入<code>CAS</code>等复杂问题。</p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>第二种方法是这个用户信息对象有多少成员就存成多少个<code>key-value</code>对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，</p>
<p> 如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mset user:001:name "李三" user:001:age 18 user:001:birthday "20010101"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get user:001:name</span><br><span class="line">"\xe6\x9d\x8e\xe4\xb8\x89"</span><br><span class="line">127.0.0.1:6379&gt; get user:001:age</span><br><span class="line">"18"</span><br><span class="line">127.0.0.1:6379&gt; get user:001:birthday</span><br><span class="line">"20010101"</span><br></pre></td></tr></table></figure>

<p> 虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。</p>
<h4 id="最好的办法"><a href="#最好的办法" class="headerlink" title="最好的办法"></a>最好的办法</h4><p>那么<code>Redis</code>提供的<code>Hash</code>很好的解决了这个问题，<code>Redis</code>的<code>Hash</code>实际是内部存储的<code>Value</code>为一个<code>HashMap</code>，</p>
<p> 并提供了直接存取这个<code>Map</code>成员的接口，</p>
<p> 如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:001 name "李三" age 18 birthday "20010101"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001</span><br><span class="line">1) "name"</span><br><span class="line">2) "\xe6\x9d\x8e\xe4\xb8\x89"</span><br><span class="line">3) "age"</span><br><span class="line">4) "18"</span><br><span class="line">5) "birthday"</span><br><span class="line">6) "20010101"</span><br><span class="line">127.0.0.1:6379&gt; hget user:001 age</span><br><span class="line">"18"</span><br></pre></td></tr></table></figure>

<p>也就是说，<code>Key</code>仍然是用户<code>ID</code>,<code>value</code>是一个<code>Map</code>，这个<code>Map</code>的<code>key</code>是成员的属性名，<code>value</code>是属性值， 这样对数据的修改和存取都可以直接通过其内部<code>Map</code>的<code>Key</code>(<code>Redis</code>里称内部<code>Map</code>的<code>key</code>为<code>field</code>), 也就是通过</p>
<p> <code>key</code>(用户ID) + <code>field</code>(属性标签) 操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/Dustin_CDS/article/details/79701975" target="_blank" rel="noopener">https://blog.csdn.net/Dustin_CDS/article/details/79701975</a></li>
<li><a href="https://www.runoob.com/redis/redis-hashes.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-hashes.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>新版IDEA 2020.1碰到的一个小坑</title>
    <url>/2020/11/07/2020/10/%E6%96%B0%E7%89%88IDEA%202020.1%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</url>
    <content><![CDATA[<p>使用新版idea创建了一个springboot项目，运行build时发生如下报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Error:(<span class="number">3</span>, <span class="number">32</span>) java: 程序包org.springframework.boot不存在</span><br><span class="line">Error:(<span class="number">4</span>, <span class="number">46</span>) java: 程序包org.springframework.boot.autoconfigure不存在</span><br><span class="line">Error:(<span class="number">5</span>, <span class="number">40</span>) java: 程序包org.springframework.boot.builder不存在</span><br><span class="line">Error:(<span class="number">6</span>, <span class="number">52</span>) java: 程序包org.springframework.boot.web.servlet.support不存在</span><br><span class="line">Error:(<span class="number">9</span>, <span class="number">34</span>) java: 找不到符号</span><br><span class="line">符号: 类 SpringBootServletInitializer</span><br></pre></td></tr></table></figure>

<p><img src="http://static.cyblogs.com/QQ20201107-080822@2x.jpg" alt="http://static.cyblogs.com/QQ20201107-080822@2x.jpg"></p>
<p>诡异的是，使用<code>mvn</code>打包却是正常的，能生成正确的jar并且能通过命令行启动 后来通过查阅资料得知新版<code>IDEA</code>需要在<code>Setting</code>里将 <code>delegate IDE build/run actions to Maven</code>勾选上即可。</p>
<p><img src="http://static.cyblogs.com/QQ20201107-081022@2x.jpg" alt="http://static.cyblogs.com/QQ20201107-081022@2x.jpg"></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>在解决这个问题的过程中，还了解到使用<code>spring-boot-maven-plugin</code>这个插件打的jar的结构会和普通插件<code>maven-jar-plugin</code>的有些不一样。<code>spring-boot-maven-plugin</code>将所有应用启动运行所需的jar全部包含进来了，具备独立运行的条件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>spring-boot-maven-plugin</code>打包的<code>jar</code>目录：</p>
<p><img src="http://static.cyblogs.com/QQ20201107-081147@2x.jpg" alt="http://static.cyblogs.com/QQ20201107-081147@2x.jpg"></p>
<p>而使用普通插件打包的结构如图：</p>
<p><img src="http://static.cyblogs.com/QQ20201107-081242@2x.jpg" alt="http://static.cyblogs.com/QQ20201107-081242@2x.jpg"></p>
<p>最后，这里补充一点。如果是你想在<code>IDEA</code>里面，不是通过<code>Maven</code>来依赖，这里就不用打钩，否则你每次都必须要<code>install</code>你的<code>jar</code>包到本地来。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://juejin.im/post/6844904177114562573" target="_blank" rel="noopener">https://juejin.im/post/6844904177114562573</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>注解@Autowired是如何实现的</title>
    <url>/2020/11/07/2020/11/%E6%B3%A8%E8%A7%A3@Autowired%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用<code>spring</code>开发时，进行配置主要有两种方式，一是<code>xml</code>的方式，二是<code>java config</code>的方式。<code>spring</code>技术自身也在不断的发展和改变，从当前<code>springboot</code>的火热程度来看，<code>java config</code>的应用是越来越广泛了，在使用<code>java config</code>的过程当中，我们不可避免的会有各种各样的注解打交道，其中，我们使用最多的注解应该就是<code>@Autowired</code>注解了。这个注解的功能就是为我们注入一个定义好的<code>bean</code>。那么，这个注解除了我们常用的属性注入方式之外还有哪些使用方式呢？它在代码层面又是怎么实现的呢？这是本篇文章着重想讨论的问题。</p>
<h4 id="Autowired注解用法"><a href="#Autowired注解用法" class="headerlink" title="@Autowired注解用法"></a>@Autowired注解用法</h4><p>在分析这个注解的实现原理之前，我们不妨先来回顾一下<code>@Autowired</code>注解的用法。</p>
<p>将<code>@Autowired</code>注解应用于构造函数，如以下示例所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>@Autowired</code>注释应用于<code>setter</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>@Autowired</code>注释应用于具有任意名称和多个参数的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span></span><br><span class="line"><span class="function"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您也可以将<code>@Autowired</code>应用于字段，或者将其与构造函数混合，如以下示例所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接应用于字段是我们使用的最多的一种方式，但是使用构造方法注入从代码层面却是更加好的，原因可以参考这篇博客：<a href="https://blog.csdn.net/topdeveloperr/article/details/81414039" target="_blank" rel="noopener">spring重点知识</a>。除此之外，还有以下不太常见的几种方式</p>
<p>将<code>@Autowired</code>注释添加到需要该类型数组的字段或方法，则<code>spring</code>会从<code>ApplicationContext</code>中搜寻符合指定类型的所有<code>bean</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组可以，我们可以马上举一反三，那容器也可以吗，答案是肯定的，下面是<code>set</code>以及<code>map</code>的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是<code>@Autowired</code>注解的主要使用方式，经常使用<code>spring</code>的话应该对其中常用的几种不会感到陌生。</p>
<h4 id="Autowired注解的作用到底是什么"><a href="#Autowired注解的作用到底是什么" class="headerlink" title="@Autowired注解的作用到底是什么?"></a>@Autowired注解的作用到底是什么?</h4><p><code>@Autowired</code>这个注解我们经常在使用，现在，我想问的是，它的作用到底是什么呢?</p>
<p>首先，我们从所属范围来看，事实上这个注解是属于<code>spring</code>的容器配置的一个注解，与它同属容器配置的注解还有：<code>@Required</code>,<code>@Primary</code>, <code>@Qualifier</code>等等。因此<code>@Autowired</code>注解是一个用于容器(<code>container</code>)配置的注解。</p>
<p>其次，我们可以直接从字面意思来看，<code>@autowired</code>注解来源于英文单词<code>autowire</code>,这个单词的意思是自动装配的意思。</p>
<p>自动装配又是什么意思？这个词语本来的意思是指的一些工业上的用机器代替人口，自动将一些需要完成的组装任务，或者别的一些任务完成。而在<code>spring</code>的世界当中，自动装配指的就是使用将<code>Spring</code>容器中的<code>bean</code>自动的和我们需要这个<code>bean</code>的类组装在一起。</p>
<p>因此，笔者个人对这个注解的作用下的定义就是:将<code>Spring</code>容器中的<code>bean</code>自动的和我们需要这个<code>bean</code>的类组装在一起协同使用。</p>
<p>接下来，我们就来看一下这个注解背后到底做了些什么工作。</p>
<h4 id="Autowired注解是如何实现的"><a href="#Autowired注解是如何实现的" class="headerlink" title="@Autowired注解是如何实现的"></a>@Autowired注解是如何实现的</h4><p>事实上，要回答这个问题必须先弄明白的是<code>java</code>是如何支持注解这样一个功能的。</p>
<p><code>java</code>的注解实现的核心技术是反射，让我们通过一些例子以及自己实现一个注解来理解它工作的原理。</p>
<h5 id="例子注解-Override"><a href="#例子注解-Override" class="headerlink" title="例子注解@Override"></a>例子注解@Override</h5><p><code>@Override</code>注解的定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Override</code>注解使用<code>java</code>官方提供的注解，它的定义里面并没有任何的实现逻辑。注意，所有的注解几乎都是这样的，<strong>注解只能是被看作元数据，它不包含任何业务逻辑</strong>。<strong>注解更像是一个标签，一个声明，表面被注释的这个地方，将具有某种特定的逻辑</strong>。</p>
<p>那么，问题接踵而至，注解本身不包含任何逻辑，那么注解的功能是如何实现的呢？答案必然是别的某个地方对这个注解做了实现。以<code>@Override</code>注解为例，他的功能是重写一个方法，而他的实现者就是<code>JVM</code>，<code>java</code>虚拟机，<code>java</code>虚拟机在字节码层面实现了这个功能。</p>
<p>但是对于开发人员，虚拟机的实现是无法控制的东西，也不能用于自定义注解。 所以，如果是我们自己想定义一个独一无二的注解的话，则我们需要自己为注解写一个实现逻辑，<strong>换言之，我们需要实现自己注解特定逻辑的功能</strong>。</p>
<h5 id="自己实现一个注解"><a href="#自己实现一个注解" class="headerlink" title="自己实现一个注解"></a>自己实现一个注解</h5><p>在自己写注解之前我们有一些基础知识需要掌握，那就是我们写注解这个功能首先是需要<code>java</code>支持的，<code>java</code>在<code>jdk5</code>当中支持了这一功能，<strong>并且在java.lang.annotation包中提供了四个注解，仅用于编写注解时使用</strong>，他们是：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><em>@Documented</em></strong></td>
<td>表明是否在java doc中添加Annotation</td>
</tr>
<tr>
<td><strong><em>@Retention</em></strong></td>
<td>定义注释应保留多长时间，即有效周期。有以下几种策略： <strong>RetentionPolicy.SOURCE</strong> - 在编译期间丢弃。 编译完成后，这些注释没有任何意义，因此它们不会写入字节码。 示例@Override，@ SuppressWarnings <strong>RetentionPolicy.CLASS</strong> - 在类加载期间丢弃。 在进行字节码级后处理时很有用。 有点令人惊讶的是，这是默认值。 <strong>RetentionPolicy.RUNTIME</strong> - 不要丢弃。 注释应该可以在运行时进行反射。 这是我们通常用于自定义注释的内容。</td>
</tr>
<tr>
<td><strong><em>@Target</em></strong></td>
<td>指定可以放置注解的位置。 如果不指定，则可以将注解放在任何位置。若我们只想要其中几个，则需要定义对应的几个。下面是这8个属性:ElementType.TYPE（类，接口，枚举）ElementType.FIELD（实例变量）ElementType.METHODElementType.PARAMETERElementType.CONSTRUCTORElementType.LOCAL_VARIABLEElementType.ANNOTATION_TYPE（在另一个注释上）ElementType.PACKAGE（记住package-info.java）</td>
</tr>
<tr>
<td><strong><em>@Inherited</em></strong></td>
<td>控制注解是否对子类产生影响。</td>
</tr>
</tbody></table>
<p>下面我们开始自己实现一个注解，注解仅支持 <code>primitives</code>, <code>string</code>和 <code>enumerations</code>这三种类型。 注解的所有属性都定义为方法，也可以提供默认值。我们先实现一个最简单的注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SimpleAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个注释里面只定义了一个字符传，它的目标注释对象是方法，保留策略是在运行期间。下面我们定义一个方法来使用这个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseAnnotation</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SimpleAnnotation</span>(<span class="string">"testStringValue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something here</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在这里使用了这个注解，并把字符串赋值为:<code>testStringValue</code>,到这里,定义一个注解并使用它，我们就已经全部完成。</p>
<p>简单的不敢相信。但是，细心一想的话，我们虽然写了一个注解也用了它，可是它并没有产生任何作用啊。也没有对我们这里方法产生任何效果啊。是的现在确实是这样的，原因在于我们前面提到的一点，我们还没有为这个注解实现它的逻辑，现在我们就来为这个注解实现逻辑。</p>
<p>应该怎么做呢？我们不妨自己来想一想。首先，我想给标注了这个注解的方法或字段实现功能，我们必须得知道，到底有哪些方法，哪些字段使用了这个注解吧，因此，这里我们很容易想到，这里应该会用到反射。其次，利用反射，我们利用反射拿到这样目标之后，得为他实现一个逻辑，这个逻辑是这些方法本身逻辑之外的逻辑，这又让我们想起了代理，aop等知识，我们相当于就是在为这些方法做一个增强。事实上的实现主借的逻辑也大概就是这个思路。梳理一下大致步骤如下:</p>
<ol>
<li>利用反射机制获取一个类的<code>Class</code>对象</li>
<li>通过这个<code>class</code>对象可以去获取他的每一个方法<code>method</code>，或字段<code>Field</code>等等</li>
<li><code>Method</code>，<code>Field</code>等类提供了类似于<code>getAnnotation</code>的方法来获取这个一个字段的所有注解</li>
<li>拿到注解之后，我们可以判断这个注解是否是我们要实现的注解，如果是则实现注解逻辑</li>
</ol>
<p>现在我们来实现一下这个逻辑，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">annotationLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     Class useAnnotationClass = UseAnnotation<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">     <span class="keyword">for</span>(Method method : useAnnotationClass.getMethods()) &#123;</span><br><span class="line">         SimpleAnnotation simpleAnnotation = (SimpleAnnotation)method.getAnnotation(SimpleAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">         <span class="keyword">if</span>(simpleAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">" Method Name : "</span> + method.getName());</span><br><span class="line">             System.out.println(<span class="string">" value : "</span> + simpleAnnotation.value());</span><br><span class="line">             System.out.println(<span class="string">" --------------------------- "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们实现的逻辑就是打印几句话。从上面的实现逻辑我们不能发现，借助于java的反射我们可以直接拿到一个类里所有的方法，然后再拿到方法上的注解，当然，我们也可以拿到字段上的注解。借助于反射我们可以拿到几乎任何属于一个类的东西。</p>
<p>关于反射更多的知识请参见这篇博客:<a href="https://blog.csdn.net/topdeveloperr/article/details/81395710#反射" target="_blank" rel="noopener">java中的反射和多态实现原理详解以及对比</a></p>
<p>一个简单的注解我们就实现完了。现在我们再回过头来，看一下@Autowired注解是如何实现的。</p>
<h5 id="Autowired注解实现逻辑分析"><a href="#Autowired注解实现逻辑分析" class="headerlink" title="@Autowired注解实现逻辑分析"></a>@Autowired注解实现逻辑分析</h5><p>知道了上面的知识，我们不难想到，上面的注解虽然简单，但是<code>@Autowired</code>和他最大的区别应该仅仅在于注解的实现逻辑，其他利用反射获取注解等等步骤应该都是一致的。先来看一下<code>@Autowired</code>这个注解在<code>spring</code>的源代码里的定义是怎样的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.annotation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读代码我们可以看到，<code>Autowired</code>注解可以应用在构造方法，普通方法，参数，字段，以及注解这五种类型的地方，它的保留策略是在运行时。下面，我们不多说直接来看spring对这个注解进行的逻辑实现.</p>
<p>在<code>Spring</code>源代码当中，<code>Autowired</code>注解位于包<code>org.springframework.beans.factory.annotation</code>之中，该包的内容如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20191031121038318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvcGRldmVsb3BlcnI=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>经过分析，不难发现<code>Spring</code>对<code>autowire</code>注解的实现逻辑位于类:<code>AutowiredAnnotationBeanPostProcessor</code>之中,已在上图标红。其中的核心处理代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		Class&lt;?&gt; targetClass = clazz;<span class="comment">//需要处理的目标类</span></span><br><span class="line">       </span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="comment">/*通过反射获取该类所有的字段，并遍历每一个字段，并通过方法findAutowiredAnnotation遍历每一个字段的所用注解，并如果用autowired修饰了，则返回auotowired相关属性*/</span>  </span><br><span class="line">			ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">				AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">				<span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;<span class="comment">//校验autowired注解是否用在了static方法上</span></span><br><span class="line">					<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">						<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">							logger.warn(<span class="string">"Autowired annotation is not supported on static fields: "</span> + field);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;<span class="comment">//判断是否指定了required</span></span><br><span class="line">					<span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">					currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">      <span class="comment">//和上面一样的逻辑，但是是通过反射处理类的method</span></span><br><span class="line">			ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">				Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">				<span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">				<span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">					<span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">						<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">							logger.warn(<span class="string">"Autowired annotation is not supported on static methods: "</span> + method);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">							logger.warn(<span class="string">"Autowired annotation should only be used on methods with parameters: "</span> +</span><br><span class="line">									method);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">					PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">              	    currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">      <span class="comment">//用@Autowired修饰的注解可能不止一个，因此都加在currElements这个容器里面，一起处理		</span></span><br><span class="line">			elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">			targetClass = targetClass.getSuperclass();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>博主在源代码里加了注释，结合注释就能看懂它做的事情了，最后这个方法返回的就是包含所有带有<code>autowire</code>注解修饰的一个<code>InjectionMetadata</code>集合。这个类由两部分组成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InjectionMetadata</span><span class="params">(Class&lt;?&gt; targetClass, Collection&lt;InjectedElement&gt; elements)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.targetClass = targetClass;</span><br><span class="line">		<span class="keyword">this</span>.injectedElements = elements;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>一是我们处理的目标类，二就是上述方法获取到的所以<code>elements</code>集合。</p>
<p>有了目标类，与所有需要注入的元素集合之后，我们就可以实现<code>autowired</code>的依赖注入逻辑了，实现的方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"> </span><br><span class="line">		InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			metadata.inject(bean, beanName, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of autowired dependencies failed"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pvs;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>它调用的方法是<code>InjectionMetadata</code>中定义的<code>inject</code>方法，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">		Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">				(checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line">		<span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Processing injected element of bean '"</span> + beanName + <span class="string">"': "</span> + element);</span><br><span class="line">				&#125;</span><br><span class="line">				element.inject(target, beanName, pvs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其逻辑就是遍历，然后调用<code>inject</code>方法，<code>inject</code>方法其实现逻辑如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Either this or &#123;<span class="doctag">@link</span> #getResourceToInject&#125; needs to be overridden.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.isField) &#123;</span><br><span class="line">		Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">		ReflectionUtils.makeAccessible(field);</span><br><span class="line">		field.set(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (checkPropertySkipping(pvs)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Method method = (Method) <span class="keyword">this</span>.member;</span><br><span class="line">			ReflectionUtils.makeAccessible(method);</span><br><span class="line">			method.invoke(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里的代码当中我们也可以看到，是<code>inject</code>也使用了反射技术并且依然是分成字段和方法去处理的。在代码里面也调用了<code>makeAccessible</code>这样的可以称之为暴力破解的方法，但是反射技术本就是为框架等用途设计的，这也无可厚非。</p>
<p>对于字段的话，本质上就是去set这个字段的值，即对对象进行实例化和赋值，例如下面代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectTest objectTest;</span><br></pre></td></tr></table></figure>

<p>那么在这里实现的就相当于给这个<code>objecTest</code>引用赋值了。</p>
<p>对于方法的话，本质就是去调用这个方法，因此这里调用的是<code>method.invoke</code>。<code>getResourceToInject</code>方法的参数就是要注入的<code>bean</code>的名字，这个方法的功能就是根据这个<code>bean</code>的名字去拿到它。</p>
<p>以上，就是<code>@Autowire</code>注解实现逻辑的全部分析。结合源代码再看一遍的话，会更加清楚一点。下面是<code>spring</code>容器如何实现<code>@AutoWired</code>自动注入的过程的图:</p>
<p> <img src="https://img-blog.csdnimg.cn/20190319171936407.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvcGRldmVsb3BlcnI=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>总结起来一句话：使用<code>@Autowired</code>注入的<code>bean</code>对于目标类来说，从代码结构上来讲也就是一个普通的成员变量，<code>@Autowired</code>和<code>spring</code>一起工作，通过反射为这个成员变量赋值，也就是将其赋为期望的类实例。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="注解的有效周期是什么？"><a href="#注解的有效周期是什么？" class="headerlink" title="注解的有效周期是什么？"></a>注解的有效周期是什么？</h5><p>各种注释之间的第一个主要区别是，它们是在编译时使用，然后被丢弃（如<code>@Override</code>），还是被放在编译的类文件中，并在运行时可用（如<code>Spring</code>的<code>@Component</code>）。这是由注释的“<code>@Retention</code>”策略决定的。如果您正在编写自己的注释，则需要决定该注释在运行时（可能用于自动配置）还是仅在编译时（用于检查或代码生成）有用。</p>
<p>当用注释编译代码时，编译器看到注释就像看到源元素上的其他修饰符一样，比如访问修饰符（<code>public/private</code>）或.。当遇到注释时，它运行一个注释处理器，就像一个插件类，表示对特定的注释感兴趣。注释处理器通常使用反射<code>API</code>来检查正在编译的元素，并且可以简单地对它们执行检查、修改它们或生成要编译的新代码。<code>@Override</code>是一个示例；它使用反射<code>API</code>来确保能够在其中一个超类中找到方法签名的匹配，如果不能，则使用<code>@Override</code>会导致编译错误。</p>
<h5 id="注入的bean和用它的bean的关系是如何维护的？"><a href="#注入的bean和用它的bean的关系是如何维护的？" class="headerlink" title="注入的bean和用它的bean的关系是如何维护的？"></a>注入的bean和用它的bean的关系是如何维护的？</h5><p>无论以何种方式注入，注入的<code>bean</code>就相当于类中的一个普通对象应用，这是它的实例化是<code>spring</code>去容器中找符合的<code>bean</code>进行实例化，并注入到类当中的。他们之间的关系就是普通的一个对象持有另一个对象引用的关系。只是这些对象都是<code>spring</code>当中的<code>bean</code>而已。</p>
<h5 id="为什么注入的bean不能被定义为static的？"><a href="#为什么注入的bean不能被定义为static的？" class="headerlink" title="为什么注入的bean不能被定义为static的？"></a>为什么注入的bean不能被定义为static的？</h5><p>从设计的角度来说 ，使用静态字段会鼓励使用静态方法。 静态方法是<code>evil</code>的。 依赖注入的主要目的是让容器为您创建对象并进行连接。 而且，它使测试更加容易。</p>
<p>一旦开始使用静态方法，您就不再需要创建对象的实例，并且测试变得更加困难。 同样，您不能创建给定类的多个实例，每个实例都注入不同的依赖项（因为该字段是隐式共享的，并且会创建全局状态）。</p>
<p>静态变量不是<code>Object</code>的属性，而是<code>Class</code>的属性。 <code>spring</code>的<code>autowire</code>是在对象上完成的，这样使得设计很干净。 在<code>spring</code>当中我们也可以将<code>bean</code>对象定义为单例，这样就能从功能上实现与静态定义相同的目的。</p>
<p>但是从纯粹技术的层面，我们可以这样做：</p>
<p>将<code>@Autowired</code>可以与<code>setter</code>方法一起使用，然后可以让<code>setter</code>修改静态字段的值。但是这种做法非常不推荐。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/topdeveloperr/article/details/87971446" target="_blank" rel="noopener">https://blog.csdn.net/topdeveloperr/article/details/87971446</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisTemplate和StringRedisTemplate的区别</title>
    <url>/2020/11/10/2020/11/RedisTemplate%E5%92%8CStringRedisTemplate%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h4><p>简单的说，<code>RedisTemplate</code>和<code>StringRedisTemplate</code>的关系如下：</p>
<blockquote>
<p>1.<code>StringRedisTemplate</code>是<code>RedisTemplate</code>的子类。</p>
<p>2.<code>StringRedisTemplate</code>的各个序列化策略都是<code>StringRedisSerializer</code>，而<code>RedisTemplate</code>用的是<code>JdkSerializationRedisSerializer</code>。</p>
</blockquote>
<h4 id="二-RedisTemplate和StringRedisTemplate的代码结构"><a href="#二-RedisTemplate和StringRedisTemplate的代码结构" class="headerlink" title="二.RedisTemplate和StringRedisTemplate的代码结构"></a>二.RedisTemplate和StringRedisTemplate的代码结构</h4><p>从<code>RedisTemplate</code>类说起。</p>
<p>在<code>RedisTemplate</code>类中，定义了这样四个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>分别代表了普通<code>key</code>，<code>value</code>，和<code>Hash</code>类型的<code>key</code>，value的序列化策略，可以分别设置。</p>
<p>另外定义变量，用来指定默认的序列化策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer&lt;?&gt; defaultSerializer;</span><br></pre></td></tr></table></figure>

<p>在<code>RedisTemplate</code>类中，定义了<code>afterPropertiesSet()</code>方法，当<code>Spring</code>创建<code>RedisTemplate</code>类的对象时，会调用这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    <span class="keyword">boolean</span> defaultUsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(<span class="keyword">this</span>.classLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.enableDefaultSerializer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.keySerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.valueSerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hashKeySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hashKeySerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hashValueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hashValueSerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.enableDefaultSerializer &amp;&amp; defaultUsed) &#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.defaultSerializer, <span class="string">"default serializer null and not all serializers initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.scriptExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scriptExecutor = <span class="keyword">new</span> DefaultScriptExecutor(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在默认情况下，<code>RedisTemplate</code>使用的默认序列化策略是<code>JdkSerializationRedisSerializer</code>。包括<code>RedisTemplate</code>下的<code>key</code>，<code>value</code>，<code>hash-key</code>，hash-value的序列化，都用这种策略。</p>
<p>再来看看<code>StringRedisTemplate</code>，他作为RedisTemplate的子类，只是修改了序列化策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="keyword">this</span>.setKeySerializer(stringSerializer);</span><br><span class="line">        <span class="keyword">this</span>.setValueSerializer(stringSerializer);</span><br><span class="line">        <span class="keyword">this</span>.setHashKeySerializer(stringSerializer);</span><br><span class="line">        <span class="keyword">this</span>.setHashValueSerializer(stringSerializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">this</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RedisConnection <span class="title">preProcessConnection</span><span class="params">(RedisConnection connection, <span class="keyword">boolean</span> existingConnection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultStringRedisConnection(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是<code>StringRedisTemplate</code>整个类的内容，可以看到，在他的默认构造中，<code>key</code>，<code>value</code>，<code>hash-key</code>，<code>hash-value</code>都使用的是StringRedisSerializer类作为序列化策略。这也就是<code>StringRedisTemplate</code>和他的父类RedisTemplate的主要区别。</p>
<h4 id="三-序列化策略"><a href="#三-序列化策略" class="headerlink" title="三.序列化策略"></a>三.序列化策略</h4><p>更进一步，看一下这个序列化策略是什么。</p>
<p>上面提到的<code>StringRedisSerializer</code>和<code>JdkSerializationRedisSerializer</code>都是序列化策略类，他们都实现了一个<code>RedisSerializer&lt;T&gt;</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisSerializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> T var1) <span class="keyword">throws</span> SerializationException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] var1)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口表达的意思很简单，两个方法，serialize用于序列化，把对象变为<code>byte</code>数组，<code>deserialize</code>用于反序列化，把byte数组转为对象。</p>
<h5 id="StringRedisSerializer"><a href="#StringRedisSerializer" class="headerlink" title="StringRedisSerializer"></a>StringRedisSerializer</h5><p>看看<code>StringRedisSerializer</code>是怎么做的：</p>
<p><strong>1.StringRedisSerializer的构造：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(charset, <span class="string">"Charset must not be null!"</span>);</span><br><span class="line">    <span class="keyword">this</span>.charset = charset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了编码格式，默认<code>UTF_8</code>。</p>
<p><strong>2.StringRedisSerializer的serialize和deserialize方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bytes == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> String(bytes, <span class="keyword">this</span>.charset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> String string) &#123;</span><br><span class="line">    <span class="keyword">return</span> string == <span class="keyword">null</span> ? <span class="keyword">null</span> : string.getBytes(<span class="keyword">this</span>.charset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>StringRedisSerializer</code>采用的是字符串和对应编码下二进制数组之间的转换。</p>
<p>在这种编码格式下，如果我们向redis保存信息，然后用客户端访问<code>Redis</code>时，只要编码格式一致，就能看到保存信息的原文。保存字符串<code>ABC</code>，客户端看到的也是字符串<code>ABC</code>。</p>
<h5 id="JdkSerializationRedisSerializer"><a href="#JdkSerializationRedisSerializer" class="headerlink" title="JdkSerializationRedisSerializer"></a>JdkSerializationRedisSerializer</h5><p>然后对比看看<code>JdkSerializationRedisSerializer</code>是怎么做的。</p>
<p><strong>1.JdkSerializationRedisSerializer的构造：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;Object, <span class="keyword">byte</span>[]&gt; serializer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;<span class="keyword">byte</span>[], Object&gt; deserializer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkSerializationRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> SerializingConverter(), <span class="keyword">new</span> DeserializingConverter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkSerializationRedisSerializer</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> SerializingConverter(), <span class="keyword">new</span> DeserializingConverter(classLoader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>JdkSerializationRedisSerializer</code>定义了两个变量，serializer和<code>deserializer</code>，显然是用来序列化和反序列化的，他们两个的类型是一样的，都是Converter接口，只是泛型不同。</p>
<p>Converter接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就一个方法。</p>
<p>另外在<code>JdkSerializationRedisSerializer</code>的构造中，对serializer和<code>deserializer</code>进行了初始化，使用<code>SerializingConverter</code>和DeserializingConverter作为实现类。</p>
<p><strong>2.JdkSerializationRedisSerializer的serialize和deserialize方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SerializationUtils.isEmpty(bytes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.deserializer.convert(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Cannot deserialize"</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> Object object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializationUtils.EMPTY_ARRAY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">byte</span>[])<span class="keyword">this</span>.serializer.convert(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Cannot serialize"</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是调用了对应<code>Converter</code>的<code>convert</code>方法。</p>
<p><strong>3.关于Converter</strong></p>
<p>既然到这了，就再深入一步，看看<code>SerializingConverter</code>和DeserializingConverter的<code>convert</code>方法。</p>
<p><strong>首先，序列化：</strong></p>
<p><code>SerializingConverter</code>的相关方法，贴一部分关键的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerializingConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = <span class="keyword">new</span> DefaultSerializer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] convert(Object source) &#123;</span><br><span class="line">        ByteArrayOutputStream byteStream = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span>  &#123;</span><br><span class="line">                <span class="keyword">this</span>.serializer.serialize(source, byteStream);</span><br><span class="line">                <span class="keyword">return</span> byteStream.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SerializationFailedException(<span class="string">"Failed to serialize object using "</span> +</span><br><span class="line">                                <span class="keyword">this</span>.serializer.getClass().getSimpleName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>SerializingConverter</code>类定义了<code>serializer</code>变量，用<strong>DefaultSerializer</strong>类实现，序列化的方式是调用<code>DefaultSerializer</code>的<code>serialize</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object object, OutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Serializable)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(getClass().getSimpleName() + <span class="string">" requires a Serializable payload "</span> +</span><br><span class="line">                                <span class="string">"but received an object of type ["</span> + object.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">        objectOutputStream.writeObject(object);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultSerializer</code>的<code>serialize</code>方法使用了<code>ObjectOutputStream</code>，调用writeObject方法序列化对象。</p>
<p><strong>对应的，反序列化：</strong></p>
<p><code>DeserializingConverter</code>的convert方法，贴一下相关代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DeserializingConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deserializer = <span class="keyword">new</span> DefaultDeserializer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(<span class="keyword">byte</span>[] source)</span> </span>&#123;</span><br><span class="line">        ByteArrayInputStream byteStream = <span class="keyword">new</span> ByteArrayInputStream(source);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.deserializer.deserialize(byteStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SerializationFailedException(<span class="string">"Failed to deserialize payload. "</span> +</span><br><span class="line">                                <span class="string">"Is the byte array a result of corresponding serialization for "</span> +</span><br><span class="line">                                <span class="keyword">this</span>.deserializer.getClass().getSimpleName() + <span class="string">"?"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见<code>DeserializingConverter</code>使用了<strong>DefaultDeserializer</strong>作为反序列化工具，调用了他的deserialize方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ConfigurableObjectInputStream(inputStream, <span class="keyword">this</span>.classLoader);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to deserialize object type"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比<code>SerializingConverter</code>，<code>DeserializingConverter</code>使用的是<code>ConfigurableObjectInputStream</code>，并调用他的<code>readObject</code>方法进行反序列化。</p>
<p>这种序列化方式，如果保存信息至<code>redis</code>，用客户端查看时，保存的信息看起来像是在原来的字符前面加了几个字符。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JdkSerializationRedisSerializer jdkSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer();</span><br><span class="line">StringRedisSerializer stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"><span class="keyword">byte</span>[] jdkByteArr = jdkSerializer.serialize(<span class="string">"CSDN博客"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] stringByteArr = stringSerializer.serialize(<span class="string">"CSDN博客"</span>);</span><br></pre></td></tr></table></figure>

<p>这种情况下，得到的<code>byte</code>数组是：</p>
<p><code>jdkByteArr</code>：</p>
<blockquote>
<p>{-84,-19,0,5,116,0,10,67,83,68,78,-27,-115,-102,-27,-82,-94}</p>
</blockquote>
<p>stringByteArr：</p>
<blockquote>
<p>{67,83,68,78,-27,-115,-102,-27,-82,-94}</p>
</blockquote>
<p><code>StringRedisSerializer</code>把字符串本身转化成<code>byte</code>数组，而<code>JdkSerializationRedisSerializer</code>在数组前面加了几个字符，这些字符也会被保存到redis中。</p>
<p>所以，从数据上来说，这两种序列化策略处理的数据是不会共通的，各人管各人的。</p>
<h4 id="四-关于redisTemplate的Operations"><a href="#四-关于redisTemplate的Operations" class="headerlink" title="四.关于redisTemplate的Operations"></a>四.关于redisTemplate的Operations</h4><p>使用<code>redisTemplate</code>时，除了调用<code>execute</code>方法并自定义RedisCallback之外，还可以使用<code>redisTemplate</code>提供的几个Operations接口。</p>
<p><code>redisTemplate</code>中定义了以下几个<code>Operations</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ValueOperations&lt;K, V&gt; valueOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ListOperations&lt;K, V&gt; listOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> SetOperations&lt;K, V&gt; setOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ZSetOperations&lt;K, V&gt; zSetOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> GeoOperations&lt;K, V&gt; geoOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HyperLogLogOperations&lt;K, V&gt; hllOps;</span><br></pre></td></tr></table></figure>

<p>这几个<code>Operations</code>接口，分别提供了对不同种类数据的操作方法。</p>
<p>以<code>ValueOperations</code>为例，他提供的方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K var1, V var2, <span class="keyword">long</span> var3, TimeUnit var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">setIfAbsent</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiSet</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">multiSetIfAbsent</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">V <span class="title">getAndSet</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">List&lt;V&gt; <span class="title">multiGet</span><span class="params">(Collection&lt;K&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Long <span class="title">increment</span><span class="params">(K var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Double <span class="title">increment</span><span class="params">(K var1, <span class="keyword">double</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Integer <span class="title">append</span><span class="params">(K var1, String var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">get</span><span class="params">(K var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K var1, V var2, <span class="keyword">long</span> var3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Long <span class="title">size</span><span class="params">(K var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">setBit</span><span class="params">(K var1, <span class="keyword">long</span> var2, <span class="keyword">boolean</span> var4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">getBit</span><span class="params">(K var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其他的<code>Operations</code>提供的方法各有不同，但是这些<code>Operations</code>的使用方式都是相同的。</p>
<p>不同的Operations分别通过<code>RedisTemplate</code>的以下方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ValueOperations&lt;K, V&gt; <span class="title">opsForValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.valueOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.valueOps = <span class="keyword">new</span> DefaultValueOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListOperations&lt;K, V&gt; <span class="title">opsForList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.listOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listOps = <span class="keyword">new</span> DefaultListOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SetOperations&lt;K, V&gt; <span class="title">opsForSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.setOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setOps = <span class="keyword">new</span> DefaultSetOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.setOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ZSetOperations&lt;K, V&gt; <span class="title">opsForZSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.zSetOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.zSetOps = <span class="keyword">new</span> DefaultZSetOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.zSetOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> GeoOperations&lt;K, V&gt; <span class="title">opsForGeo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.geoOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.geoOps = <span class="keyword">new</span> DefaultGeoOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.geoOps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，在这些获得<code>Operations</code>的方法中，都提供了一个默认实现类，并且把<code>RedisTemplate</code>对象本身当做参数传给了这个实现类。</p>
<p>还是以<code>ValueOperations</code>为例，<code>RedisTemplate</code>提供的默认实现类是DefaultValueOperations，看看这个类的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.redis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.AbstractOperations.ValueDeserializingRedisCallback;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultValueOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ValueOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    DefaultValueOperations(RedisTemplate&lt;K, V&gt; template) &#123;</span><br><span class="line">        <span class="keyword">super</span>(template);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.get(rawKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getAndSet</span><span class="params">(K key, V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(newValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.getSet(rawKey, rawValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">increment</span><span class="params">(K key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Long)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.incrBy(rawKey, delta);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">increment</span><span class="params">(K key, <span class="keyword">double</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Double)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.incrBy(rawKey, delta);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">append</span><span class="params">(K key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawString = <span class="keyword">this</span>.rawString(value);</span><br><span class="line">        <span class="keyword">return</span> (Integer)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            Long result = connection.append(rawKey, rawString);</span><br><span class="line">            <span class="keyword">return</span> result != <span class="keyword">null</span> ? result.intValue() : <span class="keyword">null</span>;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(K key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawReturn = (<span class="keyword">byte</span>[])<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.getRange(rawKey, start, end);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.deserializeString(rawReturn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;V&gt; <span class="title">multiGet</span><span class="params">(Collection&lt;K&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keys.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[][] rawKeys = <span class="keyword">new</span> <span class="keyword">byte</span>[keys.size()][];</span><br><span class="line">            <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Object hashKey;</span><br><span class="line">            <span class="keyword">for</span>(Iterator var4 = keys.iterator(); var4.hasNext(); rawKeys[counter++] = <span class="keyword">this</span>.rawKey(hashKey)) &#123;</span><br><span class="line">                hashKey = var4.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;<span class="keyword">byte</span>[]&gt; rawValues = (List)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.mGet(rawKeys);</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.deserializeValues(rawValues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiSet</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.isEmpty()) &#123;</span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; rawKeys = <span class="keyword">new</span> LinkedHashMap(m.size());</span><br><span class="line">            Iterator var3 = m.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                Entry&lt;? extends K, ? extends V&gt; entry = (Entry)var3.next();</span><br><span class="line">                rawKeys.put(<span class="keyword">this</span>.rawKey(entry.getKey()), <span class="keyword">this</span>.rawValue(entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                connection.mSet(rawKeys);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">multiSetIfAbsent</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; rawKeys = <span class="keyword">new</span> LinkedHashMap(m.size());</span><br><span class="line">            Iterator var3 = m.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                Entry&lt;? extends K, ? extends V&gt; entry = (Entry)var3.next();</span><br><span class="line">                rawKeys.put(<span class="keyword">this</span>.rawKey(entry.getKey()), <span class="keyword">this</span>.rawValue(entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.mSetNX(rawKeys);</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                connection.set(rawKey, rawValue);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value, <span class="keyword">final</span> <span class="keyword">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.potentiallyUsePsetEx(connection);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">potentiallyUsePsetEx</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!TimeUnit.MILLISECONDS.equals(unit) || !<span class="keyword">this</span>.failsafeInvokePsetEx(connection)) &#123;</span><br><span class="line">                    connection.setEx(rawKey, TimeoutUtils.toSeconds(timeout, unit), rawValue);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">failsafeInvokePsetEx</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">boolean</span> failed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.pSetEx(rawKey, timeout, rawValue);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedOperationException var4) &#123;</span><br><span class="line">                    failed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> !failed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">setIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.setNX(rawKey, rawValue);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            connection.setRange(rawKey, rawValue, offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">size</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Long)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.strLen(rawKey);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">setBit</span><span class="params">(K key, <span class="keyword">long</span> offset, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.setBit(rawKey, offset, value);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getBit</span><span class="params">(K key, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.getBit(rawKey, offset);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有<code>Operations</code>实现类都是<code>AbstractOperations</code>的子类，另外各自实现各自的接口。</p>
<p>实现类的方法中多数都是调用了<code>this.execute()</code>方法，这个方法在父类AbstractOperations中，最终调用的其实也是<code>RedisTemplate</code>的<code>execute()</code>方法。</p>
<p>以上面<code>DefaultValueOperations</code>的<code>set()</code>方法为例，看一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">    <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">            connection.set(rawKey, rawValue);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是对<code>value</code>的处理，调用<code>this.rawValue()</code>方法，把value序列化成<code>byte</code>数组，这个方法在父类<code>AbstractOperations</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] rawValue(Object value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueSerializer() == <span class="keyword">null</span> &amp;&amp; value <span class="keyword">instanceof</span> <span class="keyword">byte</span>[] ? (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])value) : <span class="keyword">this</span>.valueSerializer().serialize(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，代码用的是自己的<code>valueSerializer</code>来序列化<code>value</code>，这个valueSerializer来自<code>RedisTemplate</code>。</p>
<p>回到<code>set()</code>方法，<code>value</code>序列化完成后，调用<code>this.execute()</code>方法，给此方法传递的第一个参数是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">        connection.set(rawKey, rawValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个参数实际上是一个<code>ValueDeserializingRedisCallback</code>对象，在其中定义了<code>inRedis()</code>方法的实现。</p>
<p><code>this.execute()</code>方法在父类AbstractOperations中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; callback, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.template.execute(callback, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>this.template</code>指的就是初始化时传入的<code>RedisTemplate</code>，其execute()方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.execute(action, exposeConnection, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection, <span class="keyword">boolean</span> pipeline)</span> </span>&#123;</span><br><span class="line">    Assert.isTrue(<span class="keyword">this</span>.initialized, <span class="string">"template not initialized; call afterPropertiesSet() before using it"</span>);</span><br><span class="line">    Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line">    RedisConnectionFactory factory = <span class="keyword">this</span>.getRequiredConnectionFactory();</span><br><span class="line">    RedisConnection conn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Object var11;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.enableTransactionSupport) &#123;</span><br><span class="line">            conn = RedisConnectionUtils.bindConnection(factory, <span class="keyword">this</span>.enableTransactionSupport);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn = RedisConnectionUtils.getConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> existingConnection = TransactionSynchronizationManager.hasResource(factory);</span><br><span class="line">        RedisConnection connToUse = <span class="keyword">this</span>.preProcessConnection(conn, existingConnection);</span><br><span class="line">        <span class="keyword">boolean</span> pipelineStatus = connToUse.isPipelined();</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.openPipeline();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RedisConnection connToExpose = exposeConnection ? connToUse : <span class="keyword">this</span>.createRedisConnectionProxy(connToUse);</span><br><span class="line">        T result = action.doInRedis(connToExpose);</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.closePipeline();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var11 = <span class="keyword">this</span>.postProcessResult(result, connToUse, existingConnection);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RedisConnectionUtils.releaseConnection(conn, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法初始化了<code>RedisConnection</code>，最后面调用了<code>RedisCallback</code>的<code>doInRedis()</code>方法，也就是这一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T result = action.doInRedis(connToExpose);</span><br></pre></td></tr></table></figure>

<p>这里的变量<code>action</code>就是在<code>set()</code>方法中自定义的<code>new AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key)</code>。</p>
<p><code>ValueDeserializingRedisCallback</code>类是<code>AbstractOperations</code>的内部抽象类，他的<code>doInRedis()</code>方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">this</span>.inRedis(AbstractOperations.<span class="keyword">this</span>.rawKey(<span class="keyword">this</span>.key), connection);</span><br><span class="line">    <span class="keyword">return</span> AbstractOperations.<span class="keyword">this</span>.deserializeValue(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见调用了<code>inRedis()</code>方法，其第一个参数是序列化后的<code>key</code>，调用的是<code>AbstractOperations</code>的<code>rawKey()</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] rawKey(Object key) &#123;</span><br><span class="line">    Assert.notNull(key, <span class="string">"non null key required"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.keySerializer() == <span class="keyword">null</span> &amp;&amp; key <span class="keyword">instanceof</span> <span class="keyword">byte</span>[] ? (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])key) : <span class="keyword">this</span>.keySerializer().serialize(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把<code>key</code>进行序列化，<code>keySerializer()</code>方法从<code>RedisTemplate</code>中获取<code>keySerializer</code>，并由<code>keySerializer</code>对<code>key</code>进行序列化。</p>
<p>在<code>ValueDeserializingRedisCallback</code>类中的<code>inRedis()</code>方法是抽象方法，具体的实现在<code>DefaultValueOperations</code>的<code>set()</code>方法中，也就是这一部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">    connection.set(rawKey, rawValue);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用的是<code>RedisConnection</code>的<code>set()</code>方法，完成<code>Redis</code>的<code>set</code>操作。</p>
<p>以上就是在RedisTemplate中使用<code>ValueOperations</code>进行<code>set</code>操作的全部代码流程。</p>
<p>对<code>Redis</code>的不同操作分散在<code>RedisTemplate</code>的不同Operations中，只是调用的方法不同，调用流程都差不多。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/lkforce/article/details/103685707" target="_blank" rel="noopener">https://blog.csdn.net/lkforce/article/details/103685707</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>你是如何玩Git分支模型的呢？</title>
    <url>/2020/11/12/2020/11/%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%8E%A9Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%91%A2%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>总览(一张流程图给大家先镇镇惊)</p>
<p><img src="http://static.cyblogs.com/git%E5%88%86%E6%94%AF%E6%80%BB%E5%9B%BE%E6%A6%82%E8%A7%88.jpg" alt="http://static.cyblogs.com/git分支总图概览.jpg"></p>
<p>它主要体现了<code>Git</code>对我们源代码版本的管理。</p>
<p>（转载者加）一般情况：</p>
<ul>
<li><code>master</code>和<code>develop</code>并行。 </li>
<li><code>master</code>上始终是最稳定的代码，<code>develop</code>是正在开发的代码。 </li>
<li><code>feature</code>则是某个开发为了自己的功能拉的分支。<br>不一般情况： </li>
<li><code>develop</code>正在开发，如果你上线突然被拒绝了，这时候就要从master上开一个热分支，或者<code>release</code>分支也行，改好之后在分别合并到其他分支。但，本人感觉release通常意味着终止。别在从<code>release</code>上拉分支了。</li>
</ul>
<h4 id="为何是Git？"><a href="#为何是Git？" class="headerlink" title="为何是Git？"></a>为何是Git？</h4><p>​        对于<code>Git</code>与其他集中式代码管理工具相比的优缺点的全面讨论，请参见这里。这样的争论总是喋喋不休。作为一个开发者，与现今的其他开发工具相比较，我更喜欢<code>Git</code>。<code>Git</code>真得改变了开发者对于合并和分支的思考。我曾经使用经典的<code>CVS/Subversion</code>，然而每次的合并/分支和其他行为总让人担惊受怕（“小心合并里的冲突，简直要命！”）。<br>但是对于<code>Git</code>来说，这些行为非常简单和搞笑，它们被认为是日常工作中的核心部分。例如，在很多<code>CVS/Subversion</code>书里，分支与合并总是在后面的章节中被讨论（对于高级用户使用），然而在每个<code>Git</code>书中，在第3章就已经完全涵盖了（作为基础）。<br>简单和重复的特性带来的结果是：分支与合并不再是什么可以害怕的东西。分支/合并被认为对于版本管理工具比其他功能更重要。<br>关于工具，不再多说，让我们直接看开发模型吧。这个模型并不是如下模型：在管理软件开发进度方面，面对每个开发过程，每个队员必须按一定次序开发。</p>
<h4 id="分布式而非集中式"><a href="#分布式而非集中式" class="headerlink" title="分布式而非集中式"></a>分布式而非集中式</h4><p>​        对于这种分支模型，我们设置了一个版本库，它运转良好，这是一个”事实上” 版本库。不过请注意，这个版本库只是被认为是中心版本库（因为<code>Git</code>是一个分布式版本管理系统，从技术上来讲，并没有一个中心版本库）。我们将把这个版本库称为原始库，这个名字对所有的Git用户来说都很容易理解。</p>
<p><img src="http://static.cyblogs.com/git%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E4%B8%AD%E5%BC%8F.jpg" alt="http://static.cyblogs.com/git分布式集中式.jpg"></p>
<p>每个开发者都对<code>origin</code>库拉代码和提交代码。但是除了集中式的存取代码关系，每个开发者也可以从子团队的其他队友那里获得代码版本变更。例如，对于2个或多个开发者一起完成的大版本变更，为了防止过早地向<code>origin</code>库提交工作内容，这种机制就变得非常有用。在上述途中，有如下子团队：<code>Alice</code>和Bob，<code>Alice</code>和<code>David</code>，<code>Clair</code>和<code>David</code>。<br>从技术上将，这意味着，<code>Alice</code>创建了一个<code>Git</code>的远程节点，而对于<code>Bob</code>，该节点指向了<code>Bob</code>的版本库，反之亦然。</p>
<h4 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h4><p><img src="http://static.cyblogs.com/develop%E4%B8%8Emaster%E5%88%86%E6%94%AF%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="http://static.cyblogs.com/develop与master分支的关系.jpg"></p>
<p>在核心部分，研发模型很大程度上靠其他现有模型支撑的。中心库有2个可一直延续的分支： </p>
<ul>
<li>master分支 </li>
<li>develop分支 </li>
</ul>
<p>每个<code>Git</code>用户都要熟悉原始的<code>master</code>分支。与master分支并行的另一个分支，我们称之为<code>develop</code>分支。<br>我们把原始库/<code>master</code>库认作为主分支，HEAD的源代码存在于此版本中，并且随时都是一个预备生产状态。 </p>
<p>我们把<code>origin/develop</code>库认为是主分支，该分支<code>HEAD</code>源码始终体现下个发布版的最新软件变更。有人称这个为“集成分支”，而这是每晚自动构建得来的。<br>当<code>develop</code>分支的源码到达了一个稳定状态待发布，所有的代码变更需要以某种方式合并到master分支，然后标记一个版本号。如何操作将在稍后详细介绍。<br>所以，每次变更都合并到了<code>master</code>，这就是新产品的定义。在这一点，我们倾向于严格执行这一点，从而，理论上，每当对<code>master</code>有一个提交操作，我们就可以使用<code>Git</code>钩子脚本来自动构建并且发布软件到生产服务器。</p>
<h4 id="辅助性分支"><a href="#辅助性分支" class="headerlink" title="辅助性分支"></a>辅助性分支</h4><p>我们的开发模型使用了各种辅助性分支，这些分支与关键分支（master和develop）一起，用来支持团队成员们并行开发，使得易于追踪功能，协助生产发布环境准备，以及快速修复实时在线问题。与关键分支不同，这些分支总是有一个有限的生命期，因为他们最终会被移除。<br>我们用到的分支类型包括： </p>
<ul>
<li>功能分支 </li>
<li>发布分支 </li>
<li>热修复分支 </li>
</ul>
<p>每一种分支有一个特定目的，并且受限于严格到规则，比如：可以用哪些分支作为源分支，哪些分支能作为合并目标。我们马上将进行演练。<br>从技术角度来看，这些分支绝不是特殊分支。分支的类型基于我们使用的方法来进行分类。它们理所当然是普通的Git分支。</p>
<h4 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h4><p><img src="http://static.cyblogs.com/20181126103335995_580-0.jpg" alt="http://static.cyblogs.com/20181126103335995_580-0.jpg"></p>
<p>可能是<code>develop</code>分支的分支版本，最终必须合并到<code>develop</code>分支中。<br>分支命名规则：除了<code>master</code>、<code>develop</code>、<code>release-</code>、<code>hotfix-</code>之外，其他命名均可。<br>功能分支（有时被称为<code>topic</code>分支）通常为即将发布或者未来发布版开发新的功能。当新功能开始研发，包含该功能的发布版本在这个还是无法确定发布时间的。功能版本的实质是只要这个功能处于开发状态它就会存在，但是最终会或合并到<code>develop</code>分支（确定将新功能添加到不久的发布版中）或取消（譬如一次令人失望的测试）。<br>功能分支通常存在于开发者的软件库，而不是在源代码库中。<br><strong>创建一个功能分支</strong><br>开始一项功能的开发工作时，基于<code>develop</code>创建分支。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b myfeature develop</span></span><br><span class="line">Switched to a new branch "myfeature"</span><br></pre></td></tr></table></figure>

<p><strong>合并一个功能到develop分支</strong><br>完成的功能可以合并进develop分支，以明确加入到未来的发布：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line">Switched to branch 'develop'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff myfeature</span></span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d myfeature</span></span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br></pre></td></tr></table></figure>

<p><code>--no-ff</code>标志导致合并操作创建一个新<code>commit</code>对象，即使该合并操作可以<code>fast-forward</code>。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。 比较:</p>
<p><img src="http://static.cyblogs.com/t_70_580-0.jpg" alt="http://static.cyblogs.com/t_70_580-0.jpg"></p>
<p>后一种情况，不可能从<code>Git</code>历史中看到哪些提交一起实现了一个功能——你必须手工阅读全部的日志信息。如果对整个功能进行回退 (比如一组提交)，后一种方式会是一种真正头痛的问题，而使用<code>--no-ff flag</code>的情况则很容易.<br>是的，它会创建一个新的（空）提交对象，但是收益远大于开销。<br>不幸的是，我还没找到一种方法，让–no-ff时作为合并操作的默认选项，但它应该是可行的。</p>
<h4 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a>Release 分支</h4><p><code>Release</code>分支可能从<code>develop</code>分支分离而来，但是一定要合并到<code>develop</code>和master分支上，它的习惯命名方式为：<code>release-*</code>。<br><code>Release</code>分支是为新产品的发布做准备的。它允许我们在最后时刻做一些细小的修改。他们允许小bugs的修改和准备发布元数据（版本号，开发时间等等）。当在<code>Release</code>分支完成这些所有工作以后，对于下一次打的发布，develop分支接收<code>features</code>会更加明确。<br>从<code>develop</code>分支创建新的<code>Release</code>分支的关键时刻是<code>develop</code>分支达到了发布的理想状态。至少所有这次要发布的<code>features</code>必须在这个点及时合并到develop分支。对于所有未来准备发布的<code>features</code>必须等到Release分支创建以后再合并。<br>在<code>Release</code>分支创建的时候要为即将发行版本分配一个版本号，一点都不早。直到那时，<code>develop</code>分支反映的变化都是为了下一个发行版，但是在<code>Release</code>分支创建之前，下一个发行版到底叫<code>0.3</code>还是<code>1.0</code>是不明确的。这个决定是在<code>Release</code>分支创建时根据项目在版本号上的规则制定的。</p>
<p><strong>创建一个release分支</strong><br><code>Release</code>分支是从<code>develop</code>分支创建的。例如，当前产品的发行版本号为<code>1.1.5</code>，同事我们有一个大的版本即将发行。<code>develop</code> 分支已经为下次发行做好了准备，我们得决定下一个版本是<code>1.2</code>（而不是<code>1.1.6</code>或者<code>2.0</code>）。所以我们将<code>Release</code>分支分离出来，给一个能够反映新版本号的分支名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b release-1.2 develop</span></span><br><span class="line">Switched to a new branch "release-1.2"</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bump-version.sh 1.2</span></span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">"Bumped version number to 1.2"</span></span></span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>创建新分支以后，切换到该分支，添加版本号。这里，<code>bump-version.sh</code> 是一个虚构的<code>shell</code>脚本，它可以复制一些文件来反映新的版本（这当然可以手动改变–目的就是修改一些文件）。然后版本号被提交。<br>这个新分支可能会存在一段时间，直到该发行版到达它的预定目标。在此期间，bug的修复可能被提交到该分支上（而不是提交到<code>develop</code>分支上）。在这里严格禁止增加大的新<code>features</code>。他们必须合并到<code>develop</code>分支上，然后等待下一次大的发行版。</p>
<p><strong>完成一个release分支</strong><br>当一个<code>release</code>分支准备好成为一个真正的发行版的时候，有一些工作必须完成。首先，release分支要合并到<code>master</code>上（因为每一次提交到<code>master</code>上的都是一个新定义的发行版，记住）。然后，提交到<code>master</code>上必须打一个标签，以便以后更加方便的引用这个历史版本。最后，在<code>release</code>分支上的修改必须合并到develop分支上，以便未来发行版也包含这些<code>bugs</code>的修复。<br>在<code>Git</code>中的前两步是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release-1.2</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a 1.2</span></span><br></pre></td></tr></table></figure>

<p>发行版现在已经完成，为以后引用打上标签。<br><strong>编辑：</strong>你可能也想使用<code>the-sor-u &lt;key&gt;flags</code>来标记你的标签。<br>为了是修改保持在<code>release</code>分支上，我们需要合并这些到<code>develop</code>分支上去，在<code>Git</code>上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line">Switched to branch 'develop'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release-1.2</span></span><br><span class="line">Merge made by recursive.</span><br></pre></td></tr></table></figure>

<p>(Summary of changes)<br>这个步骤可能会导致合并冲突（可能由于改变版本号更是如此）。如果是这样，修复它然后提交。<br>现在我们真正的完成了，这个<code>release</code>分支将被删除，因为我们不再需要它了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d release-1.2</span></span><br><span class="line">Deleted branch release-1.2 (was ff452fe).</span><br></pre></td></tr></table></figure>

<h4 id="热修复分支"><a href="#热修复分支" class="headerlink" title="热修复分支"></a>热修复分支</h4><p><img src="http://static.cyblogs.com/t_70_580-1.jpg" alt="http://static.cyblogs.com/t_70_580-1.jpg"></p>
<p>可以基于<code>master</code>分支，必须合并回<code>develop</code>和<code>master</code>分支。<br>分支名约定：<code>hotfix-*</code><br>热修复分支与发布分支很相似，他们都为新的生成环境发布做准备，尽管这是未经计划的。他们来自生产环境的处于异常状态压力。当生成环境验证缺陷必须马上修复是，热修复分支可以基于<code>master</code>分支上对应与线上版本的<code>tag</code>创建。<br>其本质是团队成员（在<code>develop</code>分支上）的工作可以继续，而另一个人准备生产环境的快速修复。<br><strong>创建修补bug分支</strong><br><code>hotfix branch</code>(修补bug分支)是从<code>Master</code>分支上面分出来的。例如，1.2版本是当前生产环境的版本并且有<code>bug</code>。但是开发分支（<code>develop</code>）变化还不稳定。我们需要分出来一个修补<code>bug</code>分支（<code>hotfix branch</code>）来解决这种情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b hotfix-1.2.1 master</span></span><br><span class="line">Switched to a new branch "hotfix-1.2.1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bump-version.sh 1.2.1</span></span><br><span class="line">Files modified successfully, version bumped to 1.2.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">"Bumped version number to 1.2.1"</span></span></span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>

<p>分支关闭的时侯不要忘了更新版本号(<code>bump the version</code>)<br>然后，修复<code>bug</code>，一次提交或者多次分开提交。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"Fixed severe production problem"</span></span></span><br><span class="line">[hotfix-1.2.1 abbe5d6] Fixed severe production problem</span><br><span class="line">5 files changed, 32 insertions(+), 17 deletions(-)</span><br></pre></td></tr></table></figure>

<p><strong>完成一个hotfix分支</strong><br>完成一个<code>bugfix</code>之后，需要把<code>butfix</code>合并到<code>master</code>和develop分支去，这样就可以保证修复的这个<code>bug</code>也包含到下一个发行版中。这一点和完成<code>release</code>分支很相似。<br>首先，更新<code>master</code>并对<code>release</code>打上<code>tag</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a 1.2.1</span></span><br></pre></td></tr></table></figure>

<p>编辑：你可能也会想使用 <code>-sor-u &lt;key&gt;</code>参数来对你的tag进行加密<br>下一步，把<code>bugfix</code>添加到<code>develop</code>分支中： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop </span></span><br><span class="line">Switched to branch 'develop' </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix-1.2.1 </span></span><br><span class="line">Merge made by recursive.</span><br></pre></td></tr></table></figure>

<p>(Summary of changes)<br>规则的一个例外是： <strong>如果一个<code>release</code>分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支</strong>。当<code>release</code>分支完成后， 将<code>bugfix</code>分支合并回<code>release</code>分支也会使得<code>bugfix</code>被合并到<code>develop</code>分支。（如果在<code>develop</code>分支的工作急需这个<code>bugfix</code>，等不到<code>release</code>分支的完成，那你也可以把<code>bugfix</code>合并到develop分支）<br>最后，删除临时分支：</p>
<p>(Summary of changes)<br>规则的一个例外是： <strong>如果一个release分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支</strong>。当release分支完成后， 将bugfix分支合并回release分支也会使得bugfix被合并到develop分支。（如果在develop分支的工作急需这个bugfix，等不到release分支的完成，那你也可以把bugfix合并到develop分支）<br>最后，删除临时分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix-1.2.1</span></span><br><span class="line">Deleted branch hotfix-1.2.1 (was abbe5d6).</span><br></pre></td></tr></table></figure>

<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>尽管这个分支模型没有任何震撼的新东西, 文章开头的图表在我们的项目中表现出惊人的实用性。它形成了一个优雅的思维模型，易于领悟并使团队成员发展出对分支和发布过程的共同理解。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/hj7jay/article/details/84527062" target="_blank" rel="noopener">https://blog.csdn.net/hj7jay/article/details/84527062</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库隔离级别到底是RC还是RR？</title>
    <url>/2020/11/24/2020/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%B0%E5%BA%95%E6%98%AFRC%E8%BF%98%E6%98%AFRR%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h4><p><code>MySQL</code> 的默认事务隔离级别为 <code>Repeatable Read</code>。而 <code>ORACLE</code>、<code>SQLServer</code> 等的默认隔离级别使用的是 <code>Read Committed</code> 模式，为什么呢？</p>
<p>开始我们的内容，相信大家一定遇到过下面的一个面试场景</p>
<blockquote>
<p>面试官：“讲讲 mysql 有几个事务隔离级别？”</p>
<p>你：“读未提交，读已提交，可重复读，串行化四个！默认是可重复读”<br>面试官：“为什么 mysql 选可重复读作为默认的隔离级别？”<br>(你面露苦色，不知如何回答！)<br>面试官:“你们项目中选了哪个隔离级别？为什么？”<br>你：“当然是默认的可重复读，至于原因…呃…”<br>(然后你就可以回去等通知了！)</p>
</blockquote>
<p>为了避免上述尴尬的场景，请继续往下阅读！<br><code>Mysql</code> 默认的事务隔离级别是可重复读 (<code>Repeatable Read</code>)，那互联网项目中 <code>Mysql</code> 也是用默认隔离级别，不做修改么？<br><code>OK</code>，不是的，我们在项目中一般用读已提交 (<code>Read Commited</code>) 这个隔离级别！<br><code>what</code>！居然是读已提交，网上不是说这个隔离级别存在不可重复读和幻读问题么？不用管么？好，带着我们的疑问开始本文！</p>
<p>我们先来思考一个问题，在 <code>Oracle</code>，<code>SqlServer</code> 中都是选择读已提交 (Read Commited) 作为默认的隔离级别，为什么 <code>Mysql</code> 不选择读已提交 (<code>Read Commited</code>) 作为默认隔离级别，而选择可重复读 (<code>Repeatable Read</code>) 作为默认的隔离级别呢？</p>
<h4 id="Why-Why-Why"><a href="#Why-Why-Why" class="headerlink" title="Why?Why?Why?"></a>Why?Why?Why?</h4><p>这个是有历史原因的，当然要从我们的主从复制开始讲起了！<br>主从复制，是基于什么复制的？<br>是基于 <code>binlog</code> 复制的！这里不想去搬 <code>binlog</code> 的概念了，就简单理解为 <code>binlog</code> 是一个记录数据库更改的文件吧～<br><code>binlog</code> 有几种格式？<br>OK，三种，分别是：</p>
<ul>
<li><code>statement</code>: 记录的是修改 <code>SQL</code> 语句</li>
<li>row：记录的是每行实际数据的变更</li>
<li><code>mixed</code>：statement 和 <code>row</code> 模式的混合</li>
</ul>
<p>那 <code>Mysql</code> 在 5.0 这个版本以前，<code>binlog</code> 只支持 <code>STATEMENT</code> 这种格式！而这种格式在读已提交 (<code>Read Commited</code>) 这个隔离级别下主从复制是有 <code>bug</code> 的，因此 <code>Mysql</code> 将可重复读 (<code>Repeatable Read</code>) 作为默认的隔离级别！<br>接下来，就要说说当 <code>binlog</code> 为 <code>STATEMENT</code> 格式，且隔离级别为读已提交 (<code>Read Commited</code>) 时，有什么 <code>bug</code> 呢？如下图所示，在主 (master) 上执行如下事务</p>
<p><img src="http://static.cyblogs.com/image_editor_38dbfa43-6a3f-4812-a26c-c9dc984d4ccc.jpg" alt="http://static.cyblogs.com/image_editor_38dbfa43-6a3f-4812-a26c-c9dc984d4ccc.jpg"></p>
<p>此时在主 (<code>master</code>) 上执行下列语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>；</span><br></pre></td></tr></table></figure>


<p>输出如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">±–+</span><br><span class="line">| b |</span><br><span class="line">±–+</span><br><span class="line">| 3 |</span><br><span class="line">±–+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>


<p>但是，你在此时在从 (<code>slave</code>) 上执行该语句，得出输出如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Empty set</span><br></pre></td></tr></table></figure>


<p>这样，你就出现了主从不一致性的问题！原因其实很简单，就是在 <code>master</code> 上执行的顺序为先删后插！而此时 <code>binlog</code> 为 STATEMENT 格式，它记录的顺序为先插后删！从 (<code>slave</code>) 同步的是 <code>binglog</code>，因此从机执行的顺序和主机不一致！就会出现主从不一致！</p>
<h4 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>解决方案有两种！</p>
<ul>
<li>隔离级别设为可重复读 (<code>Repeatable Read</code>), 在该隔离级别下引入间隙锁。当 <code>Session 1</code> 执行 <code>delete</code> 语句时，会锁住间隙。那么，<code>Ssession 2</code> 执行插入语句就会阻塞住！</li>
<li>将 binglog 的格式修改为 <code>row</code> 格式，此时是基于行的复制，自然就不会出现 sql 执行顺序不一样的问题！奈何这个格式在 <code>mysql5.1</code> 版本开始才引入。因此由于历史原因，<code>mysql</code> 将默认的隔离级别设为可重复读 (<code>Repeatable Read</code>)，保证主从复制不出问题！</li>
</ul>
<p>那么，当我们了解完 <code>mysql</code> 选可重复读 (<code>Repeatable Read</code>) 作为默认隔离级别的原因后，接下来我们将其和读已提交 (<code>Read Commited</code>) 进行对比，来说明为什么在互联网项目为什么将隔离级别设为读已提交(<code>Read Commited</code>)！</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>OK，我们先明白一点！项目中是不用读未提交 (<code>Read UnCommitted</code>) 和串行化 (Serializable) 两个隔离级别，原因有二</p>
<p>采用读未提交 (<code>Read UnCommitted</code>), 一个事务读到另一个事务未提交读数据，这个不用多说吧，从逻辑上都说不过去！<br>采用串行化 (<code>Serializable</code>)，每个次读操作都会加锁，快照读失效，一般是使用 <code>mysql</code> 自带分布式事务功能时才使用该隔离级别！(笔者从未用过 <code>mysql</code> 自带的这个功能，因为这是 <code>XA</code> 事务，是强一致性事务，性能不佳！互联网的分布式方案，多采用最终一致性的事务解决方案！)<br>也就是说，我们该纠结都只有一个问题，究竟隔离级别是用读已经提交呢还是可重复读？<br>接下来对这两种级别进行对比，讲讲我们为什么选读已提交 (<code>Read Commited</code>) 作为事务隔离级别！<br>假设表结构如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">	<span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	<span class="string">`color`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	 PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure>


<p>数据如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">±—±------+</span><br><span class="line">| id | color |</span><br><span class="line">±—±------+</span><br><span class="line">| 1 | red |</span><br><span class="line">| 2 | white |</span><br><span class="line">| 5 | red |</span><br><span class="line">| 7 | white |</span><br><span class="line">±—±------+</span><br></pre></td></tr></table></figure>


<p>为了便于描述，下面将</p>
<ul>
<li>可重复读 (<code>Repeatable Read</code>)，简称为 <code>RR</code>；</li>
<li>读已提交 (Read Commited)，简称为 <code>RC</code>；</li>
</ul>
<p><strong>缘由一</strong></p>
<p>在 <code>RR</code> 隔离级别下，存在间隙锁，导致出现死锁的几率比 <code>RC</code> 大的多！<br>此时执行语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>RR</code> 隔离级别下，存在间隙锁，可以锁住 <code>(2,5)</code> 这个间隙，防止其他事务插入数据！而在 <code>RC</code> 隔离级别下，不存在间隙锁，其他事务是可以插入数据！</p>
<p>在 <code>RC</code> 隔离级别下并不是不会出现死锁，只是出现几率比 <code>RR</code> 低而已！</p>
<p><strong>缘由二</strong></p>
<p>在 <code>RR</code> 隔离级别下，条件列未命中索引会锁表！而在 <code>RC</code> 隔离级别下，只锁行<br>此时执行语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> color = <span class="string">'blue'</span> <span class="keyword">where</span> color = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure>


<p>在 <code>RC</code> 隔离级别下，其先走聚簇索引，进行全部扫描。加锁如下：</p>
<p><img src="http://static.cyblogs.com/image_editor_4485ac7d-e85b-4b76-962e-5d420e1ac0a4.png" alt="http://static.cyblogs.com/image_editor_4485ac7d-e85b-4b76-962e-5d420e1ac0a4.png"></p>
<p>但在实际中，<code>MySQL</code> 做了优化，在 <code>MySQL Server</code> 过滤条件，发现不满足后，会调用 <code>unlock_row</code> 方法，把不满足条件的记录放锁。<br>实际加锁如下</p>
<p><img src="http://static.cyblogs.com/image_editor_d329942e-3fd7-4a88-b6ae-b294989c34b5.png" alt="http://static.cyblogs.com/image_editor_d329942e-3fd7-4a88-b6ae-b294989c34b5.png"></p>
<p>然而，在 <code>RR</code> 隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上，如下所示</p>
<p><img src="http://static.cyblogs.com/image_editor_b504b652-9960-495a-a5ce-37826d0acdc7.jpg" alt="http://static.cyblogs.com/image_editor_b504b652-9960-495a-a5ce-37826d0acdc7.jpg"></p>
<p><strong>缘由三</strong></p>
<p>在 <code>RC</code> 隔离级别下，半一致性读 (<code>semi-consistent</code>) 特性增加了 <code>update</code> 操作的并发性！<br>在 <code>5.1.15</code> 的时候，<code>innodb</code> 引入了一个概念叫做 “<code>semi-consistent</code>”，减少了更新同一行记录时的冲突，减少锁等待。<br>所谓半一致性读就是，一个 <code>update</code> 语句，如果读到一行已经加锁的记录，此时 <code>InnoDB</code> 返回记录最近提交的版本，由 <code>MySQL</code> 上层判断此版本是否满足 <code>update</code> 的 <code>where</code> 条件。若满足 (需要更新)，则 <code>MySQL</code> 会重新发起一次读操作，此时会读取行的最新版本 (并加锁)！<br>具体表现如下:<br>此时有两个 <code>Session</code>：<code>Session1</code> 和 <code>Session2</code>！<br><code>Session1</code> 执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> color = <span class="string">'blue'</span> <span class="keyword">where</span> color = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure>

<p>先不 <code>Commit</code> 事务！<br>与此同时 <code>Ssession2</code> 执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> color = <span class="string">'blue'</span> <span class="keyword">where</span> color = <span class="string">'white'</span>;</span><br></pre></td></tr></table></figure>

<p><code>Session2</code> 尝试加锁的时候，发现行上已经存在锁，<code>InnoDB</code> 会开启 <code>semi-consistent read</code>，返回最新的 <code>committed</code> 版本 (1,red)，(2，white)，(5,red)，(7,white)。<code>MySQL</code> 会重新发起一次读操作，此时会读取行的最新版本 (并加锁)!<br>而在 <code>RR</code> 隔离级别下，<code>Session2</code> 只能等待！</p>
<h4 id="两个疑问"><a href="#两个疑问" class="headerlink" title="两个疑问"></a>两个疑问</h4><p>在 <code>RC</code> 级别下，不可重复读问题需要解决么？<br>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！<code>Oracle</code> 的默认隔离级别就是 <code>RC</code>，你们改过 Oracle 的默认隔离级别么？</p>
<p>在 <code>RC</code> 级别下，主从复制用什么 <code>binlog</code> 格式？<br>OK, 在该隔离级别下，用的 <code>binlog</code> 为 <code>row</code> 格式，是基于行的复制！<code>Innodb</code> 的创始人也是建议 <code>binlog</code> 使用该格式！</p>
<h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><ul>
<li>数据库默认隔离级别: <code>mysql —repeatable、oracle，sql server —read commited</code></li>
<li><code>mysql binlog</code> 的格式三种：<code>statement</code>、<code>row</code>、<code>mixed</code></li>
<li>为什么 <code>mysql</code> 用的是 <code>repeatable</code> 而不是 <code>read committed:</code> 在 <code>5.0</code> 之前只有 <code>statement</code> 一种格式，而主从复制存在了大量的不一致（<code>bug</code>），故选用 <code>repeatable</code>。</li>
<li>为什么其他数据库默认的隔离级别都会选用 <code>read commited</code> 原因有二：<code>repeatable</code> 存在间隙锁会使死锁的概率增大，在 <code>RR</code> 隔离级别下，条件列未命中索引会锁表！而在 <code>RC</code> 隔离级别下，只锁行</li>
<li>在 <code>RC</code> 级用别下，主从复制用什么 <code>binlog</code> 格式：<code>row</code> 格式，是基于行的复制！如果使用 <code>statement</code> 格式，会导致主从不一致。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.cnblogs.com/rjzheng/p/10510174.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/10510174.html</a></li>
<li><a href="https://www.cnblogs.com/digdeep/p/4968453.html" target="_blank" rel="noopener">https://www.cnblogs.com/digdeep/p/4968453.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>2020/11/带你看Eureka源代码</title>
    <url>/2020/11/17/2020/11/%E5%B8%A6%E4%BD%A0%E7%9C%8BEureka%E6%BA%90%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>首先，我们来看一下Eureka的架构图，有一个整体的认识。传送门：<a href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance" target="_blank" rel="noopener">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a></p>
<p><img src="http://static.cyblogs.com/eureka_architecture.png" alt="http://static.cyblogs.com/eureka_architecture.png"></p>
<h4 id="Eureka核心功能"><a href="#Eureka核心功能" class="headerlink" title="Eureka核心功能"></a>Eureka核心功能</h4><p><strong>服务注册</strong></p>
<p>在微服务启动时，首先，服务提供者需要将自己的服务注册到服务注册中心，服务提供者在启动的时候会发送<code>REST</code>请求将自己注册到服务注册中心上，并带上一些元信息。服务注册中心接收到<code>REST</code>请求，会将元信息存储在一个双层<code>Map</code>中，第一层<code>key</code>是服务名，第二层<code>key</code>是具体服务的实例名。</p>
<p>注意：在服务注册时，需要确认一下<code>eureka.client.register-with-eureka=true</code>是否正确，如果为false是禁止向服务注册中心注册的。</p>
<p><strong>服务同步</strong></p>
<p>当服务成功的注册到了注册中心之后，由于注册中心可能是高可用的集群，那么我们的服务可能只注册到了一个集群中的一个注册中心上，被一个注册中心所维护，而不被另外一个注册中心所维护，那么这个时候，我们就需要将这个注册中心的信息同步给集群中其他的注册中心，这就叫服务同步。那么他是如何实现的呢？</p>
<p>由于在集群中，一个注册中心互为其他注册中心的服务，当服务提供者请求到一个服务注册中心后，它会将请求转发到其他服务注册中心，实现注册中心之间的服务同步。</p>
<p>通过服务同步，服务提供者的服务信息可以通过集群中的任何一个服务注册中心获取。</p>
<p><strong>服务续约</strong></p>
<p>在注册完成后。服务提供者会维护一个心跳告诉注册中心服务，心跳间隔大约是<code>30S</code>，防止注册中心剔除服务， 正常情况下，如果<code>Eureka Server</code>在<code>90秒</code>没有收到<code>Eureka</code>客户的续约，它会将实例从其注册表中删除。这个过程称为服务续约。</p>
<p><strong>服务获取</strong></p>
<p>当一切的注册相关工作完成后，我们自然要获取服务清单，那么如何获取服务呢？ 启动服务消费者后，消费者会发送一个<code>REST</code>请求给服务注册中心，来获取上面注册的服务清单。 而服务注册中心会维护一份只读清单返回给消费者客户端，该缓存清单<code>30s</code>更新一次。</p>
<p><strong>服务调用</strong></p>
<p>消费者获取服务清单后，可以通过服务名获取到具体服务实例与实例的元数据信息。这个时候，我们可以通过<code>Ribbon</code>调用我们的目标服务，默认采用轮询的方式，从而实现负载均衡。</p>
<p><strong>服务下线</strong></p>
<p>当我们需要对服务实例进行正常的关闭操作时，它会触发一个服务下线的<code>REST</code>请求给服务端。注册中心接收到请求后，将该服务状态置为<code>DOWN</code>，并把下线时间传播出去。</p>
<p><strong>失效剔除</strong></p>
<p>有的时候，我们的服务意外挂掉了，那么<code>Eureka</code>如何识别出我们异常的服务，并将其剔除呢？</p>
<p>服务注册中心启动时会创建定时任务，默认<code>60s</code>一次，将当前清单中超时（<code>90s</code>）没有续约的服务剔除。</p>
<p><strong>自我保护</strong></p>
<p>当失效剔除机制引入的时候，就会有一个问题，如果一个地区网络特别不稳定，那么服务可能不会续约，但我们还需要这个服务存在。这个时候，我们怎么解决呢？</p>
<p>还好，<code>Eureka</code>拥有自我保护机制，可以很好的解决这个问题。<code>Eureka Server</code>在运行期间，会统计心跳失败的比例在<code>15分钟</code>之内是否低于<code>85%</code>，如果低于，就会将当前实例注册信息保护起来，同时提示一个警告，一旦进入保护模式，<code>Eureka Server</code>将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据。也就是不会注销任何微服务。 但是保护机制也有可能会出现问题，导致服务实例不能够被正确剔除。比如在保护期间，实例出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败。 </p>
<h4 id="源码细节与验证"><a href="#源码细节与验证" class="headerlink" title="源码细节与验证"></a>源码细节与验证</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  renewsLastMin.start();</span><br><span class="line">  <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    evictionTaskRef.get().cancel();</span><br><span class="line">  &#125;</span><br><span class="line">  evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</span><br><span class="line">  <span class="comment">// 服务剔除，private long evictionIntervalTimerInMs = 60 * 1000;</span></span><br><span class="line">  evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">                         serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">                         serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance" target="_blank" rel="noopener">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98572822" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98572822</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Eureka</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller里面方法不小心写成了private的问题</title>
    <url>/2020/12/04/2020/12/Controller%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%86%99%E6%88%90%E4%BA%86private%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><p>今天本来是为了解决一个<code>Apollo</code>配置与<code>Code</code>同时变更不一致问题，我需要去通过<code>SPI</code>的方式去重写<code>Apollo</code>刷新<code>Remote</code>配置。所以，我就写一个很小的<code>DEMO</code>来验证每次变更<code>Apollo</code>配置对我服务端的取数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;market.test.chenyuan&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String testName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应在<code>Apollo</code>的配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">market.test.name</span> = <span class="string">Test1111</span></span><br></pre></td></tr></table></figure>

<p><code>Controller</code>层的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MarketConfig marketConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/sayHello"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123; <span class="comment">// 注意，这里由于我的不小心写成了private</span></span><br><span class="line">    <span class="keyword">return</span> marketConfig.getMarketTestName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我就发起请求来验证我的取数，结果给我报了<code>NullpointException</code>的异常。因为这种代码几乎每天都在写，一下次说我的<code>Bean</code>没有注入进来，还有点方。</p>
<p>然后，我细心的<code>debug</code>了看了一下。如图所示：</p>
<p><img src="http://static.cyblogs.com/Jietu20201204-085800.jpg" alt="http://static.cyblogs.com/Jietu20201204-085800.jpg"></p>
<p>图片可以说明：</p>
<ul>
<li><p><code>Spring</code>容器100%已经存在了<code>MarketConfig</code>的<code>Bean</code>对象；</p>
</li>
<li><p>但是<code>MarketConfig</code>在该<code>Controller</code>里面100%没有注入进来 ；</p>
</li>
<li><p><code>this</code>显示出了一个代理的路径；</p>
<p>于是，我在同样的<code>Controller</code>去请求另外一个<code>Method</code>，但可以正常访问。</p>
</li>
</ul>
<p><img src="http://static.cyblogs.com/Jietu20201204-090305.jpg" alt="http://static.cyblogs.com/Jietu20201204-090305.jpg"></p>
<ul>
<li><code>Spring</code>容器100%已经存在了<code>MarketConfig</code>的<code>Bean</code>对象；</li>
<li>而且是可以确定这次<code>MarketConfig</code>是有注入进来的（没有展示图，不太方便）</li>
<li><code>this</code>直接是显示的自己的地址</li>
</ul>
<p>由于我就比较了一下方法的区别，最主要的区别点就是在于一个是<code>private</code>，另外一个是<code>public</code>。</p>
<p>其实，这里我就很快明白了。因为我们这边在<code>Controller</code>层做了一些AOP来做监控与埋点。现阶段主要用的是<code>CAT</code>（现在做了很多的一些封装，后面可以分享下，如何做到无浸入性以及与<code>Apollo</code>的打通）。</p>
<p><code>AOP</code> 里面用的是反射机制，用<code>private</code>修饰的类是注入失败的，因为拿不到，只能用<code>public</code>或者<code>protected</code>修饰。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/qq_31451081/article/details/84100575" target="_blank" rel="noopener">https://blog.csdn.net/qq_31451081/article/details/84100575</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>写在2020年最后一天</title>
    <url>/2020/12/31/2020/12/%E5%86%99%E5%9C%A82020%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<p>2020年，感觉真的是一个不平凡的年。是时间流逝非常快的一年，也是成长最快的一年。感谢身边所有的人~</p>
<h4 id="谈口罩"><a href="#谈口罩" class="headerlink" title="谈口罩"></a>谈口罩</h4><p>还记得年初的时候，怕被疫情隔在家里了，正月初三就开车到了深圳。那时候听新闻说可能要带半年或者一年的口罩，当时感觉不可思议，根本不可能。现在一年已经已经过去了，但口罩还依然要继续……</p>
<p>说到口罩，记得刚刚开始在老家带口罩的时候，家里好多人不理解，为什么要戴口罩？（估计跟很多老美一样，觉得不尊重，觉得自己没病等）到了“恐慌”的时候，家里人比我们更着急，更加上心。在这次疫情中，真的也是感受到了人间百态，看到了白衣天使的伟大，看到了一些黑心的商家，看到了那些平凡的人做着不平凡的事儿，感受到了近些年来祖国的伟大（非常感谢国内短视频）。</p>
<p>今年给我最大的感受是繁忙、成长、充实，总的来说是收获的一年吧。</p>
<h4 id="写作与公众号"><a href="#写作与公众号" class="headerlink" title="写作与公众号"></a>写作与公众号</h4><p>年初的时候开启了我的个人公共账号「简栈文化」，一共发表了文章112篇，几乎全部都是跟技术相关的，在编写与梳理这些知识的时候，内心是充满热情与喜悦的。特别是大家去催更的时候，或者有问题请教你的时候，跟你讨论的时候，所有的熬夜与辛苦都是值得的，因为你获得的知识与朋友。后面也是因为工作原因，更新就慢慢的停了下来，但内心一直牵挂着写作这件事儿。</p>
<h4 id="谈工作"><a href="#谈工作" class="headerlink" title="谈工作"></a>谈工作</h4><p>今年可以说自己是换了工作，也可以说自己没有换工作，因为做的事情不同了，从楼上换到了楼下，但最大的老板还是同样的老板。不过，还是真的很感谢保险与国际的同事，都给了我很大的帮助、鼓励、肯定。在保险从事的是信贷相关的业务，从小白变成了有一丝丝信贷经验的从业者，也有着自己的小团队，而且氛围非常好，非常的优秀。到国际做的是证券业务，团队又是从0开始搭建，业务又不是很熟悉，感觉一下突然回到了4年前。经过了4个月左右的时间，终于又把团队搭建起来了，同时也在努力的去学习业务与技术。更重要的，我自己对自己的要求更高了，想做的更好。这次的团队跟之前一样，无可挑剔，更加的棒~</p>
<h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>这一年虽然看的书籍不是特别多（差不多12本），但是因为这一年的写作原因，内心是非常愿意静下来去好好看一本的。不管是技术的书籍，还是人物传记的书籍，总能在从中学到一些东西，哪怕只有其中只有某一句话、一件事儿、一个技术难点、一个技巧也是非常开心的。现在看书主要是在Kindle上面，技术书籍就会买纸质版本的，非常棒的书籍纸质版与电子版都买，还是为了图方便。不管如何，只要找到自己喜欢的方式，做任何事情都是对的~</p>
<h4 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h4><p>这一年，跟我老婆吵架非常的少，但记忆中好像也有这么1<del>2次是比较严重的，但都能很快过去。都说一个成功男人的背后一定有一个优秀的女人，我非常赞同。我觉得在思想上，我家那位比我要强，我是属于追赶她的情况。今年，一起去南京休闲游完了几天，特别喜欢这种慢悠悠，自由自在的旅行。一转眼，我们已经认识了10年，本想2人在很久以前就一直筹划着要过一个非常难忘的10周年，为此要做很多的准备，也是因为工作忙碌的原因，算是过了一个开心的10周年吧。这一年我从以前什么都不管慢慢开始的变为想去用心准备点什么，付出一点什么。为了明年去更多的没有去过的地方，特此还跟我老婆买了南航的随心飞，希望能去更多的地方看看这个美好的世界，去更多的地方打打卡。这几天还对摄影有点兴趣，日后可以好好学习学习</del></p>
<h4 id="健康-amp-保险"><a href="#健康-amp-保险" class="headerlink" title="健康&amp;保险"></a>健康&amp;保险</h4><p>最近2年左右的时间，真的听说了太多太多亲人们身体不好做手术的，家里的老奶奶、舅姥姥等去世的消息。其实人到30~40岁之间，应该是蛮有经济压力的，自己的梦想还有很多未实现，爸爸妈妈的年纪也开始慢慢到了一个体质变弱、疾病变多的情况，所以今年我们为2边的家人都配置了意外险、百万医疗险，为自己也配置了这些，也终于在2020年的最后一天为我们俩配置了重疾险（本来想着买港险的，可这疫情一拖就是一年）。虽然这些保险远远还不够，但是也不用太着急，首先有了基本的保障，后面再慢慢的去添加就好了。起码，真的哪天有意外来临，也不会变得很被动。</p>
<h4 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h4><p>今年一年跟我老婆也获得一些新朋友，特别是公共的朋友。在深圳这个城市，能够找到一些私下要好的朋友是很难的，因为大家的生活节奏都很快，大部分都不认识隔壁的邻居是谁，每天都是很早的去上班，很晚才回家来。如果有一些私下的朋友，节假日的时候可以一起凑个饭局，一起郊游，一起钓个鱼什么的都是一件很幸福的事情。所以，珍惜现在已有的好朋友，结交更多更优秀的人。</p>
<p>我知道立再多的flag也不如把一个flag做好来的重要，我希望自己在2021年里能更多知道自己的内心，知道自己追求的是什么？如何让自己的内心世界丰富起来，如果让自己做任何的事情都不会被别人牵着鼻子走，如何去影响、号召更多的其他人一起来做事。</p>
<p>2021年给自己的目的是：抓重点、求突破、顾家庭。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>2020</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis二值状态统计的巧妙使用</title>
    <url>/2021/01/31/2021/01/Redis%E4%BA%8C%E5%80%BC%E7%8A%B6%E6%80%81%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h4><p>这里的二值状态就是指集合元素的取值就只有 0 和 1 两种。在签到打卡的场景中，我们只用记录：</p>
<ul>
<li>签到（1）</li>
<li>未签到（0）</li>
</ul>
<p>所以它就是非常典型的二值状态，在签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p>
<p>这个时候，我们就可以选择 <code>Bitmap</code>。这是 <code>Redis</code> 提供的扩展数据类型。我来给你解释一下它的实现原理。<code>Bitmap</code> 本身是用 <code>String</code> 类型作为底层数据结构实现的一种统计二值状态的数据类型。<code>String</code> 类型是会保存为二进制的字节数组，所以，<code>Redis</code> 就把字节数组的每个 <code>bit</code> 位利用起来，用来表示一个元素的二值状态。</p>
<p>你可以把 <code>Bitmap</code> 看作是一个 <code>bit</code> 数组。<code>Bitmap</code> 提供了 <code>GETBIT/SETBIT</code> 操作，使用一个偏移值 <code>offset</code> 对 <code>bit</code> 数组的某一个 <code>bit</code> 位进行读和写。不过，需要注意的是，<code>Bitmap</code> 的偏移量是从 0 开始算的，也就是说 <code>offset</code> 的最小值是 0。当使用 <code>SETBIT</code> 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。</p>
<p>Bitmap 还提供了 <code>BITCOUNT</code> 操作，用来统计这个 bit 数组中所有“1”的个数。那么，具体该怎么用 <code>Bitmap</code> 进行签到统计呢？我还是借助一个具体的例子来说明。</p>
<h4 id="统计一个人签到"><a href="#统计一个人签到" class="headerlink" title="统计一个人签到"></a>统计一个人签到</h4><p>假设我们要统计 <code>ID 3000</code> 的用户在 2020 年 8 月份的签到情况，就可以按照下面的步骤进行操作。</p>
<ul>
<li><p>第一步，执行下面的命令，记录该用户 8 月 3 号已签到。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETBIT uid:sign:3000:202008 2 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，检查该用户 8 月 3 日是否签到。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GETBIT uid:sign:3000:202008 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步，统计该用户在 8 月份的签到次数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BITCOUNT uid:sign:3000:202008</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这样，我们就知道该用户在 8 月份的签到情况了，是不是很简单呢？</p>
<h4 id="1-亿个用户-10-天的签到"><a href="#1-亿个用户-10-天的签到" class="headerlink" title="1 亿个用户 10 天的签到"></a>1 亿个用户 10 天的签到</h4><p>接下来，你可以再思考一个问题：如果记录了 1 亿个用户 10 天的签到情况，你有办法统计出这 10 天连续签到的用户总数吗？</p>
<p>在介绍具体的方法之前，我们要先知道，<code>Bitmap</code> 支持用 <code>BITOP</code> 命令对多个 <code>Bitmap</code> 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 <code>Bitmap</code> 中。</p>
<p>我以按位“与”操作为例来具体解释一下。从下图中，可以看到，三个 <code>Bitmap</code>： <code>bm1</code>、<code>bm2</code> 和 <code>bm3</code>，对应 bit 位做“与”操作，结果保存到了一个新的 Bitmap 中（示例中，这个结果 Bitmap 的 key 被设为“resmap”）。</p>
<p><img src="https://static001.geekbang.org/resource/image/41/7a/4151af42513cf5f7996fe86c6064f97a.jpg" alt="https://static001.geekbang.org/resource/image/41/7a/4151af42513cf5f7996fe86c6064f97a.jpg"></p>
<p>回到刚刚的问题，在统计 1 亿个用户连续 10 天的签到情况时，你可以把每天的日期作为 key，每个 key 对应一个 1 亿位的 <code>Bitmap</code>，每一个 bit 对应一个用户当天的签到情况。</p>
<p>接下来，我们对 10 个 <code>Bitmap</code> 做“与”操作，得到的结果也是一个 <code>Bitmap</code>。在这个 <code>Bitmap</code> 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。最后，我们可以用 <code>BITCOUNT</code> 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。</p>
<p>现在，我们可以计算一下记录了 10 天签到情况后的内存开销。每天使用 1 个 1 亿位的 <code>Bitmap</code>，大约占 <code>12MB</code> 的内存（10^8/8/1024/1024），10 天的 <code>Bitmap</code> 的内存开销约为 <code>120MB</code>，内存压力不算太大。不过，在实际应用时，最好对 Bitmap 设置过期时间，让 <code>Redis</code> 自动删除不再需要的签到记录，以节省内存开销。</p>
<p>所以，如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。在记录海量数据时，<code>Bitmap</code> 能够有效地节省内存空间。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://time.geekbang.org/column/article/280680" target="_blank" rel="noopener">https://time.geekbang.org/column/article/280680</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>了解一下MYSQL官方数据库Sakila</title>
    <url>/2021/01/27/2021/01/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BMYSQL%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E5%BA%93Sakila/</url>
    <content><![CDATA[<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>我们通过Docker快速的拉取一个环境，这样子对于学习来说成本比价低。直接参照<a href="https://hub.docker.com/r/mysql/mysql-server/" target="_blank" rel="noopener">https://hub.docker.com/r/mysql/mysql-server/</a> 来做就好了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 快速拉取一个mysql的image</span></span><br><span class="line">➜  ~ docker pull mysql/mysql-server</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from mysql/mysql-server</span><br><span class="line">501550cfd5c0: Pull complete</span><br><span class="line">e0509d775110: Pull complete</span><br><span class="line">d5a01765d011: Pull complete</span><br><span class="line">970507e942eb: Pull complete</span><br><span class="line">Digest: sha256:0bb21c0f1aa9296e7deafacec5703b80e4d923dfdfcaa2efbe0c8377a8592128</span><br><span class="line">Status: Downloaded newer image for mysql/mysql-server:latest</span><br><span class="line">docker.io/mysql/mysql-server:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动mysql容器</span></span><br><span class="line">➜  ~ docker run --name=mysql1 -d mysql/mysql-server:latest</span><br><span class="line">780c312f6fa1d3b001cb7c97fddb7df39fea61f27732b5fb9b59d5a29b12cfde</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看CONTAINER</span></span><br><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS                       NAMES</span><br><span class="line">780c312f6fa1        mysql/mysql-server:latest   "/entrypoint.sh mysq…"   59 seconds ago      Up 58 seconds (healthy)   3306/tcp, 33060-33061/tcp   mysql1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看默认的密码</span></span><br><span class="line">➜  ~ docker logs mysql1 2&gt;&amp;1 | grep GENERATED</span><br><span class="line">[Entrypoint] GENERATED ROOT PASSWORD: enohmYS*ecvISAqYh@GafRoDP3v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接登录进去</span></span><br><span class="line">➜  ~ docker exec -it mysql1 mysql -uroot -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 17</span><br><span class="line">Server version: 8.0.23</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改一下容易记忆的密码，方便下次来使用</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'root'</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>这是我认为非常快速的一个环境搭建的方式。</p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>一般像Orace、MySQL这些好的软件都会提供一些官网的数据来让方便学习着来学习。<a href="https://dev.mysql.com/doc/index-about.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/index-about.html</a> </p>
<p><img src="http://static.cyblogs.com/Jietu20210127-205659@2x.jpg" alt="http://static.cyblogs.com/Jietu20210127-205659@2x.jpg"></p>
<p>那我们就下载<code>sakila database</code>来学习一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show tables;</span></span><br><span class="line">+----------------------------+</span><br><span class="line">| Tables_in_sakila           |</span><br><span class="line">+----------------------------+</span><br><span class="line">| actor                      |//演员表</span><br><span class="line">| address                    |//地址表</span><br><span class="line">| category                   |//影片的分类</span><br><span class="line">| city                       |//城市信息</span><br><span class="line">| country                    |//国家信息</span><br><span class="line">| customer                   |//观看影片的用户信息</span><br><span class="line">| film                       |//影片信息</span><br><span class="line">| film_actor                 |//影片演员关联表</span><br><span class="line">| film_category              |//影片分类关联表</span><br><span class="line">| film_text                  |//影片的文本信息，更新film的时候通过触发器保持film_text的同步</span><br><span class="line">| inventory                  |//库存信息</span><br><span class="line">| language                   |//影片的语言</span><br><span class="line">| payment                    |//租赁付款信息</span><br><span class="line">| rental                     |//某个影片库存的租赁信息</span><br><span class="line">| staff                      |//商店员工信息</span><br><span class="line">| store                      |//影片的商店信息</span><br><span class="line">+----------------------------+</span><br><span class="line">22 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>整体的来看一下数据的一个关系</p>
<p><img src="http://static.cyblogs.com/sakila.png" alt="http://static.cyblogs.com/sakila.png"></p>
<h4 id="通过Sakila了解一些索引问题"><a href="#通过Sakila了解一些索引问题" class="headerlink" title="通过Sakila了解一些索引问题"></a>通过Sakila了解一些索引问题</h4><p><img src="http://static.cyblogs.com/Jietu20210127-213735.jpg" alt="http://static.cyblogs.com/Jietu20210127-213735.jpg"></p>
<p>这里会有一个非常奇怪的问题，就是第一条sql竟然走了<code>idx_actor_last_name</code>索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>可以理解为是走的B+树，叶子节点里面刚好存储的是主键，而主键刚好是actor_id，select的时候刚好是主键一个值吗？</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://zhuanlan.zhihu.com/p/50682992" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50682992</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>拥有一套属于自己的Spring源码环境</title>
    <url>/2021/02/19/2021/02/%E6%8B%A5%E6%9C%89%E4%B8%80%E5%A5%97%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><code>Spring</code>是一个非常优秀的开源项目，而且基本是互联网的标配。随着这几年的源码阅读习惯，有用一套自己的源码阅读笔记项目已经是水到渠成。今天就来在本地编译一份，以便于后面记录核心笔记用。</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><h5 id="1-准备好源代码"><a href="#1-准备好源代码" class="headerlink" title="1.准备好源代码"></a>1.准备好源代码</h5><ul>
<li><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">https://spring.io/projects/spring-framework</a></li>
<li><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></li>
<li><a href="https://gitee.com/mirrors/Spring-Framework" target="_blank" rel="noopener">https://gitee.com/mirrors/Spring-Framework</a> (推荐，毕竟速度快，而且每天会跟<code>github</code>同步一次)</li>
<li><a href="https://gitee.com/vernon/Spring-Framework" target="_blank" rel="noopener">https://gitee.com/vernon/Spring-Framework</a> (为了自己可以提交代码，必须要<code>fork</code>一份)</li>
</ul>
<p>为什么贴这些<code>url</code>地址，是因为提醒我们所有人，官网与<code>github</code>是我们最先关注的地方。</p>
<p><code>gradle.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">version</span>=<span class="string">5.3.5-SNAPSHOT</span></span><br><span class="line"><span class="meta">org.gradle.jvmargs</span>=<span class="string">-Xmx1536M</span></span><br><span class="line"><span class="meta">org.gradle.caching</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">org.gradle.parallel</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">kotlin.stdlib.default.dependency</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>从上面可以看出来，我们现在用到是<code>spring 5.3.5-SNAPSHOT</code>版本。后面会遇到一些编译问题，避免大家踩坑，我直接说。这里依赖的JDK需要在JDK11。</p>
<h5 id="2-JDK准备"><a href="#2-JDK准备" class="headerlink" title="2.JDK准备"></a>2.JDK准备</h5><p>下载<code>JDK11</code>的版本：<a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk11-downloads.html</a></p>
<p>但是，但是，但是官网的实在是太慢了，所以我这里就直接改为<code>openjdk11</code>了。传送门：<a href="https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/</a> 下载速度就看你家里的带宽了，我基本在<code>3M+</code>左右~ </p>
<p><img src="http://static.cyblogs.com/Jietu20210219-223632.jpg" alt="http://static.cyblogs.com/Jietu20210219-223632.jpg"></p>
<p>没有对比就没有伤害啊。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-223756.jpg" alt="http://static.cyblogs.com/Jietu20210219-223756.jpg"></p>
<p>配置好项目中使用的<code>JDK</code>版本，这边因为诉求不一样，平时基本还是用的<code>JDK8</code>。</p>
<h5 id="3-Gradle安装"><a href="#3-Gradle安装" class="headerlink" title="3.Gradle安装"></a>3.Gradle安装</h5><p>因为我这里是<code>Mac</code>系统，所以一般的软件我都会采用<code>brew</code>来实现，因为实在太方便了。一行命令搞定~</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install gradle</span><br></pre></td></tr></table></figure>

<p>下面是我安装的gradle信息，是最新的版本6.7。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ gradle -v</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 6.7</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Build time:   2020-10-14 16:13:12 UTC</span><br><span class="line">Revision:     312ba9e0f4f8a02d01854d1ed743b79ed996dfd3</span><br><span class="line">Kotlin:       1.3.72</span><br><span class="line">Groovy:       2.5.12</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.8 compiled on May 10 2020</span><br><span class="line">JVM:          1.8.0_172 (Oracle Corporation 25.172-b11)</span><br><span class="line">OS:           Mac OS X 10.15.7 x86_64</span><br></pre></td></tr></table></figure>

<h5 id="4-Intellij-IDEA-2020"><a href="#4-Intellij-IDEA-2020" class="headerlink" title="4.Intellij IDEA 2020"></a>4.Intellij IDEA 2020</h5><p>因为<code>spring</code>在代码中有对<code>Kotlin</code>有一些依赖（低版本的可能会出现依赖问题），建议搭建升级到比价新的版本。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-224353@2x.jpg" alt="http://static.cyblogs.com/Jietu20210219-224353@2x.jpg"></p>
<h4 id="构建源码"><a href="#构建源码" class="headerlink" title="构建源码"></a>构建源码</h4><p>因为<code>spring</code>依赖与<code>gradle</code>，而且都是国外的网站，相对来说网速会非常的慢。这里也是采用更换镜像的方式来加速处理。</p>
<p><code>build.gradle</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">	<span class="comment">// 优先本地</span></span><br><span class="line">	mavenLocal()</span><br><span class="line">	maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/groups/public/'</span> &#125; <span class="comment">//阿里云</span></span><br><span class="line">	maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/repositories/jcenter'</span> &#125;</span><br><span class="line">	maven &#123; url <span class="string">"https://repo.spring.io/snapshot"</span> &#125; <span class="comment">// Reactor</span></span><br><span class="line"></span><br><span class="line">	mavenCentral()</span><br><span class="line">	maven &#123; url <span class="string">"https://repo.spring.io/libs-spring-framework-build"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>settings.gradle</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">	<span class="comment">// 新增配置</span></span><br><span class="line">	maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/groups/public/'</span> &#125; <span class="comment">//阿里云</span></span><br><span class="line">	maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/repositories/jcenter'</span> &#125;</span><br><span class="line">	maven &#123; url <span class="string">"https://repo.spring.io/snapshot"</span> &#125;</span><br><span class="line"></span><br><span class="line">	gradlePluginPortal()</span><br><span class="line">	maven &#123; url <span class="string">'https://repo.spring.io/plugins-release'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置一下<code>gradle</code>的参数</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-224901.jpg" alt="http://static.cyblogs.com/Jietu20210219-224901.jpg"></p>
<h4 id="构建成功验证"><a href="#构建成功验证" class="headerlink" title="构建成功验证"></a>构建成功验证</h4><p>找到<code>ApplicationContext</code>接口，显示它的一个类关系图。如果出现下图所示类图界面说明构建成功了！(构建过程就是找依赖对象的过程)</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-173001@2x.jpg" alt="http://static.cyblogs.com/Jietu20210219-173001@2x.jpg"></p>
<h4 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h4><p>查看官方<a href="https://github.com/spring-projects/spring-framework/blob/master/import-into-idea.md" target="_blank" rel="noopener">import-into-idea.md</a>文档，如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.Precompile spring-oxm with ./gradlew :spring-oxm:compileTestJava</span><br><span class="line">2.Import into IntelliJ (File -&gt; New -&gt; Project from Existing Sources -&gt; Navigate to directory -&gt; Select build.gradle)</span><br><span class="line">3.When prompted exclude the spring-aspects module (or after the import via File-&gt; Project Structure -&gt; Modules)</span><br><span class="line">4.Code away</span><br></pre></td></tr></table></figure>

<h5 id="1-编译spring-oxm模块"><a href="#1-编译spring-oxm模块" class="headerlink" title="1.编译spring-oxm模块"></a>1.编译spring-oxm模块</h5><p>先编译<code>spring-oxm</code>下的<code>compileTestjava</code>，点击右上角<code>gradle</code>打开编译视图，找到<code>spring-oxm</code>模块，然后在<code>other</code>下找到<code>compileTestjava</code>，双击即可！</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-225904.jpg" alt="http://static.cyblogs.com/Jietu20210219-225904.jpg"></p>
<h5 id="2-编译spring-core模块"><a href="#2-编译spring-core模块" class="headerlink" title="2.编译spring-core模块"></a>2.编译spring-core模块</h5><p>利用同样的方式，编译<code>spring-core</code>模块，出现<code>BUILD SUCCESSFUL</code>代码成功。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-230123.jpg" alt="http://static.cyblogs.com/Jietu20210219-230123.jpg"></p>
<h5 id="3-都编译完成且成功之后，开始编译整个工程"><a href="#3-都编译完成且成功之后，开始编译整个工程" class="headerlink" title="3.都编译完成且成功之后，开始编译整个工程"></a>3.都编译完成且成功之后，开始编译整个工程</h5><p>打开右侧<code>Gradle</code>插件 <code>spring-&gt;build-&gt;build</code>。<br>编译时间，每个人电脑的性能不一样，所需时间也不一样。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-231519.jpg" alt="http://static.cyblogs.com/Jietu20210219-231519.jpg"></p>
<p>我这里基本上全部成功，但是在<code>Task :spring-webflux:test</code>模块有一个<code>test</code>跑失败。算是有一点小瑕疵，但不影响整个编译。</p>
<p><img src="http://static.cyblogs.com/Jietu20210219-231701.jpg" alt="http://static.cyblogs.com/Jietu20210219-231701.jpg"></p>
<h4 id="源码测试"><a href="#源码测试" class="headerlink" title="源码测试"></a>源码测试</h4><p>构建成功了，源码编译成功了，能否用还不知道，还要测试通过才说明源码可以用了。直接在<code>spring-context</code>里面创建我们的一个<code>service</code>，然后通过<code>ApplicationContext</code>去获取它，并执行它的一个方法。</p>
<p><img src="http://static.cyblogs.com/Jietu20210220-090140.jpg" alt="http://static.cyblogs.com/Jietu20210220-090140.jpg"></p>
<p>代码部分我已经<code>push</code>上去了：<a href="https://gitee.com/vernon/Spring-Framework，后续就可以自由自在的在上面标注以及验证了。" target="_blank" rel="noopener">https://gitee.com/vernon/Spring-Framework，后续就可以自由自在的在上面标注以及验证了。</a> </p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/weixin_44730681/article/details/107390331" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44730681/article/details/107390331</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/122732323" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/122732323</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次这么通俗易懂的讲Paxos算法</title>
    <url>/2021/02/27/2021/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%99%E4%B9%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%AE%B2Paxos%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="Paxos解决什么问题"><a href="#Paxos解决什么问题" class="headerlink" title="Paxos解决什么问题"></a>Paxos解决什么问题</h4><p>大家对<code>Paxos</code>的看法基本是“晦涩难懂”，虽然论文和网上文章也很多，但总觉得“云山雾罩”，也不知道其具体原理以及到底能解决什么问题。</p>
<p>究其原因，一方面是很多<code>Paxos</code>的资料都是在通过形式化的证明去论证算法的正确性，自然艰深晦涩；另一方面，基于<code>Paxos</code>的成熟工程实践并不多。本章试图由浅入深，从问题出发，一点点地深入<code>Paxos</code>的世界。</p>
<h5 id="一个基本的并发问题"><a href="#一个基本的并发问题" class="headerlink" title="一个基本的并发问题"></a>一个基本的并发问题</h5><p>先看一个基本的并发问题，如图116所示。假设有一个KV存储集群，三个客户端并发地向集群发送三个请求。请问，最后在get（X）的时候，X应该等于几？</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-000345.jpg" alt="http://static.cyblogs.com/Jietu20210228-000345.jpg"></p>
<p>图116（K，V）集群多写答案是：X=1、X=3或X=5都是对的！但X=4是错的！因为从客户端角度来看，三个请求是并发的，但三个请求到达服务器的顺序是不确定的，所以最终三个结果都有可能。</p>
<p>这里有很关键的一点：把答案换一种说法，即如果最终集群的结果是X=1，那么当Client1发送X=1的时候，服务器返回X=1；当Client2发送X=3的时候，服务器返回X=1；当Client3发送X=5的时候，服务器返回X=1。相当于Client1的请求被接受了，Client2、Client3的请求被拒绝了。如果集群最终结果是X=3或者X=5，是同样的道理。而这正是<code>Paxos</code>协议的一个特点。</p>
<h5 id="什么是“时序”"><a href="#什么是“时序”" class="headerlink" title="什么是“时序”"></a>什么是“时序”</h5><p>把问题进一步细化：假设KV集群有三台机器，机器之间互相通信，把自己的值传播给其他机器，三个客户端分别向三台机器发送三个请求，如图117所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-000644.jpg" alt="http://static.cyblogs.com/Jietu20210228-000644.jpg"></p>
<p>图117三台机器组成的（K，V）集群多写示意图假设每台机器都把收到的请求按日志存下来（包括客户端的请求和其他Node的请求）。当三个请求执行完毕后，三台机器的日志分别应该是什么顺序？</p>
<p>结论是：不管顺序如何，只要三台机器的日志顺序是一样的，结果就是正确的。如图118所示，总共有3的全排列，即6种情况，都是正确的。比如第1种情况，三台机器存储的日志顺序都是X=1、X=3、X=5，在最终集群里，X的值肯定等于5。其他情况类似。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-000811.jpg" alt="http://static.cyblogs.com/Jietu20210228-000811.jpg"></p>
<p>而下面的情况就是错误的：机器1的日志顺序是1、3、5，因此最终的值就是X=5；机器2是3、5、1，最终值是X=1；机器3的日志顺序是1、5、3，最终值是X=3。三台机器关于X的值不一致，如图109所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-000852.jpg" alt="http://static.cyblogs.com/Jietu20210228-000852.jpg"></p>
<p>通过这个简单的例子就能对“时序”有一个直观的了解：虽然三个客户端是并发的，没有先后顺序，但到了服务器的集群里必须保证三台机器的日志顺序是一样的，这就是所谓的“分布式一致性”。</p>
<h5 id="Paxos解决什么"><a href="#Paxos解决什么" class="headerlink" title="Paxos解决什么"></a>Paxos解决什么</h5><p>问题在例子中，Node1收到了X=1之后，复制给Node2和Node3；Node2收到X=3之后，复制给Node1和Node3；Node3收到X=5之后，复制给Node1和Node2。</p>
<p>客户端是并发的，三个Node之间的复制也是并发的，如何保证三个Node最终的日志顺序是一样的呢？也就是图118中6种正确情况中的1种。</p>
<p>比如Node1先收到客户端的X=1，之后收到Node3的X=5，最后收到Node2的X=3；Node2先收到客户端的X=3，之后收到Node1的X=1，最后收到Node3的X=5……</p>
<p>如何保证三个Node中存储的日志顺序一样呢？这正是接下来要讲的<code>Paxos</code>要解决的问题！</p>
<h4 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h4><p>在上文谈到了复制日志的问题，每个Node存储日志序列，Node之间保证日志完全一样。可能有人会问：为何要存储日志，直接存储最终的数据不就行了吗？</p>
<p>可以把一个变量X或一个对象看成一个状态机。每一次写请求，就是一次导致状态机发生变化的事件，也就是日志。</p>
<p>以上文中最简单的一个变量X为例，假设只有一个Node，3个客户端发送了三个修改X的指令，最终X的状态就是6，如图1110所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-001101.jpg" alt="http://static.cyblogs.com/Jietu20210228-001101.jpg"></p>
<p>图1110状态机X示意图把变量X扩展成MySQL数据库，客户端发送各种DML操作，这些操作落盘成Binlog。然后Binlog被应用，生成各种数据库表格（状态机），如图1111所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-001145.jpg" alt="http://static.cyblogs.com/Jietu20210228-001145.jpg"></p>
<p>这里涉及一个非常重要的思想：要选择持久化变化的“事件流（也就是日志流）”，而不是选择持久化“数据本身”（也就是状态机）。为何要这么做呢？原因有很多，列举如下：</p>
<p>（1）日志只有一种操作，就是append。而数据或状态一直在变化，可以add、delete、update。把三种操作转换成了一种，对于持久化存储来说简单了很多！</p>
<p>（2）假如要做多机之间数据同步，如果直接同步状态，状态本身可能有一个很复杂的数据结构（比如关系数据库的关联表、树、图），并且状态也一直在变化，要保证多个机器数据一致，要做数据比对，就很麻烦；而如果同步日志，日志是一个一维的线性序列，要做数据比对，则非常容易！</p>
<p>总之，无论从持久化，还是数据同步角度来看，存储状态机的输入事件流（日志流），都比存储状态机本身更容易。</p>
<p>基于这种思路，可以把状态机扩展为复制状态机。状态机的原理是：一样的初始状态+一样的输入事件=一样的最终状态。因此，要保证多个Node的状态完全一致，只要保证多个Node的日志流是一样的即可！即使这个Node宕机，只需重启和重放日志流，就能恢复之前的状态，如图1012所示。</p>
<p><img src="http://static.cyblogs.com/Jietu20210228-001253.jpg" alt="http://static.cyblogs.com/Jietu20210228-001253.jpg"></p>
<p>因此，就回到了上文最后的问题：复制日志！复制日志=复制任何数据（复制任何状态机）。因为任何复杂的数据（状态机）都可以通过日志生成！</p>
<h4 id="一个朴素而深刻的思想"><a href="#一个朴素而深刻的思想" class="headerlink" title="一个朴素而深刻的思想"></a>一个朴素而深刻的思想</h4><p><code>Paxos</code>的出现先经过了<code>Basic Paxos</code>的形式化证明，之后再有<code>Multi Paxos</code>，最后是应用场景。因为最开始没有先讲应用场景，所以直接看<code>Basic Paxos</code>的证明会很晦涩。本文将反过来，就以上文最后提出的问题为例，先介绍应用场景，再一步步倒推出<code>Paxos</code>和<code>Multi Paxos</code>。</p>
<p>当三个客户端并发地发送三个请求时，图118所示的6种可能的结果都是对的。因此，要找一种算法保证虽然每个客户端是并发地发送请求，但最终三个Node记录的日志的顺序是相同的，也就是图108所示的任取一种场景即可。</p>
<p>这里提出一个朴素而深刻的说法：全世界对数字1，2，3，4，5，……顺序的认知是一样的！所有人、所有机器，对这个的认知都是一样的！</p>
<p>当我说2的时候，全世界的人，都知道2排在1的后面、3的前面！2代表一个位置，这个位置一定在（1，3）之间。</p>
<p>把这个朴素的想法应用到计算机里面多个Node之间复制日志，会变成如下这样。当Node1收到X=1的请求时，假设要把它存放到日志中1号位置，存放前先询问另外两台机器1号位置是否已经存放了X=3或X=5；如果1号位置被占了，则询问2号位置……依此类推。如果1号位置没有被占，就把X=1存放到1号位置，同时告诉另外两个Node，把X=1存放到它们各自的1号位置！同样，Node2和Node3按此执行。</p>
<p>这里的关键思想是：虽然每个Node接收到的请求顺序不同，但它们对于日志中1号位置、2号位置、3号位置的认知是一样的，大家一起保证1号位置、2号位置、3号位置存储的数据一样！</p>
<p>在例子中可以看到，每个Node在存储日志之前先要问一下其他Node，之后再决定把这条日志写到哪个位置。这里有两个阶段：先问，再做决策，也就是<code>Paxos</code>2PC的原型！</p>
<p>把问题进一步拆解，不是复制三条日志，只复制一条。先确定三个Node的第1号日志，看有什么问题？</p>
<p>Node1询问后发现1号位置没有被占，因此它打算把X=1传播给Node2和Node3；同一时刻，Node2询问后发现1号位置也没有被占，因此它打算把X=3传播给Node1和Node3；同样，Node3也打算把X=5传播给Node1和Node2。</p>
<p>结果不就冲突了吗？会发现不要说多条日志，就算是只确定第1号位置的日志，都是个问题！</p>
<p>而Basic<code>Paxos</code>正是用来解决这个问题的。</p>
<p>首先，1号位置要么被Node1占领，大家都存放X=1；要么被Node2占领，大家都存放X=3；要么是被Node3占领，大家都存放X=5，少数服从多数！为了达到这个目的，Basic<code>Paxos</code>提出了一个方法，这个方法包括两点：</p>
<p>第1，Node1在填充1号位置的时候，发现1号位置的值被大多数确定了，比如是X=5（node3占领了1号位置，Node2跟从了Node3），则Node1就接受这个事实：1号位置不能用了，也得把自己的1号位置赋值成X=5。然后看2号位置能否把X=1存进去。同样地，如果2号也被占领了，就只能把它们的值拿过来填在自己的2号位置。只能再看3号位置是否可行……</p>
<p>第2，当发现1号位置没有被占，就锁定这个位置，不允许其他Node再占这个位置！除非它的权利更大。如果发现1号位置为空，在提交的时候发现1号位置被其他Node占了，就会提交失败，重试，尝试第二个位置，第三个位置……</p>
<p>所以，为了让1号位置日志一样，可能要重试好多次，每个节点都会不断重试2PC。这样不断重试2PC，直到最终各方达成一致的过程，就是<code>Paxos</code>协议执行的过程，也就是一个<code>Paxos</code>instance，最终确定一个值。而Multi<code>Paxos</code>就是重复这个过程，确定一系列值，也就是日志中的每一条！</p>
<p>接下来将基于这种思想详细分析<code>Paxos</code>算法本身。</p>
<h4 id="BasicPaxos算法"><a href="#BasicPaxos算法" class="headerlink" title="BasicPaxos算法"></a>Basic<code>Paxos</code>算法</h4><p>在前面的场景中提到三个Client并发地向三个Node发送三条写指令。对应到<code>Paxos</code>协议，就是每个Node同时充当了两个角色：Proposer和Acceptor。在实现过程中，一般这两个角色是在同一个进程里面的。</p>
<p>当Node1收到Client1发送的X=1的指令时，Node1就作为一个Proposer向所有的Acceptor（自己和其他两个Node）提议把X=1日志写到三个Node上面。</p>
<p>同理，当Node2收到Client2发送的X=3的指令，Node2就作为一个Proposer向所有的Acceptor提议；Node3同理。</p>
<p>下面详细阐述<code>Paxos</code>的算法细节。首先，每个Acceptor需要持久化三个变量（minProposalId，acceptProposalId，acceptValue）。在初始阶段：minProposalId=acceptProposalId=0，acceptValue=null。然后，算法有两个阶段：P1（Prepare阶段）和P2（Accept阶段）。</p>
<h5 id="P1（Prepare阶段）"><a href="#P1（Prepare阶段）" class="headerlink" title="P1（Prepare阶段）"></a>P1（Prepare阶段）</h5><p><img src="http://static.cyblogs.com/Jietu20210227-234242.jpg" alt="http://static.cyblogs.com/Jietu20210227-234242.jpg"></p>
<p>Prepare阶段P1a：Proposer广播prepare（n），其中n是本机生成的一个自增ID，不需要全局有序，比如可以用时间戳+IP。P1b：Acceptor收到prepare（n），做如下决策：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n &gt; minProposalId，回复Yes</span><br><span class="line">	同时，minProposalId=n（持久化）</span><br><span class="line">	返回(acceptProposalId，acceptValue)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	回复 No</span><br></pre></td></tr></table></figure>

<p>P1c：Proposer如果收到半数以上的yes，则取acceptorProposalId最大的acceptValue作为v，进入第二个阶段，即开始广播accept（n，v）。如果acceptor返回的都是null，则取自己的值作为v，进入第二个阶段！否则，n自增，重复P1a。</p>
<h5 id="P2（Accept阶段）"><a href="#P2（Accept阶段）" class="headerlink" title="P2（Accept阶段）"></a>P2（Accept阶段）</h5><p><img src="http://static.cyblogs.com/Jietu20210227-234722.jpg" alt="http://static.cyblogs.com/Jietu20210227-234722.jpg"></p>
<p>P2a：Proposer广播accept（n，v）。这里的n就是P1阶段的n，v可能是自己的值，也可能是第1阶段的acceptValue。P2b：Acceptor收到accept（n，v），做如下决策：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n &gt; minProposalId，回复Yes。同时</span><br><span class="line">	minProposalId=acceptProposalId=n（持久化）</span><br><span class="line">	acceptValue=value</span><br><span class="line">	<span class="keyword">return</span> minProposalId</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">	回复 No</span><br></pre></td></tr></table></figure>

<p>P2c：Proposer如果收到半数以上的yes，并且minProposalId=n，则算法结束。否则，n自增，重复P1a。</p>
<p>通过分析算法，会发现Basic<code>Paxos</code>有两个问题：</p>
<p>（1）<code>Paxos</code>是一个“不断循环”的2PC。在P1C或者P2C阶段，算法都可能失败，重新进行P1a。这就是通常所说的“活锁”问题，即可能陷入不断循环。</p>
<p>（2）每确定一个值，至少需要两次RTT（两个阶段，两个网络来回）+两次写盘，性能也是个问题。而接下来要讲的Multi<code>Paxos</code>就是要解决这两个问题。</p>
<h4 id="MultiPaxos算法"><a href="#MultiPaxos算法" class="headerlink" title="MultiPaxos算法"></a>Multi<code>Paxos</code>算法</h4><h5 id="问题1：活锁问题"><a href="#问题1：活锁问题" class="headerlink" title="问题1：活锁问题"></a>问题1：活锁问题</h5><p>在前面已经知道，Basic<code>Paxos</code>是一个不断循环的2PC。所以如果是多个客户端写多个机器，每个机器都是Proposer，会导致并发冲突很高，也就是每个节点都可能执行多次循环才能确定一条日志。极端情况是每个节点都在无限循环地执行2PC，也就是所谓的“活锁问题”。</p>
<p>为了减少并发冲突，可以变多写为单写，选出一个Leader，只让Leader充当Proposer。其他机器收到写请求，都把写请求转发给Leader；或者让客户端把写请求都发给Leader。</p>
<p>Leader的选举方法很多，下面列举两种：</p>
<p><strong>方案1：无租约的Leader选举</strong></p>
<p>Lamport在他的论文中给出了一个Leader选举的简单算法，算法如下：</p>
<p>（1）每个节点有一个编号，选取编号最大的节点为Leader；</p>
<p>（2）每个节点周期性地向其他节点发送心跳，假设周期为Tms；</p>
<p>（3）如果一个节点在最近的2Tms内还没有收到比自己编号更大的节点发来的心跳，则自己变为Leader；</p>
<p>（4）如果一个节点不是Leader，则收到请求之后转发给Leader。可以看出，这个算法很简单，但因为网络超时原因，很可能出现多个Leader，但这并不影响Multi<code>Paxos</code>协议的正确性，只是增大并发写冲突的概率。我们的算法并不需要强制保证，任意时刻只能有一个Leader。</p>
<p><strong>方案2：有租约的Leader选举</strong></p>
<p>另外一种方案是严格保证任意时刻只能有一个leader，也就是所谓的“租约”。租约的意思是在一个限定的期限内，某台机器一直是Leader。即使这个机器宕机，Leader也不能切换。必须等到租期到期之后，才能开始选举新的Leader。这种方式会带来短暂的不可用，但保证了任意时刻只会有一个Leader。具体实现方式可以参见<code>Paxos</code>Lease。</p>
<h5 id="问题2：性能问题"><a href="#问题2：性能问题" class="headerlink" title="问题2：性能问题"></a>问题2：性能问题</h5><p>我们知道Basic<code>Paxos</code>是一个无限循环的2PC，一条日志的确认至少需要两个RTT+两次落盘（一次是Prepare的广播与回复，一次是Accept的广播与回复）。如果每条日志都要两个RTT+两次落盘，这个性能就很差了。而Multi<code>Paxos</code>在选出Leader之后，可以把2PC优化成1PC，也就只需要一个RTT+一次落盘了。</p>
<p>基本思路是当一个节点被确认为Leader之后，它先广播一次Prepare，一旦超过半数同意，之后对于收到的每条日志直接执行Accept操作。在这里，Perpare不再是对一条日志的控制了，而是相对于拿到了整个日志的控制权。一旦这个Leader拿到了整个日志的控制权，后面就直接略过Prepare，直接执行Accept。</p>
<p>如果有新的Leader出现怎么办呢？新的Leader肯定会先发起Prepare，导致minProposalId变大。这时旧的Leader的广播Accept肯定会失败，旧的Leader会自己转变成一个普通的Acceptor，新的Leader把旧的顶替掉了。</p>
<p>下面是具体的实现细节：在Basic<code>Paxos</code>中，2PC的具体参数形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">prepare(n)</span><br><span class="line">accept(n,v)</span><br></pre></td></tr></table></figure>

<p>在Multi<code>Paxos</code>中，增加一个日志的index参数，即变成了如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">prepare(n,index)</span><br><span class="line">accept(n,v,index)</span><br></pre></td></tr></table></figure>

<h5 id="问题3：被choose的日志，状态如何同步给其他机器"><a href="#问题3：被choose的日志，状态如何同步给其他机器" class="headerlink" title="问题3：被choose的日志，状态如何同步给其他机器"></a>问题3：被choose的日志，状态如何同步给其他机器</h5><p>对于一条日志，当Proposer（也就是Leader）接收到多数派对Accept请求的同意后，就知道这条日志被“choose”了，也就是被确认了，不能再更改！</p>
<p>但只有Proposer知道这条日志被确认了，其他的Acceptor并不知道这条日志被确认了。如何把这个信息传递给其他Accepotor呢？</p>
<p><strong>方案1：Proposer主动通知</strong></p>
<p>给accept再增加一个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">accept(n,v,index,firstUnchooseIndex)</span><br></pre></td></tr></table></figure>

<p>Proposer在广播accept的时候，额外带来一个参数firstUnchosenIndex=7。意思是7之前的日志都已经“choose”了。Acceptor收到这种请求后，检查7之前的日志，如果发现7之前的日志符合以下条件：acceptedProposal[i]==request.proposal（也就是第一个参数n），就把该日志的状态置为choose。</p>
<p><strong>解决方案2：Acceptor被动查询</strong></p>
<p>当一个Acceptor被选为Leader后，对于所有未确认的日志，可以逐个再执行一遍<code>Paxos</code>，来判断该条日志被多数派确</p>
<p>认的值是多少。</p>
<p>因为Basic<code>Paxos</code>有一个核心特性：一旦一个值被确定后，无论再执行多少遍<code>Paxos</code>，该值都不会改变！因此，再执行1遍<code>Paxos</code>，相当于向集群发起了一次查询！</p>
<p>至此，Multi<code>Paxos</code>算法就介绍完了。回顾这个算法，有两个精髓：</p>
<p><strong>精髓之1：一个强一致的“P2P网络”</strong></p>
<p>任何一条日志，只有两种状态（choose，unchoose）。当然，还有一种状态就是applied，也就是被确认的日志被apply到状态机。这种状态跟<code>Paxos</code>协议关系不大。</p>
<p>choose状态就是这条日志，被多数派接受，不可更改；</p>
<p>unchoose就是还不确定，引用阿里OceanBase团队某工程师的话，就是“薛定谔的猫”，或者“最大commit原则”。一条unchoose的日志可能是已经被choose了，只是该节点还不知道；也可能是还没有被choose。要想确认，那就再执行一次<code>Paxos</code>，也就是所谓的“最大commit原则”。</p>
<p>整个Multi<code>Paxos</code>就是类似一个P2P网络，所有节点互相双向同步，对所有unchoose的日志进行不断确认的过程！在这个网络中可以出现多个Leader，可能出现多个Leader来回切换的情况，这都不影响算法的正确性！</p>
<p><strong>精髓之2：“时序”</strong></p>
<p>Multi<code>Paxos</code>保证了所有节点的日志顺序一模一样，但对于每个节点自身来说，可以认为它的日志并没有所谓的“顺序”。什么意思呢？</p>
<p>（1）假如一个客户端连续发送了两条日志a，b（a没有收到回复，就发出了b）。对于服务器来讲，存储顺序可能是a、b，也可能是b、a，还可能在a、b之间插入了其他客户端发来的日志！</p>
<p>（2）假如一个客户端连续发送了两条日志a、b（a收到回复之后，再发出的b）。对于服务器来讲，存储顺序可能是a、b；也可能是a、xxx、b（a与b之间插入了其他客户端的日志），但不会出现b在a的前面。</p>
<p>所以说，所谓的“时序”，只有在单个客户端串行地发送日志时，才有所谓的顺序。多个客户端并发地写，服务器又是并发地对每条日志执行<code>Paxos</code>，整体看起来就没有所谓的“顺序”。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li>文章摘自《软件架构设计》余春龙/著</li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Paxos</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么会有重排序？</title>
    <url>/2021/03/01/2021/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>在讲重排序之前，先来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with leetcode-cn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 验证重排序代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/3/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 15:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileSerialCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">				<span class="comment">// 用set来保存数据，保证不会重复</span></span><br><span class="line">        Set&lt;String&gt; resultSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                a = y;</span><br><span class="line">                x = <span class="number">1</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Thread two = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                b = x;</span><br><span class="line">                y = <span class="number">1</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            one.start();</span><br><span class="line">            two.start();</span><br><span class="line">            one.join();</span><br><span class="line">            two.join();</span><br><span class="line">          	<span class="comment">// 等待2个线程都跑完了再把结果添加到Set中去</span></span><br><span class="line">            resultSet.add(<span class="string">"a="</span> + a + <span class="string">",b="</span> + b);</span><br><span class="line">            System.out.println(resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面一段代码是非常经典来讲CPU对指令重排序的案例。因为我们经过一段时间的Run出的结果很惊讶：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[a=0,b=0, a=1,b=0, a=0,b=1, a=1,b=1]</span><br></pre></td></tr></table></figure>

<p>对于<code>a=1,b=1</code>的出现，是会让人非常的奇怪的。出现这个情况，那代码执行的顺序可能是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">     a = y; <span class="comment">// 第3步</span></span><br><span class="line">     x = <span class="number">1</span>; <span class="comment">// 第1步</span></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> Thread two = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">     b = x; <span class="comment">// 第4步</span></span><br><span class="line">     y = <span class="number">1</span>; <span class="comment">// 第2步</span></span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// 也就是说，在2个线程中，都出现了下面的代码执行到了上面的代码前面去了。</span></span><br></pre></td></tr></table></figure>

<p>如果是这样子的话，那我们还敢写多线程的代码吗？如果没有一定的规范与约定，那肯定是没人可以写好代码。</p>
<p>其实这些约定都是在<code>JSR-133内存模型与线程规范</code>里面，它就像是Java的产品需求文档或者说明书。</p>
<p><img src="http://static.cyblogs.com/Jietu20210327-174611.jpg" alt="http://static.cyblogs.com/Jietu20210327-174611.jpg"></p>
<p>百度云盘：链接: <a href="https://pan.baidu.com/s/1cO5d95Za8lyz8dMaN0i9lA" target="_blank" rel="noopener">https://pan.baidu.com/s/1cO5d95Za8lyz8dMaN0i9lA</a>  密码: l08w ,大家可以去下载查阅，这些都比较底层，并不能几句话，几篇文章可以讲清楚。</p>
<h4 id="为什么会重排序"><a href="#为什么会重排序" class="headerlink" title="为什么会重排序?"></a>为什么会重排序?</h4><p>看完上面，你可能会有疑问，为什么会有重排序呢?</p>
<p>我的程序按照我自己的逻辑写下来好好的没啥问题， Java 虚拟机为什么动我的程序逻辑?</p>
<p>你想想 <code>CPU</code> 、内存这些都是非常宝贵的资源， Java 虚拟机如果在重排序之后没啥效果，肯定也不会做这种费力不讨好的事情。</p>
<p>Java 虚拟机之所以要进行重排序就是为了提高程序的性能。你写的程序，简简单单一行代码，到底层可能需要使用不同的硬件，比如一个指令需要同时使用 <code>CPU</code> 和打印机设备，但是此时 CPU 的任务完成了，打印机的任务还没完成，这个时候怎么办呢? 不让 CPU 执行接下来的指令吗? CPU 的时间那么宝贵，你不让它工作，确定不是在浪费它的生命?</p>
<p>重排序：重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如下图所示：</p>
<p><img src="http://static.cyblogs.com/20180326170243607.png" alt="http://static.cyblogs.com/20180326170243607.png"></p>
<ul>
<li>上述的1属于编译器重排序</li>
<li>2和3属于处理器重排序</li>
</ul>
<p>这些重排序可能会导致多线程程序出现内存可见性问题。在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是<code>as-if-serial</code>语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<h4 id="重排序带来的问题"><a href="#重排序带来的问题" class="headerlink" title="重排序带来的问题"></a>重排序带来的问题</h4><p>回到文章刚开始举的那个例子，重排序提高了 CPU 的利用率没错，提高了程序性能没错，但是我的程序得到的结果可能是错误的啊，这是不是就有点儿得不偿失了?</p>
<p>因为重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</p>
<p>凡是问题，都有办法解决，要是没有，那就再想想。</p>
<p>它是怎么解决的呢? 这就需要来说说，顺序一致性<strong>内存模型</strong>和 <strong>JMM (Java Memory Model ， Java 内存模型)</strong></p>
<p>我们知道Java线程的所有操作都是在工作区进行的，那么工作区和主存之间的变量是怎么进行交互的呢，可以用下面的图来表示。</p>
<p><img src="http://static.cyblogs.com/e0e01e43ly1g186enjfwfj20k80degmr.jpg" alt="http://static.cyblogs.com/e0e01e43ly1g186enjfwfj20k80degmr.jpg"><br>Java通过几种原子操作完成<strong>工作区内存</strong>和<strong>主存</strong>的交互</p>
<ol>
<li>lock：作用于主存，把变量标识为线程独占状态。</li>
<li>unlock：作用于主存，解除变量的独占状态。</li>
<li>read：作用于主存，把一个变量的值通过主存传输到线程的工作区内存。</li>
<li>load：作用于工作区内存，把<code>read</code>操作传过来的变量值储存到工作区内存的变量副本中。</li>
<li>use：作用于工作内存，把工作区内存的变量副本传给执行引擎。</li>
<li>assign：作用于工作区内存，把从执行引擎传过来的值赋值给工作区内存的变量副本。</li>
<li>store：作用于工作区内存，把工作区内存的变量副本传给主存。</li>
<li>write：作用于主存，把<code>store</code>操作传过来的值赋值给主存变量。</li>
</ol>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p><code>as-if-serial</code>语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器、<code>runtime</code>和处理器都必须遵守<code>as-if-serial</code>语义。</p>
<p>为了遵守<code>as-if-serial</code>语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。<code>as-if-serial</code>语义把单线程程序保护了起来，<code>as-if-serial</code>语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>终于讲到了 <code>happens-before</code> ,先来看 <code>happens-before</code> 关系的定义：</p>
<ul>
<li>如果一个操作 <code>happens-before</code> 另一个操作，那么第一个操作的执行结果就会对第二个操作可见</li>
<li>两个操作之间如果存在 <code>happens-before</code> 关系，并不意味着 <code>Java</code> 平台的具体实现就必须按照 <code>happens-before</code> 关系指定的顺序来执行。如果重排序之后的执行结果，与按照 <code>happens-before</code> 关系来执行的结果一直，那么 <code>JMM</code> 也允许这样的重排序</li>
</ul>
<p>看到这儿，你是不是觉得，这个怎么和 <code>as-if-serial</code> 语义一样呢。没错， <code>happens-before</code> 关系本质上和 <code>as-if-serial</code> 语义是一回事。</p>
<p><code>as-if-serial</code> 语义保证的是单线程内重排序之后的执行结果和程序代码本身应该出现的结果是一致的， <code>happens-before</code> 关系保证的是正确同步的多线程程序的执行结果不会被重排序改变。</p>
<p>一句话来总结就是：如果操作 A <code>happens-before</code> 操作 B ，那么操作 A 在内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。</p>
<p>在 <code>Java</code> 中，对于 <code>happens-before</code> 关系，有以下规定：</p>
<ul>
<li>程序顺序规则：一个线程中的每一个操作， <code>happens-before</code> 于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁， <code>happens-before</code> 于随后对这个锁的加锁</li>
<li><code>volatile</code> 变量规则：对一个 <code>volatile</code> 域的写， <code>happens-before</code> 与任意后续对这个 <code>volatile</code> 域的读</li>
<li>传递性：如果 A <code>happens-before</code> B ， 且 B <code>happens-before</code> C ，那么 A <code>happens-before</code> C</li>
<li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>（启动线程B），那么A线程的<code>ThreadB.start()</code>操作<code>happens-before</code>于线程B中的任意操作。</li>
<li><code>join()</code>规则：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作<code>happens-before</code>于线程A从ThreadB.join()操作成功返回。</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://developer.51cto.com/art/202005/617587.htm" target="_blank" rel="noopener">https://developer.51cto.com/art/202005/617587.htm</a></li>
<li><a href="https://blog.csdn.net/ym123456677/article/details/79700623" target="_blank" rel="noopener">https://blog.csdn.net/ym123456677/article/details/79700623</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka消费者组是什么？</title>
    <url>/2021/03/25/2021/03/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h4 id="一、Kafka消费者组是什么？"><a href="#一、Kafka消费者组是什么？" class="headerlink" title="一、Kafka消费者组是什么？"></a>一、Kafka消费者组是什么？</h4><p><code>Consumer Group</code> 是<code>Kafka</code>提供的可扩展且具有容错性的消费者机制。在组内多个消费者实例(<code>Consumer Instance</code> ),它们共享一个公共的ID即 <code>Group ID</code> 。组内的所有消费者协调在一起消费订阅主题（<code>Subscribed Topics</code>）的所有分区(<code>Partition</code>)。当然一个分区只能有同一个消费者组的一个<code>Consumer</code> 实例消费。<br><code>Consumer Group</code> 有三个特性：</p>
<ul>
<li><code>Consumer Group</code> 下可以有一个或多个<code>Consumer</code> 实例。 这里的实例可以是一个单独的进程，也可以是同一进程下的线程；</li>
<li><code>Group ID</code> 是一个字符串， 在Kafka集群中唯一标识，<code>Consumer Group</code>；</li>
<li><code>Consumer Group</code><br>下所有实例订阅主体的单个分区，只能分配给组内某个<code>Consumer</code>实例消费。同一个分区消息可能被多个<code>Group</code> 消费。</li>
</ul>
<h4 id="二、Kafka消费者组解决了哪些问题？"><a href="#二、Kafka消费者组解决了哪些问题？" class="headerlink" title="二、Kafka消费者组解决了哪些问题？"></a>二、Kafka消费者组解决了哪些问题？</h4><p>传统的消息系统中，有两种消息引擎模型：点对点模型（消息队列）、发布/订阅模型<br>传统的两种消息系统各有优势，我们里对比一下：</p>
<ul>
<li>传统的消息队列模型的缺陷在于消息一旦被消费，就会从队列中删除，而且只能被下游的一个<code>Consumer</code>消费。严格的说这不是它的缺陷，<br>这是它的一个特性。但很显然这种模型的伸缩性（<code>Scalability</code>）很差，因为下游的多个<code>Consumer</code> 都要“抢”<br>这个共享消息队列的消息；</li>
<li>发布/订阅模型,允许消息被多个<code>Consumer</code> 消费，但它的问题也是伸缩性不高，因为订阅者都必须订阅所有主体的所有分区。</li>
</ul>
<p><code>Kafka</code> 为规避传统消息两种模型的缺点，引入了 <code>Consumer Group</code> 机制：</p>
<ul>
<li>当 <code>Consumer Group</code> 订阅多个主题后，组内的每个实例不要求一定要订阅主题的所有分区，它只会消费部分分区中的消息；</li>
<li><code>Consumer Group</code> 之间彼此队里，互不影响，它们可以订阅同一组主题而互不干涉。加上<code>Broker</code>端的消息留存机制，<code>Kafka</code>的<code>Consumer Group</code> 完美的避开了伸缩性差的问题；</li>
<li><code>kafka</code> 是用<code>Consumer Group</code>机制，实现了，传统两大消息引擎。如果所有实例属于同一个<code>Group</code>，那么它实现的就是消息队列模型；如果所有实例分别属于不同的<code>Group</code>，且订阅了相同的主题，那么它就实现了发布/订阅模型；</li>
</ul>
<h4 id="三、Consumer-Group-实例数量多少才合理？"><a href="#三、Consumer-Group-实例数量多少才合理？" class="headerlink" title="三、Consumer Group 实例数量多少才合理？"></a>三、Consumer Group 实例数量多少才合理？</h4><p>最理想的情况是<code>Consumer</code>实例的数量应该等于该<code>Group</code>订阅主题的分区总数。例如：<code>Consumer Group</code> 订阅了 3个主题，分别是<code>A、B、C</code>，它们的分区数依次是<code>1、2、3</code>，那么通常情况下，为该<code>Group</code> 设置<code>6</code>个<code>Consumer</code>实例是比较理想的情形。</p>
<p>如果设置小于或大于<code>6</code>的实例可以吗？当然可以，如果你有<code>3</code>个实例，那么平均下来每个实例大约消费<code>2</code>个分区<code>（6/3=2）</code>;如果你设置了<code>9</code>个实例，那么很遗憾，有<code>3</code>个实例（<code>9-6=3</code>）将不会被分配任何分区，它们永远处于空闲状态。</p>
<h4 id="四、消费位移"><a href="#四、消费位移" class="headerlink" title="四、消费位移"></a>四、消费位移</h4><p>消费者在消费的过程中要记录自己消费了多少数据，即消费位置信息，在<code>Kafka</code>中叫：位移（<code>offset</code>）。<br>看上去该Offset就是一个数字而已，其实对于Consumer Group 而言，它是一组KV对，Key是分区，V对应Consumer 消费该分区的最新位移。<br>老版本的<code>Consumer Group</code>把位移保存在<code>Zookeeper</code>中。将位移保存在<code>Zookeeper</code>外部系统显然好处是减少了<code>Kafka Broker</code> 端的状态保存开销。现在比较流行的提法是将服务器节点做成无状态的， 这样可以自由扩缩容，实现超强的伸缩性。不过在实际使用场景中，发现<code>ZooKeeper</code> 这类元框架并不是适合进行频繁的写更新，而<code>Consumer Group</code> 的位移更新却是一个非常频繁的操作。 这种大吞吐量的写操作极大的拖慢了<code>ZooKeeper</code> 集群的性能，在新版本的<code>Consumer Group</code> 中，<code>Kafka</code> 社区采用了将<code>Consumer Group</code> 位移保存在<code>Broker</code> 端的内部主题中。</p>
<h4 id="五、Rebalance"><a href="#五、Rebalance" class="headerlink" title="五、Rebalance"></a>五、Rebalance</h4><p><code>Rebalance</code> 本质上是一种协议，规定了一个<code>Consumer Group</code> 下所有<code>Consumer</code> 如何达成一致，来分配订阅<code>Topic</code>的每个分区。比如：某个<code>Group</code> 下有20个<code>Consumer</code> 实例， 它订阅了一个具有100个分区的<code>Topic</code>。正常情况下，Kafka 平均会为每个<code>Consumer</code> 分配5个分区。这个分配的过程叫<code>Rebalance</code>。<br><code>Consumer Group</code>触发 <code>Rebalance</code>有三种情况：</p>
<ul>
<li>组成员数量发生变化，比如有新的<code>Consumer</code> 实例加入组或离开组，抑或是有<code>Consumer</code>实例崩溃被“踢出”组。</li>
<li>订阅主题数量发生变更。 <code>Consumer Group</code> 可以使用正则表达式订阅主题，比如<br><code>consumer.subscribe(Pattern.complile(“t.*c”))</code>就表明该<code>Group</code>订阅所有<code>t</code>开头，字母<code>c</code>结尾的主题。在<code>Consumer Group</code> 运行时，新创建一个满足这样条件的主题，那么会触发订阅该主题所有<code>Group</code> 开始<code>Rebalance</code>。</li>
<li>订阅主题分区数发生变化，<code>Kakfka</code> 一个主题，当分区数增加时，就会触发订阅该主题的所有<code>Group</code>开启<code>Rebalance</code>。</li>
</ul>
<p><code>Consumer Group</code> 发生<code>Rebalance</code> 的过程：某个 <code>Consumer Group</code> 下有两个<code>Consumer</code> ，比如<code>A</code>和<code>B</code>，当第三个成员<code>C</code>加入时，<code>Kafka</code>会触发<code>Rebalance</code>，并根据默认的分配策重新分配<code>A、B、C</code>分配分区，如下图：<br><img src="http://static.cyblogs.com/kafka_rebalance.png" alt="http://static.cyblogs.com/kafka_rebalance.png"></p>
<p>注意：目前<code>Rebalance</code> 的设计是所有<code>Consumer</code>实例共同参与，全部重新分配所有分区，<code>Rebalance</code>过程所有<code>Consumer</code> 实例都会停止消费，等待<code>Rebalance</code> 完成。<code>Rebalance</code> 很慢，一个<code>Group</code> 内有几百个<code>Consumer</code>实例，成功进行一次<code>Rebalance</code>需要好几个小时。 目前社区没有终极解决方案，最好的解决方案是规避<code>Rebalane</code>的发生。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/qq_36918149/article/details/99656156" target="_blank" rel="noopener">https://blog.csdn.net/qq_36918149/article/details/99656156</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 kill -9 的原理</title>
    <url>/2021/03/28/2021/03/Linux%E5%91%BD%E4%BB%A4%20kill%20-9%20%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>相信很多程序员对于 <code>Linux</code> 系统都不陌生，即使自己的日常开发机器不是 <code>Linux</code>，那么线上服务器也大部分都是的，所以，掌握常用的 <code>Linux</code> 命令也是程序员必备的技能。</p>
<p>但是，怕就怕很多人对于部分命令只是一知半解，使用不当就能导致线上故障。</p>
<p>前段时间，我们的线上应用报警，频繁 <code>FGC</code>，需要紧急处理问题，于是有同事去线上重启机器（正常程序应该是先采集堆 <code>dump</code>，然后再重启，方便排查是否存在内存泄露等问题）。</p>
<p>但是在重启过程中，同事发现正常的重启命令应用无反应，然后尝试使用 <code>kill</code> 命令 “杀” 掉 <code>Java</code> 进程，但是仍然无效。于是他私自决定使用 “<code>kill -9</code>“ 结束了进程的生命。</p>
<p>虽然应用进程被干掉了，但是随之而来带来了很多问题，首先是上游系统突然发生大量报警，对应开发找过来说调用我们的 <code>RPC</code> 服务无响应，频繁超时。</p>
<p>后来，我们又发现系统中存在部分脏数据，有些在同一个事务中需要完整更新的数据，只更新了一半…</p>
<p>为什么正常的 <code>kill</code> 无法 “杀掉” 进程，而 <code>kill -9</code> 就可以？为什么 <code>kill -9</code> 会引发这一连串连锁反应？正常的 <code>kill</code> 执行时，JVM 会如何处理的呢？</p>
<p>要搞清楚这些问题，我们要先从 <code>kill</code> 命令说起。</p>
<h4 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h4><p>我们都知道，想要在 <code>Linux</code> 中终止一个进程有两种方式，如果是前台进程可以使用 <code>Ctrl+C</code> 键进行终止；如果是后台进程，那么需要使用 <code>kill</code> 命令来终止。（其实 <code>Ctrl+C</code> 也是 <code>kill</code> 命令）</p>
<p><code>kill</code> 命令的格式是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill [参数] [进程号]</span><br><span class="line">如：</span><br><span class="line">kill 90124</span><br><span class="line">kill -9  90124</span><br></pre></td></tr></table></figure>

<p>其中 [参数] 是可选的，进程号可以通过 <code>jps/ps/pidof/pstree/top</code> 等工具获取。</p>
<p><code>kill</code> 的命令参数有以下几种：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="line"></span><br><span class="line">-a 当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="line"></span><br><span class="line">-p 指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="line"></span><br><span class="line">-s 指定发送信号</span><br><span class="line"></span><br><span class="line">-u 指定用户</span><br></pre></td></tr></table></figure>

<p>通常情况下，我们使用的 <code>- l</code>(信号) 的时候比较多，如我们前文提到的 <code>kill -9</code> 中的 <code>9</code> 就是信号。</p>
<p>信号如果没有指定的话，默认会发出终止信号 (<code>15</code>)。常用的信号如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HUP 1 终端断线</span><br><span class="line"></span><br><span class="line">INT 2 中断（同 Ctrl + C）</span><br><span class="line"></span><br><span class="line">QUIT 3 退出（同 Ctrl + \）</span><br><span class="line"></span><br><span class="line">TERM 15 终止</span><br><span class="line"></span><br><span class="line">KILL 9 强制终止</span><br><span class="line"></span><br><span class="line">CONT 18 继续（与STOP相反， fg/bg命令）</span><br><span class="line"></span><br><span class="line">STOP 19 暂停（同 Ctrl + Z）</span><br></pre></td></tr></table></figure>

<p>比较常用的就是<code>强制终止信号：9</code> 和<code>终止信号：15</code>，另外，<code>中断信号：2</code> 其实就是我们前文提到的 <code>Ctrl + C</code> 结束前台进程。</p>
<p>那么，<code>kill -9</code> 和 <code>kill -15</code> 到底有什么区别呢？该如何选择呢？</p>
<h4 id="kill-9-和-kill-15-的区别"><a href="#kill-9-和-kill-15-的区别" class="headerlink" title="kill -9 和 kill -15 的区别"></a>kill -9 和 kill -15 的区别</h4><p><code>kill</code> 命令默认的信号就是 <code>15</code>，首先来说一下这个默认的 <code>kill -15</code> 信号。</p>
<p>当使用 <code>kill -15</code> 时，系统会发送一个 <code>SIGTERM</code> 的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。</p>
<p>这时候，应用程序可以选择：</p>
<ul>
<li>1、立即停止程序</li>
<li>2、释放响应资源后停止程序</li>
<li>3、忽略该信号，继续执行程序</li>
</ul>
<p>因为 <code>kill -15</code> 信号只是通知对应的进程要进行 “安全、干净的退出”，程序接到信号之后，退出前一般会进行一些 “准备工作”，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。</p>
<p>但是，如果在 “准备工作” 进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。</p>
<p>这也就是为什么我们有的时候使用 <code>kill</code> 命令是没办法 “杀死” 应用的原因，因为默认的 <code>kill</code> 信号是 <code>SIGTERM（15）</code>，而 <code>SIGTERM（15）</code>的信号是可以被阻塞和忽略的。</p>
<p>和 <code>kill -15</code> 相比，<code>kill -9</code> 就相对强硬一点，系统会发出 SIGKILL 信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。</p>
<p>所以，相比于 <code>kill -15</code> 命令，<code>kill -9</code> 在执行时，应用程序是没有时间进行 “准备工作” 的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。</p>
<h4 id="Java-是如何处理-SIGTERM（15）"><a href="#Java-是如何处理-SIGTERM（15）" class="headerlink" title="Java 是如何处理 SIGTERM（15）"></a>Java 是如何处理 SIGTERM（15）</h4><p>我们都知道，在 <code>Linux</code> 中，<code>Java</code> 应用是作为一个独立进程运行的，<code>Java</code> 程序的终止运行是基于 <code>JVM</code> 的关闭实现的，JVM 关闭方式分为 3 种：</p>
<ul>
<li>正常关闭：当最后一个非守护线程结束或者调用了 <code>System.exit</code> 或者通过其他特定平台的方法关闭（接收到 <code>SIGINT（2）</code>、<code>SIGTERM</code>（15）信号等）</li>
<li>强制关闭：通过调用 <code>Runtime.halt</code> 方法或者是在操作系统中强制 <code>kill</code>（接收到 <code>SIGKILL（9）</code>信号)</li>
<li>异常关闭：运行中遇到 <code>RuntimeException</code> 异常等</li>
</ul>
<p><code>JVM</code> 进程在接收到 <code>kill -15</code> 信号通知的时候，是可以做一些清理动作的，比如删除临时文件等。</p>
<p>当然，开发者也是可以自定义做一些额外的事情的，比如让 <code>tomcat</code> 容器停止，让 <code>dubbo</code> 服务下线等。</p>
<p>而这种自定义 <code>JVM</code> 清理动作的方式，是通过 <code>JDK</code> 中提供的 <code>shutdown hook</code> 实现的。<code>JDK</code> 提供了 <code>Java.Runtime.addShutdownHook(Thread hook)</code> 方法，可以注册一个 JVM 关闭的钩子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with leetcode-cn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/3/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 20:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"hook execute..."</span>);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// app is runing</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"main thread execute end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<p><img src="http://static.cyblogs.com/Jietu20210328-204711.jpg" alt="http://static.cyblogs.com/Jietu20210328-204711.jpg"></p>
<p>控制台输出内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hook execute...</span><br><span class="line">Process finished with exit code 143 (interrupted by signal 15: SIGTERM)</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们使用 <code>kill</code>（默认 <code>kill -15</code>）关闭进程的时候，程序会先执行我注册的 <code>shutdownHook</code>，然后再退出，并且会给出一个提示：<code>interrupted by signal 15: SIGTERM</code></p>
<p>如果我们执行命令 <code>kill -9</code>：</p>
<p><img src="http://static.cyblogs.com/Jietu20210328-204851.jpg" alt="http://static.cyblogs.com/Jietu20210328-204851.jpg"></p>
<p>控制台输出内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Process finished with exit code 137 (interrupted by signal 9: SIGKILL)</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们使用 <code>kill -9</code> 强制关闭进程的时候，程序并没有执行 <code>shutdownHook</code>，而是直接退出了，并且会给出一个提示：<code>interrupted by signal 9: SIGKILL</code></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>kill</code> 命令用于终止 <code>Linux</code> 进程，默认情况下，如果不指定信号，<code>kill</code> 等价于 <code>kill -15</code>。</p>
<p><code>kill -15</code> 执行时，系统向对应的程序发送 <code>SIGTERM（15）</code>信号，该信号是可以被执行、阻塞和忽略的，所以应用程序接收到信号后，可以做一些准备工作，再进行程序终止。</p>
<p>有的时候，<code>kill -15</code> 无法终止程序，因为他可能被忽略，这时候可以使用 <code>kill -9</code>，系统会发出 <code>SIGKILL（9）</code>信号，该信号不允许忽略和阻塞，所以应用程序会立即终止。</p>
<p>这也会带来很多副作用，如数据丢失等，所以，在非必要时，不要使用 <code>kill -9</code> 命令，尤其是那些 <code>web</code> 应用、提供 <code>RPC</code> 服务、执行定时任务、包含长事务等应用中，因为 <code>kill -9</code> 没给 <code>spring</code> 容器、<code>tomcat</code> 服务器、<code>dubbo</code> 服务、流程引擎、状态机等足够的时间进行收尾。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://blog.csdn.net/windforce828/article/details/106119445" target="_blank" rel="noopener">https://blog.csdn.net/windforce828/article/details/106119445</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1背包问题Knapsack Problem</title>
    <url>/2021/03/29/2021/03/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98Knapsack%20Problem/</url>
    <content><![CDATA[<p>背包问题<code>(Knapsack Problem, KP)</code>是<code>NP</code>完全问题，也是一类重要 的组合优化问题 ，在工业 、经济 、通信、金融与计算机 等领域的资 源分配 、 资金预算 、 投资决策 、 装载问题 、 整数规划 、 分布式系统 与密码系统中具有重要的理论和应用价值。</p>
<p><strong>通俗说法</strong></p>
<p>贼，夜入豪宅，可偷之物甚多，而负重能力有限，偷哪些才更加不枉此行？</p>
<p><strong>抽象说法</strong></p>
<p>给定一组多个（<img src="https://www.zhihu.com/equation?tex=n" alt="[公式]">)）物品，每种物品都有自己的重量（<img src="https://www.zhihu.com/equation?tex=w_i" alt="[公式]">)）和价值（<img src="https://www.zhihu.com/equation?tex=v_i" alt="[公式]">)），在限定的总重量/总容量（<img src="https://www.zhihu.com/equation?tex=C" alt="[公式]">）内，选择其中若干个（也即每种物品可以选0个或1个），设计选择方案使得物品的总价值最高。</p>
<p><strong>更加抽象的说法</strong></p>
<p>给定正整数<img src="https://www.zhihu.com/equation?tex=%5C%7B%28w_i%2Cv_i%29%5C%7D_%7B1%5Cleq+i%5Cleq+n%7D" alt="[公式]">)、给定正整数<img src="https://www.zhihu.com/equation?tex=C" alt="[公式]">，求解0-1规划问题：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cmax+%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7Bx_iv_i%7D" alt="[公式]"> ， s.t. <img src="https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7Bx_iw_i%7D%5Cleq+C" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=x_i%5Cin%5C%7B0%2C1%5C%7D" alt="[公式]"> 。</p>
<h4 id="0-1背包问题的递推关系"><a href="#0-1背包问题的递推关系" class="headerlink" title="0-1背包问题的递推关系"></a>0-1背包问题的递推关系</h4><p>定义子问题 <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7B%5Ctext%7BP%28i%2C+W%29%7D%7D" alt="[公式]"> 为：在前 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 个物品中挑选总重量不超过 <img src="https://www.zhihu.com/equation?tex=W" alt="[公式]"> 的物品，每种物品至多只能挑选1个，使得总价值最大；这时的最优值记作 <img src="https://www.zhihu.com/equation?tex=m%28i%2CW%29" alt="[公式]"> ，其中 <img src="https://www.zhihu.com/equation?tex=1%5Cleq+i%5Cleq+n" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=1%5Cleq+W%5Cleq+C" alt="[公式]"> 。</p>
<p>考虑第 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 个物品，无外乎两种可能：选，或者不选。</p>
<ul>
<li>不选的话，背包的容量不变，改变为问题 <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7B%7BP%28i-1%2C+W%29%7D%7D" alt="[公式]"> ；</li>
<li>选的话，背包的容量变小，改变为问题 <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7B%7BP%28i-1%2C+W-w_i%29%7D%7D" alt="[公式]"> 。</li>
</ul>
<p>最优方案就是比较这两种方案，哪个会更好些：</p>
<p><img src="https://www.zhihu.com/equation?tex=m%28i%2CW%29%3D%5Cmax%5C%7Bm%28i-1%2CW%29%2Cm%28i-1%2CW-w_i%29%2Bv_i%5C%7D" alt="[公式]"> 。</p>
<p><img src="http://static.cyblogs.com/v2-1d8090c991ca13cee3cb43c027b72304_1440w.jpg" alt="http://static.cyblogs.com/v2-1d8090c991ca13cee3cb43c027b72304_1440w.jpg"></p>
<p>得到</p>
<p><img src="https://www.zhihu.com/equation?tex=%5C%5Bm%28i%2CW%29%3D%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%7B55%7D%7Bl%7D%7D+0+%26+%5Ctext%7Bif+%7D+i%3D%5Ctext%7B0%7D+%5C%5C+0+%26+%5Ctext%7Bif+%7D+W%3D%5Ctext%7B0%7D+%5C%5C+m%28i-1%2CW%29+%26+%5Ctext%7Bif+%7D%7Bw_i%3EW%7D+%5C%5C+%5Cmax+%5Cleft%5C%7B+m%28i-1%2CW%29%2C%7B%7Bv%7D_%7Bi%7D%7D%2Bm%28i-1%2CW-%7B%7Bw%7D_%7Bi%7D%7D%29+%5Cright%5C%7D+%26+%5Ctext%7Botherwise%7D+%5C%5C+%5Cend%7Barray%7D+%5Cright.%5C%5D+" alt="[公式]"> 。</p>
<h4 id="“填二维表”的动态规划方法"><a href="#“填二维表”的动态规划方法" class="headerlink" title="“填二维表”的动态规划方法"></a>“填二维表”的动态规划方法</h4><p><img src="https://www.zhihu.com/equation?tex=m%28i%2CW%29%3Dm%28i-1%2CW-w_i%29%2Bv_i" alt="[公式]"> 时才会有“取第 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 件物品”发生。</p>
<p>所以从表格右下角“往回看”如果是“垂直下降”就是发生了 <img src="https://www.zhihu.com/equation?tex=m%28i%2CW%29%3Dm%28i-1%2CW%29" alt="[公式]"> ，而只有“走斜线”才是“取了”物品。</p>
<p><img src="http://static.cyblogs.com/v2-7bd4c72ec3b5f104e4db3c4aad98cc66_1440w.png" alt="http://static.cyblogs.com/v2-7bd4c72ec3b5f104e4db3c4aad98cc66_1440w.png"></p>
<p>这个算法的复杂度就很容易算了——每一个格子都要填写数字，所以时间复杂度和空间复杂度都是 <img src="https://www.zhihu.com/equation?tex=%5COmega%28nC%29" alt="[公式]"> 。当” <img src="https://www.zhihu.com/equation?tex=C%3E2%5En" alt="[公式]"> “时（就不严谨地使用渐近分析的语言了），复杂度是 <img src="https://www.zhihu.com/equation?tex=%5COmega%28n2%5En%29" alt="[公式]"> 。</p>
<h4 id="手撕Java版本代码"><a href="#手撕Java版本代码" class="headerlink" title="手撕Java版本代码"></a>手撕Java版本代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with leetcode-cn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 0-1 背包问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/3/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 10:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">6</span>, W = <span class="number">21</span>;</span><br><span class="line">        <span class="comment">// 重量</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">// 价值</span></span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="comment">// 重量 * 价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] B = <span class="keyword">new</span> <span class="keyword">int</span>[N][W];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k,C;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; N; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (C = <span class="number">1</span>; C &lt; W; C++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[k] &gt; C) &#123;</span><br><span class="line">                    B[k][C] = B[k-<span class="number">1</span>][C];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 装进书包</span></span><br><span class="line">                    <span class="keyword">int</span> value1 = B[k-<span class="number">1</span>][C-w[k]] + v[k];</span><br><span class="line">                    <span class="comment">// 不装进书包</span></span><br><span class="line">                    <span class="keyword">int</span> value2 = B[k-<span class="number">1</span>][C];</span><br><span class="line">                    <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">                        B[k][C] = value1;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        B[k][C] = value2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(B[<span class="number">5</span>][<span class="number">20</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后输出的结果是：26。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.bilibili.com/video/BV1U5411s7d7?t=1899" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1U5411s7d7?t=1899</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30959069" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30959069</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>批量操作脚本让你5mins搞定发版</title>
    <url>/2021/04/15/2021/04/%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E8%84%9A%E6%9C%AC%E8%AE%A9%E4%BD%A05mins%E6%90%9E%E5%AE%9A%E5%8F%91%E7%89%88/</url>
    <content><![CDATA[<h4 id="代码分支管理"><a href="#代码分支管理" class="headerlink" title="代码分支管理"></a>代码分支管理</h4><p>大家在做微服务拆分后，难免会导致<code>Application</code>项目以及一些二房包的数量加剧，<code>10+</code>个项目我想应该是很容易的超过。然后这些细粒度的拆分后就会导致发布版本时候的麻烦。</p>
<p>展示一下现阶段我们的一个<code>git</code>的分支流程图，仅供参考。</p>
<p><img src="http://static.cyblogs.com/git_flow_publish_20210415.jpg" alt="http://static.cyblogs.com/git_flow_publish_20210415.jpg"></p>
<p>简单说明一下：</p>
<ul>
<li><code>dev</code>环境每次都是从<code>master</code>拉取一个分支，取名为<code>dev-{发布日期}-{sequenceId}</code>，<code>sequenceId</code>从<code>01</code>开始叠加，避免一个版本需要反复拉取多次。</li>
<li>到了<code>test</code>阶段，也是为了收敛（前期严格一点）。提测的时候代码需要合并到<code>test</code>分支来。</li>
<li>到<code>UAT</code>阶段，还是需要从<code>master</code>拉取分支，如果出现要重新拉取分支的情况下，还是严格拉取<code>master</code>分支的代码。主要是为了与<code>master</code>保持一致，避免把别人的覆盖掉。取名为<code>release-{发布日期}-{sequenceId}</code>，规则同上。</li>
<li>上生产后，验证完毕后需要把代码合并到<code>master</code>分支，并且打包<code>tag</code>。</li>
</ul>
<p>但是在这个过程中，需要有拉取新分支，合并分支，批量删除分支，打<code>tag</code>等等繁琐的操作，项目一多如果有一个批量脚本就更好了。下面我就列举一些平时使用最多的几个，仅供参考：</p>
<h4 id="批量脚本"><a href="#批量脚本" class="headerlink" title="批量脚本"></a>批量脚本</h4><h5 id="01-批量拉取新分支"><a href="#01-批量拉取新分支" class="headerlink" title="01-批量拉取新分支"></a>01-批量拉取新分支</h5><p>比如一个新的迭代要开始了，就需要从<code>master</code>拉取<code>dev</code>分支。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">OLD_BR_NAME="$1"</span><br><span class="line">NEW_BR_NAME="$2"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $OLD_BR_NAME ]; then</span><br><span class="line">    echo "Please input your old branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f $NEW_BR_NAME ]; then</span><br><span class="line">    echo "Please input your new branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function gitCheckoutBrachAndPushRemote() &#123;</span><br><span class="line">    echo "-------- $1 --------"</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git checkout $OLD_BR_NAME</span><br><span class="line">	git fetch</span><br><span class="line">	git pull</span><br><span class="line">	git checkout -b $NEW_BR_NAME $OLD_BR_NAME</span><br><span class="line">	git push --set-upstream origin $NEW_BR_NAME</span><br><span class="line">	echo "success push branch " $NEW_BR_NAME " to remote"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        gitCheckoutBrachAndPushRemote "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>具体使用，比如以<code>master</code>为基础拉取一个新分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./git_batch_co_push_remote.sh master dev-20210419-01</span><br></pre></td></tr></table></figure>

<h5 id="02-批量切换分支"><a href="#02-批量切换分支" class="headerlink" title="02-批量切换分支"></a>02-批量切换分支</h5><p>做不同的需求时候，需要来回的切换分支。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">BR_NAME="$1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $BR_NAME ]; then</span><br><span class="line">    echo "Please input your branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function gitCheckoutBrach() &#123;</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git fetch</span><br><span class="line">	git checkout $BR_NAME</span><br><span class="line">	echo "success checkout to " $BR_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        gitCheckoutBrach "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>具体的使用，先切换成<code>master</code>分支。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./git_batch_co_brach.sh dev-20210412-01</span><br></pre></td></tr></table></figure>

<h5 id="03-批量删除远程分支"><a href="#03-批量删除远程分支" class="headerlink" title="03-批量删除远程分支"></a>03-批量删除远程分支</h5><p>有时候不小心写错了分支名字，或者分支太多，需要删除批量删除远程分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">BR_NAME="$1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $BR_NAME ]; then</span><br><span class="line">    echo "Please input your branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git fetch</span><br><span class="line">	git push origin --delete $BR_NAME</span><br><span class="line">	echo "success delete remote branch: " $BR_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        doSomething "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>具体的使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./git_batch_delete_remote.sh dev-20210412-01</span><br></pre></td></tr></table></figure>

<p>结果就是可以把远程分支<code>dev-20210412-01</code>一次性全部删除掉。</p>
<h5 id="04-批量合并分支代码"><a href="#04-批量合并分支代码" class="headerlink" title="04-批量合并分支代码"></a>04-批量合并分支代码</h5><p>从一个环境到另外也跟环境，就需要大量的<code>merge</code>操作。其实<code>Git</code>的<code>merge</code>操作比SVN的要好很多。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">BR_NAME="$1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $BR_NAME ]; then</span><br><span class="line">    echo "Please input your branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function gitCheckoutBrach() &#123;</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git merge $BR_NAME</span><br><span class="line">    git push</span><br><span class="line">    echo "success merge from branch" $BR_NAME " and push remote"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        gitCheckoutBrach "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>具体使用，记得要先更新相关的代码哦~ </p>
<p>比如是从<code>dev</code>合并到<code>test</code>，那么先更新对应的代码，然后<code>co</code>到test的目录去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./git_batch_co_merge_push_remote.sh dev-20210412-01</span><br></pre></td></tr></table></figure>

<h5 id="05-批量给分支打tag"><a href="#05-批量给分支打tag" class="headerlink" title="05-批量给分支打tag"></a>05-批量给分支打tag</h5><p>比如我们的流程是在上生产后为master打一个新的tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">TAG_NAME=$1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $TAG_NAME ]; then</span><br><span class="line">    echo "Please input your tag name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git fetch</span><br><span class="line">	git checkout master</span><br><span class="line">    git tag -a $TAG_NAME -m "创建分支$TAG_NAME"</span><br><span class="line">	echo "success create tag " $TAG_NAME</span><br><span class="line">    git push origin --tags</span><br><span class="line">    echo "success push tag to remote" $TAG_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        doSomething "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>具体使用，首先切换为<code>master</code>分支。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./git_batch_tag_push.sh v1.0.0</span><br></pre></td></tr></table></figure>

<h5 id="06-批量mvn打包"><a href="#06-批量mvn打包" class="headerlink" title="06-批量mvn打包"></a>06-批量mvn打包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要deploy的工程</span></span><br><span class="line">NEED_DEPLOY_DIR_OR_FILE=("xxxx") // 这里添加你要打包的项目名称，空格分开</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in "$&#123;NEED_DEPLOY_DIR_OR_FILE[@]&#125;";do</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">cd</span> <span class="string">"<span class="variable">$WORK_DIR</span>"</span></span></span><br><span class="line">echo "$WORK_DIR/$i";</span><br><span class="line">cd "$WORK_DIR/$i";</span><br><span class="line">git pull</span><br><span class="line">mvn install deploy -Dpmd.skip=true -Dcheckstyle.skip=true -Dmaven.test.skip=true</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>具体使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./git_batch_deploy_snapshot.sh</span><br></pre></td></tr></table></figure>

<p>上面的这些脚本也是因为当时自己要发布版本，总共写脚本花费了<code>20~30mins</code>的时候，发布时间也才<code>30mins</code>。如果那天我不写这个脚本，业务我每次都要花费<code>60+mins</code>去做，而且其他不熟悉的人做发布的时候肯定会花费更多的时间。开发就应该把那些重复的事情标准化与产品化。能够真的做到可持续~ </p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li>推荐一本书《持续交付2.0》，地址：<a href="https://item.jd.com/12512514.html" target="_blank" rel="noopener">https://item.jd.com/12512514.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>【go学习】地址符&amp;与指针*的差别</title>
    <url>/2021/10/15/2021/10/%E3%80%90go%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9C%B0%E5%9D%80%E7%AC%A6&amp;%E4%B8%8E%E6%8C%87%E9%92%88*%E7%9A%84%E5%B7%AE%E5%88%AB/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>项目中开始用<code>Go</code>，最近写了一下<code>Demo</code>，发现语法还是非常好用，大部分比<code>Java</code>还是简洁很多，也有一些很细节的约定。比如：</p>
<ul>
<li>字母大小写控制是全包还是本包内访问</li>
<li>变量定义了就一定要使用，否则就会编译不通过等等</li>
</ul>
<p>更好的就是方法可以返回多个值，这个跟<code>Java</code>比较就是减少很多的封装。因为<code>Go</code>的线程模型特点，用来写一些需要高并发、高性能的项目还是非常好的。所以，趁这个机会也好好的深入了解下。现在也是把<code>Python</code>、<code>PHP</code>、<code>Go</code>等都学习一遍，每种语言都有它的优缺点，其实都还挺不错的。</p>
<p>针对于<code>Go</code>语言里：<code>&amp;</code>与<code>*</code>的区别，什么时候该用什么做一个总结。</p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>我们经常会听到别人说<code>Go</code>是值传递，某某某是引用传递，某某某是指针传递，等等各种各样的说法。</p>
<p>那么首先他们的区别是什么呢？什么是指针？指针其实也是一个变量，只不过这个变量里面存的不是<code>int</code>，<code>float</code>，<code>struct</code>，而是一个地址<code>address</code>，然后在这个<code>address</code>上所存储的数据可以通过指针来被阅读到。</p>
<p><code>OK</code>，指针变量存储的是一个地址，地址从哪里来的？那就得问一个变量的地址怎么取得呢？在变量前面加上一个&amp;符号就行。</p>
<p>好的，指针变量存储了这个地址了，那这个地址所存储的值怎么被阅读到呢？也就是指针所指向的值怎么拿到呢？在指针变量前面加上一个<code>*</code>符号就行。</p>
<p>怎么修改指针所指向的数据呢？在前面加上<code>*</code>符号之后再赋一个新的值就可以了。</p>
<p>我们来看一个栗子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="string">"vernonchen"</span></span><br><span class="line">	b := &amp;a</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"a的值"</span>, a)</span><br><span class="line">	fmt.Println(<span class="string">"a的地址"</span>, b)</span><br><span class="line">	fmt.Println(<span class="string">"b的值"</span>, b)</span><br><span class="line">	fmt.Println(<span class="string">"b的指针指向"</span>, *b)</span><br><span class="line"></span><br><span class="line">	*b = <span class="string">"not vernonchen"</span></span><br><span class="line">	fmt.Println(<span class="string">"修改后，b的指针指向"</span>, *b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出的结果是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a的值 vernonchen</span><br><span class="line">a的地址 0xc00008e1e0 // 使用的是b</span><br><span class="line">b的值 0xc00008e1e0</span><br><span class="line">b的指针指向 vernonchen //使用的是指针</span><br><span class="line">修改后，b的指针指向 not vernonchen // 重新指向新的值</span><br></pre></td></tr></table></figure>

<h4 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h4><p>为什么要有指针这个东西？它有什么关键性的作用呢？</p>
<p>我们来看下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	userName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(user User)</span></span> &#123;</span><br><span class="line">	user.userName = <span class="string">"vernonchen2222"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyWithPoint</span><span class="params">(user *User)</span></span> &#123;</span><br><span class="line">	user.userName = <span class="string">"vernonchen3333"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	user := User&#123;userName: <span class="string">"vernonchen"</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"userName = "</span>, user.userName)</span><br><span class="line"></span><br><span class="line">	modify(user)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"userName = "</span>, user.userName)</span><br><span class="line"></span><br><span class="line">	modifyWithPoint(&amp;user)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"userName = "</span>, user.userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完后，输出的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">userName =  vernonchen</span><br><span class="line">userName =  vernonchen // 没有被替换</span><br><span class="line">userName =  vernonchen3333 // 被替换</span><br></pre></td></tr></table></figure>

<p>所以指针的作用:</p>
<ol>
<li><p>指针不但可以帮助函数内部修改外部变量的值，还可以帮助我们在任何地方修改其所指向数据的值；</p>
</li>
<li><p>传递指针参数可以节省拷贝大结构体的内存开销；</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>指针也是变量，只不过存储的是地址</li>
<li>通过指针可以去修改其指向数据的值</li>
<li>指针可以帮助我们在任何地方修改其所指向数据的值</li>
<li>传递指针参数可以节省拷贝大结构体的内存开销</li>
</ul>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://studygolang.com/articles/32103" target="_blank" rel="noopener">https://studygolang.com/articles/32103</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>pt-online-schema-change使用</title>
    <url>/2021/09/15/2021/09/pt-online-schema-change%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>如果说你的数据量并发量不大，或者你的数据量很少没有到千万级别，也许<code>pt-osc</code>、<code>gh-osc</code>，online-ddl这些工具都用不着。但是，如果你的数据量很大，数据又很热。如果你没有这些工具，你可能无法完成对一个数据库新增一个字段或者任何一个简单的<code>DDL</code>语句。</p>
<p>简单的分析一下，为了保证数据一致性问题，我们在哪儿都会遇到锁的问题，锁是用来保证顺序性的。谁先拥有锁，谁就可以先执行。锁也会存在力度问题，它跟你要做的一件事情息息相关，我们也会在性能上去做取舍，所有就好了行锁、表锁等。</p>
<h4 id="Waiting-for-table-metadata-lock"><a href="#Waiting-for-table-metadata-lock" class="headerlink" title="Waiting for table metadata lock"></a>Waiting for table metadata lock</h4><p>说一下我遇到的这个场景，数据量数据大概在800W左右，但是表非常的热，长事务也很多。当我要对一个表新增字段的时候，这个时候如果你经验不够足，可能就会“量成大祸”。一般在做<code>DDL</code>会出现：Waiting for table metadata lock。</p>
<p>如果长时间获取不到锁的话，就出现一个可怕的情况：</p>
<ul>
<li>如果前面的事务未提交，当前是获取不到锁，就不可以执行<code>DDL</code>语句</li>
<li>在<code>DDL</code>语句未执行之前，后面的请求全部是被hold住的</li>
</ul>
<p>这样子就会导致一前一后同时夹击，导致整个业务不可用。那么出现Waiting for table metadata lock可能是由哪些原因导致的？</p>
<h6 id="场景一：长事物运行，阻塞DDL，继而阻塞所有同表的后续操作"><a href="#场景一：长事物运行，阻塞DDL，继而阻塞所有同表的后续操作" class="headerlink" title="场景一：长事物运行，阻塞DDL，继而阻塞所有同表的后续操作"></a>场景一：长事物运行，阻塞DDL，继而阻塞所有同表的后续操作</h6><p>通过<code>show processlist</code>可以看到<code>TableA</code>上有正在进行的操作（包括读），此时alter table语句无法获取到<code>metadata</code> 独占锁，会进行等待。</p>
<p>这是最基本的一种情形，这个和<code>mysql 5.6</code>中的<code>online ddl</code>并不冲突。一般<code>alter table</code>的操作过程中，在<code>after create</code>步骤会获取<code>metadata</code> 独占锁，当进行到<code>altering table</code>的过程时（通常是最花时间的步骤），对该表的读写都可以正常进行，这就是<code>online ddl</code>的表现，并不会像之前在整个<code>alter table</code>过程中阻塞写入。（当然，也并不是所有类型的alter操作都能online的，具体可以参见官方手册：<a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html）" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html）</a><br><strong>处理方法：</strong> kill 掉 DDL所在的session.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找出所有执行时间超过 5 分钟的线程，拼凑出 kill 语句，方便后面查杀</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'kill '</span>, <span class="keyword">id</span>, <span class="string">';'</span>)</span><br><span class="line"><span class="keyword">from</span> information_schema.processlist</span><br><span class="line"><span class="keyword">where</span> Command != <span class="string">'Sleep'</span> <span class="keyword">AND</span> COMMAND != <span class="string">'Binlog Dump GTID'</span> <span class="keyword">AND</span> COMMAND != <span class="string">'Binlog Dump'</span></span><br><span class="line">  <span class="keyword">and</span> <span class="built_in">Time</span> &gt; <span class="number">300</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">Time</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h6 id="场景二：未提交事物，阻塞DDL，继而阻塞所有同表的后续操作"><a href="#场景二：未提交事物，阻塞DDL，继而阻塞所有同表的后续操作" class="headerlink" title="场景二：未提交事物，阻塞DDL，继而阻塞所有同表的后续操作"></a>场景二：未提交事物，阻塞DDL，继而阻塞所有同表的后续操作</h6><p>通过<code>show processlist</code>看不到<code>TableA</code>上有任何操作，但实际上存在有未提交的事务，可以在 <strong>information_schema.innodb_trx</strong>中查看到。在事务没有完成之前，TableA上的锁不会释放，<code>alter table</code>同样获取不到<code>metadata</code>的独占锁。</p>
<p>处理方法：通过 <code>select * from information_schema.innodb_trx\G</code>, 找到未提交事物的<code>sid</code>, 然后 <code>kill</code> 掉，让其回滚。</p>
<h6 id="场景三：显示事务失败未提交"><a href="#场景三：显示事务失败未提交" class="headerlink" title="场景三：显示事务失败未提交"></a>场景三：显示事务失败未提交</h6><p>通过<code>show processlist</code>看不到<code>TableA</code>上有任何操作，在<code>information_schema.innodb_trx</code>中也没有任何进行中的事务。这很可能是因为在一个显式的事务中，对<code>TableA</code>进行了一个失败的操作（比如查询了一个不存在的字段），这时事务没有开始，但是失败语句获取到的锁依然有效，没有释放。从<code>performance_schema.events_statements_current</code>表中可以查到失败的语句。</p>
<p>官方手册上对此的说明如下：</p>
<p>If the server acquires metadata locks for a statement that is syntactically valid but fails during execution, it does not release the locks early. Lock release is still deferred to the end of the transaction because the failed statement is written to the binary log and the locks protect log consistency.</p>
<p>也就是说除了语法错误，其他错误语句获取到的锁在这个事务提交或回滚之前，仍然不会释放掉。because the failed statement is written to the binary log and the locks protect log consistency 但是解释这一行为的原因很难理解，因为错误的语句根本不会被记录到二进制日志。</p>
<p><strong>处理方法：</strong>通过performance_schema.events_statements_current找到其sid, kill 掉该session. 也可以 <code>kill</code> 掉<code>DDL</code>所在的<code>session</code>.</p>
<p>上述是手动操作，毕竟是一个比手速的过程，而且也不能保证保证100%，还需要经常的kill进程才行。</p>
<h4 id="gt-osc使用"><a href="#gt-osc使用" class="headerlink" title="gt-osc使用"></a>gt-osc使用</h4><p>请看参考地址，对于一些online ddl工具研究后，对gt-osc做了一个初步的使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-online-schema-change --host=xxx -uxxx -pxxx \</span><br><span class="line">--alter "add xxx int(1) NOT NULL DEFAULT '0'  COMMENT 'xxx', add xxx varchar(10) NOT NULL DEFAULT '0'  COMMENT 'xxx' , lock=none"  D=xxx,t='xxx' \</span><br><span class="line">--execute \</span><br><span class="line">--print \</span><br><span class="line">--statistics \</span><br><span class="line">--no-check-alter</span><br></pre></td></tr></table></figure>

<p>执行后其实它做了这些工作，具体如下：</p>
<ol>
<li>相关环境参数检查</li>
<li>检查该表格是否存在</li>
<li>show create table xxx</li>
<li>create table _xxx_new</li>
<li>alter table _xxx_new</li>
<li>创建删除触发器 pt_osc_db_table_name_del </li>
<li>创建更新触发器 pt_osc_db_table_name_upd</li>
<li>创建插入触发器 pt_osc_db_table_name_ins</li>
<li>按块拷贝数据到新表，拷贝过程对数据行持有S锁</li>
<li>analyze 新表</li>
<li>rename 表名，RENAME TABLE <code>db</code>.<code>table_name</code> TO <code>db</code>.<code>_table_name_old</code>, <code>db</code>.<code>_table_name_new</code> TO <code>db</code>.<code>table_name</code></li>
<li>删除旧表</li>
<li>删除新表上的删除、更新、插入 触发器</li>
</ol>
<p>可以去看一下网站的说明：<a href="https://www.percona.com/blog/2019/06/07/how-pt-online-schema-change-handles-foreign-keys/" target="_blank" rel="noopener">https://www.percona.com/blog/2019/06/07/how-pt-online-schema-change-handles-foreign-keys/</a></p>
<p><img src="http://static.cyblogs.com/Jietu20211018-000822.jpg" alt="http://static.cyblogs.com/Jietu20211018-000822.jpg"></p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://cloud.tencent.com/developer/article/1500170" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1500170</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1508051" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1508051</a></li>
<li><a href="https://huangzhw.github.io/2018/09/20/mysql-online-ddl/#%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">https://huangzhw.github.io/2018/09/20/mysql-online-ddl/#%E5%B0%8F%E7%BB%93</a></li>
<li><a href="https://www.cnblogs.com/digdeep/p/4892953.html" target="_blank" rel="noopener">https://www.cnblogs.com/digdeep/p/4892953.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用wrk与Jmeter做性能压测</title>
    <url>/2021/10/23/2021/10/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8wrk%E4%B8%8EJmeter%E5%81%9A%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/</url>
    <content><![CDATA[<p>我们在新做项目的时候，需要对我们的服务有有一些性能指标，比如：<code>SLA</code>（需要达到多少个9）、<code>QPS</code>、<code>TPS</code>等。因为这些量化的数字让我们更加的了解我们的系统。</p>
<p>我们如何压测？其实个人觉得有2种场景。</p>
<p><strong>第一种</strong>：是我们明确的知道目标，看我们通过大量的并发看我们是否有达到。如果没有达到，我们需要通过水平扩容、性能优化等让其达到。</p>
<p><strong>第二种</strong>：是我们不知道目标，通过压测可以知道一个固定配置下的单机单服务的最大性能，让我们对它有一个彻底的认识。为后面的目标做更多的铺垫与准备，或者跟行业水平对比，看看差距有多少。</p>
<h4 id="如何用wrk进行压测？"><a href="#如何用wrk进行压测？" class="headerlink" title="如何用wrk进行压测？"></a>如何用wrk进行压测？</h4><p>Github地址:<a href="https://github.com/wg/wrk，该项目也是开源项目，关注的人还不少，有30.4K。咨询了一下身边的同事，使用它的人还不少。主要的语言的是C语言。" target="_blank" rel="noopener">https://github.com/wg/wrk，该项目也是开源项目，关注的人还不少，有30.4K。咨询了一下身边的同事，使用它的人还不少。主要的语言的是C语言。</a></p>
<p><img src="http://static.cyblogs.com/Jietu20211023-153923.jpg" alt="http://static.cyblogs.com/Jietu20211023-153923.jpg"></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/wg/wrk</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">-- 拷贝wrk到bin</span><br><span class="line">cp wrk /usr/sbin/wrk</span><br></pre></td></tr></table></figure>

<h5 id="压测脚本"><a href="#压测脚本" class="headerlink" title="压测脚本"></a>压测脚本</h5><p><strong>压测脚本press.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">bf=0i</span><br><span class="line">rm ./report_mock.$&#123;1&#125;.txt 2&gt; /dev/null</span><br><span class="line">for k in 10; do</span><br><span class="line">    bf=`expr $&#123;k&#125; \* 100`</span><br><span class="line">    for len in 512k; do</span><br><span class="line">        echo "start length $&#123;len&#125;" &gt;&gt; ./report_mock.$&#123;1&#125;.txt</span><br><span class="line">        ./wrk  -c$&#123;bf&#125; -t16 -d3m --timeout 2m --latency -s ./post_$&#123;len&#125;.lua http://$&#123;1&#125;/press/$&#123;len&#125; &gt;&gt; ./report_mock.$&#123;1&#125;.txt</span><br><span class="line">        echo "----------------------------------------------------" &gt;&gt; ./report_mock.$&#123;1&#125;.txt</span><br><span class="line">    done</span><br><span class="line">    sleep 10</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>Lua脚本post_512.lua</strong></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">wrk.method = <span class="string">"POST"</span></span><br><span class="line">wrk.body = <span class="string">'&#123;"key":"value"&#125;'</span></span><br><span class="line">wrk.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span></span><br><span class="line">wrk.headers[<span class="string">"X-Forwarded-For"</span>] = <span class="string">"6.6.6.6"</span></span><br></pre></td></tr></table></figure>

<p>这里是一个通用脚本，大致的含义是：</p>
<ul>
<li>删除掉原来生成的文件</li>
<li>循环10次，其实也就是从并发数从100~1000依次进行压测</li>
<li>返回的报文大小控制在512K，这个可以为根据你的Request去匹配你的Response。</li>
<li>-t16：启动16个线程</li>
<li>-d3m：也测时间是3mins</li>
<li>–timeout：2m  超时时间是2mins  </li>
<li>post_${len}.lua：就是构造512K返回的Request参数对应的lua脚本</li>
<li>report_mock.${1}.txt：结果会append到该文件中去</li>
<li>${1}：就是你要向哪个服务器发起请求的host+port</li>
</ul>
<p>总结一下，这些时间需要根据自己的服务器性能去调整，有可能压测出来的数据就是空的，因为超时了未返回Response。</p>
<h5 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  </span><br><span class="line">    -d, --duration    &lt;T&gt;  压测时间           </span><br><span class="line">    -t, --threads     &lt;N&gt;  使用多少个线程进行压测   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  指定Lua脚本路径       </span><br><span class="line">    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      </span><br><span class="line">        --latency          在压测结束后，打印延迟统计信息   </span><br><span class="line">        --timeout     &lt;T&gt;  超时时间     </span><br><span class="line">    -v, --version          打印正在使用的wrk的详细版本信息</span><br><span class="line">                                                      </span><br><span class="line">  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)</span><br><span class="line">  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)</span><br></pre></td></tr></table></figure>

<h5 id="执行的结果"><a href="#执行的结果" class="headerlink" title="执行的结果"></a>执行的结果</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start length 512k</span><br><span class="line">Running 3m test @ http://&#123;ip+port&#125;/press/512k # &#123;ip+port&#125;是你自己的</span><br><span class="line">  16 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   145.17ms  942.97ms   0.86m    98.34%</span><br><span class="line">    Req/Sec     1.39k   114.27     3.58k    70.07%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   36.58ms</span><br><span class="line">     75%   48.78ms</span><br><span class="line">     90%  185.51ms</span><br><span class="line">     99%    1.78s </span><br><span class="line">  3994727 requests in 3.00m, 65.25GB read</span><br><span class="line">  Non-2xx or 3xx responses: 3863495</span><br><span class="line">Requests/sec:  22181.33</span><br><span class="line">Transfer/sec:    371.00MB</span><br></pre></td></tr></table></figure>

<p>会给一个分布非常的好：50%、75%、90%、99%。</p>
<p>但是如果说这么看大量的数据不够直观，这里再提供一个一个python脚本来解析里面的值。使其能把这些日志的重要的信息提取出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ms</span><span class="params">(fr)</span>:</span></span><br><span class="line">    fr = fr.lower()</span><br><span class="line">    <span class="keyword">if</span> fr[<span class="number">-2</span>:] == <span class="string">'ms'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-2</span>])</span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>:] == <span class="string">'s'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>]) * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>] == <span class="string">'m'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>]) * <span class="number">1000</span> * <span class="number">60</span></span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mb</span><span class="params">(fr)</span>:</span></span><br><span class="line">    fr = fr.lower()</span><br><span class="line">    <span class="keyword">if</span> fr[<span class="number">-2</span>:] == <span class="string">'gb'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-2</span>]) * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-2</span>:] == <span class="string">'mb'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-2</span>])</span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-2</span>:] == <span class="string">'kb'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-2</span>]) / <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>] == <span class="string">'b'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>]) / <span class="number">1000</span> / <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>] == <span class="string">'k'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>]) / <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>] == <span class="string">'m'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one</span><span class="params">(one)</span>:</span></span><br><span class="line">    ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> one.split(<span class="string">'\n'</span>):</span><br><span class="line">        <span class="keyword">if</span> l.find(<span class="string">'test @ http://'</span>) &gt; <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'host'</span>] = l.split(<span class="string">'://'</span>)[<span class="number">1</span>].split(<span class="string">'/'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'start length'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'size'</span>] = l.split(<span class="string">' '</span>)[<span class="number">-1</span>].strip()</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'threads and'</span>) &gt; <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'threads'</span>] = int(l.split(<span class="string">'threads and'</span>)[<span class="number">0</span>].strip())</span><br><span class="line">            ret[<span class="string">'conns'</span>] = int(l.split(<span class="string">'threads and'</span>)[<span class="number">1</span>].split(<span class="string">'connections'</span>)[<span class="number">0</span>].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'    Latency'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'l_avg'</span>] = ms(l[len(<span class="string">'    Latency'</span>):].lstrip().split(<span class="string">' '</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'     50%'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'l_50'</span>] = ms(l[len(<span class="string">'     50%'</span>):].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'     90%'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'l_90'</span>] = ms(l[len(<span class="string">'     90%'</span>):].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'     99%'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'l_99'</span>] = ms(l[len(<span class="string">'     99%'</span>):].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'Requests/sec:'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'qps'</span>] = float(l[len(<span class="string">'Requests/sec:'</span>):].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'Transfer/sec:'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'mbps'</span>] = mb(l[len(<span class="string">'Transfer/sec:'</span>):].strip())</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/Users/chenyuan/Desktop/report_mock.127.0.0.1.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    all = f.read().strip()</span><br><span class="line">    out = []</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> all.split(<span class="string">'----------------------------------------------------\n'</span>):</span><br><span class="line">        r = parse_one(one)</span><br><span class="line">        out.append((r[<span class="string">'host'</span>], r[<span class="string">'size'</span>], r[<span class="string">'conns'</span>], r[<span class="string">'l_avg'</span>], r[<span class="string">'l_50'</span>], r[<span class="string">'l_90'</span>], r[<span class="string">'l_99'</span>], r[<span class="string">'qps'</span>], r[<span class="string">'mbps'</span>]))</span><br><span class="line">    out.sort()</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> out:</span><br><span class="line">        print(<span class="string">'\t'</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> o]))</span><br></pre></td></tr></table></figure>

<p>最终你可以再在文本里面利用列操作的方式，将内容归整到Excel中去。你就可以很好的汇报与分享给他人了~</p>
<p><img src="http://static.cyblogs.com/Jietu20211023-160325.jpg" alt="http://static.cyblogs.com/Jietu20211023-160325.jpg"></p>
<h4 id="如何利用Jmeter进行压测？"><a href="#如何利用Jmeter进行压测？" class="headerlink" title="如何利用Jmeter进行压测？"></a>如何利用Jmeter进行压测？</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。</p>
<p>Apache jmeter 可以用于对静态的和动态的资源（文件，Servlet，Perl脚本，java 对象，数据库和查询，FTP服务器等等）的性能进行测试。它可以用于对服务器、网络或对象模拟繁重的负载来测试它们的强度或分析不同压力类型下的整体性能。你可以使用它做性能的图形分析或在大并发负载测试你的服务器/脚本/对象。</p>
<p>Jmeter也是在进行压测中使用场景很多的软件，图形界面操作起来非常的友好。简单的写一个Demo流程出来。</p>
<h5 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h5><p>官网：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a> </p>
<p><img src="http://static.cyblogs.com/Jietu20211023-160918.jpg" alt="http://static.cyblogs.com/Jietu20211023-160918.jpg"></p>
<p>下载解压完毕后大概的一个目录结构，可以把bin配置到path中就可以直接通过jmeter密令激活软件了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  jmeter pwd</span><br><span class="line">/Users/chenyuan/Tools/jmeter</span><br><span class="line">➜  jmeter ll</span><br><span class="line">total 64</span><br><span class="line">-rw-rw-r--@   1 chenyuan  staff    15K  1  2  1970 LICENSE</span><br><span class="line">-rw-rw-r--@   1 chenyuan  staff   167B  1  2  1970 NOTICE</span><br><span class="line">-rw-rw-r--@   1 chenyuan  staff   9.6K  1  2  1970 README.md</span><br><span class="line">drwxrwxr-x@  43 chenyuan  staff   1.3K  1  2  1970 bin</span><br><span class="line">drwxr-xr-x@   6 chenyuan  staff   192B  1  2  1970 docs</span><br><span class="line">drwxrwxr-x@  22 chenyuan  staff   704B  1  2  1970 extras</span><br><span class="line">drwxrwxr-x@ 104 chenyuan  staff   3.3K  1  2  1970 lib</span><br><span class="line">drwxrwxr-x@ 104 chenyuan  staff   3.3K  1  2  1970 licenses</span><br><span class="line">drwxr-xr-x@  19 chenyuan  staff   608B  1  2  1970 printable_docs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我这里直接运行，最好配置PATH，后续更加的方便</span></span><br><span class="line">➜  jmeter ./bin/jmeter</span><br><span class="line">================================================================================</span><br><span class="line">Don't use GUI mode for load testing !, only for Test creation and Test debugging.</span><br><span class="line">For load testing, use CLI Mode (was NON GUI):</span><br><span class="line">   jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]</span><br><span class="line">&amp; increase Java Heap to meet your test requirements:</span><br><span class="line">   Modify current env variable HEAP="-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m" in the jmeter batch file</span><br><span class="line">Check : https://jmeter.apache.org/usermanual/best-practices.html</span><br><span class="line">================================================================================</span><br><span class="line"><span class="meta">#</span><span class="bash"> 就这代表已经启动了，运行期间不要终端命令框。</span></span><br></pre></td></tr></table></figure>

<h5 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h5><p>先看一张整体的图吧，对它有一个比较整体的认识：</p>
<p><img src="http://static.cyblogs.com/Jietu20211023-161956.jpg" alt="http://static.cyblogs.com/Jietu20211023-161956.jpg"></p>
<p>我们可以按照<a href="https://www.cnblogs.com/stulzq/p/8971531.html" target="_blank" rel="noopener">https://www.cnblogs.com/stulzq/p/8971531.html</a> 的步骤一步的去做。我这里就不做太多重复的介绍。因为相对比wrk来的简单。</p>
<p>最后可以点击运行来跑单测，一般我们会调整线程数的大小、发送的频率来进行压测看结果。</p>
<p><img src="http://static.cyblogs.com/Jietu20211023-162302.jpg" alt="http://static.cyblogs.com/Jietu20211023-162302.jpg"></p>
<p>我们在断言的地方是可以做很多的事情的，因为什么样的结果是正确的，什么样的结果是失败的。获取需要从Response中、Header里截取一些关键的key与value来做逻辑。这些可以通过编写脚本来去做到，那就算相对高阶一点的操作了。后续可以继续深入一下~ </p>
<p>最后可以在汇总报告里可以看出来我们的一个性能情况，SLA的比例等。</p>
<p>作为一名后端开发，对自己写出来的服务进行一个非常全面的性能压测是很有必要的。对于系统的一个QPS、TPS、SLA这些数字应该随口就能说出来。哪些地方存在性能瓶颈？然后再去找相应的方案去优化掉。很多时候，性能可能就会是一个最大的风险，它会导致我们的服务整体的瘫痪、不可用。这些很有可能就跟我们的KPI、奖金挂钩~</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://www.jianshu.com/p/aa76ffd6d894" target="_blank" rel="noopener">https://www.jianshu.com/p/aa76ffd6d894</a></li>
<li><a href="https://www.cnblogs.com/stulzq/p/8971531.html" target="_blank" rel="noopener">https://www.cnblogs.com/stulzq/p/8971531.html</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>性能压测</category>
      </categories>
      <tags>
        <tag>wrk</tag>
        <tag>Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用k8s的label与ingress做蓝绿发布？</title>
    <url>/2021/10/30/2021/10/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8k8s%E7%9A%84label%E4%B8%8Eingress%E5%81%9A%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>之前在思考双活/多活架构的时候，其实对于蓝绿发布是有一些了解的，也梳理过在底层存储是一份，服务是多份的模式有做过深入的分析。但那个时候对于<code>Kubernetes</code>的了解还不是很熟悉，是通过传统的方式来考量的。</p>
<p>因为现在的互联网公司基本都是上云了，我们也必须对于<code>Kubernetes</code>那一整套要有比较深入、熟悉的运用才能真的提高我们的效率。先聊一下，我为什么需要利用灰度+蓝绿发布的模式来去做？</p>
<p>现在有一个比较老的项目，应该在10年+，每天请求量大概在1.5亿+，峰值的<code>QPS</code>在6000/s，存在着比较多性能问题。现在需要在它上面新增一个服务，为了后面优化做准备，比如：请求的分流、限流、熔断、日志的上报与监控（新）、统一编译处理，特殊报文转换等。也就是说，只要你新增加了一层，你才有可能更好的去做更多的事情。</p>
<p>那么我们需要达到一些什么的基础条件了？</p>
<ul>
<li>服务流量比较大，我们需要对新服务的可靠性需要验证，需要灰度先了解</li>
<li>因为存在慢查询，不能在滚动发布中，导致请求还未执行完毕，就被k8s kill掉了，业务会感知到502</li>
</ul>
<p>如果是你？针对于这2个基础的要求，你会如何去思考的你架构方案呢？</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>新增服务的思考：</p>
<ul>
<li>它的性能必须要强、服务稳定。一个服务的性能好不好，其实跟它的：<code>I/O</code>模型、线程模型、数据结构、算法等息息相关。比如：你在思考<code>Redis</code>单线程为什么快的时候？应该就很能get到这里的点了。解决这个问题，我们选择了<code>Go</code>语言来开发（当然，最熟悉的语言风险最小），为了保证性能，也是做了2轮非常细致的压测。</li>
<li>发布过程中不能因为kill掉服务导致请求<code>502</code>。如果说我在发布的过程中，我把滚动这一步省略掉，直接先准备好一份最新的，验证可以后，我一刀直接把流量引导最新服务上，老的服务也不会断掉，这是否就可以达到效果了？</li>
</ul>
<h4 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h4><p>下面是我画的一个架构图，方便大家的理解，一共是3条路线：</p>
<p><img src="http://static.cyblogs.com/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8k8s%E7%9A%84label%E4%B8%8Eingress%E5%81%9A%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83_%E6%9E%B6%E6%9E%84%E5%9B%BE02.jpg" alt="http://static.cyblogs.com/如何利用k8s的label与ingress做蓝绿发布_架构图02.jpg"></p>
<h5 id="路线1：原始的路线"><a href="#路线1：原始的路线" class="headerlink" title="路线1：原始的路线"></a>路线1：原始的路线</h5><ul>
<li><code>Ingress</code> → <code>Service:server-read</code> → <code>StatefulSet:server-g3-read + server-g3-read-gray</code>，整条链路是通过<code>ingress</code>的指向与<code>selector</code>的标签：<code>k8s-app:server-read</code>。</li>
</ul>
<h5 id="路线2：灰度方案"><a href="#路线2：灰度方案" class="headerlink" title="路线2：灰度方案"></a>路线2：灰度方案</h5><h6 id="服务正常"><a href="#服务正常" class="headerlink" title="服务正常"></a>服务正常</h6><p>就是我只能让一少部分的流量进入到新的服务(2%~10%，支持慢慢调整，其实就是pod的数量占比)。</p>
<ul>
<li><code>2%</code>的概率走的路径：<code>Ingress</code> → <code>Service:server-gateway-read01</code> → <code>StatefulSet:server-gateway-read01</code> → <code>注册中心获取负载地址</code> → <code>Service:server-read</code> → <code>StatefulSet:server-g3-read + server-g3-read-gray</code>，整条链路是通过<code>ingress</code>的指向与<code>selector</code>的标签：<code>server-app:server-gateway-read01</code></li>
<li><code>98%</code>的概率还是走的路线1</li>
</ul>
<h6 id="服务异常解决方案"><a href="#服务异常解决方案" class="headerlink" title="服务异常解决方案"></a>服务异常解决方案</h6><ul>
<li>因为这个流量是通过节点数来控制的，如果发生异常，可以把灰度节点的POD数量调整为0</li>
<li>还可以从ingress的地址切换到线路1的原始方案。这一招永远生效，因为一整套label标签依然存在。</li>
</ul>
<h5 id="路线3：蓝绿路线"><a href="#路线3：蓝绿路线" class="headerlink" title="路线3：蓝绿路线"></a>路线3：蓝绿路线</h5><h6 id="服务正常-1"><a href="#服务正常-1" class="headerlink" title="服务正常"></a>服务正常</h6><ul>
<li>100%的流量全部走灰度方案的。即：<code>Ingress</code> → <code>Service:server-gateway-read01</code> → <code>StatefulSet:server-gateway-read01</code> → <code>注册中心获取负载地址</code> → <code>Service:server-read</code> → <code>StatefulSet:server-g3-read + server-g3-read-gray</code>。但是它的<code>selector</code>的标签：<code>server-app:server-gateway-read02</code></li>
</ul>
<h6 id="服务异常解决方案-1"><a href="#服务异常解决方案-1" class="headerlink" title="服务异常解决方案"></a>服务异常解决方案</h6><ul>
<li>直接切换ingress地址到线路1或者是线路2都可以</li>
</ul>
<h4 id="最终的方案"><a href="#最终的方案" class="headerlink" title="最终的方案"></a>最终的方案</h4><p>后面如果长期稳定后，方案2其实就没有必要再继续灰度了，直接就替换成线路3了。相当于是一个蓝绿+主备的模式了。优缺点非常的明显：</p>
<ul>
<li>优点：解决了重启中可能出现的中断问题，其实也可以通过一些 <code>Graceful Shutdown</code>优化。</li>
<li>缺点：就是发布的一瞬间，你是需要多出一倍的机器来支撑服务的。</li>
</ul>
<p>再温馨提示一下，因为做了蓝绿发布，我们的系统对应的配置中心应该也最好是要分开的。系统之间要避免蓝色通过与绿色通道之间的交叉访问等问题。</p>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>蓝绿发布</tag>
      </tags>
  </entry>
  <entry>
    <title>如何反编译一个Docker镜像还原Dockerfile？</title>
    <url>/2021/11/06/2021/11/%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AADocker%E9%95%9C%E5%83%8F%E8%BF%98%E5%8E%9FDockerfile%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>现在对于一个开发来说，<code>Docker</code>应该是再熟悉不过了。还记得在2013<del>2014左右的时候，听说多最多的就是<code>Cloud Foundry</code>，那个时候就一直在说云的事情。后面<code>Docker</code>就绝杀了它</del> </p>
<p>那它帮我们解决了一个什么问题了？面试的时候也许会问到。</p>
<p>在很久以前，我们开发代码，估计最蛋疼的事情就是发布版本了。我还记得在房多多的时候(2014~2016)左右，每次发布几个开发围绕在运维的身边，有时候运维忙不过来，开发就直接在运维的电脑上开始<code>VIM</code>干活了，修改若干配置。由于多环境的原因，我们无法保证每个环境都是一样的。</p>
<ul>
<li>可能你的操作系统不同，导致打包、发布的脚本不同</li>
<li>环境不同，没有很好的配置管理，你的代码有不同的写法</li>
<li>特别是跟操作系统相关的那些参数，可能瞬间就会带来性能问题</li>
</ul>
<p>那么<code>Docker</code>就可以把我们的操作系统、代码、脚本等都一起打包成一个<code>Image</code>，就可以保证只要是运行同一个<code>Image</code>，我们的所有内容都是一样的。就不会出现，我在测试环境跑的好好的，一到生产连启动都成问题。</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>现在一般一个<code>POD</code>就只跑一个进程，<code>DevOps</code>会根据我们的发布流水线自动的将一个项目进行打包、发布，整套的<code>CI</code>、CD做的是行云流水。但是，每个项目<code>ROOT</code>下都会需要一个叫<code>Dockerfile</code>的文件。但偏偏有一些历史项目，没有<code>Dockerfile</code>文件，只有一个<code>Run</code>的容器再跑，真的是非常惊悚。<code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code>,就<code>GAME OVER</code>了。</p>
<h4 id="怎么办？"><a href="#怎么办？" class="headerlink" title="怎么办？"></a>怎么办？</h4><h5 id="方法1：以当前容器作为基础镜像"><a href="#方法1：以当前容器作为基础镜像" class="headerlink" title="方法1：以当前容器作为基础镜像"></a>方法1：以当前容器作为基础镜像</h5><p>真的，什么也不想。先保个底，把你当前的容器打包成一个镜像推送到仓库里去，哪天有以外或者说需要基于它做一些事情的时候才有可能。比如：你要本地也部署一份代码来<code>debug</code>。</p>
<p>一般都是私有的仓库，会需要输入用户名与密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ docker login &#123;仓库地址&#125;</span><br><span class="line">Username: chenyuan</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>

<p>然后，将镜像打包推送到私有仓库去</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit -a "name" -m "小陈来拯救你" 706e502e8693 &#123;镜像地址&#125;:&#123;tag&#125;</span><br><span class="line"></span><br><span class="line">docker push &#123;镜像地址&#125;:&#123;tag&#125;</span><br><span class="line"></span><br><span class="line">docker pull &#123;镜像地址&#125;:&#123;tag&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样子的问题在于，我们无法知道环境依赖了哪些模块，如果需要重新再部署一套，我为了保证环境的干净又需要删除哪些东西。就是无法知道增加与减少哪些东西，也就会导致环境存在不一致性，失去了我们的初衷。</p>
<h5 id="方法2：从运行的容器中复制"><a href="#方法2：从运行的容器中复制" class="headerlink" title="方法2：从运行的容器中复制"></a>方法2：从运行的容器中复制</h5><p>先把镜像跑起来，然后从运行起来的容器中复制文件出来，复制命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从容器复制文件或目录到宿主机器</span></span><br><span class="line">docker cp 6619ff360cce:/opt/h2-data/pkslow ./</span><br><span class="line">docker cp 6619ff360cce:/opt/h2-data/pkslow/pkslow.txt ./</span><br></pre></td></tr></table></figure>

<p>第一种方法并不是万能的，因为有些镜像过于简单，少了许多基础命令，以至于无法复制文件，也无法进入<code>shell</code>环境。其次，要运行起来再操作，也有点占用资源，比较麻烦。</p>
<h5 id="方法3：解压镜像tar文件（推荐）"><a href="#方法3：解压镜像tar文件（推荐）" class="headerlink" title="方法3：解压镜像tar文件（推荐）"></a>方法3：解压镜像tar文件（推荐）</h5><p>此方法就是相当于反编译，拿到当时打镜像时候你做的详细操作。比较麻烦，但是是最靠谱的，最具有操作性的。</p>
<p>先将镜像保存为tar文件，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o &#123;name&#125;.tar &#123;镜像地址&#125;:&#123;tag&#125;</span><br></pre></td></tr></table></figure>

<p>下载后就会有一个tar包在本地，然后就解压出来。可以看一下<code>manifest.json</code>文件的内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Config"</span>: <span class="string">"dca33100e3683d6fb4d56a4c142ccccc1c113f061454a64bc07c852fe068ea1d.json"</span>,</span><br><span class="line">        <span class="attr">"RepoTags"</span>:</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"&#123;镜像地址&#125;:&#123;tag&#125;"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"Layers"</span>:</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"216168069a5195a9424b3a73a62bda39e4d5f8dcae2f7149a336c2e29beeb06b/layer.tar"</span>,</span><br><span class="line">            <span class="string">"4b0e1f4bede4cef5dee11aff78ff89f543dc62eb02306db1b96d896b101e069d/layer.tar"</span>,</span><br><span class="line">            <span class="string">"3fe7f20416fdd4958cc18b6fb0d28881147246c32677d102a431c31bf12288f7/layer.tar"</span>,</span><br><span class="line">            <span class="string">"84c1758c9c15f83d8aa4e1ad13c2918aea80f802f01d19eeb2f7c6e1897d7160/layer.tar"</span>,</span><br><span class="line">            <span class="string">"31bf0d828ecc19f178d8337e1c22a030984e9185e805b48ea911bd866730af2f/layer.tar"</span>,</span><br><span class="line">            <span class="string">"7b30e9a6f195343744ca82c66d31b61771e8d6502a271ad60deb1fa1103e83ca/layer.tar"</span>,</span><br><span class="line">            <span class="string">"522ee848bbd06c6e4dad8d5200b83c9197ccce717fb09687b435190d287f6829/layer.tar"</span>,</span><br><span class="line">            <span class="string">"a64965663d7c30ed09d35f05439dcfb6247f030df0d72a0e78f54fb6ae5a8c74/layer.tar"</span>,</span><br><span class="line">            <span class="string">"a93f0f89669c097497a3e3de7aeffebeba2838f180e4f13844be55fe124885ae/layer.tar"</span>,</span><br><span class="line">            <span class="string">"fd69896888f7361654ed0e27ed2634311b6707dd20706487e33e24f32bb23ebe/layer.tar"</span>,</span><br><span class="line">            <span class="string">"69c55c418aba5b8fb5239b4e8b092e02100f4ec49dae8ded9cc0a161b21884d7/layer.tar"</span>,</span><br><span class="line">            <span class="string">"5ef51ffa437403d5d33a40208c3781ea84a93f53947e5d7fad086092667bd3b1/layer.tar"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>图片是解压后的效果，里面都会存在一个<code>layer.tar</code>，这里再解压就是当时打镜像时候的一些资源文件。</p>
<p><img src="http://static.cyblogs.com/image-20210928200049751.png" alt="http://static.cyblogs.com/image-20210928200049751.png"></p>
<p><img src="http://static.cyblogs.com/image-20210928200334841.png" alt="http://static.cyblogs.com/image-20210928200334841.png"></p>
<p>红色的部分就是我们想要的内容。再辛苦一点，把自己想要的东西整理出来。描述的比较轻描淡写，任何事情只要手动去做一遍，就会理解与记住。</p>
<h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://segmentfault.com/a/1190000040213872?sort=newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040213872?sort=newest</a></li>
</ul>
<p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p>
<p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
