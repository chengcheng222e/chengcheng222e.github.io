<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>简栈文化</title>
  
  <subtitle>Java技术人的成长之路~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cyblogs.com/"/>
  <updated>2020-12-31T14:58:50.065Z</updated>
  <id>http://www.cyblogs.com/</id>
  
  <author>
    <name>Vernon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写在2020年最后一天</title>
    <link href="http://www.cyblogs.com/2020/12/31/2020/12/%E5%86%99%E5%9C%A82020%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/"/>
    <id>http://www.cyblogs.com/2020/12/31/2020/12/%E5%86%99%E5%9C%A82020%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/</id>
    <published>2020-12-30T16:00:00.000Z</published>
    <updated>2020-12-31T14:58:50.065Z</updated>
    
    <content type="html"><![CDATA[<p>2020年，感觉真的是一个不平凡的年。是时间流逝非常快的一年，也是成长最快的一年。感谢身边所有的人~</p><p>还记得年初的时候，怕被疫情隔在家里了，正月初三就开车到了深圳。那时候听新闻说可能要带半年或者一年的口罩，当时感觉不可思议，根本不可能。现在一年已经已经过去了，但口罩还依然要继续……</p><p>说到口罩，记得刚刚开始在老家带口罩的时候，家里好多人不理解，为什么要戴口罩？（估计跟很多老美一样，觉得不尊重，觉得自己没病等）到了“恐慌”的时候，家里人比我们更着急，更加上心。在这次疫情中，真的也是感受到了人间百态，看到了白衣天使的伟大，看到了一些黑心的商家，看到了那些平凡的人做着不平凡的事儿，感受到了近些年来祖国的伟大（非常感谢国内短视频）。</p><p>今年给我最大的感受是繁忙、成长、充实，总的来说是收获的一年吧。</p><p>年初的时候开启了我的个人公共账号「简栈文化」，一共发表了文章112篇，几乎全部都是跟技术相关的，在编写与梳理这些知识的时候，内心是充满热情与喜悦的。特别是大家去催更的时候，或者有问题请教你的时候，跟你讨论的时候，所有的熬夜与辛苦都是值得的，因为你获得的知识与朋友。后面也是因为工作原因，更新就慢慢的停了下来，但内心一直牵挂着写作这件事儿。</p><p>今年可以说自己是换了工作，也可以说自己没有换工作，因为做的事情不同了，从楼上换到了楼下，但最大的老板还是同样的老板。不过，还是真的很感谢保险与国际的同事，都给了我很大的帮助、鼓励、肯定。在保险从事的是信贷相关的业务，从小白变成了有一丝丝信贷经验的从业者，也有着自己的小团队，而且氛围非常好，非常的优秀。到国际做的是证券业务，团队又是从0开始搭建，业务又不是很熟悉，感觉一下突然回到了4年前。经过了4个月左右的时间，终于又把团队搭建起来了，同时也在努力的去学习业务与技术。更重要的，我自己对自己的要求更高了，想做的更好。这次的团队跟之前一样，无可挑剔，更加的棒~</p><p>这一年虽然看的书籍不是特别多（差不多12本），但是因为这一年的写作原因，内心是非常愿意静下来去好好看一本的。不管是技术的书籍，还是人物传记的书籍，总能在从中学到一些东西，哪怕只有其中只有某一句话、一件事儿、一个技术难点、一个技巧也是非常开心的。现在看书主要是在Kindle上面，技术书籍就会买纸质版本的，非常棒的书籍纸质版与电子版都买，还是为了图方便。不管如何，只要找到自己喜欢的方式，做任何事情都是对的~</p><p>这一年，跟我老婆吵架非常的少，但记忆中好像也有这么1<del>2次是比较严重的，但都能很快过去。都说一个成功男人的背后一定有一个优秀的女人，我非常赞同。我觉得在思想上，我家那位比我要强，我是属于追赶她的情况。今年，一起去南京休闲游完了几天，特别喜欢这种慢悠悠，自由自在的旅行。一转眼，我们已经认识了10年，本想2人在很久以前就一直筹划着要过一个非常难忘的10周年，为此要做很多的准备，也是因为工作忙碌的原因，算是过了一个开心的10周年吧。这一年我从以前什么都不管慢慢开始的变为想去用心准备点什么，付出一点什么。为了明年去更多的没有去过的地方，特此还跟我老婆买了南航的随心飞，希望能去更多的地方看看这个美好的世界，去更多的地方打打卡。这几天还对摄影有点兴趣，日后可以好好学习学习</del></p><p>最近2年左右的时间，真的听说了太多太多亲人们身体不好做手术的，家里的老奶奶、舅姥姥等去世的消息。其实人到30~40岁之间，应该是蛮有经济压力的，自己的梦想还有很多未实现，爸爸妈妈的年纪也开始慢慢到了一个体质变弱、疾病变多的情况，所以今年我们为2边的家人都配置了意外险、百万医疗险，为自己也配置了这些，也终于在2020年的最后一天为我们俩配置了重疾险（本来想着买港险的，可这疫情一拖就是一年）。虽然这些保险远远还不够，但是也不用太着急，首先有了基本的保障，后面再慢慢的去添加就好了。起码，真的哪天有意外来临，也不会变得很被动。</p><p>今年一年跟我老婆也获得一些新朋友，特别是公共的朋友。在深圳这个城市，能够找到一些私下要好的朋友是很难的，因为大家的生活节奏都很快，大部分都不认识隔壁的邻居是谁，每天都是很早的去上班，很晚才回家来。如果有一些私下的朋友，节假日的时候可以一起凑个饭局，一起郊游，一起钓个鱼什么的都是一件很幸福的事情。所以，珍惜现在已有的好朋友，结交更多更优秀的人。</p><p>我知道立再多的flag也不如把一个flag做好来的重要，我希望自己在2021年里能更多知道自己的内心，知道自己追求的是什么？如何让自己的内心世界丰富起来，如果让自己做任何的事情都不会被别人牵着鼻子走，如何去影响、号召更多的其他人一起来做事。</p><p>2021年给自己的目的是：抓重点、求突破、顾家庭。</p><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年，感觉真的是一个不平凡的年。是时间流逝非常快的一年，也是成长最快的一年。感谢身边所有的人~&lt;/p&gt;
&lt;p&gt;还记得年初的时候，怕被疫情隔在家里了，正月初三就开车到了深圳。那时候听新闻说可能要带半年或者一年的口罩，当时感觉不可思议，根本不可能。现在一年已经已经过去了，
      
    
    </summary>
    
    
      <category term="总结" scheme="http://www.cyblogs.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020" scheme="http://www.cyblogs.com/tags/2020/"/>
    
      <category term="总结" scheme="http://www.cyblogs.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Controller里面方法不小心写成了private的问题</title>
    <link href="http://www.cyblogs.com/2020/12/04/2020/12/Controller%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%86%99%E6%88%90%E4%BA%86private%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://www.cyblogs.com/2020/12/04/2020/12/Controller%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%86%99%E6%88%90%E4%BA%86private%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-03T16:00:00.000Z</published>
    <updated>2020-12-04T01:23:10.885Z</updated>
    
    <content type="html"><![CDATA[<h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><p>今天本来是为了解决一个<code>Apollo</code>配置与<code>Code</code>同时变更不一致问题，我需要去通过<code>SPI</code>的方式去重写<code>Apollo</code>刷新<code>Remote</code>配置。所以，我就写一个很小的<code>DEMO</code>来验证每次变更<code>Apollo</code>配置对我服务端的取数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;market.test.chenyuan&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String testName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应在<code>Apollo</code>的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">market.test.name</span> = <span class="string">Test1111</span></span><br></pre></td></tr></table></figure><p><code>Controller</code>层的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MarketConfig marketConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/sayHello"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123; <span class="comment">// 注意，这里由于我的不小心写成了private</span></span><br><span class="line">    <span class="keyword">return</span> marketConfig.getMarketTestName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我就发起请求来验证我的取数，结果给我报了<code>NullpointException</code>的异常。因为这种代码几乎每天都在写，一下次说我的<code>Bean</code>没有注入进来，还有点方。</p><p>然后，我细心的<code>debug</code>了看了一下。如图所示：</p><p><img src="http://static.cyblogs.com/Jietu20201204-085800.jpg" alt="http://static.cyblogs.com/Jietu20201204-085800.jpg"></p><p>图片可以说明：</p><ul><li><p><code>Spring</code>容器100%已经存在了<code>MarketConfig</code>的<code>Bean</code>对象；</p></li><li><p>但是<code>MarketConfig</code>在该<code>Controller</code>里面100%没有注入进来 ；</p></li><li><p><code>this</code>显示出了一个代理的路径；</p><p>于是，我在同样的<code>Controller</code>去请求另外一个<code>Method</code>，但可以正常访问。</p></li></ul><p><img src="http://static.cyblogs.com/Jietu20201204-090305.jpg" alt="http://static.cyblogs.com/Jietu20201204-090305.jpg"></p><ul><li><code>Spring</code>容器100%已经存在了<code>MarketConfig</code>的<code>Bean</code>对象；</li><li>而且是可以确定这次<code>MarketConfig</code>是有注入进来的（没有展示图，不太方便）</li><li><code>this</code>直接是显示的自己的地址</li></ul><p>由于我就比较了一下方法的区别，最主要的区别点就是在于一个是<code>private</code>，另外一个是<code>public</code>。</p><p>其实，这里我就很快明白了。因为我们这边在<code>Controller</code>层做了一些AOP来做监控与埋点。现阶段主要用的是<code>CAT</code>（现在做了很多的一些封装，后面可以分享下，如何做到无浸入性以及与<code>Apollo</code>的打通）。</p><p><code>AOP</code> 里面用的是反射机制，用<code>private</code>修饰的类是注入失败的，因为拿不到，只能用<code>public</code>或者<code>protected</code>修饰。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/qq_31451081/article/details/84100575" target="_blank" rel="noopener">https://blog.csdn.net/qq_31451081/article/details/84100575</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h4&gt;&lt;p&gt;今天本来是为了解决一个&lt;code&gt;Apollo&lt;/code&gt;配置与&lt;code&gt;Code&lt;/code&gt;同时变更不一致问题，我需
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://www.cyblogs.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.cyblogs.com/tags/Spring/"/>
    
      <category term="AOP" scheme="http://www.cyblogs.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库隔离级别到底是RC还是RR？</title>
    <link href="http://www.cyblogs.com/2020/11/24/2020/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%B0%E5%BA%95%E6%98%AFRC%E8%BF%98%E6%98%AFRR%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/11/24/2020/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%B0%E5%BA%95%E6%98%AFRC%E8%BF%98%E6%98%AFRR%EF%BC%9F/</id>
    <published>2020-11-23T16:00:00.000Z</published>
    <updated>2020-11-24T11:04:49.662Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h4><p><code>MySQL</code> 的默认事务隔离级别为 <code>Repeatable Read</code>。而 <code>ORACLE</code>、<code>SQLServer</code> 等的默认隔离级别使用的是 <code>Read Committed</code> 模式，为什么呢？</p><p>开始我们的内容，相信大家一定遇到过下面的一个面试场景</p><blockquote><p>面试官：“讲讲 mysql 有几个事务隔离级别？”<br>你：“读未提交，读已提交，可重复读，串行化四个！默认是可重复读”<br>面试官：“为什么 mysql 选可重复读作为默认的隔离级别？”<br>(你面露苦色，不知如何回答！)<br>面试官:“你们项目中选了哪个隔离级别？为什么？”<br>你：“当然是默认的可重复读，至于原因…呃…”<br>(然后你就可以回去等通知了！)</p></blockquote><p>为了避免上述尴尬的场景，请继续往下阅读！<br><code>Mysql</code> 默认的事务隔离级别是可重复读 (<code>Repeatable Read</code>)，那互联网项目中 <code>Mysql</code> 也是用默认隔离级别，不做修改么？<br><code>OK</code>，不是的，我们在项目中一般用读已提交 (<code>Read Commited</code>) 这个隔离级别！<br><code>what</code>！居然是读已提交，网上不是说这个隔离级别存在不可重复读和幻读问题么？不用管么？好，带着我们的疑问开始本文！</p><p>我们先来思考一个问题，在 <code>Oracle</code>，<code>SqlServer</code> 中都是选择读已提交 (Read Commited) 作为默认的隔离级别，为什么 <code>Mysql</code> 不选择读已提交 (<code>Read Commited</code>) 作为默认隔离级别，而选择可重复读 (<code>Repeatable Read</code>) 作为默认的隔离级别呢？</p><h4 id="Why-Why-Why"><a href="#Why-Why-Why" class="headerlink" title="Why?Why?Why?"></a>Why?Why?Why?</h4><p>这个是有历史原因的，当然要从我们的主从复制开始讲起了！<br>主从复制，是基于什么复制的？<br>是基于 <code>binlog</code> 复制的！这里不想去搬 <code>binlog</code> 的概念了，就简单理解为 <code>binlog</code> 是一个记录数据库更改的文件吧～<br><code>binlog</code> 有几种格式？<br>OK，三种，分别是：</p><ul><li><code>statement</code>: 记录的是修改 <code>SQL</code> 语句</li><li>row：记录的是每行实际数据的变更</li><li><code>mixed</code>：statement 和 <code>row</code> 模式的混合</li></ul><p>那 <code>Mysql</code> 在 5.0 这个版本以前，<code>binlog</code> 只支持 <code>STATEMENT</code> 这种格式！而这种格式在读已提交 (<code>Read Commited</code>) 这个隔离级别下主从复制是有 <code>bug</code> 的，因此 <code>Mysql</code> 将可重复读 (<code>Repeatable Read</code>) 作为默认的隔离级别！<br>接下来，就要说说当 <code>binlog</code> 为 <code>STATEMENT</code> 格式，且隔离级别为读已提交 (<code>Read Commited</code>) 时，有什么 <code>bug</code> 呢？如下图所示，在主 (master) 上执行如下事务</p><p><img src="http://static.cyblogs.com/image_editor_38dbfa43-6a3f-4812-a26c-c9dc984d4ccc.jpg" alt="http://static.cyblogs.com/image_editor_38dbfa43-6a3f-4812-a26c-c9dc984d4ccc.jpg"></p><p>此时在主 (<code>master</code>) 上执行下列语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>；</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">±–+</span><br><span class="line">| b |</span><br><span class="line">±–+</span><br><span class="line">| 3 |</span><br><span class="line">±–+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>但是，你在此时在从 (<code>slave</code>) 上执行该语句，得出输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty set</span><br></pre></td></tr></table></figure><p>这样，你就出现了主从不一致性的问题！原因其实很简单，就是在 <code>master</code> 上执行的顺序为先删后插！而此时 <code>binlog</code> 为 STATEMENT 格式，它记录的顺序为先插后删！从 (<code>slave</code>) 同步的是 <code>binglog</code>，因此从机执行的顺序和主机不一致！就会出现主从不一致！</p><h4 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>解决方案有两种！</p><ul><li>隔离级别设为可重复读 (<code>Repeatable Read</code>), 在该隔离级别下引入间隙锁。当 <code>Session 1</code> 执行 <code>delete</code> 语句时，会锁住间隙。那么，<code>Ssession 2</code> 执行插入语句就会阻塞住！</li><li>将 binglog 的格式修改为 <code>row</code> 格式，此时是基于行的复制，自然就不会出现 sql 执行顺序不一样的问题！奈何这个格式在 <code>mysql5.1</code> 版本开始才引入。因此由于历史原因，<code>mysql</code> 将默认的隔离级别设为可重复读 (<code>Repeatable Read</code>)，保证主从复制不出问题！</li></ul><p>那么，当我们了解完 <code>mysql</code> 选可重复读 (<code>Repeatable Read</code>) 作为默认隔离级别的原因后，接下来我们将其和读已提交 (<code>Read Commited</code>) 进行对比，来说明为什么在互联网项目为什么将隔离级别设为读已提交(<code>Read Commited</code>)！</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>OK，我们先明白一点！项目中是不用读未提交 (<code>Read UnCommitted</code>) 和串行化 (Serializable) 两个隔离级别，原因有二</p><p>采用读未提交 (<code>Read UnCommitted</code>), 一个事务读到另一个事务未提交读数据，这个不用多说吧，从逻辑上都说不过去！<br>采用串行化 (<code>Serializable</code>)，每个次读操作都会加锁，快照读失效，一般是使用 <code>mysql</code> 自带分布式事务功能时才使用该隔离级别！(笔者从未用过 <code>mysql</code> 自带的这个功能，因为这是 <code>XA</code> 事务，是强一致性事务，性能不佳！互联网的分布式方案，多采用最终一致性的事务解决方案！)<br>也就是说，我们该纠结都只有一个问题，究竟隔离级别是用读已经提交呢还是可重复读？<br>接下来对这两种级别进行对比，讲讲我们为什么选读已提交 (<code>Read Commited</code>) 作为事务隔离级别！<br>假设表结构如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`color`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure><p>数据如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">±—±------+</span><br><span class="line">| id | color |</span><br><span class="line">±—±------+</span><br><span class="line">| 1 | red |</span><br><span class="line">| 2 | white |</span><br><span class="line">| 5 | red |</span><br><span class="line">| 7 | white |</span><br><span class="line">±—±------+</span><br></pre></td></tr></table></figure><p>为了便于描述，下面将</p><ul><li>可重复读 (<code>Repeatable Read</code>)，简称为 <code>RR</code>；</li><li>读已提交 (Read Commited)，简称为 <code>RC</code>；</li></ul><p><strong>缘由一</strong></p><p>在 <code>RR</code> 隔离级别下，存在间隙锁，导致出现死锁的几率比 <code>RC</code> 大的多！<br>此时执行语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>在 <code>RR</code> 隔离级别下，存在间隙锁，可以锁住 <code>(2,5)</code> 这个间隙，防止其他事务插入数据！而在 <code>RC</code> 隔离级别下，不存在间隙锁，其他事务是可以插入数据！</p><p>在 <code>RC</code> 隔离级别下并不是不会出现死锁，只是出现几率比 <code>RR</code> 低而已！</p><p><strong>缘由二</strong></p><p>在 <code>RR</code> 隔离级别下，条件列未命中索引会锁表！而在 <code>RC</code> 隔离级别下，只锁行<br>此时执行语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> color = <span class="string">'blue'</span> <span class="keyword">where</span> color = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure><p>在 <code>RC</code> 隔离级别下，其先走聚簇索引，进行全部扫描。加锁如下：</p><p><img src="http://static.cyblogs.com/image_editor_4485ac7d-e85b-4b76-962e-5d420e1ac0a4.png" alt="http://static.cyblogs.com/image_editor_4485ac7d-e85b-4b76-962e-5d420e1ac0a4.png"></p><p>但在实际中，<code>MySQL</code> 做了优化，在 <code>MySQL Server</code> 过滤条件，发现不满足后，会调用 <code>unlock_row</code> 方法，把不满足条件的记录放锁。<br>实际加锁如下</p><p><img src="http://static.cyblogs.com/image_editor_d329942e-3fd7-4a88-b6ae-b294989c34b5.png" alt="http://static.cyblogs.com/image_editor_d329942e-3fd7-4a88-b6ae-b294989c34b5.png"></p><p>然而，在 <code>RR</code> 隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上，如下所示</p><p><img src="http://static.cyblogs.com/image_editor_b504b652-9960-495a-a5ce-37826d0acdc7.jpg" alt="http://static.cyblogs.com/image_editor_b504b652-9960-495a-a5ce-37826d0acdc7.jpg"></p><p><strong>缘由三</strong></p><p>在 <code>RC</code> 隔离级别下，半一致性读 (<code>semi-consistent</code>) 特性增加了 <code>update</code> 操作的并发性！<br>在 <code>5.1.15</code> 的时候，<code>innodb</code> 引入了一个概念叫做 “<code>semi-consistent</code>”，减少了更新同一行记录时的冲突，减少锁等待。<br>所谓半一致性读就是，一个 <code>update</code> 语句，如果读到一行已经加锁的记录，此时 <code>InnoDB</code> 返回记录最近提交的版本，由 <code>MySQL</code> 上层判断此版本是否满足 <code>update</code> 的 <code>where</code> 条件。若满足 (需要更新)，则 <code>MySQL</code> 会重新发起一次读操作，此时会读取行的最新版本 (并加锁)！<br>具体表现如下:<br>此时有两个 <code>Session</code>：<code>Session1</code> 和 <code>Session2</code>！<br><code>Session1</code> 执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> color = <span class="string">'blue'</span> <span class="keyword">where</span> color = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure><p>先不 <code>Commit</code> 事务！<br>与此同时 <code>Ssession2</code> 执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> color = <span class="string">'blue'</span> <span class="keyword">where</span> color = <span class="string">'white'</span>;</span><br></pre></td></tr></table></figure><p><code>Session2</code> 尝试加锁的时候，发现行上已经存在锁，<code>InnoDB</code> 会开启 <code>semi-consistent read</code>，返回最新的 <code>committed</code> 版本 (1,red)，(2，white)，(5,red)，(7,white)。<code>MySQL</code> 会重新发起一次读操作，此时会读取行的最新版本 (并加锁)!<br>而在 <code>RR</code> 隔离级别下，<code>Session2</code> 只能等待！</p><h4 id="两个疑问"><a href="#两个疑问" class="headerlink" title="两个疑问"></a>两个疑问</h4><p>在 <code>RC</code> 级别下，不可重复读问题需要解决么？<br>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！<code>Oracle</code> 的默认隔离级别就是 <code>RC</code>，你们改过 Oracle 的默认隔离级别么？</p><p>在 <code>RC</code> 级别下，主从复制用什么 <code>binlog</code> 格式？<br>OK, 在该隔离级别下，用的 <code>binlog</code> 为 <code>row</code> 格式，是基于行的复制！<code>Innodb</code> 的创始人也是建议 <code>binlog</code> 使用该格式！</p><h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><ul><li>数据库默认隔离级别: <code>mysql —repeatable、oracle，sql server —read commited</code></li><li><code>mysql binlog</code> 的格式三种：<code>statement</code>、<code>row</code>、<code>mixed</code></li><li>为什么 <code>mysql</code> 用的是 <code>repeatable</code> 而不是 <code>read committed:</code> 在 <code>5.0</code> 之前只有 <code>statement</code> 一种格式，而主从复制存在了大量的不一致（<code>bug</code>），故选用 <code>repeatable</code>。</li><li>为什么其他数据库默认的隔离级别都会选用 <code>read commited</code> 原因有二：<code>repeatable</code> 存在间隙锁会使死锁的概率增大，在 <code>RR</code> 隔离级别下，条件列未命中索引会锁表！而在 <code>RC</code> 隔离级别下，只锁行</li><li>在 <code>RC</code> 级用别下，主从复制用什么 <code>binlog</code> 格式：<code>row</code> 格式，是基于行的复制！如果使用 <code>statement</code> 格式，会导致主从不一致。</li></ul><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.cnblogs.com/rjzheng/p/10510174.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/10510174.html</a></li><li><a href="https://www.cnblogs.com/digdeep/p/4968453.html" target="_blank" rel="noopener">https://www.cnblogs.com/digdeep/p/4968453.html</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前奏&quot;&gt;&lt;a href=&quot;#前奏&quot; class=&quot;headerlink&quot; title=&quot;前奏&quot;&gt;&lt;/a&gt;前奏&lt;/h4&gt;&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt; 的默认事务隔离级别为 &lt;code&gt;Repeatable Read&lt;/code&gt;。而 &lt;code&gt;ORA
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.cyblogs.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.cyblogs.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>2020/11/带你看Eureka源代码</title>
    <link href="http://www.cyblogs.com/2020/11/17/2020/11/%E5%B8%A6%E4%BD%A0%E7%9C%8BEureka%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.cyblogs.com/2020/11/17/2020/11/%E5%B8%A6%E4%BD%A0%E7%9C%8BEureka%E6%BA%90%E4%BB%A3%E7%A0%81/</id>
    <published>2020-11-16T16:00:00.000Z</published>
    <updated>2020-11-17T01:44:46.604Z</updated>
    
    <content type="html"><![CDATA[<p>首先，我们来看一下Eureka的架构图，有一个整体的认识。传送门：<a href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance" target="_blank" rel="noopener">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a></p><p><img src="http://static.cyblogs.com/eureka_architecture.png" alt="http://static.cyblogs.com/eureka_architecture.png"></p><h4 id="Eureka核心功能"><a href="#Eureka核心功能" class="headerlink" title="Eureka核心功能"></a>Eureka核心功能</h4><p><strong>服务注册</strong></p><p>在微服务启动时，首先，服务提供者需要将自己的服务注册到服务注册中心，服务提供者在启动的时候会发送<code>REST</code>请求将自己注册到服务注册中心上，并带上一些元信息。服务注册中心接收到<code>REST</code>请求，会将元信息存储在一个双层<code>Map</code>中，第一层<code>key</code>是服务名，第二层<code>key</code>是具体服务的实例名。</p><p>注意：在服务注册时，需要确认一下<code>eureka.client.register-with-eureka=true</code>是否正确，如果为false是禁止向服务注册中心注册的。</p><p><strong>服务同步</strong></p><p>当服务成功的注册到了注册中心之后，由于注册中心可能是高可用的集群，那么我们的服务可能只注册到了一个集群中的一个注册中心上，被一个注册中心所维护，而不被另外一个注册中心所维护，那么这个时候，我们就需要将这个注册中心的信息同步给集群中其他的注册中心，这就叫服务同步。那么他是如何实现的呢？</p><p>由于在集群中，一个注册中心互为其他注册中心的服务，当服务提供者请求到一个服务注册中心后，它会将请求转发到其他服务注册中心，实现注册中心之间的服务同步。</p><p>通过服务同步，服务提供者的服务信息可以通过集群中的任何一个服务注册中心获取。</p><p><strong>服务续约</strong></p><p>在注册完成后。服务提供者会维护一个心跳告诉注册中心服务，心跳间隔大约是<code>30S</code>，防止注册中心剔除服务， 正常情况下，如果<code>Eureka Server</code>在<code>90秒</code>没有收到<code>Eureka</code>客户的续约，它会将实例从其注册表中删除。这个过程称为服务续约。</p><p><strong>服务获取</strong></p><p>当一切的注册相关工作完成后，我们自然要获取服务清单，那么如何获取服务呢？ 启动服务消费者后，消费者会发送一个<code>REST</code>请求给服务注册中心，来获取上面注册的服务清单。 而服务注册中心会维护一份只读清单返回给消费者客户端，该缓存清单<code>30s</code>更新一次。</p><p><strong>服务调用</strong></p><p>消费者获取服务清单后，可以通过服务名获取到具体服务实例与实例的元数据信息。这个时候，我们可以通过<code>Ribbon</code>调用我们的目标服务，默认采用轮询的方式，从而实现负载均衡。</p><p><strong>服务下线</strong></p><p>当我们需要对服务实例进行正常的关闭操作时，它会触发一个服务下线的<code>REST</code>请求给服务端。注册中心接收到请求后，将该服务状态置为<code>DOWN</code>，并把下线时间传播出去。</p><p><strong>失效剔除</strong></p><p>有的时候，我们的服务意外挂掉了，那么<code>Eureka</code>如何识别出我们异常的服务，并将其剔除呢？</p><p>服务注册中心启动时会创建定时任务，默认<code>60s</code>一次，将当前清单中超时（<code>90s</code>）没有续约的服务剔除。</p><p><strong>自我保护</strong></p><p>当失效剔除机制引入的时候，就会有一个问题，如果一个地区网络特别不稳定，那么服务可能不会续约，但我们还需要这个服务存在。这个时候，我们怎么解决呢？</p><p>还好，<code>Eureka</code>拥有自我保护机制，可以很好的解决这个问题。<code>Eureka Server</code>在运行期间，会统计心跳失败的比例在<code>15分钟</code>之内是否低于<code>85%</code>，如果低于，就会将当前实例注册信息保护起来，同时提示一个警告，一旦进入保护模式，<code>Eureka Server</code>将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据。也就是不会注销任何微服务。 但是保护机制也有可能会出现问题，导致服务实例不能够被正确剔除。比如在保护期间，实例出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败。 </p><h4 id="源码细节与验证"><a href="#源码细节与验证" class="headerlink" title="源码细节与验证"></a>源码细节与验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  renewsLastMin.start();</span><br><span class="line">  <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    evictionTaskRef.get().cancel();</span><br><span class="line">  &#125;</span><br><span class="line">  evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</span><br><span class="line">  <span class="comment">// 服务剔除，private long evictionIntervalTimerInMs = 60 * 1000;</span></span><br><span class="line">  evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">                         serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">                         serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance" target="_blank" rel="noopener">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a></li><li><a href="https://zhuanlan.zhihu.com/p/98572822" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98572822</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，我们来看一下Eureka的架构图，有一个整体的认识。传送门：&lt;a href=&quot;https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https
      
    
    </summary>
    
    
      <category term="Eureka" scheme="http://www.cyblogs.com/categories/Eureka/"/>
    
    
      <category term="源码" scheme="http://www.cyblogs.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Eureka" scheme="http://www.cyblogs.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>你是如何玩Git分支模型的呢？</title>
    <link href="http://www.cyblogs.com/2020/11/12/2020/11/%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%8E%A9Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%91%A2%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/11/12/2020/11/%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%8E%A9Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%91%A2%EF%BC%9F/</id>
    <published>2020-11-11T16:00:00.000Z</published>
    <updated>2020-11-12T11:35:11.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>总览(一张流程图给大家先镇镇惊)</p><p><img src="http://static.cyblogs.com/git%E5%88%86%E6%94%AF%E6%80%BB%E5%9B%BE%E6%A6%82%E8%A7%88.jpg" alt="http://static.cyblogs.com/git分支总图概览.jpg"></p><p>它主要体现了<code>Git</code>对我们源代码版本的管理。</p><p>（转载者加）一般情况：</p><ul><li><code>master</code>和<code>develop</code>并行。 </li><li><code>master</code>上始终是最稳定的代码，<code>develop</code>是正在开发的代码。 </li><li><code>feature</code>则是某个开发为了自己的功能拉的分支。<br>不一般情况： </li><li><code>develop</code>正在开发，如果你上线突然被拒绝了，这时候就要从master上开一个热分支，或者<code>release</code>分支也行，改好之后在分别合并到其他分支。但，本人感觉release通常意味着终止。别在从<code>release</code>上拉分支了。</li></ul><h4 id="为何是Git？"><a href="#为何是Git？" class="headerlink" title="为何是Git？"></a>为何是Git？</h4><p>​        对于<code>Git</code>与其他集中式代码管理工具相比的优缺点的全面讨论，请参见这里。这样的争论总是喋喋不休。作为一个开发者，与现今的其他开发工具相比较，我更喜欢<code>Git</code>。<code>Git</code>真得改变了开发者对于合并和分支的思考。我曾经使用经典的<code>CVS/Subversion</code>，然而每次的合并/分支和其他行为总让人担惊受怕（“小心合并里的冲突，简直要命！”）。<br>但是对于<code>Git</code>来说，这些行为非常简单和搞笑，它们被认为是日常工作中的核心部分。例如，在很多<code>CVS/Subversion</code>书里，分支与合并总是在后面的章节中被讨论（对于高级用户使用），然而在每个<code>Git</code>书中，在第3章就已经完全涵盖了（作为基础）。<br>简单和重复的特性带来的结果是：分支与合并不再是什么可以害怕的东西。分支/合并被认为对于版本管理工具比其他功能更重要。<br>关于工具，不再多说，让我们直接看开发模型吧。这个模型并不是如下模型：在管理软件开发进度方面，面对每个开发过程，每个队员必须按一定次序开发。</p><h4 id="分布式而非集中式"><a href="#分布式而非集中式" class="headerlink" title="分布式而非集中式"></a>分布式而非集中式</h4><p>​        对于这种分支模型，我们设置了一个版本库，它运转良好，这是一个”事实上” 版本库。不过请注意，这个版本库只是被认为是中心版本库（因为<code>Git</code>是一个分布式版本管理系统，从技术上来讲，并没有一个中心版本库）。我们将把这个版本库称为原始库，这个名字对所有的Git用户来说都很容易理解。</p><p><img src="http://static.cyblogs.com/git%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E4%B8%AD%E5%BC%8F.jpg" alt="http://static.cyblogs.com/git分布式集中式.jpg"></p><p>每个开发者都对<code>origin</code>库拉代码和提交代码。但是除了集中式的存取代码关系，每个开发者也可以从子团队的其他队友那里获得代码版本变更。例如，对于2个或多个开发者一起完成的大版本变更，为了防止过早地向<code>origin</code>库提交工作内容，这种机制就变得非常有用。在上述途中，有如下子团队：<code>Alice</code>和Bob，<code>Alice</code>和<code>David</code>，<code>Clair</code>和<code>David</code>。<br>从技术上将，这意味着，<code>Alice</code>创建了一个<code>Git</code>的远程节点，而对于<code>Bob</code>，该节点指向了<code>Bob</code>的版本库，反之亦然。</p><h4 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h4><p><img src="http://static.cyblogs.com/develop%E4%B8%8Emaster%E5%88%86%E6%94%AF%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="http://static.cyblogs.com/develop与master分支的关系.jpg"></p><p>在核心部分，研发模型很大程度上靠其他现有模型支撑的。中心库有2个可一直延续的分支： </p><ul><li>master分支 </li><li>develop分支 </li></ul><p>每个<code>Git</code>用户都要熟悉原始的<code>master</code>分支。与master分支并行的另一个分支，我们称之为<code>develop</code>分支。<br>我们把原始库/<code>master</code>库认作为主分支，HEAD的源代码存在于此版本中，并且随时都是一个预备生产状态。 </p><p>我们把<code>origin/develop</code>库认为是主分支，该分支<code>HEAD</code>源码始终体现下个发布版的最新软件变更。有人称这个为“集成分支”，而这是每晚自动构建得来的。<br>当<code>develop</code>分支的源码到达了一个稳定状态待发布，所有的代码变更需要以某种方式合并到master分支，然后标记一个版本号。如何操作将在稍后详细介绍。<br>所以，每次变更都合并到了<code>master</code>，这就是新产品的定义。在这一点，我们倾向于严格执行这一点，从而，理论上，每当对<code>master</code>有一个提交操作，我们就可以使用<code>Git</code>钩子脚本来自动构建并且发布软件到生产服务器。</p><h4 id="辅助性分支"><a href="#辅助性分支" class="headerlink" title="辅助性分支"></a>辅助性分支</h4><p>我们的开发模型使用了各种辅助性分支，这些分支与关键分支（master和develop）一起，用来支持团队成员们并行开发，使得易于追踪功能，协助生产发布环境准备，以及快速修复实时在线问题。与关键分支不同，这些分支总是有一个有限的生命期，因为他们最终会被移除。<br>我们用到的分支类型包括： </p><ul><li>功能分支 </li><li>发布分支 </li><li>热修复分支 </li></ul><p>每一种分支有一个特定目的，并且受限于严格到规则，比如：可以用哪些分支作为源分支，哪些分支能作为合并目标。我们马上将进行演练。<br>从技术角度来看，这些分支绝不是特殊分支。分支的类型基于我们使用的方法来进行分类。它们理所当然是普通的Git分支。</p><h4 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h4><p><img src="http://static.cyblogs.com/20181126103335995_580-0.jpg" alt="http://static.cyblogs.com/20181126103335995_580-0.jpg"></p><p>可能是<code>develop</code>分支的分支版本，最终必须合并到<code>develop</code>分支中。<br>分支命名规则：除了<code>master</code>、<code>develop</code>、<code>release-</code>、<code>hotfix-</code>之外，其他命名均可。<br>功能分支（有时被称为<code>topic</code>分支）通常为即将发布或者未来发布版开发新的功能。当新功能开始研发，包含该功能的发布版本在这个还是无法确定发布时间的。功能版本的实质是只要这个功能处于开发状态它就会存在，但是最终会或合并到<code>develop</code>分支（确定将新功能添加到不久的发布版中）或取消（譬如一次令人失望的测试）。<br>功能分支通常存在于开发者的软件库，而不是在源代码库中。<br><strong>创建一个功能分支</strong><br>开始一项功能的开发工作时，基于<code>develop</code>创建分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b myfeature develop</span></span><br><span class="line">Switched to a new branch "myfeature"</span><br></pre></td></tr></table></figure><p><strong>合并一个功能到develop分支</strong><br>完成的功能可以合并进develop分支，以明确加入到未来的发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line">Switched to branch 'develop'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff myfeature</span></span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d myfeature</span></span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br></pre></td></tr></table></figure><p><code>--no-ff</code>标志导致合并操作创建一个新<code>commit</code>对象，即使该合并操作可以<code>fast-forward</code>。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。 比较:</p><p><img src="http://static.cyblogs.com/t_70_580-0.jpg" alt="http://static.cyblogs.com/t_70_580-0.jpg"></p><p>后一种情况，不可能从<code>Git</code>历史中看到哪些提交一起实现了一个功能——你必须手工阅读全部的日志信息。如果对整个功能进行回退 (比如一组提交)，后一种方式会是一种真正头痛的问题，而使用<code>--no-ff flag</code>的情况则很容易.<br>是的，它会创建一个新的（空）提交对象，但是收益远大于开销。<br>不幸的是，我还没找到一种方法，让–no-ff时作为合并操作的默认选项，但它应该是可行的。</p><h4 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a>Release 分支</h4><p><code>Release</code>分支可能从<code>develop</code>分支分离而来，但是一定要合并到<code>develop</code>和master分支上，它的习惯命名方式为：<code>release-*</code>。<br><code>Release</code>分支是为新产品的发布做准备的。它允许我们在最后时刻做一些细小的修改。他们允许小bugs的修改和准备发布元数据（版本号，开发时间等等）。当在<code>Release</code>分支完成这些所有工作以后，对于下一次打的发布，develop分支接收<code>features</code>会更加明确。<br>从<code>develop</code>分支创建新的<code>Release</code>分支的关键时刻是<code>develop</code>分支达到了发布的理想状态。至少所有这次要发布的<code>features</code>必须在这个点及时合并到develop分支。对于所有未来准备发布的<code>features</code>必须等到Release分支创建以后再合并。<br>在<code>Release</code>分支创建的时候要为即将发行版本分配一个版本号，一点都不早。直到那时，<code>develop</code>分支反映的变化都是为了下一个发行版，但是在<code>Release</code>分支创建之前，下一个发行版到底叫<code>0.3</code>还是<code>1.0</code>是不明确的。这个决定是在<code>Release</code>分支创建时根据项目在版本号上的规则制定的。</p><p><strong>创建一个release分支</strong><br><code>Release</code>分支是从<code>develop</code>分支创建的。例如，当前产品的发行版本号为<code>1.1.5</code>，同事我们有一个大的版本即将发行。<code>develop</code> 分支已经为下次发行做好了准备，我们得决定下一个版本是<code>1.2</code>（而不是<code>1.1.6</code>或者<code>2.0</code>）。所以我们将<code>Release</code>分支分离出来，给一个能够反映新版本号的分支名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b release-1.2 develop</span></span><br><span class="line">Switched to a new branch "release-1.2"</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bump-version.sh 1.2</span></span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">"Bumped version number to 1.2"</span></span></span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>创建新分支以后，切换到该分支，添加版本号。这里，<code>bump-version.sh</code> 是一个虚构的<code>shell</code>脚本，它可以复制一些文件来反映新的版本（这当然可以手动改变–目的就是修改一些文件）。然后版本号被提交。<br>这个新分支可能会存在一段时间，直到该发行版到达它的预定目标。在此期间，bug的修复可能被提交到该分支上（而不是提交到<code>develop</code>分支上）。在这里严格禁止增加大的新<code>features</code>。他们必须合并到<code>develop</code>分支上，然后等待下一次大的发行版。</p><p><strong>完成一个release分支</strong><br>当一个<code>release</code>分支准备好成为一个真正的发行版的时候，有一些工作必须完成。首先，release分支要合并到<code>master</code>上（因为每一次提交到<code>master</code>上的都是一个新定义的发行版，记住）。然后，提交到<code>master</code>上必须打一个标签，以便以后更加方便的引用这个历史版本。最后，在<code>release</code>分支上的修改必须合并到develop分支上，以便未来发行版也包含这些<code>bugs</code>的修复。<br>在<code>Git</code>中的前两步是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release-1.2</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a 1.2</span></span><br></pre></td></tr></table></figure><p>发行版现在已经完成，为以后引用打上标签。<br><strong>编辑：</strong>你可能也想使用<code>the-sor-u &lt;key&gt;flags</code>来标记你的标签。<br>为了是修改保持在<code>release</code>分支上，我们需要合并这些到<code>develop</code>分支上去，在<code>Git</code>上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line">Switched to branch 'develop'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release-1.2</span></span><br><span class="line">Merge made by recursive.</span><br></pre></td></tr></table></figure><p>(Summary of changes)<br>这个步骤可能会导致合并冲突（可能由于改变版本号更是如此）。如果是这样，修复它然后提交。<br>现在我们真正的完成了，这个<code>release</code>分支将被删除，因为我们不再需要它了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d release-1.2</span></span><br><span class="line">Deleted branch release-1.2 (was ff452fe).</span><br></pre></td></tr></table></figure><h4 id="热修复分支"><a href="#热修复分支" class="headerlink" title="热修复分支"></a>热修复分支</h4><p><img src="http://static.cyblogs.com/t_70_580-1.jpg" alt="http://static.cyblogs.com/t_70_580-1.jpg"></p><p>可以基于<code>master</code>分支，必须合并回<code>develop</code>和<code>master</code>分支。<br>分支名约定：<code>hotfix-*</code><br>热修复分支与发布分支很相似，他们都为新的生成环境发布做准备，尽管这是未经计划的。他们来自生产环境的处于异常状态压力。当生成环境验证缺陷必须马上修复是，热修复分支可以基于<code>master</code>分支上对应与线上版本的<code>tag</code>创建。<br>其本质是团队成员（在<code>develop</code>分支上）的工作可以继续，而另一个人准备生产环境的快速修复。<br><strong>创建修补bug分支</strong><br><code>hotfix branch</code>(修补bug分支)是从<code>Master</code>分支上面分出来的。例如，1.2版本是当前生产环境的版本并且有<code>bug</code>。但是开发分支（<code>develop</code>）变化还不稳定。我们需要分出来一个修补<code>bug</code>分支（<code>hotfix branch</code>）来解决这种情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b hotfix-1.2.1 master</span></span><br><span class="line">Switched to a new branch "hotfix-1.2.1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bump-version.sh 1.2.1</span></span><br><span class="line">Files modified successfully, version bumped to 1.2.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">"Bumped version number to 1.2.1"</span></span></span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>分支关闭的时侯不要忘了更新版本号(<code>bump the version</code>)<br>然后，修复<code>bug</code>，一次提交或者多次分开提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"Fixed severe production problem"</span></span></span><br><span class="line">[hotfix-1.2.1 abbe5d6] Fixed severe production problem</span><br><span class="line">5 files changed, 32 insertions(+), 17 deletions(-)</span><br></pre></td></tr></table></figure><p><strong>完成一个hotfix分支</strong><br>完成一个<code>bugfix</code>之后，需要把<code>butfix</code>合并到<code>master</code>和develop分支去，这样就可以保证修复的这个<code>bug</code>也包含到下一个发行版中。这一点和完成<code>release</code>分支很相似。<br>首先，更新<code>master</code>并对<code>release</code>打上<code>tag</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a 1.2.1</span></span><br></pre></td></tr></table></figure><p>编辑：你可能也会想使用 <code>-sor-u &lt;key&gt;</code>参数来对你的tag进行加密<br>下一步，把<code>bugfix</code>添加到<code>develop</code>分支中： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop </span></span><br><span class="line">Switched to branch 'develop' </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix-1.2.1 </span></span><br><span class="line">Merge made by recursive.</span><br></pre></td></tr></table></figure><p>(Summary of changes)<br>规则的一个例外是： <strong>如果一个<code>release</code>分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支</strong>。当<code>release</code>分支完成后， 将<code>bugfix</code>分支合并回<code>release</code>分支也会使得<code>bugfix</code>被合并到<code>develop</code>分支。（如果在<code>develop</code>分支的工作急需这个<code>bugfix</code>，等不到<code>release</code>分支的完成，那你也可以把<code>bugfix</code>合并到develop分支）<br>最后，删除临时分支：</p><p>(Summary of changes)<br>规则的一个例外是： <strong>如果一个release分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支</strong>。当release分支完成后， 将bugfix分支合并回release分支也会使得bugfix被合并到develop分支。（如果在develop分支的工作急需这个bugfix，等不到release分支的完成，那你也可以把bugfix合并到develop分支）<br>最后，删除临时分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix-1.2.1</span></span><br><span class="line">Deleted branch hotfix-1.2.1 (was abbe5d6).</span><br></pre></td></tr></table></figure><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>尽管这个分支模型没有任何震撼的新东西, 文章开头的图表在我们的项目中表现出惊人的实用性。它形成了一个优雅的思维模型，易于领悟并使团队成员发展出对分支和发布过程的共同理解。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/hj7jay/article/details/84527062" target="_blank" rel="noopener">https://blog.csdn.net/hj7jay/article/details/84527062</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h4&gt;&lt;p&gt;总览(一张流程图给大家先镇镇惊)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cyblogs.com/gi
      
    
    </summary>
    
    
      <category term="Git" scheme="http://www.cyblogs.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.cyblogs.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>RedisTemplate和StringRedisTemplate的区别</title>
    <link href="http://www.cyblogs.com/2020/11/10/2020/11/RedisTemplate%E5%92%8CStringRedisTemplate%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.cyblogs.com/2020/11/10/2020/11/RedisTemplate%E5%92%8CStringRedisTemplate%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2020-11-10T01:51:04.917Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h4><p>简单的说，<code>RedisTemplate</code>和<code>StringRedisTemplate</code>的关系如下：</p><blockquote><p>1.<code>StringRedisTemplate</code>是<code>RedisTemplate</code>的子类。</p><p>2.<code>StringRedisTemplate</code>的各个序列化策略都是<code>StringRedisSerializer</code>，而<code>RedisTemplate</code>用的是<code>JdkSerializationRedisSerializer</code>。</p></blockquote><h4 id="二-RedisTemplate和StringRedisTemplate的代码结构"><a href="#二-RedisTemplate和StringRedisTemplate的代码结构" class="headerlink" title="二.RedisTemplate和StringRedisTemplate的代码结构"></a>二.RedisTemplate和StringRedisTemplate的代码结构</h4><p>从<code>RedisTemplate</code>类说起。</p><p>在<code>RedisTemplate</code>类中，定义了这样四个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>分别代表了普通<code>key</code>，<code>value</code>，和<code>Hash</code>类型的<code>key</code>，value的序列化策略，可以分别设置。</p><p>另外定义变量，用来指定默认的序列化策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer&lt;?&gt; defaultSerializer;</span><br></pre></td></tr></table></figure><p>在<code>RedisTemplate</code>类中，定义了<code>afterPropertiesSet()</code>方法，当<code>Spring</code>创建<code>RedisTemplate</code>类的对象时，会调用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    <span class="keyword">boolean</span> defaultUsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(<span class="keyword">this</span>.classLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.enableDefaultSerializer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.keySerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.valueSerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hashKeySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hashKeySerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hashValueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hashValueSerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.enableDefaultSerializer &amp;&amp; defaultUsed) &#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.defaultSerializer, <span class="string">"default serializer null and not all serializers initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.scriptExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scriptExecutor = <span class="keyword">new</span> DefaultScriptExecutor(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在默认情况下，<code>RedisTemplate</code>使用的默认序列化策略是<code>JdkSerializationRedisSerializer</code>。包括<code>RedisTemplate</code>下的<code>key</code>，<code>value</code>，<code>hash-key</code>，hash-value的序列化，都用这种策略。</p><p>再来看看<code>StringRedisTemplate</code>，他作为RedisTemplate的子类，只是修改了序列化策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="keyword">this</span>.setKeySerializer(stringSerializer);</span><br><span class="line">        <span class="keyword">this</span>.setValueSerializer(stringSerializer);</span><br><span class="line">        <span class="keyword">this</span>.setHashKeySerializer(stringSerializer);</span><br><span class="line">        <span class="keyword">this</span>.setHashValueSerializer(stringSerializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">this</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RedisConnection <span class="title">preProcessConnection</span><span class="params">(RedisConnection connection, <span class="keyword">boolean</span> existingConnection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultStringRedisConnection(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>StringRedisTemplate</code>整个类的内容，可以看到，在他的默认构造中，<code>key</code>，<code>value</code>，<code>hash-key</code>，<code>hash-value</code>都使用的是StringRedisSerializer类作为序列化策略。这也就是<code>StringRedisTemplate</code>和他的父类RedisTemplate的主要区别。</p><h4 id="三-序列化策略"><a href="#三-序列化策略" class="headerlink" title="三.序列化策略"></a>三.序列化策略</h4><p>更进一步，看一下这个序列化策略是什么。</p><p>上面提到的<code>StringRedisSerializer</code>和<code>JdkSerializationRedisSerializer</code>都是序列化策略类，他们都实现了一个<code>RedisSerializer&lt;T&gt;</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisSerializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> T var1) <span class="keyword">throws</span> SerializationException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] var1)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口表达的意思很简单，两个方法，serialize用于序列化，把对象变为<code>byte</code>数组，<code>deserialize</code>用于反序列化，把byte数组转为对象。</p><h5 id="StringRedisSerializer"><a href="#StringRedisSerializer" class="headerlink" title="StringRedisSerializer"></a>StringRedisSerializer</h5><p>看看<code>StringRedisSerializer</code>是怎么做的：</p><p><strong>1.StringRedisSerializer的构造：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(charset, <span class="string">"Charset must not be null!"</span>);</span><br><span class="line">    <span class="keyword">this</span>.charset = charset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了编码格式，默认<code>UTF_8</code>。</p><p><strong>2.StringRedisSerializer的serialize和deserialize方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bytes == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> String(bytes, <span class="keyword">this</span>.charset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> String string) &#123;</span><br><span class="line">    <span class="keyword">return</span> string == <span class="keyword">null</span> ? <span class="keyword">null</span> : string.getBytes(<span class="keyword">this</span>.charset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>StringRedisSerializer</code>采用的是字符串和对应编码下二进制数组之间的转换。</p><p>在这种编码格式下，如果我们向redis保存信息，然后用客户端访问<code>Redis</code>时，只要编码格式一致，就能看到保存信息的原文。保存字符串<code>ABC</code>，客户端看到的也是字符串<code>ABC</code>。</p><h5 id="JdkSerializationRedisSerializer"><a href="#JdkSerializationRedisSerializer" class="headerlink" title="JdkSerializationRedisSerializer"></a>JdkSerializationRedisSerializer</h5><p>然后对比看看<code>JdkSerializationRedisSerializer</code>是怎么做的。</p><p><strong>1.JdkSerializationRedisSerializer的构造：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;Object, <span class="keyword">byte</span>[]&gt; serializer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;<span class="keyword">byte</span>[], Object&gt; deserializer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkSerializationRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> SerializingConverter(), <span class="keyword">new</span> DeserializingConverter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkSerializationRedisSerializer</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> SerializingConverter(), <span class="keyword">new</span> DeserializingConverter(classLoader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>JdkSerializationRedisSerializer</code>定义了两个变量，serializer和<code>deserializer</code>，显然是用来序列化和反序列化的，他们两个的类型是一样的，都是Converter接口，只是泛型不同。</p><p>Converter接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就一个方法。</p><p>另外在<code>JdkSerializationRedisSerializer</code>的构造中，对serializer和<code>deserializer</code>进行了初始化，使用<code>SerializingConverter</code>和DeserializingConverter作为实现类。</p><p><strong>2.JdkSerializationRedisSerializer的serialize和deserialize方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SerializationUtils.isEmpty(bytes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.deserializer.convert(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Cannot deserialize"</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> Object object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializationUtils.EMPTY_ARRAY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">byte</span>[])<span class="keyword">this</span>.serializer.convert(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Cannot serialize"</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是调用了对应<code>Converter</code>的<code>convert</code>方法。</p><p><strong>3.关于Converter</strong></p><p>既然到这了，就再深入一步，看看<code>SerializingConverter</code>和DeserializingConverter的<code>convert</code>方法。</p><p><strong>首先，序列化：</strong></p><p><code>SerializingConverter</code>的相关方法，贴一部分关键的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerializingConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = <span class="keyword">new</span> DefaultSerializer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] convert(Object source) &#123;</span><br><span class="line">        ByteArrayOutputStream byteStream = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span>  &#123;</span><br><span class="line">                <span class="keyword">this</span>.serializer.serialize(source, byteStream);</span><br><span class="line">                <span class="keyword">return</span> byteStream.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SerializationFailedException(<span class="string">"Failed to serialize object using "</span> +</span><br><span class="line">                                <span class="keyword">this</span>.serializer.getClass().getSimpleName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>SerializingConverter</code>类定义了<code>serializer</code>变量，用<strong>DefaultSerializer</strong>类实现，序列化的方式是调用<code>DefaultSerializer</code>的<code>serialize</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object object, OutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Serializable)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(getClass().getSimpleName() + <span class="string">" requires a Serializable payload "</span> +</span><br><span class="line">                                <span class="string">"but received an object of type ["</span> + object.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">        objectOutputStream.writeObject(object);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultSerializer</code>的<code>serialize</code>方法使用了<code>ObjectOutputStream</code>，调用writeObject方法序列化对象。</p><p><strong>对应的，反序列化：</strong></p><p><code>DeserializingConverter</code>的convert方法，贴一下相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DeserializingConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deserializer = <span class="keyword">new</span> DefaultDeserializer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(<span class="keyword">byte</span>[] source)</span> </span>&#123;</span><br><span class="line">        ByteArrayInputStream byteStream = <span class="keyword">new</span> ByteArrayInputStream(source);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.deserializer.deserialize(byteStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SerializationFailedException(<span class="string">"Failed to deserialize payload. "</span> +</span><br><span class="line">                                <span class="string">"Is the byte array a result of corresponding serialization for "</span> +</span><br><span class="line">                                <span class="keyword">this</span>.deserializer.getClass().getSimpleName() + <span class="string">"?"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见<code>DeserializingConverter</code>使用了<strong>DefaultDeserializer</strong>作为反序列化工具，调用了他的deserialize方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ConfigurableObjectInputStream(inputStream, <span class="keyword">this</span>.classLoader);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to deserialize object type"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>SerializingConverter</code>，<code>DeserializingConverter</code>使用的是<code>ConfigurableObjectInputStream</code>，并调用他的<code>readObject</code>方法进行反序列化。</p><p>这种序列化方式，如果保存信息至<code>redis</code>，用客户端查看时，保存的信息看起来像是在原来的字符前面加了几个字符。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JdkSerializationRedisSerializer jdkSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer();</span><br><span class="line">StringRedisSerializer stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"><span class="keyword">byte</span>[] jdkByteArr = jdkSerializer.serialize(<span class="string">"CSDN博客"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] stringByteArr = stringSerializer.serialize(<span class="string">"CSDN博客"</span>);</span><br></pre></td></tr></table></figure><p>这种情况下，得到的<code>byte</code>数组是：</p><p><code>jdkByteArr</code>：</p><blockquote><p>{-84,-19,0,5,116,0,10,67,83,68,78,-27,-115,-102,-27,-82,-94}</p></blockquote><p>stringByteArr：</p><blockquote><p>{67,83,68,78,-27,-115,-102,-27,-82,-94}</p></blockquote><p><code>StringRedisSerializer</code>把字符串本身转化成<code>byte</code>数组，而<code>JdkSerializationRedisSerializer</code>在数组前面加了几个字符，这些字符也会被保存到redis中。</p><p>所以，从数据上来说，这两种序列化策略处理的数据是不会共通的，各人管各人的。</p><h4 id="四-关于redisTemplate的Operations"><a href="#四-关于redisTemplate的Operations" class="headerlink" title="四.关于redisTemplate的Operations"></a>四.关于redisTemplate的Operations</h4><p>使用<code>redisTemplate</code>时，除了调用<code>execute</code>方法并自定义RedisCallback之外，还可以使用<code>redisTemplate</code>提供的几个Operations接口。</p><p><code>redisTemplate</code>中定义了以下几个<code>Operations</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ValueOperations&lt;K, V&gt; valueOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ListOperations&lt;K, V&gt; listOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> SetOperations&lt;K, V&gt; setOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ZSetOperations&lt;K, V&gt; zSetOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> GeoOperations&lt;K, V&gt; geoOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HyperLogLogOperations&lt;K, V&gt; hllOps;</span><br></pre></td></tr></table></figure><p>这几个<code>Operations</code>接口，分别提供了对不同种类数据的操作方法。</p><p>以<code>ValueOperations</code>为例，他提供的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K var1, V var2, <span class="keyword">long</span> var3, TimeUnit var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">setIfAbsent</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiSet</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">multiSetIfAbsent</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">V <span class="title">getAndSet</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">List&lt;V&gt; <span class="title">multiGet</span><span class="params">(Collection&lt;K&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Long <span class="title">increment</span><span class="params">(K var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Double <span class="title">increment</span><span class="params">(K var1, <span class="keyword">double</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Integer <span class="title">append</span><span class="params">(K var1, String var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">get</span><span class="params">(K var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K var1, V var2, <span class="keyword">long</span> var3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Long <span class="title">size</span><span class="params">(K var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">setBit</span><span class="params">(K var1, <span class="keyword">long</span> var2, <span class="keyword">boolean</span> var4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">getBit</span><span class="params">(K var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure><p>其他的<code>Operations</code>提供的方法各有不同，但是这些<code>Operations</code>的使用方式都是相同的。</p><p>不同的Operations分别通过<code>RedisTemplate</code>的以下方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ValueOperations&lt;K, V&gt; <span class="title">opsForValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.valueOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.valueOps = <span class="keyword">new</span> DefaultValueOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListOperations&lt;K, V&gt; <span class="title">opsForList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.listOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listOps = <span class="keyword">new</span> DefaultListOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SetOperations&lt;K, V&gt; <span class="title">opsForSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.setOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setOps = <span class="keyword">new</span> DefaultSetOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.setOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ZSetOperations&lt;K, V&gt; <span class="title">opsForZSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.zSetOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.zSetOps = <span class="keyword">new</span> DefaultZSetOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.zSetOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> GeoOperations&lt;K, V&gt; <span class="title">opsForGeo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.geoOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.geoOps = <span class="keyword">new</span> DefaultGeoOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.geoOps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在这些获得<code>Operations</code>的方法中，都提供了一个默认实现类，并且把<code>RedisTemplate</code>对象本身当做参数传给了这个实现类。</p><p>还是以<code>ValueOperations</code>为例，<code>RedisTemplate</code>提供的默认实现类是DefaultValueOperations，看看这个类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.redis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.AbstractOperations.ValueDeserializingRedisCallback;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultValueOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ValueOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    DefaultValueOperations(RedisTemplate&lt;K, V&gt; template) &#123;</span><br><span class="line">        <span class="keyword">super</span>(template);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.get(rawKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getAndSet</span><span class="params">(K key, V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(newValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.getSet(rawKey, rawValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">increment</span><span class="params">(K key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Long)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.incrBy(rawKey, delta);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">increment</span><span class="params">(K key, <span class="keyword">double</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Double)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.incrBy(rawKey, delta);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">append</span><span class="params">(K key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawString = <span class="keyword">this</span>.rawString(value);</span><br><span class="line">        <span class="keyword">return</span> (Integer)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            Long result = connection.append(rawKey, rawString);</span><br><span class="line">            <span class="keyword">return</span> result != <span class="keyword">null</span> ? result.intValue() : <span class="keyword">null</span>;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(K key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawReturn = (<span class="keyword">byte</span>[])<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.getRange(rawKey, start, end);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.deserializeString(rawReturn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;V&gt; <span class="title">multiGet</span><span class="params">(Collection&lt;K&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keys.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[][] rawKeys = <span class="keyword">new</span> <span class="keyword">byte</span>[keys.size()][];</span><br><span class="line">            <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Object hashKey;</span><br><span class="line">            <span class="keyword">for</span>(Iterator var4 = keys.iterator(); var4.hasNext(); rawKeys[counter++] = <span class="keyword">this</span>.rawKey(hashKey)) &#123;</span><br><span class="line">                hashKey = var4.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;<span class="keyword">byte</span>[]&gt; rawValues = (List)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.mGet(rawKeys);</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.deserializeValues(rawValues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiSet</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.isEmpty()) &#123;</span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; rawKeys = <span class="keyword">new</span> LinkedHashMap(m.size());</span><br><span class="line">            Iterator var3 = m.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                Entry&lt;? extends K, ? extends V&gt; entry = (Entry)var3.next();</span><br><span class="line">                rawKeys.put(<span class="keyword">this</span>.rawKey(entry.getKey()), <span class="keyword">this</span>.rawValue(entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                connection.mSet(rawKeys);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">multiSetIfAbsent</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; rawKeys = <span class="keyword">new</span> LinkedHashMap(m.size());</span><br><span class="line">            Iterator var3 = m.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                Entry&lt;? extends K, ? extends V&gt; entry = (Entry)var3.next();</span><br><span class="line">                rawKeys.put(<span class="keyword">this</span>.rawKey(entry.getKey()), <span class="keyword">this</span>.rawValue(entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.mSetNX(rawKeys);</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                connection.set(rawKey, rawValue);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value, <span class="keyword">final</span> <span class="keyword">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.potentiallyUsePsetEx(connection);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">potentiallyUsePsetEx</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!TimeUnit.MILLISECONDS.equals(unit) || !<span class="keyword">this</span>.failsafeInvokePsetEx(connection)) &#123;</span><br><span class="line">                    connection.setEx(rawKey, TimeoutUtils.toSeconds(timeout, unit), rawValue);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">failsafeInvokePsetEx</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">boolean</span> failed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.pSetEx(rawKey, timeout, rawValue);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedOperationException var4) &#123;</span><br><span class="line">                    failed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> !failed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">setIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.setNX(rawKey, rawValue);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            connection.setRange(rawKey, rawValue, offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">size</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Long)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.strLen(rawKey);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">setBit</span><span class="params">(K key, <span class="keyword">long</span> offset, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.setBit(rawKey, offset, value);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getBit</span><span class="params">(K key, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.getBit(rawKey, offset);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有<code>Operations</code>实现类都是<code>AbstractOperations</code>的子类，另外各自实现各自的接口。</p><p>实现类的方法中多数都是调用了<code>this.execute()</code>方法，这个方法在父类AbstractOperations中，最终调用的其实也是<code>RedisTemplate</code>的<code>execute()</code>方法。</p><p>以上面<code>DefaultValueOperations</code>的<code>set()</code>方法为例，看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">    <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">            connection.set(rawKey, rawValue);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是对<code>value</code>的处理，调用<code>this.rawValue()</code>方法，把value序列化成<code>byte</code>数组，这个方法在父类<code>AbstractOperations</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] rawValue(Object value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueSerializer() == <span class="keyword">null</span> &amp;&amp; value <span class="keyword">instanceof</span> <span class="keyword">byte</span>[] ? (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])value) : <span class="keyword">this</span>.valueSerializer().serialize(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，代码用的是自己的<code>valueSerializer</code>来序列化<code>value</code>，这个valueSerializer来自<code>RedisTemplate</code>。</p><p>回到<code>set()</code>方法，<code>value</code>序列化完成后，调用<code>this.execute()</code>方法，给此方法传递的第一个参数是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">        connection.set(rawKey, rawValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个参数实际上是一个<code>ValueDeserializingRedisCallback</code>对象，在其中定义了<code>inRedis()</code>方法的实现。</p><p><code>this.execute()</code>方法在父类AbstractOperations中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; callback, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.template.execute(callback, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>this.template</code>指的就是初始化时传入的<code>RedisTemplate</code>，其execute()方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.execute(action, exposeConnection, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection, <span class="keyword">boolean</span> pipeline)</span> </span>&#123;</span><br><span class="line">    Assert.isTrue(<span class="keyword">this</span>.initialized, <span class="string">"template not initialized; call afterPropertiesSet() before using it"</span>);</span><br><span class="line">    Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line">    RedisConnectionFactory factory = <span class="keyword">this</span>.getRequiredConnectionFactory();</span><br><span class="line">    RedisConnection conn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Object var11;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.enableTransactionSupport) &#123;</span><br><span class="line">            conn = RedisConnectionUtils.bindConnection(factory, <span class="keyword">this</span>.enableTransactionSupport);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn = RedisConnectionUtils.getConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> existingConnection = TransactionSynchronizationManager.hasResource(factory);</span><br><span class="line">        RedisConnection connToUse = <span class="keyword">this</span>.preProcessConnection(conn, existingConnection);</span><br><span class="line">        <span class="keyword">boolean</span> pipelineStatus = connToUse.isPipelined();</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.openPipeline();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RedisConnection connToExpose = exposeConnection ? connToUse : <span class="keyword">this</span>.createRedisConnectionProxy(connToUse);</span><br><span class="line">        T result = action.doInRedis(connToExpose);</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.closePipeline();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var11 = <span class="keyword">this</span>.postProcessResult(result, connToUse, existingConnection);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RedisConnectionUtils.releaseConnection(conn, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法初始化了<code>RedisConnection</code>，最后面调用了<code>RedisCallback</code>的<code>doInRedis()</code>方法，也就是这一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T result = action.doInRedis(connToExpose);</span><br></pre></td></tr></table></figure><p>这里的变量<code>action</code>就是在<code>set()</code>方法中自定义的<code>new AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key)</code>。</p><p><code>ValueDeserializingRedisCallback</code>类是<code>AbstractOperations</code>的内部抽象类，他的<code>doInRedis()</code>方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">this</span>.inRedis(AbstractOperations.<span class="keyword">this</span>.rawKey(<span class="keyword">this</span>.key), connection);</span><br><span class="line">    <span class="keyword">return</span> AbstractOperations.<span class="keyword">this</span>.deserializeValue(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见调用了<code>inRedis()</code>方法，其第一个参数是序列化后的<code>key</code>，调用的是<code>AbstractOperations</code>的<code>rawKey()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] rawKey(Object key) &#123;</span><br><span class="line">    Assert.notNull(key, <span class="string">"non null key required"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.keySerializer() == <span class="keyword">null</span> &amp;&amp; key <span class="keyword">instanceof</span> <span class="keyword">byte</span>[] ? (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])key) : <span class="keyword">this</span>.keySerializer().serialize(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把<code>key</code>进行序列化，<code>keySerializer()</code>方法从<code>RedisTemplate</code>中获取<code>keySerializer</code>，并由<code>keySerializer</code>对<code>key</code>进行序列化。</p><p>在<code>ValueDeserializingRedisCallback</code>类中的<code>inRedis()</code>方法是抽象方法，具体的实现在<code>DefaultValueOperations</code>的<code>set()</code>方法中，也就是这一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">    connection.set(rawKey, rawValue);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用的是<code>RedisConnection</code>的<code>set()</code>方法，完成<code>Redis</code>的<code>set</code>操作。</p><p>以上就是在RedisTemplate中使用<code>ValueOperations</code>进行<code>set</code>操作的全部代码流程。</p><p>对<code>Redis</code>的不同操作分散在<code>RedisTemplate</code>的不同Operations中，只是调用的方法不同，调用流程都差不多。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/lkforce/article/details/103685707" target="_blank" rel="noopener">https://blog.csdn.net/lkforce/article/details/103685707</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;headerlink&quot; title=&quot;一.简介&quot;&gt;&lt;/a&gt;一.简介&lt;/h4&gt;&lt;p&gt;简单的说，&lt;code&gt;RedisTemplate&lt;/code&gt;和&lt;code&gt;StringRedisTemplate&lt;/cod
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>新版IDEA 2020.1碰到的一个小坑</title>
    <link href="http://www.cyblogs.com/2020/11/07/2020/10/%E6%96%B0%E7%89%88IDEA%202020.1%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/"/>
    <id>http://www.cyblogs.com/2020/11/07/2020/10/%E6%96%B0%E7%89%88IDEA%202020.1%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/</id>
    <published>2020-11-06T16:00:00.000Z</published>
    <updated>2020-11-07T00:15:20.377Z</updated>
    
    <content type="html"><![CDATA[<p>使用新版idea创建了一个springboot项目，运行build时发生如下报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error:(<span class="number">3</span>, <span class="number">32</span>) java: 程序包org.springframework.boot不存在</span><br><span class="line">Error:(<span class="number">4</span>, <span class="number">46</span>) java: 程序包org.springframework.boot.autoconfigure不存在</span><br><span class="line">Error:(<span class="number">5</span>, <span class="number">40</span>) java: 程序包org.springframework.boot.builder不存在</span><br><span class="line">Error:(<span class="number">6</span>, <span class="number">52</span>) java: 程序包org.springframework.boot.web.servlet.support不存在</span><br><span class="line">Error:(<span class="number">9</span>, <span class="number">34</span>) java: 找不到符号</span><br><span class="line">符号: 类 SpringBootServletInitializer</span><br></pre></td></tr></table></figure><p><img src="http://static.cyblogs.com/QQ20201107-080822@2x.jpg" alt="http://static.cyblogs.com/QQ20201107-080822@2x.jpg"></p><p>诡异的是，使用<code>mvn</code>打包却是正常的，能生成正确的jar并且能通过命令行启动 后来通过查阅资料得知新版<code>IDEA</code>需要在<code>Setting</code>里将 <code>delegate IDE build/run actions to Maven</code>勾选上即可。</p><p><img src="http://static.cyblogs.com/QQ20201107-081022@2x.jpg" alt="http://static.cyblogs.com/QQ20201107-081022@2x.jpg"></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>在解决这个问题的过程中，还了解到使用<code>spring-boot-maven-plugin</code>这个插件打的jar的结构会和普通插件<code>maven-jar-plugin</code>的有些不一样。<code>spring-boot-maven-plugin</code>将所有应用启动运行所需的jar全部包含进来了，具备独立运行的条件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-maven-plugin</code>打包的<code>jar</code>目录：</p><p><img src="http://static.cyblogs.com/QQ20201107-081147@2x.jpg" alt="http://static.cyblogs.com/QQ20201107-081147@2x.jpg"></p><p>而使用普通插件打包的结构如图：</p><p><img src="http://static.cyblogs.com/QQ20201107-081242@2x.jpg" alt="http://static.cyblogs.com/QQ20201107-081242@2x.jpg"></p><p>最后，这里补充一点。如果是你想在<code>IDEA</code>里面，不是通过<code>Maven</code>来依赖，这里就不用打钩，否则你每次都必须要<code>install</code>你的<code>jar</code>包到本地来。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://juejin.im/post/6844904177114562573" target="_blank" rel="noopener">https://juejin.im/post/6844904177114562573</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用新版idea创建了一个springboot项目，运行build时发生如下报错。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="工具" scheme="http://www.cyblogs.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IntelliJ IDEA" scheme="http://www.cyblogs.com/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>注解@Autowired是如何实现的</title>
    <link href="http://www.cyblogs.com/2020/11/07/2020/11/%E6%B3%A8%E8%A7%A3@Autowired%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
    <id>http://www.cyblogs.com/2020/11/07/2020/11/%E6%B3%A8%E8%A7%A3@Autowired%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</id>
    <published>2020-11-06T16:00:00.000Z</published>
    <updated>2020-11-07T00:37:27.387Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用<code>spring</code>开发时，进行配置主要有两种方式，一是<code>xml</code>的方式，二是<code>java config</code>的方式。<code>spring</code>技术自身也在不断的发展和改变，从当前<code>springboot</code>的火热程度来看，<code>java config</code>的应用是越来越广泛了，在使用<code>java config</code>的过程当中，我们不可避免的会有各种各样的注解打交道，其中，我们使用最多的注解应该就是<code>@Autowired</code>注解了。这个注解的功能就是为我们注入一个定义好的<code>bean</code>。那么，这个注解除了我们常用的属性注入方式之外还有哪些使用方式呢？它在代码层面又是怎么实现的呢？这是本篇文章着重想讨论的问题。</p><h4 id="Autowired注解用法"><a href="#Autowired注解用法" class="headerlink" title="@Autowired注解用法"></a>@Autowired注解用法</h4><p>在分析这个注解的实现原理之前，我们不妨先来回顾一下<code>@Autowired</code>注解的用法。</p><p>将<code>@Autowired</code>注解应用于构造函数，如以下示例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>@Autowired</code>注释应用于<code>setter</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>@Autowired</code>注释应用于具有任意名称和多个参数的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span></span><br><span class="line"><span class="function"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您也可以将<code>@Autowired</code>应用于字段，或者将其与构造函数混合，如以下示例所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接应用于字段是我们使用的最多的一种方式，但是使用构造方法注入从代码层面却是更加好的，原因可以参考这篇博客：<a href="https://blog.csdn.net/topdeveloperr/article/details/81414039" target="_blank" rel="noopener">spring重点知识</a>。除此之外，还有以下不太常见的几种方式</p><p>将<code>@Autowired</code>注释添加到需要该类型数组的字段或方法，则<code>spring</code>会从<code>ApplicationContext</code>中搜寻符合指定类型的所有<code>bean</code>，如以下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组可以，我们可以马上举一反三，那容器也可以吗，答案是肯定的，下面是<code>set</code>以及<code>map</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>@Autowired</code>注解的主要使用方式，经常使用<code>spring</code>的话应该对其中常用的几种不会感到陌生。</p><h4 id="Autowired注解的作用到底是什么"><a href="#Autowired注解的作用到底是什么" class="headerlink" title="@Autowired注解的作用到底是什么?"></a>@Autowired注解的作用到底是什么?</h4><p><code>@Autowired</code>这个注解我们经常在使用，现在，我想问的是，它的作用到底是什么呢?</p><p>首先，我们从所属范围来看，事实上这个注解是属于<code>spring</code>的容器配置的一个注解，与它同属容器配置的注解还有：<code>@Required</code>,<code>@Primary</code>, <code>@Qualifier</code>等等。因此<code>@Autowired</code>注解是一个用于容器(<code>container</code>)配置的注解。</p><p>其次，我们可以直接从字面意思来看，<code>@autowired</code>注解来源于英文单词<code>autowire</code>,这个单词的意思是自动装配的意思。</p><p>自动装配又是什么意思？这个词语本来的意思是指的一些工业上的用机器代替人口，自动将一些需要完成的组装任务，或者别的一些任务完成。而在<code>spring</code>的世界当中，自动装配指的就是使用将<code>Spring</code>容器中的<code>bean</code>自动的和我们需要这个<code>bean</code>的类组装在一起。</p><p>因此，笔者个人对这个注解的作用下的定义就是:将<code>Spring</code>容器中的<code>bean</code>自动的和我们需要这个<code>bean</code>的类组装在一起协同使用。</p><p>接下来，我们就来看一下这个注解背后到底做了些什么工作。</p><h4 id="Autowired注解是如何实现的"><a href="#Autowired注解是如何实现的" class="headerlink" title="@Autowired注解是如何实现的"></a>@Autowired注解是如何实现的</h4><p>事实上，要回答这个问题必须先弄明白的是<code>java</code>是如何支持注解这样一个功能的。</p><p><code>java</code>的注解实现的核心技术是反射，让我们通过一些例子以及自己实现一个注解来理解它工作的原理。</p><h5 id="例子注解-Override"><a href="#例子注解-Override" class="headerlink" title="例子注解@Override"></a>例子注解@Override</h5><p><code>@Override</code>注解的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Override</code>注解使用<code>java</code>官方提供的注解，它的定义里面并没有任何的实现逻辑。注意，所有的注解几乎都是这样的，<strong>注解只能是被看作元数据，它不包含任何业务逻辑</strong>。<strong>注解更像是一个标签，一个声明，表面被注释的这个地方，将具有某种特定的逻辑</strong>。</p><p>那么，问题接踵而至，注解本身不包含任何逻辑，那么注解的功能是如何实现的呢？答案必然是别的某个地方对这个注解做了实现。以<code>@Override</code>注解为例，他的功能是重写一个方法，而他的实现者就是<code>JVM</code>，<code>java</code>虚拟机，<code>java</code>虚拟机在字节码层面实现了这个功能。</p><p>但是对于开发人员，虚拟机的实现是无法控制的东西，也不能用于自定义注解。 所以，如果是我们自己想定义一个独一无二的注解的话，则我们需要自己为注解写一个实现逻辑，<strong>换言之，我们需要实现自己注解特定逻辑的功能</strong>。</p><h5 id="自己实现一个注解"><a href="#自己实现一个注解" class="headerlink" title="自己实现一个注解"></a>自己实现一个注解</h5><p>在自己写注解之前我们有一些基础知识需要掌握，那就是我们写注解这个功能首先是需要<code>java</code>支持的，<code>java</code>在<code>jdk5</code>当中支持了这一功能，<strong>并且在java.lang.annotation包中提供了四个注解，仅用于编写注解时使用</strong>，他们是：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><strong><em>@Documented</em></strong></td><td>表明是否在java doc中添加Annotation</td></tr><tr><td><strong><em>@Retention</em></strong></td><td>定义注释应保留多长时间，即有效周期。有以下几种策略： <strong>RetentionPolicy.SOURCE</strong> - 在编译期间丢弃。 编译完成后，这些注释没有任何意义，因此它们不会写入字节码。 示例@Override，@ SuppressWarnings <strong>RetentionPolicy.CLASS</strong> - 在类加载期间丢弃。 在进行字节码级后处理时很有用。 有点令人惊讶的是，这是默认值。 <strong>RetentionPolicy.RUNTIME</strong> - 不要丢弃。 注释应该可以在运行时进行反射。 这是我们通常用于自定义注释的内容。</td></tr><tr><td><strong><em>@Target</em></strong></td><td>指定可以放置注解的位置。 如果不指定，则可以将注解放在任何位置。若我们只想要其中几个，则需要定义对应的几个。下面是这8个属性:ElementType.TYPE（类，接口，枚举）ElementType.FIELD（实例变量）ElementType.METHODElementType.PARAMETERElementType.CONSTRUCTORElementType.LOCAL_VARIABLEElementType.ANNOTATION_TYPE（在另一个注释上）ElementType.PACKAGE（记住package-info.java）</td></tr><tr><td><strong><em>@Inherited</em></strong></td><td>控制注解是否对子类产生影响。</td></tr></tbody></table><p>下面我们开始自己实现一个注解，注解仅支持 <code>primitives</code>, <code>string</code>和 <code>enumerations</code>这三种类型。 注解的所有属性都定义为方法，也可以提供默认值。我们先实现一个最简单的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SimpleAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个注释里面只定义了一个字符传，它的目标注释对象是方法，保留策略是在运行期间。下面我们定义一个方法来使用这个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseAnnotation</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@SimpleAnnotation</span>(<span class="string">"testStringValue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something here</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里使用了这个注解，并把字符串赋值为:<code>testStringValue</code>,到这里,定义一个注解并使用它，我们就已经全部完成。</p><p>简单的不敢相信。但是，细心一想的话，我们虽然写了一个注解也用了它，可是它并没有产生任何作用啊。也没有对我们这里方法产生任何效果啊。是的现在确实是这样的，原因在于我们前面提到的一点，我们还没有为这个注解实现它的逻辑，现在我们就来为这个注解实现逻辑。</p><p>应该怎么做呢？我们不妨自己来想一想。首先，我想给标注了这个注解的方法或字段实现功能，我们必须得知道，到底有哪些方法，哪些字段使用了这个注解吧，因此，这里我们很容易想到，这里应该会用到反射。其次，利用反射，我们利用反射拿到这样目标之后，得为他实现一个逻辑，这个逻辑是这些方法本身逻辑之外的逻辑，这又让我们想起了代理，aop等知识，我们相当于就是在为这些方法做一个增强。事实上的实现主借的逻辑也大概就是这个思路。梳理一下大致步骤如下:</p><ol><li>利用反射机制获取一个类的<code>Class</code>对象</li><li>通过这个<code>class</code>对象可以去获取他的每一个方法<code>method</code>，或字段<code>Field</code>等等</li><li><code>Method</code>，<code>Field</code>等类提供了类似于<code>getAnnotation</code>的方法来获取这个一个字段的所有注解</li><li>拿到注解之后，我们可以判断这个注解是否是我们要实现的注解，如果是则实现注解逻辑</li></ol><p>现在我们来实现一下这个逻辑，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">annotationLogic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     Class useAnnotationClass = UseAnnotation<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">     <span class="keyword">for</span>(Method method : useAnnotationClass.getMethods()) &#123;</span><br><span class="line">         SimpleAnnotation simpleAnnotation = (SimpleAnnotation)method.getAnnotation(SimpleAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">         <span class="keyword">if</span>(simpleAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">             System.out.println(<span class="string">" Method Name : "</span> + method.getName());</span><br><span class="line">             System.out.println(<span class="string">" value : "</span> + simpleAnnotation.value());</span><br><span class="line">             System.out.println(<span class="string">" --------------------------- "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这里我们实现的逻辑就是打印几句话。从上面的实现逻辑我们不能发现，借助于java的反射我们可以直接拿到一个类里所有的方法，然后再拿到方法上的注解，当然，我们也可以拿到字段上的注解。借助于反射我们可以拿到几乎任何属于一个类的东西。</p><p>关于反射更多的知识请参见这篇博客:<a href="https://blog.csdn.net/topdeveloperr/article/details/81395710#反射" target="_blank" rel="noopener">java中的反射和多态实现原理详解以及对比</a></p><p>一个简单的注解我们就实现完了。现在我们再回过头来，看一下@Autowired注解是如何实现的。</p><h5 id="Autowired注解实现逻辑分析"><a href="#Autowired注解实现逻辑分析" class="headerlink" title="@Autowired注解实现逻辑分析"></a>@Autowired注解实现逻辑分析</h5><p>知道了上面的知识，我们不难想到，上面的注解虽然简单，但是<code>@Autowired</code>和他最大的区别应该仅仅在于注解的实现逻辑，其他利用反射获取注解等等步骤应该都是一致的。先来看一下<code>@Autowired</code>这个注解在<code>spring</code>的源代码里的定义是怎样的，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.annotation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读代码我们可以看到，<code>Autowired</code>注解可以应用在构造方法，普通方法，参数，字段，以及注解这五种类型的地方，它的保留策略是在运行时。下面，我们不多说直接来看spring对这个注解进行的逻辑实现.</p><p>在<code>Spring</code>源代码当中，<code>Autowired</code>注解位于包<code>org.springframework.beans.factory.annotation</code>之中，该包的内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20191031121038318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvcGRldmVsb3BlcnI=,size_16,color_FFFFFF,t_70" alt="img"></p><p>经过分析，不难发现<code>Spring</code>对<code>autowire</code>注解的实现逻辑位于类:<code>AutowiredAnnotationBeanPostProcessor</code>之中,已在上图标红。其中的核心处理代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Class&lt;?&gt; targetClass = clazz;<span class="comment">//需要处理的目标类</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="comment">/*通过反射获取该类所有的字段，并遍历每一个字段，并通过方法findAutowiredAnnotation遍历每一个字段的所用注解，并如果用autowired修饰了，则返回auotowired相关属性*/</span>  </span><br><span class="line">ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line"><span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;<span class="comment">//校验autowired注解是否用在了static方法上</span></span><br><span class="line"><span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Autowired annotation is not supported on static fields: "</span> + field);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//判断是否指定了required</span></span><br><span class="line"><span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">      <span class="comment">//和上面一样的逻辑，但是是通过反射处理类的method</span></span><br><span class="line">ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line"><span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line"><span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line"><span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Autowired annotation is not supported on static methods: "</span> + method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Autowired annotation should only be used on methods with parameters: "</span> +</span><br><span class="line">method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                  currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">      <span class="comment">//用@Autowired修饰的注解可能不止一个，因此都加在currElements这个容器里面，一起处理</span></span><br><span class="line">elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">targetClass = targetClass.getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>博主在源代码里加了注释，结合注释就能看懂它做的事情了，最后这个方法返回的就是包含所有带有<code>autowire</code>注解修饰的一个<code>InjectionMetadata</code>集合。这个类由两部分组成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InjectionMetadata</span><span class="params">(Class&lt;?&gt; targetClass, Collection&lt;InjectedElement&gt; elements)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetClass = targetClass;</span><br><span class="line"><span class="keyword">this</span>.injectedElements = elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一是我们处理的目标类，二就是上述方法获取到的所以<code>elements</code>集合。</p><p>有了目标类，与所有需要注入的元素集合之后，我们就可以实现<code>autowired</code>的依赖注入逻辑了，实现的方法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"> </span><br><span class="line">InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">metadata.inject(bean, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of autowired dependencies failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用的方法是<code>InjectionMetadata</code>中定义的<code>inject</code>方法，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">(checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line"><span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Processing injected element of bean '"</span> + beanName + <span class="string">"': "</span> + element);</span><br><span class="line">&#125;</span><br><span class="line">element.inject(target, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其逻辑就是遍历，然后调用<code>inject</code>方法，<code>inject</code>方法其实现逻辑如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Either this or &#123;<span class="doctag">@link</span> #getResourceToInject&#125; needs to be overridden.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isField) &#123;</span><br><span class="line">Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">ReflectionUtils.makeAccessible(field);</span><br><span class="line">field.set(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (checkPropertySkipping(pvs)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Method method = (Method) <span class="keyword">this</span>.member;</span><br><span class="line">ReflectionUtils.makeAccessible(method);</span><br><span class="line">method.invoke(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里的代码当中我们也可以看到，是<code>inject</code>也使用了反射技术并且依然是分成字段和方法去处理的。在代码里面也调用了<code>makeAccessible</code>这样的可以称之为暴力破解的方法，但是反射技术本就是为框架等用途设计的，这也无可厚非。</p><p>对于字段的话，本质上就是去set这个字段的值，即对对象进行实例化和赋值，例如下面代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ObjectTest objectTest;</span><br></pre></td></tr></table></figure><p>那么在这里实现的就相当于给这个<code>objecTest</code>引用赋值了。</p><p>对于方法的话，本质就是去调用这个方法，因此这里调用的是<code>method.invoke</code>。<code>getResourceToInject</code>方法的参数就是要注入的<code>bean</code>的名字，这个方法的功能就是根据这个<code>bean</code>的名字去拿到它。</p><p>以上，就是<code>@Autowire</code>注解实现逻辑的全部分析。结合源代码再看一遍的话，会更加清楚一点。下面是<code>spring</code>容器如何实现<code>@AutoWired</code>自动注入的过程的图:</p><p> <img src="https://img-blog.csdnimg.cn/20190319171936407.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RvcGRldmVsb3BlcnI=,size_16,color_FFFFFF,t_70" alt="img"></p><p>总结起来一句话：使用<code>@Autowired</code>注入的<code>bean</code>对于目标类来说，从代码结构上来讲也就是一个普通的成员变量，<code>@Autowired</code>和<code>spring</code>一起工作，通过反射为这个成员变量赋值，也就是将其赋为期望的类实例。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="注解的有效周期是什么？"><a href="#注解的有效周期是什么？" class="headerlink" title="注解的有效周期是什么？"></a>注解的有效周期是什么？</h5><p>各种注释之间的第一个主要区别是，它们是在编译时使用，然后被丢弃（如<code>@Override</code>），还是被放在编译的类文件中，并在运行时可用（如<code>Spring</code>的<code>@Component</code>）。这是由注释的“<code>@Retention</code>”策略决定的。如果您正在编写自己的注释，则需要决定该注释在运行时（可能用于自动配置）还是仅在编译时（用于检查或代码生成）有用。</p><p>当用注释编译代码时，编译器看到注释就像看到源元素上的其他修饰符一样，比如访问修饰符（<code>public/private</code>）或.。当遇到注释时，它运行一个注释处理器，就像一个插件类，表示对特定的注释感兴趣。注释处理器通常使用反射<code>API</code>来检查正在编译的元素，并且可以简单地对它们执行检查、修改它们或生成要编译的新代码。<code>@Override</code>是一个示例；它使用反射<code>API</code>来确保能够在其中一个超类中找到方法签名的匹配，如果不能，则使用<code>@Override</code>会导致编译错误。</p><h5 id="注入的bean和用它的bean的关系是如何维护的？"><a href="#注入的bean和用它的bean的关系是如何维护的？" class="headerlink" title="注入的bean和用它的bean的关系是如何维护的？"></a>注入的bean和用它的bean的关系是如何维护的？</h5><p>无论以何种方式注入，注入的<code>bean</code>就相当于类中的一个普通对象应用，这是它的实例化是<code>spring</code>去容器中找符合的<code>bean</code>进行实例化，并注入到类当中的。他们之间的关系就是普通的一个对象持有另一个对象引用的关系。只是这些对象都是<code>spring</code>当中的<code>bean</code>而已。</p><h5 id="为什么注入的bean不能被定义为static的？"><a href="#为什么注入的bean不能被定义为static的？" class="headerlink" title="为什么注入的bean不能被定义为static的？"></a>为什么注入的bean不能被定义为static的？</h5><p>从设计的角度来说 ，使用静态字段会鼓励使用静态方法。 静态方法是<code>evil</code>的。 依赖注入的主要目的是让容器为您创建对象并进行连接。 而且，它使测试更加容易。</p><p>一旦开始使用静态方法，您就不再需要创建对象的实例，并且测试变得更加困难。 同样，您不能创建给定类的多个实例，每个实例都注入不同的依赖项（因为该字段是隐式共享的，并且会创建全局状态）。</p><p>静态变量不是<code>Object</code>的属性，而是<code>Class</code>的属性。 <code>spring</code>的<code>autowire</code>是在对象上完成的，这样使得设计很干净。 在<code>spring</code>当中我们也可以将<code>bean</code>对象定义为单例，这样就能从功能上实现与静态定义相同的目的。</p><p>但是从纯粹技术的层面，我们可以这样做：</p><p>将<code>@Autowired</code>可以与<code>setter</code>方法一起使用，然后可以让<code>setter</code>修改静态字段的值。但是这种做法非常不推荐。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/topdeveloperr/article/details/87971446" target="_blank" rel="noopener">https://blog.csdn.net/topdeveloperr/article/details/87971446</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;使用&lt;code&gt;spring&lt;/code&gt;开发时，进行配置主要有两种方式，一是&lt;code&gt;xml&lt;/code&gt;的方式，二是&lt;code&gt;jav
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis保存一个用户信息是用String还是Hash？</title>
    <link href="http://www.cyblogs.com/2020/08/14/2020/08/Redis%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%98%AF%E7%94%A8String%E8%BF%98%E6%98%AFHash%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/08/14/2020/08/Redis%E4%BF%9D%E5%AD%98%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%98%AF%E7%94%A8String%E8%BF%98%E6%98%AFHash%EF%BC%9F/</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-08-24T15:11:54.476Z</updated>
    
    <content type="html"><![CDATA[<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>如果用普通的<code>key/value</code>结构来存储，主要有以下2种存储方式：</p><p>第一种方式将用户<code>ID</code>作为查找<code>key</code>,把其他信息封装成一个对象以序列化的方式存储，</p><p> 如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set u001 "李三,18,20010101" </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get u001</span><br><span class="line">"\xe6\x9d\x8e\xe4\xb8\x89,18,20010101"</span><br></pre></td></tr></table></figure><p> 这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入<code>CAS</code>等复杂问题。</p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>第二种方法是这个用户信息对象有多少成员就存成多少个<code>key-value</code>对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，</p><p> 如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mset user:001:name "李三" user:001:age 18 user:001:birthday "20010101"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get user:001:name</span><br><span class="line">"\xe6\x9d\x8e\xe4\xb8\x89"</span><br><span class="line">127.0.0.1:6379&gt; get user:001:age</span><br><span class="line">"18"</span><br><span class="line">127.0.0.1:6379&gt; get user:001:birthday</span><br><span class="line">"20010101"</span><br></pre></td></tr></table></figure><p> 虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。</p><h4 id="最好的办法"><a href="#最好的办法" class="headerlink" title="最好的办法"></a>最好的办法</h4><p>那么<code>Redis</code>提供的<code>Hash</code>很好的解决了这个问题，<code>Redis</code>的<code>Hash</code>实际是内部存储的<code>Value</code>为一个<code>HashMap</code>，</p><p> 并提供了直接存取这个<code>Map</code>成员的接口，</p><p> 如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:001 name "李三" age 18 birthday "20010101"</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall user:001</span><br><span class="line">1) "name"</span><br><span class="line">2) "\xe6\x9d\x8e\xe4\xb8\x89"</span><br><span class="line">3) "age"</span><br><span class="line">4) "18"</span><br><span class="line">5) "birthday"</span><br><span class="line">6) "20010101"</span><br><span class="line">127.0.0.1:6379&gt; hget user:001 age</span><br><span class="line">"18"</span><br></pre></td></tr></table></figure><p>也就是说，<code>Key</code>仍然是用户<code>ID</code>,<code>value</code>是一个<code>Map</code>，这个<code>Map</code>的<code>key</code>是成员的属性名，<code>value</code>是属性值， 这样对数据的修改和存取都可以直接通过其内部<code>Map</code>的<code>Key</code>(<code>Redis</code>里称内部<code>Map</code>的<code>key</code>为<code>field</code>), 也就是通过</p><p> <code>key</code>(用户ID) + <code>field</code>(属性标签) 操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/Dustin_CDS/article/details/79701975" target="_blank" rel="noopener">https://blog.csdn.net/Dustin_CDS/article/details/79701975</a></li><li><a href="https://www.runoob.com/redis/redis-hashes.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-hashes.html</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;方式一&quot;&gt;&lt;a href=&quot;#方式一&quot; class=&quot;headerlink&quot; title=&quot;方式一&quot;&gt;&lt;/a&gt;方式一&lt;/h4&gt;&lt;p&gt;如果用普通的&lt;code&gt;key/value&lt;/code&gt;结构来存储，主要有以下2种存储方式：&lt;/p&gt;
&lt;p&gt;第一种方式将用户&lt;cod
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>了解Eureka工作原理</title>
    <link href="http://www.cyblogs.com/2020/08/03/2020/08/%E4%BA%86%E8%A7%A3Eureka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://www.cyblogs.com/2020/08/03/2020/08/%E4%BA%86%E8%A7%A3Eureka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-02T16:00:00.000Z</published>
    <updated>2020-08-04T04:42:32.023Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Eureka-工作原理"><a href="#Eureka-工作原理" class="headerlink" title="Eureka 工作原理"></a>Eureka 工作原理</h4><p><code>Eureka</code> 作为 <code>Spring Cloud</code> 体系中最核心、默认的注册中心组件，研究它的运行机制，有助于我们在工作中更好地使用它。</p><h4 id="Eureka-核心概念"><a href="#Eureka-核心概念" class="headerlink" title="Eureka 核心概念"></a>Eureka 核心概念</h4><p>回到上节的服务注册调用示意图，服务提供者和服务的消费者，本质上也是 <code>Eureka Client</code> 角色。整体上可以分为两个主体：<code>Eureka Server</code> 和 <code>Eureka Client</code>。<br><img src="http://static.cyblogs.com/20190703102014756.png" alt="http://static.cyblogs.com/20190703102014756.png"></p><p><strong>Eureka Server：注册中心服务端</strong></p><p>注册中心服务端主要对外提供了三个功能：</p><p><strong>服务注册</strong><br>服务提供者启动时，会通过 <code>Eureka Client</code> 向 <code>Eureka Server</code> 注册信息，<code>Eureka Server</code> 会存储该服务的信息，<code>Eureka Server</code> 内部有二层缓存机制来维护整个注册表</p><p><strong>提供注册表</strong><br>服务消费者在调用服务时，如果 <code>Eureka Client</code> 没有缓存注册表的话，会从 <code>Eureka Server</code> 获取最新的注册表</p><p><strong>同步状态</strong><br><code>Eureka Client</code> 通过注册、心跳机制和 <code>Eureka Server</code> 同步当前客户端的状态。</p><p><strong>Eureka Client：注册中心客户端</strong><br><code>Eureka Client</code> 是一个 <code>Java</code> 客户端，用于简化与 <code>Eureka Server</code> 的交互。<code>Eureka Client</code> 会拉取、更新和缓存 <code>Eureka Server</code> 中的信息。因此当所有的 <code>Eureka Server</code> 节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者，但是当服务有更改的时候会出现信息不一致。</p><p><strong>Register: 服务注册</strong><br>服务的提供者，将自身注册到注册中心，服务提供者也是一个 <code>Eureka Client</code>。当 <code>Eureka Client</code> 向 <code>Eureka Server</code> 注册时，它提供自身的元数据，比如 IP 地址、端口，运行状况指示符 URL，主页等。</p><p><strong>Renew: 服务续约</strong><br><code>Eureka Client</code> 会每隔 30 秒发送一次心跳来续约。 通过续约来告知 <code>Eureka Server</code> 该 <code>Eureka Client</code> 运行正常，没有出现问题。 默认情况下，如果 <code>Eureka Server</code> 在 90 秒内没有收到 <code>Eureka Client</code> 的续约，<code>Server</code> 端会将实例从其注册表中删除，此时间可配置，一般情况不建议更改。</p><p><strong>服务续约的两个重要属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务续约任务的调用间隔时间，默认为<span class="number">30</span>秒</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=<span class="number">30</span></span><br><span class="line"></span><br><span class="line">服务失效的时间，默认为<span class="number">90</span>秒。</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=<span class="number">90</span></span><br></pre></td></tr></table></figure><p><strong>Eviction 服务剔除</strong><br>当 <code>Eureka Client</code> 和 <code>Eureka Server</code> 不再有心跳时，<code>Eureka Server</code> 会将该服务实例从服务注册列表中删除，即服务剔除。</p><p><strong>Cancel: 服务下线</strong><br><code>Eureka Client</code> 在程序关闭时向 <code>Eureka Server</code> 发送取消请求。 发送请求后，该客户端实例信息将从 <code>Eureka Server</code> 的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryManager.getInstance().shutdownComponent()；</span><br></pre></td></tr></table></figure><p><strong>GetRegisty: 获取注册列表信息</strong><br><code>Eureka Client</code> 从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 <code>Eureka Client</code> 的缓存信息不同，<code>Eureka Client</code> 自动处理。</p><p>如果由于某种原因导致注册列表信息不能及时匹配，<code>Eureka Client</code> 则会重新获取整个注册表信息。 <code>Eureka Server</code> 缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。<code>Eureka Client</code> 和 <code>Eureka Server</code> 可以使用 <code>JSON/XML</code> 格式进行通讯。在默认情况下 <code>Eureka Client</code> 使用压缩 <code>JSON</code> 格式来获取注册列表的信息。</p><p><strong>获取服务是服务消费者的基础，所以必有两个重要参数需要注意：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 启用服务消费者从注册中心拉取服务列表的功能</span><br><span class="line">eureka.client.fetch-registry=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"># 设置服务消费者从注册中心拉取服务列表的间隔</span><br><span class="line">eureka.client.registry-fetch-interval-seconds=<span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>Remote Call: 远程调用</strong><br>当 <code>Eureka Client</code> 从注册中心获取到服务提供者信息后，就可以通过 <code>Http</code> 请求调用对应的服务；服务提供者有多个时，<code>Eureka Client</code> 客户端会通过 <code>Ribbon</code> 自动进行负载均衡。</p><h4 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h4><p>默认情况下，如果 <code>Eureka Server</code> 在一定的 90s 内没有接收到某个微服务实例的心跳，会注销该实例。但是在微服务架构下服务之间通常都是跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，网络分区故障，导致此实例被注销。</p><p>固定时间内大量实例被注销，可能会严重威胁整个微服务架构的可用性。为了解决这个问题，<code>Eureka</code> 开发了自我保护机制，那么什么是自我保护机制呢？</p><p><code>Eureka Server</code> 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，<code>Eureka Server</code> 即会进入自我保护机制。</p><p><strong>Eureka Server 触发自我保护机制后，页面会出现提示：</strong></p><p><img src="https://img-blog.csdnimg.cn/20190703103514416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F3ZTg2MzE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>Eureka Server 进入自我保护机制，会出现以下几种情况：</strong></p><ul><li>(1) <code>Eureka</code> 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li><li>(2)<code>Eureka</code> 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</li><li>(3)当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li></ul><p><code>Eureka</code> 自我保护机制是为了防止误杀服务而提供的一个机制。当个别客户端出现心跳失联时，则认为是客户端的问题，剔除掉客户端；当 <code>Eureka</code> 捕获到大量的心跳失败时，则认为可能是网络问题，进入自我保护机制；当客户端心跳恢复时，<code>Eureka</code> 会自动退出自我保护机制。</p><p>如果在保护期内刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，即会调用失败。对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。</p><p><strong>通过在 Eureka Server 配置如下参数，开启或者关闭保护机制，生产环境建议打开：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.server.enable-self-preservation=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h4 id="Eureka-集群原理"><a href="#Eureka-集群原理" class="headerlink" title="Eureka 集群原理"></a>Eureka 集群原理</h4><p>再来看看 Eureka 集群的工作原理。我们假设有三台 <code>Eureka Server</code> 组成的集群，第一台 <code>Eureka Server</code> 在北京机房，另外两台 <code>Eureka Server</code> 在深圳和西安机房。这样三台 <code>Eureka Server</code> 就组建成了一个跨区域的高可用集群，只要三个地方的任意一个机房不出现问题，都不会影响整个架构的稳定性。</p><p><img src="http://static.cyblogs.com/20190703103823398.png" alt="http://static.cyblogs.com/20190703103823398.png"></p><p>从图中可以看出 <code>Eureka Server</code> 集群相互之间通过 <code>Replicate</code> 来同步数据，相互之间不区分主节点和从节点，所有的节点都是平等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的 <code>serviceUrl</code> 指向其他节点。</p><p>如果某台 <code>Eureka Server</code> 宕机，<code>Eureka Client</code> 的请求会自动切换到新的 <code>Eureka Server</code> 节点。当宕机的服务器重新恢复后，<code>Eureka</code> 会再次将其纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它 <code>Eureka Server</code> 当前所知的所有节点中。</p><p>另外 <code>Eureka Server</code> 的同步遵循着一个非常简单的原则：只要有一条边将节点连接，就可以进行信息传播与同步。所以，如果存在多个节点，只需要将节点之间两两连接起来形成通路，那么其它注册中心都可以共享信息。每个 <code>Eureka Server</code> 同时也是 <code>Eureka Client</code>，多个 <code>Eureka Server</code> 之间通过 <code>P2P</code> 的方式完成服务注册表的同步。</p><p><code>Eureka Server</code> 集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。</p><p><strong>Eureka 分区</strong><br><code>Eureka</code> 提供了 <code>Region</code> 和 <code>Zone</code> 两个概念来进行分区，这两个概念均来自于亚马逊的 <code>AWS</code>:</p><ul><li>region：可以理解为地理上的不同区域，比如亚洲地区，中国区或者深圳等等。没有具体大小的限制。根据项目具体的情况，可以自行合理划分 region。</li><li>zone：可以简单理解为 region 内的具体机房，比如说 region 划分为深圳，然后深圳有两个机房，就可以在此 region 之下划分出 zone1、zone2 两个 zone。</li></ul><p>上图中的 <code>us-east-1c</code>、<code>us-east-1d</code>、<code>us-east-1e</code> 就代表了不同的 <code>Zone</code>。<code>Zone</code> 内的 <code>Eureka Client</code> 优先和 <code>Zone</code> 内的 <code>Eureka Server</code> 进行心跳同步，同样调用端优先在 <code>Zone</code> 内的 <code>Eureka Server</code> 获取服务列表，当 <code>Zone</code> 内的 <code>Eureka Server</code> 挂掉之后，才会从别的 <code>Zone</code> 中获取信息。</p><p><strong>Eurka 保证 AP</strong></p><p><code>Eureka Server</code> 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 <code>Eureka Client</code> 在向某个 <code>Eureka</code> 注册时，如果发现连接失败，则会自动切换至其它节点。只要有一台 <code>Eureka Server</code> 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p><h4 id="Eurka-工作流程"><a href="#Eurka-工作流程" class="headerlink" title="Eurka 工作流程"></a>Eurka 工作流程</h4><p>了解完 <code>Eureka</code> 核心概念，自我保护机制，以及集群内的工作原理后，我们来整体梳理一下 <code>Eureka</code> 的工作流程：</p><p>1、<code>Eureka Server</code> 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 <code>Replicate</code> 同步注册表，每个 <code>Eureka Server</code> 都存在独立完整的服务注册表信息</p><p>2、<code>Eureka Client</code> 启动时根据配置的 <code>Eureka Server</code> 地址去注册中心注册服务</p><p>3、<code>Eureka Client</code> 会每 30s 向 <code>Eureka Server</code> 发送一次心跳请求，证明客户端服务正常</p><p>4、当 <code>Eureka Server</code> 90s 内没有收到 <code>Eureka Client</code> 的心跳，注册中心则认为该节点失效，会注销该实例</p><p>5、单位时间内 <code>Eureka Server</code> 统计到有大量的 <code>Eureka Client</code> 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端</p><p>6、当 <code>Eureka Client</code> 心跳请求恢复正常之后，<code>Eureka Server</code> 自动退出自我保护模式</p><p>7、<code>Eureka Client</code> 定时全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地</p><p>8、服务调用时，<code>Eureka Client</code> 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存</p><p>9、<code>Eureka Client</code> 获取到目标服务器信息，发起服务调用</p><p>10、<code>Eureka Client</code> 程序关闭时向 <code>Eureka Server</code> 发送取消请求，<code>Eureka Server</code> 将实例从注册表中删除</p><p>讲了 <code>Eureka</code> 核心概念、<code>Eureka</code> 自我保护机制和 <code>Eureka</code> 集群原理。通过分析 <code>Eureka</code> 工作原理，我可以明显地感觉到 <code>Eureka</code> 的设计之巧妙，通过一些列的机制，完美地解决了注册中心的稳定性和高可用性。</p><p><code>Eureka</code> 为了保障注册中心的高可用性，容忍了数据的非强一致性，服务节点间的数据可能不一致， <code>Client-Server</code> 间的数据可能不一致。比较适合跨越多机房、对注册中心服务可用性要求较高的使用场景。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/qwe86314/article/details/94552801" target="_blank" rel="noopener">https://blog.csdn.net/qwe86314/article/details/94552801</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Eureka-工作原理&quot;&gt;&lt;a href=&quot;#Eureka-工作原理&quot; class=&quot;headerlink&quot; title=&quot;Eureka 工作原理&quot;&gt;&lt;/a&gt;Eureka 工作原理&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Eureka&lt;/code&gt; 作为 &lt;code&gt;Sprin
      
    
    </summary>
    
    
      <category term="注册中心" scheme="http://www.cyblogs.com/categories/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    
    
      <category term="Eureka" scheme="http://www.cyblogs.com/tags/Eureka/"/>
    
      <category term="注册中心" scheme="http://www.cyblogs.com/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>什么能力很重要，但大多数人却没有？</title>
    <link href="http://www.cyblogs.com/2020/07/30/2020/07/%E4%BB%80%E4%B9%88%E8%83%BD%E5%8A%9B%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%BD%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E5%8D%B4%E6%B2%A1%E6%9C%89%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/07/30/2020/07/%E4%BB%80%E4%B9%88%E8%83%BD%E5%8A%9B%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%BD%86%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%E5%8D%B4%E6%B2%A1%E6%9C%89%EF%BC%9F/</id>
    <published>2020-07-29T16:00:00.000Z</published>
    <updated>2020-08-02T15:03:30.737Z</updated>
    
    <content type="html"><![CDATA[<h4 id="深度阅读的能力"><a href="#深度阅读的能力" class="headerlink" title="深度阅读的能力"></a>深度阅读的能力</h4><p>我敢保证，看完这个回答之前，就有很多人会划走。</p><p>这绝逼不是因为我这个回答写的太无趣，或者他们不同意我的某些观点，而是因为——<strong>他们看什么东西都是这样。</strong></p><p>他们根本不能沉浸式的阅读什么东西，一般超过几百字的内容就很少看了，除非是小黄文和超能力爽文。他们做的最多的是浮皮潦草的刷刷抖音、看看段子，稍微有点复杂的电影都看不下去，更何况那些晦涩枯燥的工具书了。</p><p>我不能说知乎用户就比抖音用户牛逼，但是经过我这些年的学习和生活，我发现能够全神贯注的阅读长篇文字，本身就是很强的一种能力，它能够轻而易举的影响到我们的学习效果和工作效果，它关乎到我们的注意力、记忆力、逻辑思维能力和理解能力。</p><p>你信也好，你不信也罢，越看书就会越聪明，一直看爽文、肥皂剧、抖音就会变得不善思考。</p><h4 id="自我认知能力"><a href="#自我认知能力" class="headerlink" title="自我认知能力"></a>自我认知能力</h4><p>不要觉得这个能力很菜，真没几个人有。</p><p>不服你可以冷静下来想想，你真的了解你自己么？你真的知道你自己在这个社会中处于怎样的一个阶层和水平么？如果你觉得你都了解，那我再问你一句，<strong>你的这些认知，都来源于哪里？</strong></p><p>其实你对自己的评价往往都来源于他人对你的反馈，所以人其实是很容易被环境和他人的评价所左右的，不要觉得你不可能进入传销，当你周围的环境和人全都变了，你得到的反馈就完全乱了，你自己就会失去对自己的认知。</p><p>而更值得注意的是，很多人并没有进入什么传销组织，但是却在他人的吹捧之中失去了对自己的判断，很多商家就是利用这一点，忽悠了不知多少人前赴后继的去送钱。</p><h4 id="持久且专注的坚持做一件事的能力"><a href="#持久且专注的坚持做一件事的能力" class="headerlink" title="持久且专注的坚持做一件事的能力"></a>持久且专注的坚持做一件事的能力</h4><p>其实这世界上绝大多数对未来很有意义的事情，短期内往往不会看到成效。比如健身、读书、早睡早起。你健身一天不会有八块腹肌，读一本书不能洞悉人性，早睡早起一天也不能容光焕发。</p><p>这些从长期看来对一个人有利的行为，不会像你刷抖音、看段子一样，短短一两分钟内就能够带给你刺激的感觉。</p><p>而且我相信所有的人都知道读书有好处，但问题就是读一本往往看不到效果，所以我一直觉得牛逼的人和普通人之间最大的差距就是——<strong>牛逼的人能在看不到回馈的情况下继续坚持下去，持续且专注的坚持下去。</strong></p><p>对于99%的普通人来说，长期执着于一件事，持续深耕，五年十年后，你就会得到巨大的回报，并且成为这个领域的专家。</p><h4 id="控制情绪的能力"><a href="#控制情绪的能力" class="headerlink" title="控制情绪的能力"></a>控制情绪的能力</h4><p>每个人的生活中，都有一大半决策是在情绪的影响下做出的，而且往往这样做出的决策都不是最佳决策。只要你能在情绪失控的时候，提醒自己不要做出决策，让自己平复一下，就能解决很多麻烦事儿。</p><p>生而为人，必然有很多事情让你很愤怒、很悲伤、很焦躁，但是我想说的是，你要学会别跟自己过不去，让自己活的轻松点！</p><p>这本身就是很强悍的一种能力，会影响自己的生活，并影响身边人对你的看法。</p><h4 id="掌控自己欲望的能力"><a href="#掌控自己欲望的能力" class="headerlink" title="掌控自己欲望的能力"></a>掌控自己欲望的能力</h4><p>很多人都以为自律是限制自己的欲望，据我所知，恰恰相反，自律应该是更好的分配自己的欲望。</p><p>你觉得健身的人是没有食欲的人么？错了，他们只是为了满足自己“拥有好身材”的长期欲望而放弃了满足眼前美食的欲望而已。</p><p>所以一个真正长期自律的人实际上就是对自己欲望进行更好的规划的分配的人。</p><h4 id="用语言表达自己思想的能力"><a href="#用语言表达自己思想的能力" class="headerlink" title="用语言表达自己思想的能力"></a>用语言表达自己思想的能力</h4><p>知乎有一个很重要的特点就是会把质量好的回答都排在前面，你看多了就会觉得所有的人都很牛逼，但是你可以做这么一个实验：</p><p>先给我这个回答点个赞（别走丢了），然后随便翻几个情感、生活类的大问题，几千个回答的那种，按时间排序，再找找那些0赞的回答看一下，长长一段文字，要么在写自己家里的琐事，要么是生活中遇到的不良情绪，要么试图用自己蹩脚的生活经验来总结人生的大道理，读完以后再回来看看我这个回答我自己都觉得我是个大文豪。</p><p>不光如此，就连一个简单的提问，很多人也能问的乱七八糟，完全没有逻辑顺序，描述抓不住重点，最后连自己想要问什么都说不明白。</p><p>连话都说不明白，你说还谈什么能力？</p><h4 id="共情能力"><a href="#共情能力" class="headerlink" title="共情能力"></a>共情能力</h4><p>为什么经常有人会被说情商低？据我所知不是因为他们脑子笨或者不会说话，本质上是因为<strong>他不能体会到对方的情绪和感觉</strong>，不能通过对方的描述、表情、动作而产生共情。</p><p>你说人家在那儿跟你诉着苦，说的就差哭出来了，你突然get到了笑点，对着别人哈哈大笑，你说这是不是缺？</p><p>你女朋友含情脉脉的看着你，说她冷，结果你说，“活该，谁让你穿那么点，瞅你冻得那逼出”，我就问你抗不抗揍吧。</p><h4 id="不要脸的能力"><a href="#不要脸的能力" class="headerlink" title="不要脸的能力"></a>不要脸的能力</h4><p>别觉得这不算什么能力，我很严肃的告诉你，这能力特别牛逼，而且非常重要。</p><p>不要脸这个词，表面上是骂人，其实你仔细想想，这里面还包含了一个人对外界评判的不在意，对别人眼光的不care，甚至还能够体现出一个人的大局观。</p><p>你有多少次想跟领导去提要求最后却打了退堂鼓？你有多少次内心一万只草泥马奔腾而过但是嘴上却答应了别人的请求？你有多少次因为对方说咱们这么好的交情而抹不开面子？</p><p>多少因为面子天天加班的，因为面子【顺路】帮别人送东西的，因为面子给别人办事儿丢了饭碗的，还有因为面子借给别人钱要不回来的。</p><h4 id="接纳不同观点的能力"><a href="#接纳不同观点的能力" class="headerlink" title="接纳不同观点的能力"></a>接纳不同观点的能力</h4><p>你有没有想过，为什么现在满大街都是教别人说话的和提高情商的书籍？但是却没有多少书是教人说大实话的？</p><p><strong>因为很多人根本就听不下那些难听的大实话！</strong></p><p>哪怕你是真的为他好，他也不爱听。</p><p>比如一个女生要买一件衣服，你觉得很难看，她穿上以后像块被马蹄子踩了的奶油蛋糕，但是她自己还觉得自己美美哒。</p><p>如果她能心平气和的接纳你的不同观点，显然对她有好处，她就不至于买那么难看的衣服，不至于乱花钱。</p><p>但事实是大部分人总是先入为主，根本听不进去不同观点，别人的好言相劝大多都被当做情商低和柠檬精。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.zhihu.com/question/305507128/answer/1073167931" target="_blank" rel="noopener">https://www.zhihu.com/question/305507128/answer/1073167931</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;深度阅读的能力&quot;&gt;&lt;a href=&quot;#深度阅读的能力&quot; class=&quot;headerlink&quot; title=&quot;深度阅读的能力&quot;&gt;&lt;/a&gt;深度阅读的能力&lt;/h4&gt;&lt;p&gt;我敢保证，看完这个回答之前，就有很多人会划走。&lt;/p&gt;
&lt;p&gt;这绝逼不是因为我这个回答写的太无趣，或
      
    
    </summary>
    
    
      <category term="随感" scheme="http://www.cyblogs.com/categories/%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="随感" scheme="http://www.cyblogs.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>3种web会话管理的方式</title>
    <link href="http://www.cyblogs.com/2020/06/07/2020/06/3%E7%A7%8Dweb%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.cyblogs.com/2020/06/07/2020/06/3%E7%A7%8Dweb%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2020-06-06T16:00:00.000Z</published>
    <updated>2020-08-02T15:02:56.770Z</updated>
    
    <content type="html"><![CDATA[<p><code>http</code> 是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道 <code>http</code> 请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。本文总结了 3 种常见的实现 <code>web</code> 应用会话管理的方式：</p><p>1）基于 <code>server</code> 端 <code>session</code> 的管理方式</p><p>2）<code>cookie-base</code> 的管理方式</p><p>3）<code>token-base</code> 的管理方式</p><p>这些内容可以帮助加深对 <code>web</code> 中用户登录机制的理解，对实际项目开发也有参考价值，欢迎阅读与指正。</p><h4 id="1-基于-server-端-session-的管理"><a href="#1-基于-server-端-session-的管理" class="headerlink" title="1. 基于 server 端 session 的管理"></a>1. 基于 server 端 session 的管理</h4><p>在早期 <code>web</code> 应用中，通常使用服务端 <code>session</code> 来管理用户的会话。快速了解服务端 <code>session</code>:</p><p>1) 服务端 <code>session</code> 是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个 <code>session</code> 都分配一个唯一的 <code>sessionid</code>，以保证每个用户都有一个不同的 <code>session</code> 对象。</p><p>2）服务器在创建完 <code>session</code> 后，会把 <code>sessionid</code> 通过 <code>cookie</code> 返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过 <code>cookie</code> 把 <code>sessionid</code> 传回给服务器，以便服务器能够根据 <code>sessionid</code> 找到与该用户对应的 <code>session</code> 对象。</p><p>3）<code>session</code> 通常有失效时间的设定，比如 2 个小时。当失效时间到，服务器会销毁之前的 <code>session</code>，并创建新的 <code>session</code> 返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的 <code>session</code> 的失效时间根据当前的请求时间再延长 2 个小时。</p><p>4）<code>session</code> 在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往 <code>sesssion</code> 对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的 <code>session</code> 对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的 <code>session</code> 对象里的登录凭证清掉。所以在用户登录前或退出后或者 <code>session</code> 对象失效时，肯定都是拿不到需要的登录凭证的。</p><p>以上过程可简单使用流程图描述如下：</p><p><img src="http://static.cyblogs.com/459873-20161115231400951-1095594983.png" alt="http://static.cyblogs.com/459873-20161115231400951-1095594983.png"></p><p>主流的 <code>web</code> 开发平台（<code>java</code>,<code>.net</code>,<code>php</code>）都原生支持这种会话管理的方式，而且开发起来很简单，相信大部分后端开发人员在入门的时候都了解并使用过它。它还有一个比较大的优点就是安全性好，因为在浏览器端与服务器端保持会话状态的媒介始终只是一个 <code>sessionid</code> 串，只要这个串够随机，攻击者就不能轻易冒充他人的 <code>sessionid</code> 进行操作；除非通过 <code>CSRF</code> 或 <code>http</code> 劫持的方式，才有可能冒充别人进行操作；即使冒充成功，也必须被冒充的用户 <code>session</code> 里面包含有效的登录凭证才行。但是在真正决定用它管理会话之前，也得根据自己的应用情况考虑以下几个问题：</p><p>1）这种方式将会话信息存储在 <code>web</code> 服务器里面，所以在用户同时在线量比较多时，这些会话信息会占据比较多的内存；</p><p>2）当应用采用集群部署的时候，会遇到多台 <code>web</code> 服务器之间如何做 <code>session</code> 共享的问题。因为 <code>session</code> 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 <code>session</code> 的服务器，这样他就拿不到之前已经放入到 <code>session</code> 中的登录凭证之类的信息了；</p><p>3）多个应用要共享 <code>session</code> 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 <code>cookie</code> 跨域的处理。</p><p>针对问题 1 和问题 2，我见过的解决方案是采用 <code>redis</code> 这种中间服务器来管理 <code>session</code> 的增删改查，一来减轻 <code>web</code> 服务器的负担，二来解决不同 web 服务器共享 <code>session</code> 的问题。针对问题 3，由于服务端的 <code>session</code> 依赖 <code>cookie</code> 来传递 <code>sessionid</code>，所以在实际项目中，只要解决各个项目里面如何实现 <code>sessionid</code> 的 <code>cookie</code> 跨域访问即可，这个是可以实现的，就是比较麻烦，前后端有可能都要做处理。</p><p>如果不考虑以上三个问题，这种管理方式比较值得使用，尤其是一些小型的 <code>web</code> 应用。但是一旦应用将来有扩展的必要，那就得谨慎对待前面的三个问题。如果真要在项目中使用这种方式，推荐结合单点登录框架如 <code>CAS</code> 一起用，这样会使应用的扩展性更强。</p><h4 id="2-cookie-based-的管理方式"><a href="#2-cookie-based-的管理方式" class="headerlink" title="2. cookie-based 的管理方式"></a>2. cookie-based 的管理方式</h4><p>由于前一种方式会增加服务器的负担和架构的复杂性，所以后来就有人想出直接把用户的登录凭证直接存到客户端的方案，当用户登录成功之后，把登录凭证写到 <code>cookie</code> 里面，并给 <code>cookie</code> 设置有效期，后续请求直接验证存有登录凭证的 <code>cookie</code> 是否存在以及凭证是否有效，即可判断用户的登录状态。使用它来实现会话管理的整体流程如下：</p><p>1）用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证，这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户 id，凭证创建时间和过期时间三个值。</p><p>2）服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入 <code>cookie</code>。<code>cookie</code> 的名字必须固定（如 <code>ticket</code>），因为后面再获取的时候，还得根据这个名字来获取 cookie 值。这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。做加密的目的，是防止 <code>cookie</code> 被别人截取的时候，无法轻易读到其中的用户信息。</p><p>3）用户登录后发起后续请求，服务端根据上一步存登录凭证的 <code>cookie</code> 名字，获取到相关的 <code>cookie</code> 值。然后先做解密处理，再做数字签名的认证，如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比，判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。</p><p><img src="http://static.cyblogs.com/459873-20161120210043123-760641758.png" alt="http://static.cyblogs.com/459873-20161120210043123-760641758.png"></p><p>这种方式最大的优点就是实现了服务端的无状态化，彻底移除了服务端对会话的管理的逻辑，服务端只需要负责创建和验证登录 <code>cookie</code> 即可，无需保持用户的状态信息。对于第一种方式的第二个问题，用户会话信息共享的问题，它也能很好解决：因为如果只是同一个应用做集群部署，由于验证登录凭证的代码都是一样的，所以不管是哪个服务器处理用户请求，总能拿到 <code>cookie</code> 中的登录凭证来进行验证；如果是不同的应用，只要每个应用都包含相同的登录逻辑，那么他们也是能轻易实现会话共享的，不过这种情况下，登录逻辑里面数字签名以及加密解密要用到的密钥文件或者密钥串，需要在不同的应用里面共享，总而言之，就是需要算法完全保持一致。</p><p>这种方式由于把登录凭证直接存放客户端，并且需要 <code>cookie</code> 传来传去，所以它的缺点也比较明显：</p><p>1）<code>cookie</code> 有大小限制，存储不了太多数据，所以要是登录凭证存的消息过多，导致加密签名后的串太长，就会引发别的问题，比如其它业务场景需要 <code>cookie</code> 的时候，就有可能没那么多空间可用了；所以用的时候得谨慎，得观察实际的登录 <code>cookie</code> 的大小；比如太长，就要考虑是非是数字签名的算法太严格，导致签名后的串太长，那就适当调整签名逻辑；比如如果一开始用 <code>4096</code> 位的 <code>RSA</code> 算法做数字签名，可以考虑换成 <code>1024</code>、<code>2048</code> 位；</p><p>2）每次传送 <code>cookie</code>，增加了请求的数量，对访问性能也有影响；</p><p>3）也有跨域问题，毕竟还是要用 <code>cookie</code>。</p><p>相比起第一种方式，<code>cookie-based</code> 方案明显还是要好一些，目前好多 <code>web</code> 开发平台或框架都默认使用这种方式来做会话管理，比如 <code>php</code> 里面 <code>yii</code> 框架，这是我们团队后端目前用的，它用的就是这个方案，以上提到的那些登录逻辑，框架也都已经封装好了，实际用起来也很简单；<code>asp.net</code> 里面 <code>forms</code> 身份认证，也是这个思路，这里有一篇好文章把它的实现细节都说的很清楚：</p><p><a href="http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html" target="_blank" rel="noopener">http://www.cnblogs.com/fish-li/archive/2012/04/15/2450571.html</a></p><p>前面两种会话管理方式因为都用到 <code>cookie</code>，不适合用在 <code>native app</code> 里面：<code>native app</code> 不好管理 <code>cookie</code>，毕竟它不是浏览器。这两种方案都不适合用来做纯 <code>api</code> 服务的登录认证。要实现 api 服务的登录认证，就要考虑下面要介绍的第三种会话管理方式。</p><h4 id="3-token-based-的管理方式"><a href="#3-token-based-的管理方式" class="headerlink" title="3. token-based 的管理方式"></a>3. token-based 的管理方式</h4><p>这种方式从流程和实现上来说，跟 <code>cookie-based</code> 的方式没有太多区别，只不过 <code>cookie-based</code> 里面写到 <code>cookie</code> 里面的 <code>ticket</code> 在这种方式下称为 <code>token</code>，这个 <code>token</code> 在返回给客户端之后，后续请求都必须通过 <code>url</code> 参数或者是 <code>http header</code> 的形式，主动带上 <code>token</code>，这样服务端接收到请求之后就能直接从 <code>http header</code> 或者 <code>url</code> 里面取到 <code>token</code> 进行验证：</p><p><img src="http://static.cyblogs.com/459873-20161120210044154-648255641.png" alt="http://static.cyblogs.com/459873-20161120210044154-648255641.png"></p><p>这种方式不通过 <code>cookie</code> 进行 <code>token</code> 的传递，而是每次请求的时候，主动把 <code>token</code> 加到 <code>http header</code> 里面或者 <code>url</code> 后面，所以即使在 <code>native app</code> 里面也能使用它来调用我们通过 <code>web</code> 发布的 <code>api</code> 接口。<code>app</code> 里面还要做两件事情：</p><p>1）有效存储 <code>token</code>，得保证每次调接口的时候都能从同一个位置拿到同一个 <code>token</code>；</p><p>2）每次调接口的的代码里都得把 <code>token</code> 加到 <code>header</code> 或者接口地址里面。</p><p>看起来麻烦，其实也不麻烦，这两件事情，对于 <code>app</code> 来说，很容易做到，只要对接口调用的模块稍加封装即可。</p><p>这种方式同样适用于网页应用，<code>token</code> 可以存于 <code>localStorage</code> 或者 <code>sessionStorage</code> 里面，然后每发 <code>ajax</code> 请求的时候，都把 <code>token</code> 拿出来放到 <code>ajax</code> 请求的 <code>header</code> 里即可。不过如果是非接口的请求，比如直接通过点击链接请求一个页面这种，是无法自动带上 <code>token</code> 的。所以这种方式也仅限于走纯接口的 <code>web</code> 应用。</p><p>这种方式用在 <code>web</code> 应用里也有跨域的问题，比如应用如果部署在 <code>a.com</code>，<code>api</code> 服务部署在 <code>b.com</code>，从 <code>a.com</code> 里面发出 <code>ajax</code> 请求到 <code>b.com</code>，默认情况下是会报跨域错误的，这种问题可以用 <code>CORS</code>（<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享</a>）的方式来快速解决，相关细节可去阅读前面给出的 <code>CORS</code> 文章详细了解。</p><p>这种方式跟 <code>cookie-based</code> 的方式同样都还有的一个问题就是 <code>ticket</code> 或者 <code>token</code> 刷新的问题。有的产品里面，你肯定不希望用户登录后，操作了半个小时，结果 <code>ticket</code> 或者 <code>token</code> 到了过期时间，然后用户又得去重新登录的情况出现。这个时候就得考虑 <code>ticket</code> 或 <code>token</code> 的自动刷新的问题，简单来说，可以在验证 <code>ticket</code> 或 <code>token</code> 有效之后，自动把 <code>ticket</code> 或 <code>token</code> 的失效时间延长，然后把它再返回给客户端；客户端如果检测到服务器有返回新的 <code>ticket</code> 或 <code>token</code>，就替换原来的 <code>ticket</code> 或 <code>token</code>。</p><h4 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4. 安全问题"></a>4. 安全问题</h4><p>在 <code>web</code> 应用里面，会话管理的安全性始终是最重要的安全问题，这个对用户的影响极大。</p><p>首先从会话管理凭证来说，第一种方式的会话凭证仅仅是一个 <code>session id</code>，所以只要这个 <code>session id</code> 足够随机，而不是一个自增的数字 <code>id</code> 值，那么其它人就不可能轻易地冒充别人的 <code>session id</code> 进行操作；第二种方式的凭证（ticket）以及第三种方式的凭证（<code>token</code>）都是一个在服务端做了数字签名，和加密处理的串，所以只要密钥不泄露，别人也无法轻易地拿到这个串中的有效信息并对它进行篡改。总之，这三种会话管理方式的凭证本身是比较安全的。</p><p>然后从客户端和服务端的 <code>http</code> 过程来说，当别人截获到客户端请求中的会话凭证，就能拿这个凭证冒充原用户，做一些非法操作，而服务器也认不出来。这种安全问题，可以简单采用 <code>https</code> 来解决，虽然可能还有 <code>http</code> 劫持这种更高程度的威胁存在，但是我们从代码能做的防范，确实也就是这个层次了。</p><p>最后的安全问题就是 <code>CSRF</code>（跨站请求伪造）。这个跟代码有很大关系，本质上它就是代码的漏洞，只不过一般情况下这些漏洞，作为开发人员都不容易发现，只有那些一门心思想搞些事情的人才会专门去找这些漏洞，所以这种问题的防范更多地还是依赖于开发人员对这种攻击方式的了解，包括常见的攻击形式和应对方法。不管凭证信息本身多么安全，别人利用 <code>CSRF</code>，就能拿到别人的凭证，然后用它冒充别人进行非法操作，所以有时间还真得多去了解下它的相关资料才行。举例来说，假如我们把凭证直接放到 url 后面进行传递，就有可能成为一个 <code>CSRF</code> 的漏洞：当恶意用户在我们的应用内上传了 1 张引用了他自己网站的图片，当正常的用户登录之后访问的页面里面包含这个图片的时候，由于这个图片加载的时候会向恶意网站发送 <code>get</code> 请求；当恶意网站收到请求的时候，就会从这个请求的 <code>Reffer header</code> 里面看到包含这个图片的页面地址，而这个地址正好包含了正常用户的会话凭证；于是恶意用户就拿到了正常用户的凭证；只要这个凭证还没失效，他就能用它冒充用户进行非法操作。</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p>前面这三种方式，各自有各自的优点及使用场景，我觉得没有哪个是最好的，做项目的时候，根据项目将来的扩展情况和架构情况，才能决定用哪个是最合适的。本文的目的也就是想介绍这几种方式的原理，以便掌握 web 应用中登录验证的关键因素。</p><p>作为一个前端开发人员，本文虽然介绍了 3 种会话管理的方式，但是与前端关系最紧密的还是第三种方式，毕竟现在前端开发 <code>SPA</code> 应用以及 <code>hybrid</code> 应用已经非常流行了，所以掌握好这个方式的认证过程和使用方式，对前端来说，显然是很有帮助的。好在这个方式的技术其实早就有很多实现了，而且还有现成的标准可用，这个标准就是 <code>JWT(json-web-token)</code>。</p><p><code>JWT</code> 本身并没有做任何技术实现，它只是定义了 <code>token-based</code> 的管理方式该如何实现，它规定了 <code>token</code> 的应该包含的标准内容以及 <code>token</code> 的生成过程和方法。目前实现了这个标准的技术已经有非常多：</p><p><img src="http://static.cyblogs.com/459873-20161120210045904-1163191341.png" alt="http://static.cyblogs.com/459873-20161120210045904-1163191341.png"></p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.cnblogs.com/lyzg/p/6067766.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyzg/p/6067766.html</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;http&lt;/code&gt; 是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/tags/Java/"/>
    
      <category term="会话" scheme="http://www.cyblogs.com/tags/%E4%BC%9A%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean解决循环依赖为什么是三级缓存？</title>
    <link href="http://www.cyblogs.com/2020/06/06/2020/06/Spring%20Bean%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/06/06/2020/06/Spring%20Bean%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F/</id>
    <published>2020-06-05T16:00:00.000Z</published>
    <updated>2020-08-02T15:02:33.714Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>循环依赖：就是N个类循环(嵌套)引用</strong>。 通俗的讲就是N个Bean互相引用对方，最终形成<code>闭环</code>。用一副经典的图示可以表示成这样（A、B、C都代表对象，虚线代表引用关系）： </p><p><img src="http://static.cyblogs.com/mxuio3xfqc.png" alt="http://static.cyblogs.com/mxuio3xfqc.png"></p><blockquote><p> 注意：其实可以N=1，也就是极限情况的循环依赖：<code>自己依赖自己</code> </p><p> 另需注意：这里指的循环引用不是方法之间的循环调用，<strong>而是对象的相互依赖关系</strong>。（方法之间循环调用若有出口也是能够正常work的） </p></blockquote><p>可以设想一下这个场景：如果在日常开发中我们用new对象的方式，若构造函数之间发生这种<strong>循环依赖</strong>的话，程序会在运行时一直循环调用<strong>最终导致内存溢出</strong>，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>这是一个典型的循环依赖问题。本文说一下<code>Spring</code>是如果巧妙的解决平时我们会遇到的<code>三大循环依赖问题</code>的~</p><h4 id="Spring-Bean的循环依赖"><a href="#Spring-Bean的循环依赖" class="headerlink" title="Spring Bean的循环依赖"></a>Spring Bean的循环依赖</h4><p>谈到<code>Spring Bean</code>的循环依赖，有的小伙伴可能比较陌生，毕竟开发过程中好像对<code>循环依赖</code>这个概念<strong>无感知</strong>。其实不然，你有这种错觉，权是因为你工作在Spring的<code>襁褓</code>中，从而让你“高枕无忧”~ <strong>我十分坚信，小伙伴们在平时业务开发中一定一定写过如下结构的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl</span> <span class="keyword">implements</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServiceImpl</span> <span class="keyword">implements</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是Spring环境下典型的循环依赖场景。但是很显然，这种循环依赖场景，Spring已经完美的帮我们解决和规避了问题。所以即使平时我们这样循环引用，也能够整成进行我们的coding之旅~</p><h5 id="Spring中三大循环依赖场景演示"><a href="#Spring中三大循环依赖场景演示" class="headerlink" title="Spring中三大循环依赖场景演示"></a>Spring中<code>三大循环依赖场景</code>演示</h5><p>在Spring环境中，因为我们的Bean的实例化、初始化都是交给了容器，因此它的循环依赖主要表现为下面三种场景。为了方便演示，我准备了如下两个类： </p><h6 id="1、构造器注入循环依赖"><a href="#1、构造器注入循环依赖" class="headerlink" title="1、构造器注入循环依赖"></a>1、构造器注入循环依赖</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：项目启动失败抛出异常<code>BeanCurrentlyInCreationException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">'a'</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.beforeSingletonCreation(DefaultSingletonBeanRegistry.java:<span class="number">339</span>)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">215</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">318</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">199</span>)</span><br></pre></td></tr></table></figure><blockquote><p> 构造器注入构成的循环依赖，此种循环依赖方式<strong>是无法解决的</strong>，只能抛出<code>BeanCurrentlyInCreationException</code>异常表示循环依赖。这也是构造器注入的最大劣势（它有很多独特的优势，请小伙伴自行发掘） </p><p> <code>根本原因</code>：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是<code>已经实例化</code>，但还没初始化的状态。而构造器是完成实例化的东东，所以构造器的循环依赖无法解决<del>~</del> </p></blockquote><h6 id="2、field属性注入（setter方法注入）循环依赖"><a href="#2、field属性注入（setter方法注入）循环依赖" class="headerlink" title="2、field属性注入（setter方法注入）循环依赖"></a>2、field属性注入（setter方法注入）循环依赖</h6><p>这种方式是我们<strong>最最最最</strong>为常用的依赖注入方式（所以猜都能猜到它肯定不会有问题啦）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：项目启动成功，能够正常work</strong></p><blockquote><p> 备注：setter方法注入方式因为原理和字段注入方式类似，此处不多加演示 </p></blockquote><h6 id="3、prototype-field属性注入循环依赖"><a href="#3、prototype-field属性注入循环依赖" class="headerlink" title="3、prototype field属性注入循环依赖"></a>3、<code>prototype</code> field属性注入循环依赖</h6><p><code>prototype</code>在平时使用情况较少，但是也并不是不会使用到，因此此种方式也需要引起重视。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<strong>需要注意的是</strong>本例中<strong>启动时是不会报错的</strong>（因为非单例Bean<code>默认</code>不会初始化，而是使用时才会初始化），所以很简单咱们只需要手动<code>getBean()</code>或者在一个单例Bean内<code>@Autowired</code>一下它即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单例Bean内注入</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> A a;</span><br></pre></td></tr></table></figure><p>这样子启动就报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'mytest.TestSpringBean'</span>: Unsatisfied dependency expressed through field <span class="string">'a'</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'a'</span>: Unsatisfied dependency expressed through field <span class="string">'b'</span>; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">'b'</span>: Unsatisfied dependency expressed through field <span class="string">'a'</span>; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">'a'</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line"></span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:<span class="number">596</span>)</span><br><span class="line">at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:<span class="number">90</span>)</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:<span class="number">374</span>)</span><br></pre></td></tr></table></figure><p>如何解决？？？ 可能有的小伙伴看到网上有说使用<code>@Lazy</code>注解解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> A a;</span><br></pre></td></tr></table></figure><p>此处负责任的告诉你这样是解决不了问题的(<strong>可能会掩盖问题</strong>)，<code>@Lazy</code>只是延迟初始化而已，当你真正使用到它（初始化）的时候，依旧会报如上异常。</p><p>对于Spring循环依赖的情况总结如下：</p><ol><li>不能解决的情况： 1. 构造器注入循环依赖 2. <code>prototype</code> field属性注入循环依赖</li><li>能解决的情况： 1. field属性注入（setter方法注入）循环依赖</li></ol><h4 id="Spring解决循环依赖的原理分析"><a href="#Spring解决循环依赖的原理分析" class="headerlink" title="Spring解决循环依赖的原理分析"></a>Spring解决循环依赖的原理分析</h4><p>在这之前需要明白java中所谓的<code>引用传递</code>和<code>值传递</code>的区别。</p><blockquote><p> 说明：看到这句话可能有小伙伴就想喷我了。java中明明都是传递啊，这是我初学java时背了100遍的面试题，怎么可能有错？？？ 这就是我做这个申明的必要性：伙计，你的说法是正确的，<code>java中只有值传递</code>。但是本文借用<code>引用传递</code>来辅助讲解，希望小伙伴明白我想表达的意思~ </p></blockquote><p><strong><code>Spring的循环依赖的理论依据基于Java的引用传递</code></strong>，当获得对象的引用时，<strong>对象的属性是可以延后设置的</strong>。（但是构造器必须是在获取引用之前，毕竟你的引用是靠构造器给你生成的，儿子能先于爹出生？哈哈）</p><h5 id="Spring创建Bean的流程"><a href="#Spring创建Bean的流程" class="headerlink" title="Spring创建Bean的流程"></a>Spring创建Bean的流程</h5><p>首先需要了解是Spring它创建Bean的流程，我把它的大致调用栈绘图如下： </p><p><img src="http://static.cyblogs.com/oepgq3cnb0.png" alt="http://static.cyblogs.com/oepgq3cnb0.png"></p><p> 对Bean的创建最为核心三个方法解释如下：</p><ul><li><code>createBeanInstance</code>：例化，其实也就是调用对象的<strong>构造方法</strong>实例化对象</li><li><code>populateBean</code>：填充属性，这一步主要是对bean的依赖属性进行注入(<code>@Autowired</code>)</li><li><code>initializeBean</code>：回到一些形如<code>initMethod</code>、<code>InitializingBean</code>等方法</li></ul><p>从对<code>单例Bean</code>的初始化可以看出，循环依赖主要发生在<strong>第二步（populateBean）</strong>，也就是field属性注入的处理。</p><h5 id="Spring容器的-39-三级缓存-39"><a href="#Spring容器的-39-三级缓存-39" class="headerlink" title="Spring容器的&#39;三级缓存&#39;"></a>Spring容器的<code>&#39;三级缓存&#39;</code></h5><p>在Spring容器的整个声明周期中，单例Bean有且仅有一个对象。这很容易让人想到可以用缓存来加速访问。 从源码中也可以看出Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至不惜使用了“三级缓存”，这也便是它设计的精妙之处~</p><p><code>三级缓存</code>其实它更像是Spring容器工厂的内的<code>术语</code>，采用三级缓存模式来解决循环依赖问题，这三级缓存分别指：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 从上至下 分表代表这“三级缓存”</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>); <span class="comment">//一级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>); <span class="comment">// 二级缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>); <span class="comment">// 三级缓存</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line"><span class="comment">// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~</span></span><br><span class="line"><span class="comment">// 它在Bean开始创建时放值，创建完成时会将其移出~</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans that have already been created at least once. */</span></span><br><span class="line"><span class="comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span></span><br><span class="line"><span class="comment">// 至少被创建了一次的  都会放进这里~~~~</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<code>AbstractBeanFactory</code>继承自<code>DefaultSingletonBeanRegistry</code>~</p><ol><li><code>singletonObjects</code>：用于存放完全初始化好的 bean，<strong>从该缓存中取出的 bean 可以直接使用</strong></li><li><code>earlySingletonObjects</code>：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖</li><li><code>singletonFactories</code>：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖</li></ol><p><strong>获取单例Bean的源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isActuallyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先从<code>一级缓存singletonObjects</code>中去获取。（如果获取到就直接return）</li><li>如果获取不到或者对象正在创建中（<code>isSingletonCurrentlyInCreation()</code>），那就再从<code>二级缓存earlySingletonObjects</code>中获取。（如果获取到就直接return）</li><li>如果还是获取不到，且允许singletonFactories（allowEarlyReference=true）通过<code>getObject()</code>获取。就从<code>三级缓存singletonFactory</code>.getObject()获取。<strong>（如果获取到了就从</strong><code>**singletonFactories**</code><strong>中移除，并且放进</strong><code>**earlySingletonObjects**</code><strong>。其实也就是从三级缓存</strong><code>**移动（是剪切、不是复制哦~）**</code><strong>到了二级缓存）</strong></li></ol><blockquote><p> <strong>加入<code>singletonFactories</code>三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决</strong> </p></blockquote><p><code>getSingleton()</code>从缓存里获取单例对象步骤分析可知，Spring解决循环依赖的诀窍：<strong>就在于singletonFactories这个三级缓存</strong>。这个Cache里面都是<code>ObjectFactory</code>，它是解决问题的关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它可以将创建对象的步骤封装到ObjectFactory中 交给自定义的Scope来选择是否需要创建对象来灵活的实现scope。  具体参见Scope接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 经过ObjectFactory.getObject()后，此时放进了二级缓存<code>earlySingletonObjects</code>内。这个时候对象已经实例化了，<code>虽然还不完美</code>，但是对象的引用已经可以被其它引用了。 </p></blockquote><p><strong>此处说一下二级缓存<code>earlySingletonObjects</code>它里面的数据什么时候添加什么移除？？?</strong></p><p><strong>添加</strong>：向里面添加数据只有一个地方，就是上面说的<code>getSingleton()</code>里从三级缓存里挪过来 <strong>移除</strong>：<code>addSingleton、addSingletonFactory、removeSingleton</code>从语义中可以看出添加单例、添加单例工厂<code>ObjectFactory</code>的时候都会删除二级缓存里面对应的缓存值，是互斥的</p><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p><code>Spring</code>容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持在这个池中，而对于创建完毕的Bean将从<code>当前创建Bean池</code>中清除掉。 这个“当前创建Bean池”指的是上面提到的<code>singletonsCurrentlyInCreation</code>那个集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType, @Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line"><span class="comment">// 先去获取一次，如果不为null，此处就会走缓存了~~</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 如果不是只检查类型，那就标记这个Bean被创建了~~添加到缓存里 也就是所谓的  当前创建Bean池</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个getSingleton方法不是SingletonBeanRegistry的接口方法  属于实现类DefaultSingletonBeanRegistry的一个public重载方法~~~</span></span><br><span class="line"><span class="comment">// 它的特点是在执行singletonFactory.getObject();前后会执行beforeSingletonCreation(beanName);和afterSingletonCreation(beanName);  </span></span><br><span class="line"><span class="comment">// 也就是保证这个Bean在创建过程中，放入正在创建的缓存池里  可以看到它实际创建bean调用的是我们的createBean方法~~~~</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法createBean所在地  这个接口方法是属于抽象父类AbstractBeanFactory的   实现在这个抽象类里</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">AutowireCapableBeanFactory</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建Bean对象，并且将对象包裹在BeanWrapper 中</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line"><span class="comment">// 再从Wrapper中把Bean原始对象（非代理~~~）  这个时候这个Bean就有地址值了，就能被引用了~~~</span></span><br><span class="line"><span class="comment">// 注意：此处是原始对象，这点非常的重要</span></span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// earlySingletonExposure 用于表示是否”提前暴露“原始对象的引用，用于解决循环依赖。</span></span><br><span class="line"><span class="comment">// 对于单例Bean，该变量一般为 true   但你也可以通过属性allowCircularReferences = false来关闭循环引用</span></span><br><span class="line"><span class="comment">// isSingletonCurrentlyInCreation(beanName) 表示当前bean必须在创建中才行</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName + <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面讲过调用此方法放进一个ObjectFactory，二级缓存会对应删除的</span></span><br><span class="line"><span class="comment">// getEarlyBeanReference的作用：调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference()这个方法  否则啥都不做</span></span><br><span class="line"><span class="comment">// 也就是给调用者个机会，自己去实现暴露这个bean的应用的逻辑~~~</span></span><br><span class="line"><span class="comment">// 比如在getEarlyBeanReference()里可以实现AOP的逻辑~~~  参考自动代理创建器AbstractAutoProxyCreator  实现了这个方法来创建代理对象</span></span><br><span class="line"><span class="comment">// 若不需要执行AOP的逻辑，直接返回Bean</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line">Object exposedObject = bean; <span class="comment">//exposedObject 是最终返回的对象</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 填充属于，解决@Autowired依赖~</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 执行初始化回调方法们~~~</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// earlySingletonExposure：如果你的bean允许被早期暴露出去 也就是说可以被循环引用  那这里就会进行检查</span></span><br><span class="line"><span class="comment">// 此段代码非常重要~~~~~但大多数人都忽略了它</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 此时一级缓存肯定还没数据，但是呢此时候二级缓存earlySingletonObjects也没数据</span></span><br><span class="line"><span class="comment">//注意，注意：第二参数为false  表示不会再去三级缓存里查了~~~</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处非常巧妙的一点：：：因为上面各式各样的实例化、初始化的后置处理器都执行了，如果你在上面执行了这一句</span></span><br><span class="line"><span class="comment">//  ((ConfigurableListableBeanFactory)this.beanFactory).registerSingleton(beanName, bean);</span></span><br><span class="line"><span class="comment">// 那么此处得到的earlySingletonReference 的引用最终会是你手动放进去的Bean最终返回，完美的实现了"偷天换日" 特别适合中间件的设计</span></span><br><span class="line"><span class="comment">// 我们知道，执行完此doCreateBean后执行addSingleton()  其实就是把自己再添加一次  **再一次强调，完美实现偷天换日**</span></span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个意思是如果经过了initializeBean()后，exposedObject还是木有变，那就可以大胆放心的返回了</span></span><br><span class="line"><span class="comment">// initializeBean会调用后置处理器，这个时候可以生成一个代理对象，那这个时候它哥俩就不会相等了 走else去判断吧</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// allowRawInjectionDespiteWrapping这个值默认是false</span></span><br><span class="line"><span class="comment">// hasDependentBean：若它有依赖的bean 那就需要继续校验了~~~(若没有依赖的 就放过它~)</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line"><span class="comment">// 拿到它所依赖的Bean们~~~~ 下面会遍历一个一个的去看~~</span></span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个个检查它所以Bean</span></span><br><span class="line"><span class="comment">// removeSingletonIfCreatedForTypeCheckOnly这个放见下面  在AbstractBeanFactory里面</span></span><br><span class="line"><span class="comment">// 简单的说，它如果判断到该dependentBean并没有在创建中的了的情况下,那就把它从所有缓存中移除~~~  并且返回true</span></span><br><span class="line"><span class="comment">// 否则（比如确实在创建中） 那就返回false 进入我们的if里面~  表示所谓的真正依赖</span></span><br><span class="line"><span class="comment">//（解释：就是真的需要依赖它先实例化，才能实例化自己的依赖）</span></span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若存在真正依赖，那就报错（不要等到内存移除你才报错，那是非常不友好的） </span></span><br><span class="line"><span class="comment">// 这个异常是BeanCurrentlyInCreationException，报错日志也稍微留意一下，方便定位错误~~~~</span></span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line"><span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line"><span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line"><span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然是remove方法 但是它的返回值也非常重要</span></span><br><span class="line"><span class="comment">// 该方法唯一调用的地方就是循环依赖的最后检查处~~~~~</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeSingletonIfCreatedForTypeCheckOnly</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果这个bean不在创建中  比如是ForTypeCheckOnly的  那就移除掉</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">removeSingleton(beanName);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里举例：例如是<code>field</code>属性依赖注入，在<code>populateBean</code>时它就会先去完成它所依赖注入的那个bean的实例化、初始化过程，最终返回到本流程继续处理，<strong>因此Spring这样处理是不存在任何问题的。</strong></p><p>这里有个小细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一句如果<code>exposedObject == bean</code>表示最终返回的对象就是原始对象，说明在<code>populateBean</code>和<code>initializeBean</code>没对他代理过，那就啥话都不说了<code>exposedObject = earlySingletonReference</code>，最终把二级缓存里的引用返回即可~</p><h4 id="流程总结（非常重要）"><a href="#流程总结（非常重要）" class="headerlink" title="流程总结（非常重要）"></a>流程总结（<code>非常重要</code>）</h4><p>此处以如上的A、B类的互相依赖注入为例，在这里表达出<strong>关键代码</strong>的走势：</p><p>1、入口处即是<strong>实例化、初始化A这个单例Bean</strong>。<code>AbstractBeanFactory.doGetBean(&quot;a&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">... </span><br><span class="line"><span class="comment">// 标记beanName a是已经创建过至少一次的~~~ 它会一直存留在缓存里不会被移除（除非抛出了异常）</span></span><br><span class="line"><span class="comment">// 参见缓存Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256))</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时a不存在任何一级缓存中，且不是在创建中  所以此处返回null</span></span><br><span class="line"><span class="comment">// 此处若不为null，然后从缓存里拿就可以了(主要处理FactoryBean和BeanFactory情况吧)</span></span><br><span class="line">Object beanInstance = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这个getSingleton方法非常关键。</span></span><br><span class="line"><span class="comment">//1、标注a正在创建中~</span></span><br><span class="line"><span class="comment">//2、调用singletonObject = singletonFactory.getObject();（实际上调用的是createBean()方法）  因此这一步最为关键</span></span><br><span class="line"><span class="comment">//3、此时实例已经创建完成  会把a移除整整创建的缓存中</span></span><br><span class="line"><span class="comment">//4、执行addSingleton()添加进去。（备注：注册bean的接口方法为registerSingleton，它依赖于addSingleton方法）</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123; ... <span class="keyword">return</span> createBean(beanName, mbd, args); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、下面进入到最为复杂的<code>AbstractAutowireCapableBeanFactory.createBean/doCreateBean()</code>环节，创建A的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 使用构造器/工厂方法   instanceWrapper是一个BeanWrapper</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line"><span class="comment">// 此处bean为"原始Bean"   也就是这里的A实例对象：A@1234</span></span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 是否要提前暴露（允许循环依赖）  现在此处A是被允许的</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许暴露，就把A绑定在ObjectFactory上，注册到三级缓存`singletonFactories`里面去保存着</span></span><br><span class="line"><span class="comment">// Tips:这里后置处理器的getEarlyBeanReference方法会被促发，自动代理创建器在此处创建代理对象（注意执行时机 为执行三级缓存的时候）</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// exposedObject 为最终返回的对象，此处为原始对象bean也就是A@1234,下面会有用处</span></span><br><span class="line">Object exposedObject = bean; </span><br><span class="line"><span class="comment">// 给A@1234属性完成赋值，@Autowired在此处起作用~</span></span><br><span class="line"><span class="comment">// 因此此处会调用getBean("b")，so 会重复上面步骤创建B类的实例</span></span><br><span class="line"><span class="comment">// 此处我们假设B已经创建好了 为B@5678</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是在populateBean("b")的时候依赖有beanA，所以此时候调用getBean("a")最终会调用getSingleton("a")，</span></span><br><span class="line"><span class="comment">//此时候上面说到的getEarlyBeanReference方法就会被执行。这也解释为何我们@Autowired是个代理对象，而不是普通对象的根本原因</span></span><br><span class="line"></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 实例化。这里会执行后置处理器BeanPostProcessor的两个方法</span></span><br><span class="line"><span class="comment">// 此处注意：postProcessAfterInitialization()是有可能返回一个代理对象的，这样exposedObject 就不再是原始对象了  特备注意哦~~~</span></span><br><span class="line"><span class="comment">// 比如处理@Aysnc的AsyncAnnotationBeanPostProcessor它就是在这个时间里生成代理对象的（有坑，请小心使用@Aysnc）</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 至此，相当于A@1234已经实例化完成、初始化完成（属性也全部赋值了~）</span></span><br><span class="line"><span class="comment">// 这一步我把它理解为校验：校验：校验是否有循环引用问题~~~~~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 注意此处第二个参数传的false，表示不去三级缓存里singletonFactories再去调用一次getObject()方法了~~~</span></span><br><span class="line"><span class="comment">// 上面建讲到了由于B在初始化的时候，会触发A的ObjectFactory.getObject()  所以a此处已经在二级缓存earlySingletonObjects里了</span></span><br><span class="line"><span class="comment">// 因此此处返回A的实例：A@1234</span></span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个等式表示，exposedObject若没有再被代理过，这里就是相等的</span></span><br><span class="line"><span class="comment">// 显然此处我们的a对象的exposedObject它是没有被代理过的  所以if会进去~</span></span><br><span class="line"><span class="comment">// 这种情况至此，就全部结束了~~~</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续以A为例，比如方法标注了@Aysnc注解，exposedObject此时候就是一个代理对象，因此就会进到这里来</span></span><br><span class="line"><span class="comment">//hasDependentBean(beanName)是肯定为true，因为getDependentBeans(beanName)得到的是["b"]这个依赖</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A@1234依赖的是["b"]，所以此处去检查b</span></span><br><span class="line"><span class="comment">// 如果最终存在实际依赖的bean：actualDependentBeans不为空 那就抛出异常  证明循环引用了~</span></span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="comment">// 这个判断原则是：如果此时候b并还没有创建好，this.alreadyCreated.contains(beanName)=true表示此bean已经被创建过，就返回false</span></span><br><span class="line"><span class="comment">// 若该bean没有在alreadyCreated缓存里，就是说没被创建过(其实只有CreatedForTypeCheckOnly才会是此仓库)</span></span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line"><span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line"><span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line"><span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于关键代码部分的步骤不太好拆分，为了更具象表达，那么使用下面一副图示帮助小伙伴们理解： </p><p><img src="http://static.cyblogs.com/qv40e3auxf.png" alt="http://static.cyblogs.com/qv40e3auxf.png"></p><p><strong>最后的最后，由于我太暖心了_，再来个纯文字版的总结。</strong> 依旧以上面<code>A</code>、<code>B</code>类使用属性<code>field</code>注入循环依赖的例子为例，对整个流程做文字步骤总结如下：</p><ol><li>使用<code>context.getBean(A.class)</code>，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走<strong>A的创建之路~</strong></li><li><code>实例化</code>A（注意此处仅仅是实例化），并将它放进<code>缓存</code>（此时A已经实例化完成，已经可以被引用了）</li><li><code>初始化</code>A：<code>@Autowired</code>依赖注入B（此时需要去容器内获取B）</li><li>为了完成依赖注入B，会通过<code>getBean(B)</code>去容器内找B。但此时B在容器内不存在，就走向<strong>B的创建之路~</strong></li><li><code>实例化</code>B，并将其放入缓存。（此时B也能够被引用了）</li><li><code>初始化</code>B，<code>@Autowired</code>依赖注入A（此时需要去容器内获取A）</li><li><code>此处重要</code>：初始化B时会调用<code>getBean(A)</code>去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以<code>getBean(A)</code>能够正常返回</li><li><strong>B初始化成功</strong>（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的<code>getBean(B)</code>这句代码，回到了初始化A的流程中~）。</li><li>因为B实例已经成功返回了，因此最终<strong>A也初始化成功</strong></li><li><strong>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~</strong></li></ol><p>站的角度高一点，宏观上看Spring处理循环依赖的整个流程就是如此。希望这个宏观层面的总结能更加有助于小伙伴们对Spring解决循环依赖的原理的了解，<strong>同时也顺便能解释为何构造器循环依赖就不好使的原因。</strong></p><h5 id="循环依赖对AOP代理对象创建流程和结果的影响"><a href="#循环依赖对AOP代理对象创建流程和结果的影响" class="headerlink" title="循环依赖对AOP代理对象创建流程和结果的影响"></a>循环依赖对AOP代理对象创建<code>流程和结果</code>的影响</h5><p>我们都知道<strong>Spring AOP、事务</strong>等都是通过代理对象来实现的，而<strong>事务</strong>的代理对象是由自动代理创建器来自动完成的。也就是说Spring最终给我们放进容器里面的是一个代理对象，<strong>而非原始对象</strong>。</p><p>本文结合<code>循环依赖</code>，回头再看AOP代理对象的创建过程，和最终放进容器内的动作，非常有意思。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"service hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此<code>Service</code>类使用到了事务，所以最终会生成一个JDK动态代理对象<code>Proxy</code>。刚好它又存在<code>自己引用自己</code>的循环依赖。看看这个Bean的创建概要描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">( ... )</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段告诉我们：如果允许循环依赖的话，此处会添加一个ObjectFactory到三级缓存里面，以备创建对象并且提前暴露引用~</span></span><br><span class="line"><span class="comment">// 此处Tips：getEarlyBeanReference是后置处理器SmartInstantiationAwareBeanPostProcessor的一个方法，它的功效为：</span></span><br><span class="line"><span class="comment">// 保证自己被循环依赖的时候，即使被别的Bean @Autowire进去的也是代理对象~~~~  AOP自动代理创建器此方法里会创建的代理对象~~~</span></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123; <span class="comment">// 需要提前暴露（支持循环依赖），就注册一个ObjectFactory到三级缓存</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处注意：如果此处自己被循环依赖了  那它会走上面的getEarlyBeanReference，从而创建一个代理对象从三级缓存转移到二级缓存里</span></span><br><span class="line"><span class="comment">// 注意此时候对象还在二级缓存里，并没有在一级缓存。并且此时可以知道exposedObject仍旧是原始对象~~~</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过这两大步后，exposedObject还是原始对象（注意此处以事务的AOP为例子的，</span></span><br><span class="line"><span class="comment">// 因为事务的AOP自动代理创建器在getEarlyBeanReference创建代理后，initializeBean就不会再重复创建了，二选一的，下面会有描述~~~）</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环依赖校验（非常重要）~~~~</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 前面说了因为自己被循环依赖了，所以此时候代理对象还在二级缓存里~~~（备注：本利讲解的是自己被循环依赖了的情况）</span></span><br><span class="line"><span class="comment">// so，此处getSingleton，就会把里面的对象拿出来，我们知道此时候它已经是个Proxy代理对象~~~</span></span><br><span class="line"><span class="comment">// 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  </span></span><br><span class="line"><span class="comment">// 这样就保证了我们容器里**最终实际上是代理对象**，而非原始对象~~~~~</span></span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上演示的是<code>代理对象+自己存在循环依赖</code>的case：Spring用三级缓存很巧妙的进行解决了。 若是这种case：代理对象，但是自己并<strong>不存在循环依赖</strong>，过程稍微有点不一样儿了，如下描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">( ... )</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 这些语句依旧会执行，三级缓存里是会加入的  表示它支持被循环引用嘛~~~</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处注意，因为它没有被其它Bean循环引用（注意是循环引用，而不是直接引用~）,所以上面getEarlyBeanReference不会执行~</span></span><br><span class="line"><span class="comment">// 也就是说此时二级缓存里并不会存在它~~~ 知晓这点特别的重要</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 重点在这：AnnotationAwareAspectJAutoProxyCreator自动代理创建器此处的postProcessAfterInitialization方法里，会给创建一个代理对象返回</span></span><br><span class="line"><span class="comment">// 所以此部分执行完成后，exposedObject **已经是个代理对象**而不再是个原始对象了~~~~ 此时二级缓存里依旧无它，更别提一级缓存了</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环依赖校验</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 前面说了一级、二级缓存里都木有它，然后这里传的又是false（表示不看三级缓存~~）</span></span><br><span class="line"><span class="comment">// 所以毋庸置疑earlySingletonReference = null  so下面的逻辑就不用看了，直接return出去~~</span></span><br><span class="line"><span class="comment">// 然后执行addSingleton()方法，由此可知  容器里最终存在的也还是代理对象~~~~~~</span></span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123; <span class="comment">// 这个判断不可少（因为如果initializeBean改变了exposedObject ，就不能这么玩了，否则就是两个对象了~~~）</span></span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line">&#125;...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知，即使自己只需要代理，并不被循环引用，最终存在Spring容器里的<strong>仍旧是</strong>代理对象。（so此时别人直接<code>@Autowired</code>进去的也是代理对象呀<del>~</del>）</p><p><strong>终极case：如果我关闭Spring容器的循环依赖能力，也就是把<code>allowCircularReferences</code>设值为false，那么会不会造成什么问题呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它用于关闭循环引用（关闭后只要有循环引用现象就直接报错~~）</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        ((AbstractAutowireCapableBeanFactory) beanFactory).setAllowCircularReferences(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若关闭了循环依赖后，还存在上面A、B的循环依赖现象，启动便会报错如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">'a'</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.beforeSingletonCreation(DefaultSingletonBeanRegistry.java:<span class="number">339</span>)</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">215</span>)</span><br></pre></td></tr></table></figure><blockquote><p> 注意此处异常类型也是<code>BeanCurrentlyInCreationException</code>异常，但是文案内容和上面强调的有所区别<del>~ 它报错位置在：<code>DefaultSingletonBeanRegistry.beforeSingletonCreation</code>这个位置</del> </p></blockquote><p><code>报错浅析</code>：在实例化A后给其属性赋值时，会去实例化B。B实例化完成后会继续给B属性赋值，这时由于此时我们<code>关闭了循环依赖</code>，所以不存在<code>提前暴露</code>引用这么一说来给实用。因此B无法直接拿到A的引用地址，因此只能又去创建A的实例。<strong>而此时我们知道A其实已经正在创建中了</strong>，不能再创建了。so，就报错了~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为管理了循环依赖，所以此处不能再依赖自己的</span></span><br><span class="line"><span class="comment">// 但是：我们的此bean还是需要AOP代理的~~~</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//private HelloService helloService;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hello</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"service hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样它的大致运行如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">( ... )</span> </span>&#123;</span><br><span class="line"><span class="comment">// 毫无疑问此时候earlySingletonExposure = false  也就是Bean都不会提前暴露引用了  显然就不能被循环依赖了~</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">...</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line"><span class="comment">// 若是事务的AOP  在这里会为源生Bean创建代理对象（因为上面没有提前暴露这个代理）</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">... 这里更不用说，因为earlySingletonExposure=<span class="keyword">false</span>  所以上面的代理对象exposedObject 直接<span class="keyword">return</span>了~</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到即使把这个开关给关了，最终放进容器了的仍旧是代理对象，显然<code>@Autowired</code>给属性赋值的也一定是代理对象。</p><p>最后，以<code>AbstractAutoProxyCreator</code>为例看看自动代理创建器是怎么配合实现：循环依赖+创建代理</p><blockquote><p> <code>AbstractAutoProxyCreator</code>是抽象类，它的三大实现子类<code>InfrastructureAdvisorAutoProxyCreator</code>、<code>AspectJAwareAdvisorAutoProxyCreator</code>、<code>AnnotationAwareAspectJAutoProxyCreator</code>小伙伴们应该会更加的熟悉些 </p></blockquote><p>该抽象类实现了创建代理的动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @since 13.10.2003  它实现代理创建的方法有如下两个</span></span><br><span class="line"><span class="comment">// 实现了SmartInstantiationAwareBeanPostProcessor 所以有方法getEarlyBeanReference来只能的解决循环引用问题：提前把代理对象暴露出去~</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 下面两个方法是自动代理创建器创建代理对象的唯二的两个节点~</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提前暴露代理对象的引用  它肯定在postProcessAfterInitialization之前执行</span></span><br><span class="line"><span class="comment">// 所以它并不需要判断啥的~~~~  创建好后放进缓存earlyProxyReferences里  注意此处value是原始Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为它会在getEarlyBeanReference之后执行，所以此处的重要逻辑是下面的判断</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="comment">// remove方法返回被移除的value，上面说了它记录的是原始bean</span></span><br><span class="line"><span class="comment">// 若被循环引用了，那就是执行了上面的`getEarlyBeanReference`方法，所以此时remove返回值肯定是==bean的（注意此时方法入参的bean还是原始对象）</span></span><br><span class="line"><span class="comment">// 若没有被循环引用，getEarlyBeanReference()不执行 所以remove方法返回null，所以就进入if执行此处的创建代理对象方法~~~</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可知，自动代理创建器它保证了代理对象只会被创建一次，而且支持循环依赖的自动注入的依旧是代理对象。</p><p><strong><code>上面分析了三种case，现给出结论如下：</code></strong> 不管是自己被循环依赖了还是没有，<strong>甚至是把Spring容器的循环依赖给关了</strong>，它对AOP代理的创建流程有影响，<strong>但对结果是无影响的。</strong> 也就是说Spring很好的对调用者屏蔽了这些实现细节，使得使用者使用起来完全的无感知~</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>解决此类问题的关键是要对<code>SpringIOC</code>和<code>DI</code>的整个流程做到心中有数，要理解好本文章，建议有【相关阅读】里文章的大量知识的铺垫，同时呢本文又能<strong>进一步</strong>的帮助小伙伴理解到Spring Bean的实例化、初始化流程。</p><p>本文还是花了我一番心思的，个人觉得对Spring这部分的处理流程描述得还是比较详细的，希望我的总结能够给大家带来帮助。 <strong>另外为了避免循环依赖导致启动问题而又不会解决，有如下建议：</strong></p><ol><li><code>业务代码中</code>尽量不要使用构造器注入，即使它有很多优点。</li><li><code>业务代码中</code>为了简洁，尽量使用field注入而非setter方法注入</li><li>若你注入的同时，立马需要处理一些逻辑（一般见于框架设计中，业务代码中不太可能出现），可以使用setter方法注入辅助完成</li></ol><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://cloud.tencent.com/developer/article/1497692" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1497692</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;循环依赖：就是N个类循环(嵌套)引用&lt;/strong&gt;。 通俗的讲就是N个Bean互相引用对方，最终形成&lt;code&gt;闭环&lt;/
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://www.cyblogs.com/categories/Spring/"/>
    
    
      <category term="SpringBoot" scheme="http://www.cyblogs.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java4种引用类型到底如何用？</title>
    <link href="http://www.cyblogs.com/2020/06/05/2020/06/Java4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E7%94%A8%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/06/05/2020/06/Java4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95%E7%94%A8%EF%BC%9F/</id>
    <published>2020-06-04T16:00:00.000Z</published>
    <updated>2020-08-02T15:02:25.682Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>JDK.1.2</code> 之后，<code>Java</code> 对引用的概念进行了扩充，将引用分为了：</p><ul><li>强引用<code>（Strong Reference）</code></li><li>软引用<code>（Soft Reference）</code></li><li>弱引用<code>（Weak Reference）</code></li><li>虚引用<code>（Phantom Reference）</code>4 种，这 4 种引用的强度依次减弱。不同的引用在垃圾回收中体现也是不一样~</li></ul><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p>我们先创建一个M对象，后面为了方便的感受GC的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:30 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">M</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"finalize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>finalize</code>函数是对象在<code>gc</code>的时候，一定会调用该方法。我们重写一下该方法并且打印一行日志。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，<code>JVM</code>也会直接抛出<code>OutOfMemoryError</code>，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为<code>null</code>，这样一来，<code>JVM</code>就可以适时的回收对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 正常引用/强引用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C001_01_NormalReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        M m = <span class="keyword">new</span> M();</span><br><span class="line">        <span class="comment">// 将对象复制为空</span></span><br><span class="line">        m = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 手动触发GC</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为不是触发gc就一定会立马gc，所以让线程阻塞一下</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台日志输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:53621', transport: 'socket'</span><br><span class="line">finalize</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:53621', transport: 'socket'</span><br></pre></td></tr></table></figure><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 软引用：当内存不足的时候，gc才会回收。非常适合做缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:31 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C001_02_SoftReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 开辟一个20M的空间</span></span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; m = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]);</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 手动GC一下，看是否可以GC掉</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 避免gc不会立马触发，尝试休眠1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 然后再尝试获取</span></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        <span class="comment">// 重新开辟一个空间</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">15</span>];</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为它是在内存不足的时候才会触发，所以我们在跑之前需要设置一下最大堆。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmx20M</span><br></pre></td></tr></table></figure><p>控制台日志输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:54335', transport: 'socket'</span><br><span class="line">[B@4c3e4790</span><br><span class="line">[B@4c3e4790</span><br><span class="line">null</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:54335', transport: 'socket'</span><br></pre></td></tr></table></figure><p>你会发现就算我们<code>gc</code>了，后面还是会<code>get</code>得到，因为空间还足够。当后面<code>byte[] b</code>再继续申请空间的时候，发现空间不足了，这个时候就会触发<code>gc</code>动作，把软引用的部分清除掉。</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 弱引用：是为了解决某些地方的内存泄露问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:32 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C001_03_WeakReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakReference&lt;M&gt; m = <span class="keyword">new</span> WeakReference&lt;M&gt;(<span class="keyword">new</span> M());</span><br><span class="line"></span><br><span class="line">        System.out.println(m.get());</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(m.get());</span><br><span class="line"></span><br><span class="line">        ThreadLocal&lt;M&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;M&gt;();</span><br><span class="line">        tl.set(<span class="keyword">new</span> M());</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台日志输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Connected to the target VM, address: '127.0.0.1:55151', transport: 'socket'</span><br><span class="line">com.cyblogs.java.learning.C001_ReferenceType.M@38cccef</span><br><span class="line">null</span><br><span class="line">finalize</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:55151', transport: 'socket'</span><br></pre></td></tr></table></figure><p>我们看一下<code>ThreadLocal</code>的<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.cyblogs.com/QQ20200616-225739@2x.jpg" alt="http://static.cyblogs.com/QQ20200616-225739@2x.jpg"></p><p>为什么<code>Entry</code>要使用弱引用？</p><ul><li><p>若是强引用，即使<code>tl=null</code>，但是<code>key</code>的引用还是指向<code>ThreadLocal</code>。所以内存会泄露~而弱引用不会</p></li><li><p>但是还会有内存泄露的问题，<code>ThreadLocal</code>被回收。<code>key</code>的值变成了<code>null</code>，则导致<code>value</code>的值再也无法被访问到，因此依然存在内存泄露问题。</p></li></ul><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.java.learning.C001_ReferenceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with java-learning-demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 虚引用：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:33 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C001_04_PhantomReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;M&gt; QUEUE = <span class="keyword">new</span> ReferenceQueue&lt;M&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; LIST = <span class="keyword">new</span> LinkedList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PhantomReference&lt;M&gt; m = <span class="keyword">new</span> PhantomReference&lt;M&gt;(<span class="keyword">new</span> M(), QUEUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                LIST.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(m.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Reference&lt;? extends M&gt; poll = QUEUE.poll();</span><br><span class="line">                <span class="keyword">if</span> (poll != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"虚引用对象被JVM回收了"</span> + poll);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在零拷贝中就会使用到虚引用，但我们又无法去操作对外的内存。因为太弱了，我们也无法感知到~ 这里就需要利用到<code>ReferenceQueue</code>。</p><p><img src="http://static.cyblogs.com/QQ20200616-222909@2x.jpg" alt="http://static.cyblogs.com/QQ20200616-222909@2x.jpg"></p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.bilibili.com/video/BV1iK4y1x7tj" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iK4y1x7tj</a></li><li><a href="https://www.cnblogs.com/liyutian/p/9690974.html" target="_blank" rel="noopener">https://www.cnblogs.com/liyutian/p/9690974.html</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;code&gt;JDK.1.2&lt;/code&gt; 之后，&lt;code&gt;Java&lt;/code&gt; 对引用的概念进行了扩充，将引用分为了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强引用&lt;code&gt;（Strong Reference）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;软引用&lt;code&gt;（Soft R
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>四张图带你了解Tomcat系统架构</title>
    <link href="http://www.cyblogs.com/2020/06/04/2020/06/%E5%9B%9B%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.cyblogs.com/2020/06/04/2020/06/%E5%9B%9B%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Tomcat%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</id>
    <published>2020-06-03T16:00:00.000Z</published>
    <updated>2020-08-02T15:02:15.939Z</updated>
    
    <content type="html"><![CDATA[<p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，<code>Tomcat</code>的结构很复杂，但是 <code>Tomcat</code> 非常的模块化，找到了 <code>Tomcat</code>最核心的模块，问题才可以游刃而解，了解了<code>Tomcat</code>的整体架构对以后深入了解<code>Tomcat</code>来说至关重要！</p><h4 id="一、Tomcat顶层架构"><a href="#一、Tomcat顶层架构" class="headerlink" title="一、Tomcat顶层架构"></a><strong>一、Tomcat顶层架构</strong></h4><p>先上一张<code>Tomcat</code>的顶层结构图（图A），如下：</p><p><img src="http://static.cyblogs.com/5j8j72c1yz.jpg" alt="http://static.cyblogs.com/5j8j72c1yz.jpg"></p><p><code>Tomcat</code>中最顶层的容器是<code>Server</code>，代表着整个服务器，从上图中可以看出，一个<code>Server</code>可以包含至少一个<code>Service</code>，用于具体提供服务。</p><p><code>Service</code>主要包含两个部分：<code>Connector</code>和<code>Container</code>。从上图中可以看出 <code>Tomcat</code> 的心脏就是这两个组件，他们的作用如下：</p><p>1、<code>Connector</code>用于处理连接相关的事情，并提供<code>Socket</code>与<code>Request</code>和<code>Response</code>相关的转化; </p><p>2、<code>Container</code>用于封装和管理Servlet，以及具体处理<code>Request</code>请求；</p><p>一个<code>Tomcat</code>中只有一个<code>Server</code>，一个<code>Server</code>可以包含多个<code>Service</code>，一个<code>Service</code>只有一个<code>Container</code>，但是可以有多个<code>Connectors</code>，这是因为一个服务可以有多个连接，如同时提供<code>Http</code>和<code>Https</code>链接，也可以提供向相同协议不同端口的连接,示意图如下（<code>Engine</code>、<code>Host</code>、<code>Context</code>下边会说到）：</p><p><img src="http://static.cyblogs.com/q0q4dy3ioh.jpg" alt="img"></p><p>多个 <code>Connector</code> 和一个 <code>Container</code> 就形成了一个 <code>Service</code>，有了 <code>Service</code> 就可以对外提供服务了，但是 <code>Service</code> 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 <code>Server</code> 莫属了！所以整个 <code>Tomcat</code> 的生命周期由 <code>Server</code> 控制。</p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的<code>server.xml</code>配置文件中看出，下图是删除了注释内容之后的一个完整的<code>server.xml</code>配置文件（Tomcat版本为8.0）</p><p><img src="http://static.cyblogs.com/ruzbrbmp9e.jpg" alt="img"></p><p>详细的配置文件文件内容可以到<code>Tomcat</code>官网查看：<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-8.0-doc/index.html</a></p><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="http://static.cyblogs.com/pwsqbf6laq.png" alt="img"></p><p><code>Server</code>标签设置的端口号为<code>8005</code>，<code>shutdown=”SHUTDOWN”</code> ，表示在<code>8005</code>端口监听“<code>SHUTDOWN</code>”命令，如果接收到了就会关闭<code>Tomcat</code>。一个<code>Server</code>有一个<code>Service</code>，当然还可以进行配置，一个<code>Service</code>有多个，<code>Service</code>左边的内容都属于<code>Container</code>的，<code>Service</code>下边是<code>Connector</code>。</p><h4 id="二、Tomcat顶层架构小结："><a href="#二、Tomcat顶层架构小结：" class="headerlink" title="二、Tomcat顶层架构小结："></a><strong>二、Tomcat顶层架构小结：</strong></h4><p>（1）<code>Tomcat</code>中只有一个<code>Server</code>，一个<code>Server</code>可以有多个<code>Service</code>，一个<code>Service</code>可以有多个<code>Connector</code>和一个<code>Container</code>；  </p><p>（2） <code>Server</code>掌管着整个<code>Tomcat</code>的生死大权；  </p><p>（3）<code>Service</code> 是对外提供服务的；  </p><p>（4）<code>Connector</code>用于接受请求并将请求封装成<code>Request</code>和<code>Response</code>来具体处理；  </p><p>（5）<code>Container</code>用于封装和管理<code>Servlet</code>，以及具体处理<code>request</code>请求；</p><p>知道了整个<code>Tomcat</code>顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说<code>Server</code>和<code>Service</code>对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于<code>Connector</code>和<code>Container</code>的，所以接下来介绍一下<code>Connector</code>和<code>Container</code>。</p><h4 id="三、Connector和Container的微妙关系"><a href="#三、Connector和Container的微妙关系" class="headerlink" title="三、Connector和Container的微妙关系"></a><strong>三、Connector和Container的微妙关系</strong></h4><p>由上述内容我们大致可以知道一个请求发送到<code>Tomcat</code>之后，首先经过<code>Service</code>然后会交给我们的<code>Connector</code>，<code>Connector</code>用于接收请求并将接收的请求封装为<code>Request</code>和<code>Response</code>来具体处理，<code>Request</code>和<code>Response</code>封装完之后再交由<code>Container</code>进行处理，<code>Container</code>处理完请求之后再返回给<code>Connector</code>，最后在由<code>Connector</code>通过<code>Socket</code>将处理的结果返回给客户端，这样整个请求的就处理完了！</p><p><code>Connector</code>最底层使用的是<code>Socket</code>来进行连接的，<code>Request</code>和<code>Response</code>是按照HTTP协议来封装的，所以<code>Connector</code>同时需要实现<code>TCP/IP</code>协议和<code>HTTP</code>协议！</p><p><code>Tomcat</code>既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下<code>Connector</code>！</p><h4 id="四、Connector架构分析"><a href="#四、Connector架构分析" class="headerlink" title="四、Connector架构分析"></a><strong>四、Connector架构分析</strong></h4><p><code>Connector</code>用于接受请求并将请求封装成<code>Request</code>和<code>Response</code>，然后交给<code>Container</code>进行处理，<code>Container</code>处理完之后在交给<code>Connector</code>返回给客户端。</p><p>因此，我们可以把<code>Connector</code>分为四个方面进行理解：</p><p>（1）<code>Connector</code>如何接受请求的？ </p><p>（2）如何将请求封装成<code>Request</code>和<code>Response</code>的？ </p><p>（3）封装完之后的<code>Request</code>和<code>Response</code>如何交给<code>Container</code>进行处理的？ </p><p>（4）<code>Container</code>处理完之后如何交给<code>Connector</code>并返回给客户端的？</p><p>首先看一下<code>Connector</code>的结构图（图B），如下所示：</p><p><img src="http://static.cyblogs.com/b3o0gef7y5.png" alt="img"></p><p><code>Connector</code>就是使用<code>ProtocolHandler</code>来处理请求的，不同的<code>ProtocolHandler</code>代表不同的连接类型，比如：<code>Http11Protocol</code>使用的是普通<code>Socket</code>来连接的，<code>Http11NioProtocol</code>使用的是<code>NioSocket</code>来连接的。</p><p>其中<code>ProtocolHandler</code>由包含了三个部件：<code>Endpoint</code>、<code>Processor</code>、<code>Adapter</code>。</p><p>（1）<code>Endpoint</code>用来处理底层<code>Socket</code>的网络连接，<code>Processor</code>用于将<code>Endpoint</code>接收到的<code>Socket</code>封装成<code>Request</code>，<code>Adapter</code>用于将<code>Request</code>交给<code>Container</code>进行具体的处理。</p><p>（2）<code>Endpoint</code>由于是处理底层的<code>Socket</code>网络连接，因此<code>Endpoint</code>是用来实现<code>TCP/IP</code>协议的，而<code>Processor</code>用来实现<code>HTTP</code>协议的，<code>Adapter</code>将请求适配到<code>Servlet</code>容器进行具体的处理。</p><p>（3）<code>Endpoint</code>的抽象实现<code>AbstractEndpoint</code>里面定义的<code>Acceptor</code>和<code>AsyncTimeout</code>两个内部类和一个<code>Handler</code>接口。<code>Acceptor</code>用于监听请求，<code>AsyncTimeout</code>用于检查异步<code>Request</code>的超时，<code>Handler</code>用于处理接收到的<code>Socket</code>，在内部调用<code>Processor</code>进行处理。</p><p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下<code>Container</code>是如何进行处理的以及处理完之后是如何将处理完的结果返回给<code>Connector</code>的？</p><h4 id="五、Container架构分析"><a href="#五、Container架构分析" class="headerlink" title="五、Container架构分析"></a><strong>五、Container架构分析</strong></h4><p><code>Container</code>用于封装和管理<code>Servlet</code>，以及具体处理<code>Request</code>请求，在<code>Connector</code>内部包含了4个子容器，结构图如下（图C）：</p><p><img src="http://static.cyblogs.com/fk1p1et9di.png" alt="img"></p><p>4个子容器的作用分别是：</p><p>（1）<code>Engine</code>：引擎，用来管理多个站点，一个<code>Service</code>最多只能有一个<code>Engine</code>； </p><p>（2）<code>Host</code>：代表一个站点，也可以叫虚拟主机，通过配置<code>Host</code>就可以添加站点； </p><p>（3）<code>Context</code>：代表一个应用程序，对应着平时开发的一套程序，或者一个<code>WEB-INF</code>目录以及下面的<code>web.xml</code>文件； </p><p>（4）<code>Wrapper</code>：每一<code>Wrapper</code>封装着一个<code>Servlet</code>；</p><p>下面找一个<code>Tomcat</code>的文件目录对照一下，如下图所示：</p><p><img src="http://static.cyblogs.com/w37kwebdoy.png" alt="img"></p><p><code>Context</code>和<code>Host</code>的区别是<code>Context</code>表示一个应用，我们的<code>Tomcat</code>中默认的配置下<code>webapps</code>下的每一个文件夹目录都是一个<code>Context</code>，其中<code>ROOT</code>目录中存放着主应用，其他目录存放着子应用，而整个<code>webapps</code>就是一个<code>Host</code>站点。</p><p>我们访问应用<code>Context</code>的时候，如果是<code>ROOT</code>下的则直接使用域名就可以访问，例如：<a href="http://www.ledouit.com,如果是`Host（webapps）`下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。" target="_blank" rel="noopener">www.ledouit.com,如果是`Host（webapps）`下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</a></p><p>看到这里我们知道<code>Container</code>是什么，但是还是不知道<code>Container</code>是如何进行处理的以及处理完之后是如何将处理完的结果返回给<code>Connector</code>的？别急！下边就开始探讨一下<code>Container</code>是如何进行处理的！</p><h4 id="六、Container如何处理请求的"><a href="#六、Container如何处理请求的" class="headerlink" title="六、Container如何处理请求的"></a><strong>六、Container如何处理请求的</strong></h4><p><code>Container</code>处理请求是使用<code>Pipeline-Value</code>管道来处理的！</p><p><code>Pipeline-Value</code>是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。</p><p><img src="http://static.cyblogs.com/y6ugeww863.jpg" alt="img"></p><p>但是！<code>Pipeline-Value</code>使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p><p>（1）每个<code>Pipeline</code>都有特定的<code>Value</code>，而且是在管道的最后一个执行，这个<code>Value</code>叫做<code>BaseValue</code>，<code>BaseValue</code>是不可删除的；</p><p>（2）在上层容器的管道的<code>BaseValue</code>中会调用下层容器的管道。</p><p>我们知道<code>Container</code>包含四个子容器，而这四个子容器对应的<code>BaseValue</code>分别在：<code>StandardEngineValue</code>、<code>StandardHostValue</code>、<code>StandardContextValue</code>、<code>StandardWrapperValue</code>。</p><p><code>Pipeline</code>的处理流程图如下（图D）：</p><p><img src="http://static.cyblogs.com/6bewzizid7.png" alt="img"></p><p>（1）<code>Connector</code>在接收到请求后会首先调用最顶层容器的<code>Pipeline</code>来处理，这里的最顶层容器的<code>Pipeline</code>就是<code>EnginePipeline</code>（<code>Engine</code>的管道）；</p><p>（2）在<code>Engine</code>的管道中依次会执行<code>EngineValue1</code>、<code>EngineValue2</code>等等，最后会执行<code>StandardEngineValue</code>，在<code>StandardEngineValue</code>中会调用<code>Host</code>管道，然后再依次执行<code>Host</code>的<code>HostValue1</code>、<code>HostValue2</code>等，最后在执行<code>StandardHostValue</code>，然后再依次调用<code>Context</code>的管道和<code>Wrapper</code>的管道，最后执行到<code>StandardWrapperValue</code>。</p><p>（3）当执行到<code>StandardWrapperValue</code>的时候，会在<code>StandardWrapperValue</code>中创建<code>FilterChain</code>，并调用其<code>doFilter</code>方法来处理请求，这个<code>FilterChain</code>包含着我们配置的与请求相匹配的<code>Filter</code>和<code>Servlet</code>，其<code>doFilter</code>方法会依次调用所有的<code>Filter</code>的<code>doFilter</code>方法和<code>Servlet</code>的<code>service</code>方法，这样请求就得到了处理！</p><p>（4）当所有的<code>Pipeline-Value</code>都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给<code>Connector</code>了，<code>Connector</code>在通过<code>Socket</code>的方式将结果返回给客户端。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>至此，我们已经对<code>Tomcat</code>的整体架构有了大致的了解，从图<code>A、B、C、D</code>可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下<code>Tomcat</code>，上面的内容你能脱口而出吗？当你能够脱口而出的时候，这位面试官一定会对你刮目相看的！</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://cloud.tencent.com/developer/article/1181587" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1181587</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员<code>Vernon</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/Vernon.jpeg" alt="Vernon"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，&lt;code&gt;Tomcat&lt;/code&gt;的结构很复杂，但是 &lt;code&gt;Tomcat&lt;/code&gt; 非常的模块化，找到了 &lt;code&gt;Tomcat&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="Tomcat" scheme="http://www.cyblogs.com/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="http://www.cyblogs.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>神器的布隆过滤器</title>
    <link href="http://www.cyblogs.com/2020/06/03/2020/06/%E7%A5%9E%E5%99%A8%E7%9A%84%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://www.cyblogs.com/2020/06/03/2020/06/%E7%A5%9E%E5%99%A8%E7%9A%84%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2020-06-02T16:00:00.000Z</published>
    <updated>2020-08-02T15:02:04.588Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a><strong>什么是布隆过滤器</strong></h4><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构<code>（probabilistic data structure）</code>，特点是高效地插入和查询，可以用来告诉你 <strong>“某样东西一定不存在或者可能存在”</strong>。</p><p>相比于传统的 <code>List</code>、<code>Set</code>、<code>Map</code> 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h4><h5 id="HashMap-的问题"><a href="#HashMap-的问题" class="headerlink" title="HashMap 的问题"></a>HashMap 的问题</h5><p>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 <code>HashMap</code> 吧，确实可以将值映射到 <code>HashMap</code> 的 <code>Key</code>，然后可以在 <code>O(1)</code> 的时间复杂度内返回结果，效率奇高。但是 <code>HashMap</code> 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 <code>HashMap</code> 占据的内存大小就变得很可观了。</p><p>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 <code>HashMap</code> 的时候，也会存在问题。</p><p><strong>布隆过滤器数据结构</strong></p><p>布隆过滤器是一个 <code>bit</code> 向量或者说 <code>bit</code> 数组，长这样：</p><p><img src="http://static.cyblogs.com/QQ20200618-210117@2x.jpg" alt="http://static.cyblogs.com/QQ20200618-210117@2x.jpg"></p><p>数组里面的值就只会存在<code>true</code>与<code>false</code>。</p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 <code>bit</code> 位置 <code>1</code>，例如针对值 “<code>baidu</code>” 和三个不同的哈希函数分别生成了哈希值则上图转变为：</p><p><img src="http://static.cyblogs.com/QQ20200618-210604@2x.jpg" alt="http://static.cyblogs.com/QQ20200618-210604@2x.jpg"></p><p>而当我们需要查询 “<code>baidu</code>” 这个值是否存在的话，那么哈希函数必然会返回图中的<code>3</code>个<code>bit</code>位，然后我们检查发现这三个 <code>bit</code> 位上的值均为 <code>1</code>，那么我们可以说 “<code>baidu</code>” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p><p>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 <code>1</code> 的 <code>bit</code> 位也会越来越多，这样某个值 “<code>taobao</code>” 即使没有被存储过，但是万一哈希函数返回的三个 <code>bit</code> 位都被其他值置为了 <code>1</code> ，那么程序还是会判断 “<code>taobao</code>” 这个值存在。</p><h4 id="支持删除么"><a href="#支持删除么" class="headerlink" title="支持删除么"></a>支持删除么</h4><p>传统的布隆过滤器并不支持删除操作。但是名为 Counting Bloom filter 的变种可以用来测试元素计数个数是否绝对小于某个阈值，它支持元素删除。可以参考文章 Counting Bloom Filter 的原理和实现：<a href="https://cloud.tencent.com/developer/article/1136056" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1136056</a></p><p>Guava里的布隆过滤器：com.google.common.hash.BloomFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategy.mightContain(object, funnel, numHashFunctions, bits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放入值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategy.put(object, funnel, numHashFunctions, bits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择哈希函数个数和布隆过滤器长度"><a href="#如何选择哈希函数个数和布隆过滤器长度" class="headerlink" title="如何选择哈希函数个数和布隆过滤器长度"></a>如何选择哈希函数个数和布隆过滤器长度</h4><p>很显然，过小的布隆过滤器很快所有的 <code>bit</code> 位均为 <code>1</code>，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p><p>另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 <code>bit</code> 位置位 <code>1</code> 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高。</p><p><img src="http://static.cyblogs.com/QQ20200618-212220@2x.jpg" alt="http://static.cyblogs.com/QQ20200618-212220@2x.jpg"></p><p>我们可以参考网站给的一个参考值：<a href="https://krisives.github.io/bloom-calculator/" target="_blank" rel="noopener">https://krisives.github.io/bloom-calculator/</a></p><p><img src="http://static.cyblogs.com/QQ20200618-212520@2x.jpg" alt="http://static.cyblogs.com/QQ20200618-212520@2x.jpg"></p><p>比如：我们有<code>1000</code>的数量，误判率是<code>0.1</code>，那么需要<code>3.32</code>个<code>hash</code>函数，位的长度为<code>4793</code>。</p><h4 id="Redis-BloomFilter实践"><a href="#Redis-BloomFilter实践" class="headerlink" title="Redis-BloomFilter实践"></a>Redis-BloomFilter实践</h4><p><code>Redis</code>在<code>4.0</code>版本推出了 <code>module</code> 的形式，可以将 <code>module</code> 作为插件额外实现<code>Redis</code>的一些功能。官网推荐了一个 <code>RedisBloom</code> 作为 <code>Redis</code> 布隆过滤器的 <code>Module</code>。</p><p><code>RedisBloom</code>需要先进行安装，推荐使用<code>Docker</code>进行安装，简单方便:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull redislabs/rebloom:latest</span><br><span class="line">docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest</span><br><span class="line">docker exec -it redis-redisbloom bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> redis-cli</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 127.0.0.1:6379&gt; bf.add tiancheng hello</span></span><br></pre></td></tr></table></figure><p>熟悉一下布隆过滤器基本指令:</p><ul><li><code>bf.add</code> 添加元素到布隆过滤器</li><li><code>bf.exists</code> 判断元素是否在布隆过滤器</li><li><code>bf.madd</code> 添加多个元素到布隆过滤器，<code>bf.add</code>只能添加一个</li><li><code>bf.mexists</code> 判断多个元素是否在布隆过滤器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bf.add tiancheng tc01</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add tiancheng tc02</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.add tiancheng tc03</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists tiancheng tc01</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists tiancheng tc02</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists tiancheng tc03</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.exists tiancheng tc04</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bf.madd tiancheng tc05 tc06 tc07</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br><span class="line">3) (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bf.mexists tiancheng tc05 tc06 tc07 tc08</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br><span class="line">3) (integer) 1</span><br><span class="line">4) (integer) 0</span><br></pre></td></tr></table></figure><h4 id="Redis-Bitmap实现简单的布隆过滤器"><a href="#Redis-Bitmap实现简单的布隆过滤器" class="headerlink" title="Redis Bitmap实现简单的布隆过滤器"></a>Redis Bitmap实现简单的布隆过滤器</h4><p><code>Bitmap</code>在<code>Redis</code>中并不是一个单独的数据类型，而是由字符串类型（<code>Redis</code>内部称<code>Simple Dynamic String，SDS</code>）之上定义的与比特相关的操作实现的，此时<code>SDS</code>就被当做位数组了。下面是在<code>redis-cli</code>中使用<code>getbit</code>和<code>setbit</code>指令的操作示例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 字符串<span class="string">"meow"</span>的二进制表示：01101101 01100101 01101111 01110111</span></span><br><span class="line">es1:19000&gt; set bitmap_cat "meow"</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最低位下标为0。取得第3位的比特（0）</span></span><br><span class="line">es1:19000&gt; getbit bitmap_cat 3</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得第23位的比特（1）</span></span><br><span class="line">es1:19000&gt; getbit bitmap_cat 23</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将第7位设为0</span></span><br><span class="line">es1:19000&gt; setbit bitmap_cat 7 0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将第14位设为1</span></span><br><span class="line">es1:19000&gt; setbit bitmap_cat 14 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改过后的字符串变成了<span class="string">"lgow"</span></span></span><br><span class="line">es1:19000&gt; get bitmap_cat</span><br><span class="line">"lgow"</span><br></pre></td></tr></table></figure><p><code>Redis</code>的<code>Bitmap</code>是自动扩容的，亦即<code>get/set</code>到高位时，就会主动填充<code>0</code>。此外，还有<code>bitcount</code>指令用于计算特定字节范围内<code>1</code>的个数，<code>bitop</code>指令用来执行位运算（支持<code>and</code>、<code>or</code>、<code>xor</code>和<code>not</code>）。相应的用法可以查询<code>Redis</code>官方文档等。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.jasondavies.com/bloomfilter/" target="_blank" rel="noopener">https://www.jasondavies.com/bloomfilter/</a></li><li><a href="https://zhuanlan.zhihu.com/p/43263751" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43263751</a></li><li><a href="https://www.jianshu.com/p/c2defe549b40" target="_blank" rel="noopener">https://www.jianshu.com/p/c2defe549b40</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是布隆过滤器&quot;&gt;&lt;a href=&quot;#什么是布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;什么是布隆过滤器&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是布隆过滤器&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构&lt;
      
    
    </summary>
    
    
      <category term="布隆过滤器" scheme="http://www.cyblogs.com/categories/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="Redis" scheme="http://www.cyblogs.com/categories/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/Redis/"/>
    
    
      <category term="布隆过滤器" scheme="http://www.cyblogs.com/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>你是否真的能把单例模式给写好？</title>
    <link href="http://www.cyblogs.com/2020/06/02/2020/06/%E4%BD%A0%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E8%83%BD%E6%8A%8A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%99%E5%86%99%E5%A5%BD%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/06/02/2020/06/%E4%BD%A0%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E8%83%BD%E6%8A%8A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%99%E5%86%99%E5%A5%BD%EF%BC%9F/</id>
    <published>2020-06-01T16:00:00.000Z</published>
    <updated>2020-08-02T15:01:46.147Z</updated>
    
    <content type="html"><![CDATA[<p>当你看到这个标题的时候，以为我是一个标题党？（其实也是…）</p><p>但是你真的不能小瞧这个单例模式，不信的话，你可以继续往下看。</p><h4 id="小白些单例模式"><a href="#小白些单例模式" class="headerlink" title="小白些单例模式"></a>小白些单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            System.out.println(<span class="string">"我开始new对象了~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种单例估计是我们第一眼就能想到的，咋一眼看没问题，因为我们的大脑一眼反应我们的程序都是单线程的。实际上我们系统在初始化的时候就有可能存在多线程的情况。我们模拟并发写一个小程序来验证下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:27 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Singleton instance = Singleton.getInstance();</span><br><span class="line">                    System.out.println(instance);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一眼运行的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">我开始new对象了~</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@a963d08</span><br><span class="line">我开始new对象了~</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br><span class="line">com.vernon.test.designpattern.singleton.Singleton@773d663a</span><br></pre></td></tr></table></figure><p>很明显，new了2次对象，看打印的对象地址也是不对的。</p><p>那我们如何去改进呢？– 加锁</p><h4 id="加synchronized锁"><a href="#加synchronized锁" class="headerlink" title="加synchronized锁"></a>加synchronized锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 加锁不就搞定了吗？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">            System.out.println(<span class="string">"我开始new对象了~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个确实能解决掉问题，但是后续每次获取它的时候每次都要加锁排队，性能存在一定的问题。</p><h4 id="Double-Check"><a href="#Double-Check" class="headerlink" title="Double Check"></a>Double Check</h4><p>那是不是在方法里面做2次校验就能解决掉问题呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// double check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                    System.out.println(<span class="string">"我开始new对象了~"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看上去，不管是单线程还是多线程，起码在<code>instance==null</code>的时候都能被hold住。但是表现懵逼了我们的双眼。如果这里发生了重排序，就会存在问题。</p><p>创建一个对象可以划分为3步：</p><ul><li>1、分配内存空间；</li><li>2、初始化对象；</li><li>3、将内存空间的地址赋值给对象的引用；</li></ul><p>如果发生重排序的话，步骤2~3有可能颠倒过来。</p><h4 id="防止重排序"><a href="#防止重排序" class="headerlink" title="防止重排序"></a>防止重排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加上volatile关键字，防止重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                    System.out.println(<span class="string">"我开始new对象了~"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里加上volatile关键字就可以很好的解决了。传送门：<a href="https://mp.weixin.qq.com/s/HtMphMK8lyrieg-663q9og" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/HtMphMK8lyrieg-663q9og</a></p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with vernon-test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 设计模式-单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 9:25 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法采用内部类来解决，加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。 </p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.bilibili.com/video/BV1DK4y1t7MY" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1DK4y1t7MY</a></li><li><a href="https://blog.csdn.net/zmx729618/article/details/69227762" target="_blank" rel="noopener">https://blog.csdn.net/zmx729618/article/details/69227762</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当你看到这个标题的时候，以为我是一个标题党？（其实也是…）&lt;/p&gt;
&lt;p&gt;但是你真的不能小瞧这个单例模式，不信的话，你可以继续往下看。&lt;/p&gt;
&lt;h4 id=&quot;小白些单例模式&quot;&gt;&lt;a href=&quot;#小白些单例模式&quot; class=&quot;headerlink&quot; title=&quot;小白些
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁用Redis还是Zookeeper？</title>
    <link href="http://www.cyblogs.com/2020/06/01/2020/06/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%94%A8Redis%E8%BF%98%E6%98%AFZookeeper%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/06/01/2020/06/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%94%A8Redis%E8%BF%98%E6%98%AFZookeeper%EF%BC%9F/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2020-08-02T15:01:36.901Z</updated>
    
    <content type="html"><![CDATA[<p>为什么用分布式锁？在讨论这个问题之前，我们先来看一个业务场景。</p><h4 id="为什么用分布式锁？"><a href="#为什么用分布式锁？" class="headerlink" title="为什么用分布式锁？"></a>为什么用分布式锁？</h4><p>系统 A 是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。</p><p>由于系统有一定的并发，所以会预先将商品的库存保存在 Redis 中，用户下单的时候会更新 Redis 的库存。</p><p>此时系统架构如下：</p><p><img src="https://s5.51cto.com/oss/201907/16/3e9e699864efd973960054445fbc67f4.jpg" alt="img"></p><p>但是这样一来会产生一个问题：假如某个时刻，Redis 里面的某个商品库存为 1。</p><p>此时两个请求同时到来，其中一个请求执行到上图的第 3 步，更新数据库的库存为 0，但是第 4 步还没有执行。</p><p>而另外一个请求执行到了第 2 步，发现库存还是 1，就继续执行第 3 步。这样的结果，是导致卖出了 2 个商品，然而其实库存只有 1 个。</p><p>很明显不对啊！这就是典型的库存超卖问题。此时，我们很容易想到解决方案：用锁把 2、3、4 步锁住，让他们执行完之后，另一个线程才能进来执行第 2 步。</p><p><img src="http://static.cyblogs.com/ce0fee95ef6880c9ac5ba670fe5be268.jpg" alt="http://static.cyblogs.com/ce0fee95ef6880c9ac5ba670fe5be268.jpg"></p><p>按照上面的图，在执行第 2 步时，使用 Java 提供的 Synchronized 或者 ReentrantLock 来锁住，然后在第 4 步执行完之后才释放锁。</p><p>这样一来，2、3、4 这 3 个步骤就被“锁”住了，多个线程之间只能串行化执行。</p><p>但是好景不长，整个系统的并发飙升，一台机器扛不住了。现在要增加一台机器，如下图：</p><p><img src="http://static.cyblogs.com/99f3874bd484b4ea8000ca41023be3dc.jpg-wh_600x-s_592420448.jpg" alt="http://static.cyblogs.com/99f3874bd484b4ea8000ca41023be3dc.jpg-wh_600x-s_592420448.jpg"></p><p>增加机器之后，系统变成上图所示，我的天！假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现库存超卖的问题。</p><p>为什么呢？因为上图中的两个 A 系统，运行在两个不同的 JVM 里面，他们加的锁只对属于自己 JVM 里面的线程有效，对于其他 JVM 的线程是无效的。</p><p>因此，这里的问题是：Java 提供的原生锁机制在多机部署场景下失效了，这是因为两台机器加的锁不是同一个锁（两个锁在不同的 JVM 里面）。</p><p>那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？此时，就该分布式锁隆重登场了。</p><p>分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。</p><p>至于这个“东西”，可以是 Redis、Zookeeper，也可以是数据库。文字描述不太直观，我们来看下图：</p><p><img src="http://static.cyblogs.com/3667d7cff8435d47f5a187ad596bdb09.jpg-wh_600x-s_1198484587.jpg" alt="http://static.cyblogs.com/3667d7cff8435d47f5a187ad596bdb09.jpg-wh_600x-s_1198484587.jpg"></p><p>通过上面的分析，我们知道了库存超卖场景在分布式部署系统的情况下使用 Java 原生的锁机制无法保证线程安全，所以我们需要用到分布式锁的方案。</p><p>那么，如何实现分布式锁呢？接着往下看！</p><h4 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h4><p>上面分析为啥要使用分布式锁了，这里我们来具体看看分布式锁落地的时候应该怎么样处理。</p><p><strong>①常见的一种方案就是使用 Redis 做分布式锁</strong></p><p>使用 Redis 做分布式锁的思路大概是这样的：在 Redis 中设置一个值表示加了锁，然后释放锁的时候就把这个 Key 删除。</p><p>具体代码是这样的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 获取锁 </span><br><span class="line">// NX是指如果key不存在就成功，key存在返回<span class="literal">false</span>，PX可以指定过期时间 </span><br><span class="line">SET anyLock unique_value NX PX <span class="number">30000</span> </span><br><span class="line"> </span><br><span class="line">// 释放锁：通过执行一段lua脚本 </span><br><span class="line">// 释放锁涉及到两条指令，这两条指令不是原子性的 </span><br><span class="line">// 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的 </span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种方式有几大要点：</p><ul><li>一定要用 SET key value NX PX milliseconds 命令。如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(Key ***存在)</li><li>Value 要具有唯一性。这个是为了在解锁的时候，需要验证 Value 是和加锁的一致才删除 Key。</li></ul><p>这时避免了一种情况：假设 A 获取了锁，过期时间 30s，此时 35s 之后，锁已经自动释放了，A 去释放锁，但是此时可能 B 获取了锁。A 客户端就不能删除 B 的锁了。</p><p>除了要考虑客户端要怎么实现分布式锁之外，还需要考虑 Redis 的部署问题。</p><p>Redis 有 3 种部署方式：</p><ul><li>单机模式</li><li>Master-Slave+Sentinel 选举模式</li><li>Redis Cluster 模式</li></ul><p>使用 Redis 做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要 Redis 故障了。加锁就不行了。</p><p>采用 Master-Slave 模式，加锁的时候只对一个节点加锁，即便通过 Sentinel 做了高可用，但是如果 Master 节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。</p><p>基于以上的考虑，Redis 的作者也考虑到这个问题，他提出了一个 RedLock 的算法。</p><p>这个算法的意思大概是这样的：假设 Redis 的部署模式是 Redis Cluster，总共有 5 个 Master 节点。</p><p>通过以下步骤获取一把锁：</p><ul><li>获取当前时间戳，单位是毫秒。</li><li>轮流尝试在每个 Master 节点上创建锁，过期时间设置较短，一般就几十毫秒。</li><li>尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点（n / 2 +1）。</li><li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了。</li><li>要是锁建立失败了，那么就依次删除这个锁。</li><li>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。</li></ul><p>但是这样的这种算法还是颇具争议的，可能还会存在不少的问题，无法保证加锁的过程一定正确。</p><p><img src="http://static.cyblogs.com/da6b5468501519f5688e47824b56ba21.jpg-wh_600x-s_4091681668.jpg" alt="http://static.cyblogs.com/da6b5468501519f5688e47824b56ba21.jpg-wh_600x-s_4091681668.jpg"></p><p><strong>②另一种方式：Redisson</strong></p><p>此外，实现 Redis 的分布式锁，除了自己基于 Redis Client 原生 API 来实现之外，还可以使用开源框架：Redission。</p><p>Redisson 是一个企业级的开源 Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？</p><p>回想一下上面说的，如果自己写代码来通过 Redis 设置一个值，是通过下面这个命令设置的：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET anyLock unique_value NX PX <span class="number">30000</span></span><br></pre></td></tr></table></figure><p>这里设置的超时时间是 30s，假如我超过 30s 都还没有完成业务逻辑的情况下，Key 会过期，其他线程有可能会获取到锁。</p><p>这样一来的话，***个线程还没执行完业务逻辑，第二个线程进来了也会出现线程安全问题。</p><p>所以我们还需要额外的去维护这个过期时间，太麻烦了~我们来看看 Redisson 是怎么实现的？</p><p>先感受一下使用 Redission 的爽：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config(); </span><br><span class="line">config.useClusterServers() </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7001"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7002"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.101:7003"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7001"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7002"</span>) </span><br><span class="line">.addNodeAddress(<span class="string">"redis://192.168.31.102:7003"</span>); </span><br><span class="line"> </span><br><span class="line">RedissonClient redisson = Redisson.create(config); </span><br><span class="line"></span><br><span class="line">RLock lock = redisson.getLock(<span class="string">"anyLock"</span>); </span><br><span class="line">lock.lock(); </span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><p>就是这么简单，我们只需要通过它的 API 中的 Lock 和 Unlock 即可完成分布式锁，他帮我们考虑了很多细节：</p><ul><li>Redisson 所有指令都通过 Lua 脚本执行，Redis 支持 Lua 脚本原子性执行。</li><li>Redisson 设置一个 Key 的默认过期时间为 30s，如果某个客户端持有一个锁超过了 30s 怎么办？</li><li>Redisson 中有一个 Watchdog 的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔 10s 帮你把 Key 的超时时间设为 30s。</li></ul><p>这样的话，就算一直持有锁也不会出现 Key 过期了，其他线程获取到锁的问题了。</p><ul><li>Redisson 的“看门狗”逻辑保证了没有死锁发生。(如果机器宕机了，看门狗也就没了。此时就不会延长 Key 的过期时间，到了 30s 之后就会自动过期了，其他线程可以获取到锁)</li></ul><p><img src="http://static.cyblogs.com/a7fbd80edbe1bc035e0a6e1c3c691ed7.jpg-wh_600x-s_1313345474.jpg" alt="http://static.cyblogs.com/a7fbd80edbe1bc035e0a6e1c3c691ed7.jpg-wh_600x-s_1313345474.jpg"></p><p>这里稍微贴出来其实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁逻辑 </span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 调用一段lua脚本，设置一些key、过期时间 </span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG); </span><br><span class="line">    ttlRemainingFuture.addListener(<span class="keyword">new</span> FutureListener&lt;Long&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Long&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (!future.isSuccess()) &#123; </span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            Long ttlRemaining = future.getNow(); </span><br><span class="line">            <span class="comment">// lock acquired </span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="comment">// 看门狗逻辑 </span></span><br><span class="line">                scheduleExpirationRenewal(threadId); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123; </span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command, </span><br><span class="line">              <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> + </span><br><span class="line">                  <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> + </span><br><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> + </span><br><span class="line">                  <span class="string">"return nil; "</span> + </span><br><span class="line">              <span class="string">"end; "</span> + </span><br><span class="line">              <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> + </span><br><span class="line">                  <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> + </span><br><span class="line">                  <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> + </span><br><span class="line">                  <span class="string">"return nil; "</span> + </span><br><span class="line">              <span class="string">"end; "</span> + </span><br><span class="line">              <span class="string">"return redis.call('pttl', KEYS[1]);"</span>, </span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId)); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 看门狗最终会调用了这里 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExpirationRenewal</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> threadId)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.containsKey(getEntryName())) &#123; </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 这个任务会延迟10s执行 </span></span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> TimerTask() &#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这个操作会将key的过期时间重新设置为30s </span></span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId); </span><br><span class="line"> </span><br><span class="line">            future.addListener(<span class="keyword">new</span> FutureListener&lt;Boolean&gt;() &#123; </span><br><span class="line">                <span class="meta">@Override</span> </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Boolean&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">                    expirationRenewalMap.remove(getEntryName()); </span><br><span class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123; </span><br><span class="line">                        log.error(<span class="string">"Can't update lock "</span> + getName() + <span class="string">" expiration"</span>, future.cause()); </span><br><span class="line">                        <span class="keyword">return</span>; </span><br><span class="line">                    &#125; </span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (future.getNow()) &#123; </span><br><span class="line">                        <span class="comment">// reschedule itself </span></span><br><span class="line">                        <span class="comment">// 通过递归调用本方法，***循环延长过期时间 </span></span><br><span class="line">                        scheduleExpirationRenewal(threadId); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (expirationRenewalMap.putIfAbsent(getEntryName(), <span class="keyword">new</span> ExpirationEntry(threadId, task)) != <span class="keyword">null</span>) &#123; </span><br><span class="line">        task.cancel(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，Redisson 还提供了对 Redlock 算法的支持，它的用法也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RedissonClient redisson = Redisson.create(config); </span><br><span class="line">RLock lock1 = redisson.getFairLock(<span class="string">"lock1"</span>); </span><br><span class="line">RLock lock2 = redisson.getFairLock(<span class="string">"lock2"</span>); </span><br><span class="line">RLock lock3 = redisson.getFairLock(<span class="string">"lock3"</span>); </span><br><span class="line">RedissonRedLock multiLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3); </span><br><span class="line">multiLock.lock(); </span><br><span class="line">multiLock.unlock();</span><br></pre></td></tr></table></figure><p>小结：本节分析了使用 Redis 作为分布式锁的具体落地方案以及其一些局限性，然后介绍了一个 Redis 的客户端框架 Redisson，这也是我推荐大家使用的，比自己写代码实现会少 Care 很多细节。</p><h4 id="基于-Zookeeper-实现分布式锁"><a href="#基于-Zookeeper-实现分布式锁" class="headerlink" title="基于 Zookeeper 实现分布式锁"></a>基于 Zookeeper 实现分布式锁</h4><p>常见的分布式锁实现方案里面，除了使用 Redis 来实现之外，使用 Zookeeper 也可以实现分布式锁。</p><p>在介绍 Zookeeper(下文用 ZK 代替)实现分布式锁的机制之前，先粗略介绍一下 ZK 是什么东西：ZK 是一种提供配置管理、分布式协同以及命名的中心化服务。</p><p>ZK 的模型是这样的：ZK 包含一系列的节点，叫做 Znode，就好像文件系统一样，每个 Znode 表示一个目录。</p><p>然后 Znode 有一些特性：</p><ul><li>有序节点：假如当前有一个父节点为 /lock，我们可以在这个父节点下面创建子节点，ZK 提供了一个可选的有序特性。</li></ul><p>例如我们可以创建子节点“/lock/node-”并且指明有序，那么 ZK 在生成子节点时会根据当前的子节点数量自动添加整数序号。</p><p>也就是说，如果是***个创建的子节点，那么生成的子节点为 /lock/node-0000000000，下一个节点则为 /lock/node-0000000001，依次类推。</p><ul><li>临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，ZK 会自动删除该节点。</li><li>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，ZK 会通知客户端。</li></ul><p>当前 ZK 有如下四种事件：</p><ul><li>节点创建</li><li>节点删除</li><li>节点数据修改</li><li>子节点变更</li></ul><p>基于以上的一些 ZK 的特性，我们很容易得出使用 ZK 实现分布式锁的落地方案：</p><ul><li>使用 ZK 的临时节点和有序节点，每个线程获取锁就是在 ZK 创建一个临时有序的节点，比如在 /lock/ 目录下。</li><li>创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点。</li><li>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。</li><li>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</li></ul><p>比如当前线程获取到的节点序号为 /lock/003，然后所有的节点列表为[/lock/001，/lock/002，/lock/003]，则对 /lock/002 这个节点添加一个事件监听器。</p><p>如果锁释放了，会唤醒下一个序号的节点，然后重新执行第 3 步，判断是否自己的节点序号是最小。</p><p>比如 /lock/001 释放了，/lock/002 监听到时间，此时节点集合为[/lock/002，/lock/003]，则 /lock/002 为最小序号节点，获取到锁。</p><p>整个过程如下：</p><p><img src="http://static.cyblogs.com/fb6c27bb22de93cbeb965718156f578f.jpg" alt="http://static.cyblogs.com/fb6c27bb22de93cbeb965718156f578f.jpg"></p><p>具体的实现思路就是这样，至于代码怎么写，这里比较复杂就不贴出来了。</p><p><strong>Curator 介绍</strong></p><p>Curator 是一个 ZK 的开源客户端，也提供了分布式锁的实现。它的使用方式也比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client,<span class="string">"/anyLock"</span>); </span><br><span class="line">interProcessMutex.acquire(); </span><br><span class="line">interProcessMutex.release();</span><br></pre></td></tr></table></figure><p>其实现分布式锁的核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">boolean</span>  haveTheLock = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">boolean</span>  doDelete = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> ( revocable.get() != <span class="keyword">null</span> ) &#123; </span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock ) &#123; </span><br><span class="line">            <span class="comment">// 获取当前所有节点排序后的集合 </span></span><br><span class="line">            List&lt;String&gt;        children = getSortedChildren(); </span><br><span class="line">            <span class="comment">// 获取当前节点的名称 </span></span><br><span class="line">            String              sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// +1 to include the slash </span></span><br><span class="line">            <span class="comment">// 判断当前节点是否是最小的节点 </span></span><br><span class="line">            PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases); </span><br><span class="line">            <span class="keyword">if</span> ( predicateResults.getsTheLock() ) &#123; </span><br><span class="line">                <span class="comment">// 获取到锁 </span></span><br><span class="line">                haveTheLock = <span class="keyword">true</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">// 没获取到锁，对当前节点的上一个节点注册一个监听器 </span></span><br><span class="line">                String  previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch(); </span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123; </span><br><span class="line">                    Stat stat = client.checkExists().usingWatcher(watcher).forPath(previousSequencePath); </span><br><span class="line">                    <span class="keyword">if</span> ( stat != <span class="keyword">null</span> )&#123; </span><br><span class="line">                        <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )&#123; </span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis); </span><br><span class="line">                            startMillis = System.currentTimeMillis(); </span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )&#123; </span><br><span class="line">                                doDelete = <span class="keyword">true</span>;    <span class="comment">// timed out - delete our node </span></span><br><span class="line">                                <span class="keyword">break</span>; </span><br><span class="line">                            &#125; </span><br><span class="line">                            wait(millisToWait); </span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                            wait(); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// else it may have been deleted (i.e. lock released). Try to acquire again </span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> ( Exception e ) &#123; </span><br><span class="line">        doDelete = <span class="keyword">true</span>; </span><br><span class="line">        <span class="keyword">throw</span> e; </span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123; </span><br><span class="line">        <span class="keyword">if</span> ( doDelete )&#123; </span><br><span class="line">            deleteOurPath(ourPath); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> haveTheLock; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 Curator 实现分布式锁的底层原理和上面分析的是差不多的。这里我们用一张图详细描述其原理：</p><p><img src="https://s5.51cto.com/oss/201907/16/84636c96585ff2611ff55e284a57c6ab.jpg-wh_600x-s_3685227374.jpg" alt="https://s5.51cto.com/oss/201907/16/84636c96585ff2611ff55e284a57c6ab.jpg-wh_600x-s_3685227374.jpg"></p><p>小结：本节介绍了 ZK 实现分布式锁的方案以及 ZK 的开源客户端的基本使用，简要的介绍了其实现原理。</p><h4 id="两种方案的优缺点比较"><a href="#两种方案的优缺点比较" class="headerlink" title="两种方案的优缺点比较"></a>两种方案的优缺点比较</h4><p>学完了两种分布式锁的实现方案之后，本节需要讨论的是 Redis 和 ZK 的实现方案中各自的优缺点。</p><p>对于 Redis 的分布式锁而言，它有以下缺点：</p><ul><li>它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。</li><li>另外来说的话，Redis 的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮。</li><li>即便使用 Redlock 算法来实现，在某些复杂场景下，也无法保证其实现 100% 没有问题，关于 Redlock 的讨论可以看 How to do distributed locking。</li><li>Redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。</li></ul><p>但是另一方面使用 Redis 实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”。</p><p>所以使用 Redis 作为分布式锁也不失为一种好的方案，最重要的一点是 Redis 的性能很高，可以支撑高并发的获取、释放锁操作。</p><p>对于 ZK 分布式锁而言:</p><ul><li>ZK 天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。</li><li>如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</li></ul><p>但是 ZK 也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。</p><p>小结：综上所述，Redis 和 ZK 都有其优缺点。我们在做技术选型的时候可以根据这些问题作为参考因素。</p><h4 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h4><p>通过前面的分析，实现分布式锁的两种常见方案：Redis 和 ZK，他们各有千秋。应该如何选型呢？</p><p>就个人而言的话，我比较推崇 ZK 实现的锁：因为 Redis 是有可能存在隐患的，可能会导致数据不对的情况。但是，怎么选用要看具体在公司的场景了。</p><p>如果公司里面有 ZK 集群条件，优先选用 ZK 实现，但是如果说公司里面只有 Redis 集群，没有条件搭建 ZK 集群。</p><p>那么其实用 Redis 来实现也可以，另外还可能是系统设计者考虑到了系统已经有 Redis，但是又不希望再次引入一些外部依赖的情况下，可以选用 Redis。这个是要系统设计者基于架构来考虑了。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://developer.51cto.com/art/201907/599642.htm" target="_blank" rel="noopener">https://developer.51cto.com/art/201907/599642.htm</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么用分布式锁？在讨论这个问题之前，我们先来看一个业务场景。&lt;/p&gt;
&lt;h4 id=&quot;为什么用分布式锁？&quot;&gt;&lt;a href=&quot;#为什么用分布式锁？&quot; class=&quot;headerlink&quot; title=&quot;为什么用分布式锁？&quot;&gt;&lt;/a&gt;为什么用分布式锁？&lt;/h4&gt;&lt;p&gt;系统 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/categories/Java/"/>
    
    
      <category term="Zookeeper" scheme="http://www.cyblogs.com/tags/Zookeeper/"/>
    
      <category term="Redis" scheme="http://www.cyblogs.com/tags/Redis/"/>
    
      <category term="分布式锁" scheme="http://www.cyblogs.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux Rsync 增量同步与快速删除</title>
    <link href="http://www.cyblogs.com/2020/05/15/2020/05/Linux%20Rsync%20%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4/"/>
    <id>http://www.cyblogs.com/2020/05/15/2020/05/Linux%20Rsync%20%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%88%A0%E9%99%A4/</id>
    <published>2020-05-14T16:00:00.000Z</published>
    <updated>2020-08-02T15:00:36.122Z</updated>
    
    <content type="html"><![CDATA[<h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p><code>rsync [args] SRC [DEST]</code><br>情形：同时维护着两份不同的<code>data_center</code>，但以<code>old_data_center</code>为标准。因为权限的缘故没有开启rsync自动同步，只是每隔一段时间手动同步一下。<code>SRC</code>和<code>DEST</code>都是采用mount形式，如果每一次都完整地<code>copy</code>，耗时很长，这时候就想到采用增量同步的方法，因为两份<code>data_center</code>同时由不同人维护，所以内容略有不同，<code>data_center</code>同步的时候不光要完全同步<code>old_data_center</code>的所有内容，而且要删除自身多余的内容，保持完全一致。</p><p><img src="http://static.cyblogs.com/1559267-20190509170938551-832776092.png" alt="http://static.cyblogs.com/1559267-20190509170938551-832776092.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rsync -a </span><br><span class="line">--delete </span><br><span class="line">--progress /old_vip_data_center/test_envs/trainer/resource /vip_data_center/test_envs/trainer/resource/</span><br></pre></td></tr></table></figure><p>–delete: 删除<code>DEST</code>端存在但是<code>SRC</code>端不存在的文件，如果不使用此参数，则DEST端会同步SRC端的文件，但DEST端已有的文件不受影响。</p><h4 id="快速删除大量文件"><a href="#快速删除大量文件" class="headerlink" title="快速删除大量文件"></a>快速删除大量文件</h4><ol><li><p>先建一个空目录，随便位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /local/empty_dir</span><br></pre></td></tr></table></figure></li><li><p>用rsync删除目标目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync --delete-before -avH --progress /local/empty_dir/ /local/trainer_test/</span><br></pre></td></tr></table></figure></li></ol><p><code>trainer_test</code>清空之后可以再用<code>rm -rf trainer_test</code>删除</p><p>注意不要忘了文件夹最后的<code>/</code></p><p><code>rsync</code>提供了一些跟删除相关的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rsync --help | grep delete</span><br><span class="line">--del an alias for --delete-during</span><br><span class="line">--delete-before receiver deletes before transfer (default)</span><br></pre></td></tr></table></figure><p>选项说明：<br>-a 递归方式传输文件，并保持文件属性<br>–delete-before 接收者在传输之前进行删除操作<br>–progress 在传输时显示传输过程<br>– 归档模式，表示以递归方式传输文件，并保持所有文件属性<br>-H 保持硬连接的文件<br>-v 详细输出模式<br>-stats 给出某些文件的传输状态</p><p>不过在使用上面的命令进行清理时，存在一个问题，清空后，目标目录的权限会和源目录的权限一样。如：<code>/tmp/empty</code>是<code>root：root</code>，而<code>maildrop</code>之前是<code>postfix：postdrop</code> ，执行之后也会<code>maildrop</code>目录的权限也会变成<code>root：root</code> 。由于-a权限是-rlptogD几个参数的集合，所以可以将og（owner:group）两个参数去掉。清空时自动保持之前的目录权限，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync --delete -rlptD /tmp/empty/ /var/spool/postfix/maildrop/</span><br></pre></td></tr></table></figure><h4 id="为什么rsync这么快呢？"><a href="#为什么rsync这么快呢？" class="headerlink" title="为什么rsync这么快呢？"></a>为什么rsync这么快呢？</h4><p>rm删除内容时，将目录的每一个条目逐个删除(unlink)，需要循环重复操作很多次；</p><p>rsync删除内容时，建立好新的空目录，替换掉老目录，基本没开销。</p><blockquote><p>If you want to conquer fear, don’t sit home and think about it. Go out and get busy.</p></blockquote><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>今天因为用代码生成SQL脚本的时候，本来是说100W的数据生成一个的，结果因为一个运算符的问题导致了生成上百万的小文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; skipHeadCount) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每MAX_SIZE就会生成一个,MAX_SIZE=1000000</span></span><br><span class="line">    <span class="keyword">int</span> fileExtName = (count - skipHeadCount) / MAX_SIZE; <span class="comment">// 当时种类count - skipHeadCount忘记打括号了</span></span><br><span class="line">    <span class="keyword">if</span> (fileExtName &gt; currentFileExtName) &#123;</span><br><span class="line">        bw.flush();</span><br><span class="line">        currentFileExtName = fileExtName;</span><br><span class="line">        bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(String.format(fileOutputPath, currentFileExtName)))));</span><br><span class="line">    &#125;</span><br><span class="line">    String formatStr = genService.format(line);</span><br><span class="line">    bw.write(formatStr);</span><br><span class="line">    bw.newLine();</span><br><span class="line">    log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除的时候会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Argument list too long</span><br></pre></td></tr></table></figure><p>实战后发现效率贵高的一种方式：</p><p><img src="http://static.cyblogs.com/WechatIMG461.png" alt="http://static.cyblogs.com/WechatIMG461.png"></p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.cnblogs.com/sayiqiu/p/10816572.html" target="_blank" rel="noopener">https://www.cnblogs.com/sayiqiu/p/10816572.html</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;增量同步&quot;&gt;&lt;a href=&quot;#增量同步&quot; class=&quot;headerlink&quot; title=&quot;增量同步&quot;&gt;&lt;/a&gt;增量同步&lt;/h4&gt;&lt;p&gt;&lt;code&gt;rsync [args] SRC [DEST]&lt;/code&gt;&lt;br&gt;情形：同时维护着两份不同的&lt;code&gt;dat
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.cyblogs.com/categories/Linux/"/>
    
    
      <category term="Rsync" scheme="http://www.cyblogs.com/tags/Rsync/"/>
    
  </entry>
  
  <entry>
    <title>JVM深入理解-内存调优与GC日志</title>
    <link href="http://www.cyblogs.com/2020/05/14/2020/05/JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B8%8EGC%E6%97%A5%E5%BF%97/"/>
    <id>http://www.cyblogs.com/2020/05/14/2020/05/JVM%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98%E4%B8%8EGC%E6%97%A5%E5%BF%97/</id>
    <published>2020-05-13T16:00:00.000Z</published>
    <updated>2020-12-29T02:26:30.935Z</updated>
    
    <content type="html"><![CDATA[<h6 id="CPU飚高分析"><a href="#CPU飚高分析" class="headerlink" title="CPU飚高分析"></a>CPU飚高分析</h6><p>一般可以使用</p><ul><li>ps -Lfp pid</li><li>ps -mp pid -o THREAD, tid, time</li><li>top -Hp pid</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@redis webapps]# top -Hp 22272</span><br><span class="line">top - 10:09:30 up 9 days, 22:10,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks:  30 total,   0 running,  30 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:   3923196k total,  3795588k used,   127608k free,   153056k buffers</span><br><span class="line">Swap:  6160376k total,        0k used,  6160376k free,  3079244k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                                </span><br><span class="line">22272 root      20   0 2286m 122m  11m S  0.0  3.2   0:00.00 java                                                                                                                                                    </span><br><span class="line">22278 root      20   0 2286m 122m  11m S  0.0  3.2   0:00.00 java</span><br></pre></td></tr></table></figure><p>TIME列就是各个Java线程耗费的CPU时间，CPU时间最长的是线程ID为22283 的线程。</p><p>用 <code>printf &quot;%x\n&quot; 22283</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@redis webapps]# printf ‘%x\n’ 22283</span><br><span class="line">570b得到22283 的十六进制值为570b。</span><br></pre></td></tr></table></figure><p>下一步轮到jstack上场了，它用来输出进程22272 的堆栈信息，然后根据线程ID的十六进制值grep，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@redis webapps]# jstack 22272 | grep 570b</span><br><span class="line">“SchedulerThread” prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait()</span><br></pre></td></tr></table></figure><p>可以看到CPU消耗在SchedulerThread这个类的Object.wait()，定位到下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Idle wait</span></span><br><span class="line"><span class="keyword">synchronized</span>(sigLock) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!halted.get()) &#123;</span><br><span class="line">      sigLock.wait(timeUntilContinue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是轮询任务的空闲等待代码，上面的sigLock.wait(timeUntilContinue)就对应了前面的Object.wait()。</p><p>总结：可以通过PID找到对应的的线程，然后通过JVM的jstack找到栈里对应的线程信息。通过找到对应的代码一般就能分析出CPU占用高的原因。</p><h4 id="利用JVM命令分析"><a href="#利用JVM命令分析" class="headerlink" title="利用JVM命令分析"></a>利用JVM命令分析</h4><h5 id="jstat-gcutil"><a href="#jstat-gcutil" class="headerlink" title="jstat -gcutil"></a>jstat -gcutil</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@xxxx-nccz8-b57dd64fc-nt9dj logs]# jstat -gcutil 1 2000 20</span><br><span class="line">S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00   8.64   2.62  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   2.81  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   2.81  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   2.81  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.06  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.10  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.10  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.21  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.22  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   3.61  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   6.47  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   6.76  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   6.81  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.07  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.08  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.38  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.38  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.62  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.62  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br><span class="line">  0.00   8.64   7.76  27.32  80.59  73.86   1350   22.705     5    1.449   24.154</span><br></pre></td></tr></table></figure><p>S0：Heap上的 Survivor space 0 区已使用空间的百分比<br>S1：Heap上的 Survivor space 1 区已使用空间的百分比<br>E：Heap上的 Eden space 区已使用空间的百分比<br>O：Heap上的 Old space 区已使用空间的百分比<br>M：Metaspace 区已使用空间的百分比<br>YGC：从应用程序启动到采样时发生 Young GC 的次数<br>YGCT：从应用程序启动到采样时 Young GC 所用的时间(单位秒)<br>FGC：从应用程序启动到采样时发生 Full GC 的次数<br>FGCT：从应用程序启动到采样时 Full GC 所用的时间(单位秒)<br>GCT：从应用程序启动到采样时用于垃圾回收的总时间(单位秒)</p><h5 id="jmap-heap"><a href="#jmap-heap" class="headerlink" title="jmap -heap"></a>jmap -heap</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@xxxx-nccz8-b57dd64fc-nt9dj startup]# jmap -heap 1</span><br><span class="line">Attaching to process ID 1, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.191-b12</span><br><span class="line"></span><br><span class="line">using parallel threads in the new generation.</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Concurrent Mark-Sweep GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 2147483648 (2048.0MB)</span><br><span class="line">   NewSize                  = 805306368 (768.0MB)</span><br><span class="line">   MaxNewSize               = 805306368 (768.0MB)</span><br><span class="line">   OldSize                  = 1342177280 (1280.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 268435456 (256.0MB)</span><br><span class="line">   CompressedClassSpaceSize = 260046848 (248.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 268435456 (256.0MB)</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 724828160 (691.25MB)</span><br><span class="line">   used     = 284988360 (271.7860794067383MB)</span><br><span class="line">   free     = 439839800 (419.4639205932617MB)</span><br><span class="line">   39.318058503687276% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 644349952 (614.5MB)</span><br><span class="line">   used     = 275398000 (262.63999938964844MB)</span><br><span class="line">   free     = 368951952 (351.86000061035156MB)</span><br><span class="line">   42.74043928228616% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 80478208 (76.75MB)</span><br><span class="line">   used     = 9590360 (9.146080017089844MB)</span><br><span class="line">   free     = 70887848 (67.60391998291016MB)</span><br><span class="line">   11.916716634644748% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 80478208 (76.75MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 80478208 (76.75MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation:</span><br><span class="line">   capacity = 1342177280 (1280.0MB)</span><br></pre></td></tr></table></figure><p>通过heap命令能看出当前整个堆的一个使用情况，used与free的一个实际占用比。</p><h5 id="jmap-dump"><a href="#jmap-dump" class="headerlink" title="jmap -dump"></a>jmap -dump</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=xxxxxx.20200707.hprof 1</span><br></pre></td></tr></table></figure><p>我们一般会在Dockerfile里面配置好如果出现OOM的情况，保留一下现场。<code>-XX:HeapDumpPath=/alidata1/admin/xxxxx/logs</code></p><h4 id="利用JProfiler分析"><a href="#利用JProfiler分析" class="headerlink" title="利用JProfiler分析"></a>利用JProfiler分析</h4><p>发现大对象，这里是因为我们用了Jeager链路跟踪，但是用过多线程导致ThreadLocal没有释放掉。</p><p><img src="http://static.cyblogs.com/QQ20200507-183901@2x.jpg" alt="http://static.cyblogs.com/QQ20200507-183901@2x.jpg"></p><p>发现char[]占用比较多，并且找出是从哪儿产生的？</p><p><img src="http://static.cyblogs.com/QQ20200507-194442@2x.jpg" alt="http://static.cyblogs.com/QQ20200507-194442@2x.jpg"></p><p>通过Outgoing references找到具体的实例情况。</p><p><img src="http://static.cyblogs.com/QQ20200507-194529@2x.jpg" alt="http://static.cyblogs.com/QQ20200507-194529@2x.jpg"></p><p>什么是outgoing references与incoming references？让我们通过示例来了解有关 Incoming references 和 Outgoing references 的更多知识。例如，一个应用程序的源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;     </span><br><span class="line">  <span class="keyword">private</span> C c1 = C.getInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;     </span><br><span class="line"><span class="keyword">private</span> C c2 = C.getInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;     </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> C myC = <span class="keyword">new</span> C();     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> C <span class="title">getInstance</span><span class="params">()</span> </span>&#123;             </span><br><span class="line"><span class="keyword">return</span> myC;     </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> D d1 = <span class="keyword">new</span> D();     </span><br><span class="line"><span class="keyword">private</span> E e1 = <span class="keyword">new</span> E();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExample</span> </span>&#123;     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String argsp[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           A a = <span class="keyword">new</span> A();</span><br><span class="line">           B b = <span class="keyword">new</span> B();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对象 A 和对象 B 持有对象 C 的引用</li><li>对象 C 持有对象 D 和对象 E 的引用</li></ul><p>在这个示例项目中，让我们具体分析下对象 C 的 Incoming references 和 Outgoing references 。</p><p><strong>对象 C 的 Incoming References</strong></p><p>拥有对象 C 的引用的所有对象都称为 Incoming references。在此示例中，对象 C 的“Incoming references”是对象 A、对象 B 和 C 的类对象 。</p><p><strong>对象 C 的 Outgoing References</strong></p><p>对象 C 引用的所有对象都称为 Outgoing References。在此示例中，对象 C 的“outgoing references”是对象 D、对象 E 和 C 的类对象。</p><p>然后通过<code>Show in graph</code>的菜单，一层一层的点击。直到你看到你最熟悉的类。</p><p><img src="http://static.cyblogs.com/WechatIMG459.png" alt="http://static.cyblogs.com/WechatIMG459.png"></p><p><img src="http://static.cyblogs.com/WechatIMG460.png" alt="http://static.cyblogs.com/WechatIMG460.png"></p><h4 id="如何看GC日志"><a href="#如何看GC日志" class="headerlink" title="如何看GC日志"></a>如何看GC日志</h4><p>设置gc日志配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC 输出简要GC日志 </span><br><span class="line">-XX:+PrintGCDetails 输出详细GC日志 </span><br><span class="line">-Xloggc:gc.log  输出GC日志到文件</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以JVM启动到当期的总时长的时间戳形式） </span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 <span class="number">2013</span>-<span class="number">05</span>-<span class="number">04</span>T21:<span class="number">53</span>:<span class="number">59.234</span>+<span class="number">0800</span>） </span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-verbose:gc</span><br><span class="line">-XX:+PrintReferenceGC 打印年轻代各个引用的数量以及时长</span><br></pre></td></tr></table></figure><h5 id="XX-PrintGC"><a href="#XX-PrintGC" class="headerlink" title="-XX:+PrintGC"></a>-XX:+PrintGC</h5><p>如果只设置<code>-XX:+PrintGC</code>那么打印的日志如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  61805K-&gt;9849K(256000K), 0.0041139 secs]</span><br><span class="line"></span><br><span class="line">1、GC 表示是一次YGC（Young GC）</span><br><span class="line">2、Allocation Failure 表示是失败的类型</span><br><span class="line">3、61805K-&gt;9849K 表示年轻代从61805K降为9849K</span><br><span class="line">4、256000K表示整个堆的大小</span><br><span class="line">5、0.0041139 secs表示这次GC总计所用的时间</span><br><span class="line">在JDK 8中，-verbose:gc是-XX:+PrintGC一个别称，日志格式等价与：-XX:+PrintGC，。</span><br></pre></td></tr></table></figure><h5 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 53248K-&gt;2176K(59392K)] 58161K-&gt;7161K(256000K), 0.0039189 secs] [Times: user&#x3D;0.02 sys&#x3D;0.01, real&#x3D;0.00 secs]</span><br><span class="line">1、GC 表示是一次YGC（Young GC）</span><br><span class="line">2、Allocation Failure 表示是失败的类型</span><br><span class="line">3、PSYoungGen 表示年轻代大小</span><br><span class="line">4、53248K-&gt;2176K 表示年轻代占用从53248K降为2176K</span><br><span class="line">5、59392K表示年轻带的大小</span><br><span class="line">6、58161K-&gt;7161K 表示整个堆占用从53248K降为2176K</span><br><span class="line">7、256000K表示整个堆的大小</span><br><span class="line">8、 0.0039189 secs 表示这次GC总计所用的时间</span><br><span class="line">9、[Times: user&#x3D;0.02 sys&#x3D;0.01, real&#x3D;0.00 secs]  分别表示，用户态占用时长，内核用时，真实用时。</span><br><span class="line">时间保留两位小数，四舍五入。</span><br></pre></td></tr></table></figure><h5 id="XX-PrintGCTimeStamps"><a href="#XX-PrintGCTimeStamps" class="headerlink" title="-XX:+PrintGCTimeStamps"></a>-XX:+PrintGCTimeStamps</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.963: [GC (Allocation Failure)  61805K-&gt;9849K(256000K), 0.0041139 secs]</span><br></pre></td></tr></table></figure><p>如果加上<code>-XX:+PrintGCTimeStamps</code>那么日志仅仅比1.1介绍的最前面多了一个时间戳： <code>1.963</code>， 表示从JVM启动到打印GC时刻用了1.963秒。</p><h5 id="XX-PrintGCDateStamps"><a href="#XX-PrintGCDateStamps" class="headerlink" title="-XX:+PrintGCDateStamps"></a>-XX:+PrintGCDateStamps</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-03-05T16:56:15.108+0800: [GC (Allocation Failure)  61805K-&gt;9849K(256000K), 0.0041139 secs]</span><br></pre></td></tr></table></figure><p>如果加上<code>-XX:+PrintGCDateStamps</code>那么日志仅仅比1.1介绍的最前面多了一个日期时间： <code>2019-03-05T16:56:15.108+0800</code>， 表示打印GC的时刻的时间是<code>2019-03-05T16:56:15.108+0800</code>。+0800表示是东8区。</p><h5 id="CMS-GC日志详细分析"><a href="#CMS-GC日志详细分析" class="headerlink" title="CMS GC日志详细分析"></a>CMS GC日志详细分析</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[GC (CMS Initial Mark) [1 CMS-initial-mark: 19498K(32768K)] 36184K(62272K), 0.0018083 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: 0.011/0.011 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[CMS-concurrent-abortable-preclean-start]</span><br><span class="line"> CMS: abort preclean due to time [CMS-concurrent-abortable-preclean: 0.558/5.093 secs] [Times: user=0.57 sys=0.00, real=5.09 secs] </span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 16817 K (29504 K)][Rescan (parallel) , 0.0021918 secs][weak refs processing, 0.0000245 secs][class unloading, 0.0044098 secs][scrub symbol table, 0.0029752 secs][scrub string table, 0.0006820 secs][1 CMS-remark: 19498K(32768K)] 36316K(62272K), 0.0104997 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: 0.007/0.007 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure><p>CMS日志分为两个STW(stop the world)</p><p>分别是<code>init remark</code>（1） 与 <code>remark</code>（7）两个阶段。一般耗时比YGC长约10倍（个人经验）。</p><p>（1）、<code>[GC (CMS Initial Mark) [1 CMS-initial-mark: 19498K(32768K)] 36184K(62272K), 0.0018083 secs][Times: user=0.01 sys=0.00, real=0.01 secs]</code></p><p>会STW(Stop The World)，这时候的老年代容量为 32768K， 在使用到 19498K 时开始初始化标记。耗时短。</p><p>（2）、<code>[CMS-concurrent-mark-start]</code></p><p>并发标记阶段开始</p><p>（3）、<code>[CMS-concurrent-mark: 0.011/0.011 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]</code></p><p>并发标记阶段花费时间。</p><p>（4）、<code>[CMS-concurrent-preclean-start]</code></p><p>并发预清理阶段，也是与用户线程并发执行。虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从<a href="https://www.baidu.com/s?wd=新生代&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">新生代</a>晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段”重新标记”的工作，因为下一个阶段会Stop The World。</p><p>（5）、<code>[CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</code></p><p>并发预清理阶段花费时间。</p><p>（6）、<code>[CMS-concurrent-abortable-preclean-start] CMS: abort preclean due to time [CMS-concurrent-abortable-preclean: 0.558/5.093 secs][Times: user=0.57 sys=0.00, real=5.09 secs]</code></p><p>并发可中止预清理阶段，运行在并行预清理和重新标记之间，直到获得所期望的eden空间占用率。增加这个阶段是为了避免在重新标记阶段后紧跟着发生一次垃圾清除</p><p>（7）、<code>[GC (CMS Final Remark) [YG occupancy: 16817 K (29504 K)][Rescan (parallel) , 0.0021918 secs][weak refs processing, 0.0000245 secs][class unloading, 0.0044098 secs][scrub symbol table, 0.0029752 secs][scrub string table, 0.0006820 secs][1 CMS-remark: 19498K(32768K)] 36316K(62272K), 0.0104997 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</code></p><p>会STW(Stop The World)，收集阶段，这个阶段会标记老年代全部的存活对象，包括那些在并发标记阶段更改的或者新创建的引用对象</p><p>（8）、<code>[CMS-concurrent-sweep-start]</code></p><p>并发清理阶段开始，与用户线程并发执行。</p><p>（9）、<code>[CMS-concurrent-sweep: 0.007/0.007 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</code></p><p>并发清理阶段结束，所用的时间。</p><p>（10）、<code>[CMS-concurrent-reset-start]</code></p><p>开始并发重置。在这个阶段，与CMS相关数据结构被重新初始化，这样下一个周期可以正常进行。</p><p>（11）、<code>[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></p><p>并发重置所用结束，所用的时间。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://mp.weixin.qq.com/s/bSv2YDqOJsWYj6ZjAnf1ew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/bSv2YDqOJsWYj6ZjAnf1ew</a></li><li><a href="https://blog.csdn.net/preterhuman_peak/article/details/43674037" target="_blank" rel="noopener">https://blog.csdn.net/preterhuman_peak/article/details/43674037</a></li><li><a href="https://juejin.im/post/5c80b0f451882532cd57b541" target="_blank" rel="noopener">https://juejin.im/post/5c80b0f451882532cd57b541</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员简栈文化-小助手（lastpass4u），他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;CPU飚高分析&quot;&gt;&lt;a href=&quot;#CPU飚高分析&quot; class=&quot;headerlink&quot; title=&quot;CPU飚高分析&quot;&gt;&lt;/a&gt;CPU飚高分析&lt;/h6&gt;&lt;p&gt;一般可以使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ps -Lfp pid&lt;/li&gt;
&lt;li&gt;ps -mp pi
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://www.cyblogs.com/tags/JVM/"/>
    
  </entry>
  
</feed>
