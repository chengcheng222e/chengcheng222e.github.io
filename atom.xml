<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>简栈文化</title>
  
  <subtitle>Java技术人的成长之路~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cyblogs.com/"/>
  <updated>2021-11-06T00:07:34.957Z</updated>
  <id>http://www.cyblogs.com/</id>
  
  <author>
    <name>Vernon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何反编译一个Docker镜像还原Dockerfile？</title>
    <link href="http://www.cyblogs.com/2021/11/06/2021/11/%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AADocker%E9%95%9C%E5%83%8F%E8%BF%98%E5%8E%9FDockerfile%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2021/11/06/2021/11/%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AADocker%E9%95%9C%E5%83%8F%E8%BF%98%E5%8E%9FDockerfile%EF%BC%9F/</id>
    <published>2021-11-05T16:00:00.000Z</published>
    <updated>2021-11-06T00:07:34.957Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>现在对于一个开发来说，<code>Docker</code>应该是再熟悉不过了。还记得在2013<del>2014左右的时候，听说多最多的就是<code>Cloud Foundry</code>，那个时候就一直在说云的事情。后面<code>Docker</code>就绝杀了它</del> </p><p>那它帮我们解决了一个什么问题了？面试的时候也许会问到。</p><p>在很久以前，我们开发代码，估计最蛋疼的事情就是发布版本了。我还记得在房多多的时候(2014~2016)左右，每次发布几个开发围绕在运维的身边，有时候运维忙不过来，开发就直接在运维的电脑上开始<code>VIM</code>干活了，修改若干配置。由于多环境的原因，我们无法保证每个环境都是一样的。</p><ul><li>可能你的操作系统不同，导致打包、发布的脚本不同</li><li>环境不同，没有很好的配置管理，你的代码有不同的写法</li><li>特别是跟操作系统相关的那些参数，可能瞬间就会带来性能问题</li></ul><p>那么<code>Docker</code>就可以把我们的操作系统、代码、脚本等都一起打包成一个<code>Image</code>，就可以保证只要是运行同一个<code>Image</code>，我们的所有内容都是一样的。就不会出现，我在测试环境跑的好好的，一到生产连启动都成问题。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>现在一般一个<code>POD</code>就只跑一个进程，<code>DevOps</code>会根据我们的发布流水线自动的将一个项目进行打包、发布，整套的<code>CI</code>、CD做的是行云流水。但是，每个项目<code>ROOT</code>下都会需要一个叫<code>Dockerfile</code>的文件。但偏偏有一些历史项目，没有<code>Dockerfile</code>文件，只有一个<code>Run</code>的容器再跑，真的是非常惊悚。<code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code>,就<code>GAME OVER</code>了。</p><h4 id="怎么办？"><a href="#怎么办？" class="headerlink" title="怎么办？"></a>怎么办？</h4><h5 id="方法1：以当前容器作为基础镜像"><a href="#方法1：以当前容器作为基础镜像" class="headerlink" title="方法1：以当前容器作为基础镜像"></a>方法1：以当前容器作为基础镜像</h5><p>真的，什么也不想。先保个底，把你当前的容器打包成一个镜像推送到仓库里去，哪天有以外或者说需要基于它做一些事情的时候才有可能。比如：你要本地也部署一份代码来<code>debug</code>。</p><p>一般都是私有的仓库，会需要输入用户名与密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker login &#123;仓库地址&#125;</span><br><span class="line">Username: chenyuan</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><p>然后，将镜像打包推送到私有仓库去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a "name" -m "小陈来拯救你" 706e502e8693 &#123;镜像地址&#125;:&#123;tag&#125;</span><br><span class="line"></span><br><span class="line">docker push &#123;镜像地址&#125;:&#123;tag&#125;</span><br><span class="line"></span><br><span class="line">docker pull &#123;镜像地址&#125;:&#123;tag&#125;</span><br></pre></td></tr></table></figure><p>但是这样子的问题在于，我们无法知道环境依赖了哪些模块，如果需要重新再部署一套，我为了保证环境的干净又需要删除哪些东西。就是无法知道增加与减少哪些东西，也就会导致环境存在不一致性，失去了我们的初衷。</p><h5 id="方法2：从运行的容器中复制"><a href="#方法2：从运行的容器中复制" class="headerlink" title="方法2：从运行的容器中复制"></a>方法2：从运行的容器中复制</h5><p>先把镜像跑起来，然后从运行起来的容器中复制文件出来，复制命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从容器复制文件或目录到宿主机器</span></span><br><span class="line">docker cp 6619ff360cce:/opt/h2-data/pkslow ./</span><br><span class="line">docker cp 6619ff360cce:/opt/h2-data/pkslow/pkslow.txt ./</span><br></pre></td></tr></table></figure><p>第一种方法并不是万能的，因为有些镜像过于简单，少了许多基础命令，以至于无法复制文件，也无法进入<code>shell</code>环境。其次，要运行起来再操作，也有点占用资源，比较麻烦。</p><h5 id="方法3：解压镜像tar文件（推荐）"><a href="#方法3：解压镜像tar文件（推荐）" class="headerlink" title="方法3：解压镜像tar文件（推荐）"></a>方法3：解压镜像tar文件（推荐）</h5><p>此方法就是相当于反编译，拿到当时打镜像时候你做的详细操作。比较麻烦，但是是最靠谱的，最具有操作性的。</p><p>先将镜像保存为tar文件，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &#123;name&#125;.tar &#123;镜像地址&#125;:&#123;tag&#125;</span><br></pre></td></tr></table></figure><p>下载后就会有一个tar包在本地，然后就解压出来。可以看一下<code>manifest.json</code>文件的内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Config"</span>: <span class="string">"dca33100e3683d6fb4d56a4c142ccccc1c113f061454a64bc07c852fe068ea1d.json"</span>,</span><br><span class="line">        <span class="attr">"RepoTags"</span>:</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"&#123;镜像地址&#125;:&#123;tag&#125;"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"Layers"</span>:</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"216168069a5195a9424b3a73a62bda39e4d5f8dcae2f7149a336c2e29beeb06b/layer.tar"</span>,</span><br><span class="line">            <span class="string">"4b0e1f4bede4cef5dee11aff78ff89f543dc62eb02306db1b96d896b101e069d/layer.tar"</span>,</span><br><span class="line">            <span class="string">"3fe7f20416fdd4958cc18b6fb0d28881147246c32677d102a431c31bf12288f7/layer.tar"</span>,</span><br><span class="line">            <span class="string">"84c1758c9c15f83d8aa4e1ad13c2918aea80f802f01d19eeb2f7c6e1897d7160/layer.tar"</span>,</span><br><span class="line">            <span class="string">"31bf0d828ecc19f178d8337e1c22a030984e9185e805b48ea911bd866730af2f/layer.tar"</span>,</span><br><span class="line">            <span class="string">"7b30e9a6f195343744ca82c66d31b61771e8d6502a271ad60deb1fa1103e83ca/layer.tar"</span>,</span><br><span class="line">            <span class="string">"522ee848bbd06c6e4dad8d5200b83c9197ccce717fb09687b435190d287f6829/layer.tar"</span>,</span><br><span class="line">            <span class="string">"a64965663d7c30ed09d35f05439dcfb6247f030df0d72a0e78f54fb6ae5a8c74/layer.tar"</span>,</span><br><span class="line">            <span class="string">"a93f0f89669c097497a3e3de7aeffebeba2838f180e4f13844be55fe124885ae/layer.tar"</span>,</span><br><span class="line">            <span class="string">"fd69896888f7361654ed0e27ed2634311b6707dd20706487e33e24f32bb23ebe/layer.tar"</span>,</span><br><span class="line">            <span class="string">"69c55c418aba5b8fb5239b4e8b092e02100f4ec49dae8ded9cc0a161b21884d7/layer.tar"</span>,</span><br><span class="line">            <span class="string">"5ef51ffa437403d5d33a40208c3781ea84a93f53947e5d7fad086092667bd3b1/layer.tar"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>图片是解压后的效果，里面都会存在一个<code>layer.tar</code>，这里再解压就是当时打镜像时候的一些资源文件。</p><p><img src="http://static.cyblogs.com/image-20210928200049751.png" alt="http://static.cyblogs.com/image-20210928200049751.png"></p><p><img src="http://static.cyblogs.com/image-20210928200334841.png" alt="http://static.cyblogs.com/image-20210928200334841.png"></p><p>红色的部分就是我们想要的内容。再辛苦一点，把自己想要的东西整理出来。描述的比较轻描淡写，任何事情只要手动去做一遍，就会理解与记住。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://segmentfault.com/a/1190000040213872?sort=newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040213872?sort=newest</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;现在对于一个开发来说，&lt;code&gt;Docker&lt;/code&gt;应该是再熟悉不过了。还记得在2013&lt;del&gt;2014左右的时候，听说多最多的就
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://www.cyblogs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://www.cyblogs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>如何利用k8s的label与ingress做蓝绿发布？</title>
    <link href="http://www.cyblogs.com/2021/10/30/2021/10/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8k8s%E7%9A%84label%E4%B8%8Eingress%E5%81%9A%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2021/10/30/2021/10/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8k8s%E7%9A%84label%E4%B8%8Eingress%E5%81%9A%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83%EF%BC%9F/</id>
    <published>2021-10-29T16:00:00.000Z</published>
    <updated>2021-10-30T02:54:41.325Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>之前在思考双活/多活架构的时候，其实对于蓝绿发布是有一些了解的，也梳理过在底层存储是一份，服务是多份的模式有做过深入的分析。但那个时候对于<code>Kubernetes</code>的了解还不是很熟悉，是通过传统的方式来考量的。</p><p>因为现在的互联网公司基本都是上云了，我们也必须对于<code>Kubernetes</code>那一整套要有比较深入、熟悉的运用才能真的提高我们的效率。先聊一下，我为什么需要利用灰度+蓝绿发布的模式来去做？</p><p>现在有一个比较老的项目，应该在10年+，每天请求量大概在1.5亿+，峰值的<code>QPS</code>在6000/s，存在着比较多性能问题。现在需要在它上面新增一个服务，为了后面优化做准备，比如：请求的分流、限流、熔断、日志的上报与监控（新）、统一编译处理，特殊报文转换等。也就是说，只要你新增加了一层，你才有可能更好的去做更多的事情。</p><p>那么我们需要达到一些什么的基础条件了？</p><ul><li>服务流量比较大，我们需要对新服务的可靠性需要验证，需要灰度先了解</li><li>因为存在慢查询，不能在滚动发布中，导致请求还未执行完毕，就被k8s kill掉了，业务会感知到502</li></ul><p>如果是你？针对于这2个基础的要求，你会如何去思考的你架构方案呢？</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>新增服务的思考：</p><ul><li>它的性能必须要强、服务稳定。一个服务的性能好不好，其实跟它的：<code>I/O</code>模型、线程模型、数据结构、算法等息息相关。比如：你在思考<code>Redis</code>单线程为什么快的时候？应该就很能get到这里的点了。解决这个问题，我们选择了<code>Go</code>语言来开发（当然，最熟悉的语言风险最小），为了保证性能，也是做了2轮非常细致的压测。</li><li>发布过程中不能因为kill掉服务导致请求<code>502</code>。如果说我在发布的过程中，我把滚动这一步省略掉，直接先准备好一份最新的，验证可以后，我一刀直接把流量引导最新服务上，老的服务也不会断掉，这是否就可以达到效果了？</li></ul><h4 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h4><p>下面是我画的一个架构图，方便大家的理解，一共是3条路线：</p><p><img src="http://static.cyblogs.com/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8k8s%E7%9A%84label%E4%B8%8Eingress%E5%81%9A%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83_%E6%9E%B6%E6%9E%84%E5%9B%BE02.jpg" alt="http://static.cyblogs.com/如何利用k8s的label与ingress做蓝绿发布_架构图02.jpg"></p><h5 id="路线1：原始的路线"><a href="#路线1：原始的路线" class="headerlink" title="路线1：原始的路线"></a>路线1：原始的路线</h5><ul><li><code>Ingress</code> → <code>Service:server-read</code> → <code>StatefulSet:server-g3-read + server-g3-read-gray</code>，整条链路是通过<code>ingress</code>的指向与<code>selector</code>的标签：<code>k8s-app:server-read</code>。</li></ul><h5 id="路线2：灰度方案"><a href="#路线2：灰度方案" class="headerlink" title="路线2：灰度方案"></a>路线2：灰度方案</h5><h6 id="服务正常"><a href="#服务正常" class="headerlink" title="服务正常"></a>服务正常</h6><p>就是我只能让一少部分的流量进入到新的服务(2%~10%，支持慢慢调整，其实就是pod的数量占比)。</p><ul><li><code>2%</code>的概率走的路径：<code>Ingress</code> → <code>Service:server-gateway-read01</code> → <code>StatefulSet:server-gateway-read01</code> → <code>注册中心获取负载地址</code> → <code>Service:server-read</code> → <code>StatefulSet:server-g3-read + server-g3-read-gray</code>，整条链路是通过<code>ingress</code>的指向与<code>selector</code>的标签：<code>server-app:server-gateway-read01</code></li><li><code>98%</code>的概率还是走的路线1</li></ul><h6 id="服务异常解决方案"><a href="#服务异常解决方案" class="headerlink" title="服务异常解决方案"></a>服务异常解决方案</h6><ul><li>因为这个流量是通过节点数来控制的，如果发生异常，可以把灰度节点的POD数量调整为0</li><li>还可以从ingress的地址切换到线路1的原始方案。这一招永远生效，因为一整套label标签依然存在。</li></ul><h5 id="路线3：蓝绿路线"><a href="#路线3：蓝绿路线" class="headerlink" title="路线3：蓝绿路线"></a>路线3：蓝绿路线</h5><h6 id="服务正常-1"><a href="#服务正常-1" class="headerlink" title="服务正常"></a>服务正常</h6><ul><li>100%的流量全部走灰度方案的。即：<code>Ingress</code> → <code>Service:server-gateway-read01</code> → <code>StatefulSet:server-gateway-read01</code> → <code>注册中心获取负载地址</code> → <code>Service:server-read</code> → <code>StatefulSet:server-g3-read + server-g3-read-gray</code>。但是它的<code>selector</code>的标签：<code>server-app:server-gateway-read02</code></li></ul><h6 id="服务异常解决方案-1"><a href="#服务异常解决方案-1" class="headerlink" title="服务异常解决方案"></a>服务异常解决方案</h6><ul><li>直接切换ingress地址到线路1或者是线路2都可以</li></ul><h4 id="最终的方案"><a href="#最终的方案" class="headerlink" title="最终的方案"></a>最终的方案</h4><p>后面如果长期稳定后，方案2其实就没有必要再继续灰度了，直接就替换成线路3了。相当于是一个蓝绿+主备的模式了。优缺点非常的明显：</p><ul><li>优点：解决了重启中可能出现的中断问题，其实也可以通过一些 <code>Graceful Shutdown</code>优化。</li><li>缺点：就是发布的一瞬间，你是需要多出一倍的机器来支撑服务的。</li></ul><p>再温馨提示一下，因为做了蓝绿发布，我们的系统对应的配置中心应该也最好是要分开的。系统之间要避免蓝色通过与绿色通道之间的交叉访问等问题。</p><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;之前在思考双活/多活架构的时候，其实对于蓝绿发布是有一些了解的，也梳理过在底层存储是一份，服务是多份的模式有做过深入的分析。但那个时候对于&lt;
      
    
    </summary>
    
    
      <category term="运维" scheme="http://www.cyblogs.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Kubernetes" scheme="http://www.cyblogs.com/tags/Kubernetes/"/>
    
      <category term="蓝绿发布" scheme="http://www.cyblogs.com/tags/%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>如何利用wrk与Jmeter做性能压测</title>
    <link href="http://www.cyblogs.com/2021/10/23/2021/10/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8wrk%E4%B8%8EJmeter%E5%81%9A%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/"/>
    <id>http://www.cyblogs.com/2021/10/23/2021/10/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8wrk%E4%B8%8EJmeter%E5%81%9A%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/</id>
    <published>2021-10-22T16:00:00.000Z</published>
    <updated>2021-10-23T08:43:44.510Z</updated>
    
    <content type="html"><![CDATA[<p>我们在新做项目的时候，需要对我们的服务有有一些性能指标，比如：<code>SLA</code>（需要达到多少个9）、<code>QPS</code>、<code>TPS</code>等。因为这些量化的数字让我们更加的了解我们的系统。</p><p>我们如何压测？其实个人觉得有2种场景。</p><p><strong>第一种</strong>：是我们明确的知道目标，看我们通过大量的并发看我们是否有达到。如果没有达到，我们需要通过水平扩容、性能优化等让其达到。</p><p><strong>第二种</strong>：是我们不知道目标，通过压测可以知道一个固定配置下的单机单服务的最大性能，让我们对它有一个彻底的认识。为后面的目标做更多的铺垫与准备，或者跟行业水平对比，看看差距有多少。</p><h4 id="如何用wrk进行压测？"><a href="#如何用wrk进行压测？" class="headerlink" title="如何用wrk进行压测？"></a>如何用wrk进行压测？</h4><p>Github地址:<a href="https://github.com/wg/wrk，该项目也是开源项目，关注的人还不少，有30.4K。咨询了一下身边的同事，使用它的人还不少。主要的语言的是C语言。" target="_blank" rel="noopener">https://github.com/wg/wrk，该项目也是开源项目，关注的人还不少，有30.4K。咨询了一下身边的同事，使用它的人还不少。主要的语言的是C语言。</a></p><p><img src="http://static.cyblogs.com/Jietu20211023-153923.jpg" alt="http://static.cyblogs.com/Jietu20211023-153923.jpg"></p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg/wrk</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">-- 拷贝wrk到bin</span><br><span class="line">cp wrk /usr/sbin/wrk</span><br></pre></td></tr></table></figure><h5 id="压测脚本"><a href="#压测脚本" class="headerlink" title="压测脚本"></a>压测脚本</h5><p><strong>压测脚本press.sh</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">bf=0i</span><br><span class="line">rm ./report_mock.$&#123;1&#125;.txt 2&gt; /dev/null</span><br><span class="line">for k in 10; do</span><br><span class="line">    bf=`expr $&#123;k&#125; \* 100`</span><br><span class="line">    for len in 512k; do</span><br><span class="line">        echo "start length $&#123;len&#125;" &gt;&gt; ./report_mock.$&#123;1&#125;.txt</span><br><span class="line">        ./wrk  -c$&#123;bf&#125; -t16 -d3m --timeout 2m --latency -s ./post_$&#123;len&#125;.lua http://$&#123;1&#125;/press/$&#123;len&#125; &gt;&gt; ./report_mock.$&#123;1&#125;.txt</span><br><span class="line">        echo "----------------------------------------------------" &gt;&gt; ./report_mock.$&#123;1&#125;.txt</span><br><span class="line">    done</span><br><span class="line">    sleep 10</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>Lua脚本post_512.lua</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrk.method = <span class="string">"POST"</span></span><br><span class="line">wrk.body = <span class="string">'&#123;"key":"value"&#125;'</span></span><br><span class="line">wrk.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span></span><br><span class="line">wrk.headers[<span class="string">"X-Forwarded-For"</span>] = <span class="string">"6.6.6.6"</span></span><br></pre></td></tr></table></figure><p>这里是一个通用脚本，大致的含义是：</p><ul><li>删除掉原来生成的文件</li><li>循环10次，其实也就是从并发数从100~1000依次进行压测</li><li>返回的报文大小控制在512K，这个可以为根据你的Request去匹配你的Response。</li><li>-t16：启动16个线程</li><li>-d3m：也测时间是3mins</li><li>–timeout：2m  超时时间是2mins  </li><li>post_${len}.lua：就是构造512K返回的Request参数对应的lua脚本</li><li>report_mock.${1}.txt：结果会append到该文件中去</li><li>${1}：就是你要向哪个服务器发起请求的host+port</li></ul><p>总结一下，这些时间需要根据自己的服务器性能去调整，有可能压测出来的数据就是空的，因为超时了未返回Response。</p><h5 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  </span><br><span class="line">    -d, --duration    &lt;T&gt;  压测时间           </span><br><span class="line">    -t, --threads     &lt;N&gt;  使用多少个线程进行压测   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  指定Lua脚本路径       </span><br><span class="line">    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      </span><br><span class="line">        --latency          在压测结束后，打印延迟统计信息   </span><br><span class="line">        --timeout     &lt;T&gt;  超时时间     </span><br><span class="line">    -v, --version          打印正在使用的wrk的详细版本信息</span><br><span class="line">                                                      </span><br><span class="line">  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)</span><br><span class="line">  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)</span><br></pre></td></tr></table></figure><h5 id="执行的结果"><a href="#执行的结果" class="headerlink" title="执行的结果"></a>执行的结果</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">start length 512k</span><br><span class="line">Running 3m test @ http://&#123;ip+port&#125;/press/512k # &#123;ip+port&#125;是你自己的</span><br><span class="line">  16 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   145.17ms  942.97ms   0.86m    98.34%</span><br><span class="line">    Req/Sec     1.39k   114.27     3.58k    70.07%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     50%   36.58ms</span><br><span class="line">     75%   48.78ms</span><br><span class="line">     90%  185.51ms</span><br><span class="line">     99%    1.78s </span><br><span class="line">  3994727 requests in 3.00m, 65.25GB read</span><br><span class="line">  Non-2xx or 3xx responses: 3863495</span><br><span class="line">Requests/sec:  22181.33</span><br><span class="line">Transfer/sec:    371.00MB</span><br></pre></td></tr></table></figure><p>会给一个分布非常的好：50%、75%、90%、99%。</p><p>但是如果说这么看大量的数据不够直观，这里再提供一个一个python脚本来解析里面的值。使其能把这些日志的重要的信息提取出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ms</span><span class="params">(fr)</span>:</span></span><br><span class="line">    fr = fr.lower()</span><br><span class="line">    <span class="keyword">if</span> fr[<span class="number">-2</span>:] == <span class="string">'ms'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-2</span>])</span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>:] == <span class="string">'s'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>]) * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>] == <span class="string">'m'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>]) * <span class="number">1000</span> * <span class="number">60</span></span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mb</span><span class="params">(fr)</span>:</span></span><br><span class="line">    fr = fr.lower()</span><br><span class="line">    <span class="keyword">if</span> fr[<span class="number">-2</span>:] == <span class="string">'gb'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-2</span>]) * <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-2</span>:] == <span class="string">'mb'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-2</span>])</span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-2</span>:] == <span class="string">'kb'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-2</span>]) / <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>] == <span class="string">'b'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>]) / <span class="number">1000</span> / <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>] == <span class="string">'k'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>]) / <span class="number">1000</span></span><br><span class="line">    <span class="keyword">elif</span> fr[<span class="number">-1</span>] == <span class="string">'m'</span>:</span><br><span class="line">        to = float(fr[:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> to</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one</span><span class="params">(one)</span>:</span></span><br><span class="line">    ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> one.split(<span class="string">'\n'</span>):</span><br><span class="line">        <span class="keyword">if</span> l.find(<span class="string">'test @ http://'</span>) &gt; <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'host'</span>] = l.split(<span class="string">'://'</span>)[<span class="number">1</span>].split(<span class="string">'/'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'start length'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'size'</span>] = l.split(<span class="string">' '</span>)[<span class="number">-1</span>].strip()</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'threads and'</span>) &gt; <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'threads'</span>] = int(l.split(<span class="string">'threads and'</span>)[<span class="number">0</span>].strip())</span><br><span class="line">            ret[<span class="string">'conns'</span>] = int(l.split(<span class="string">'threads and'</span>)[<span class="number">1</span>].split(<span class="string">'connections'</span>)[<span class="number">0</span>].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'    Latency'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'l_avg'</span>] = ms(l[len(<span class="string">'    Latency'</span>):].lstrip().split(<span class="string">' '</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'     50%'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'l_50'</span>] = ms(l[len(<span class="string">'     50%'</span>):].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'     90%'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'l_90'</span>] = ms(l[len(<span class="string">'     90%'</span>):].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'     99%'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'l_99'</span>] = ms(l[len(<span class="string">'     99%'</span>):].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'Requests/sec:'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'qps'</span>] = float(l[len(<span class="string">'Requests/sec:'</span>):].strip())</span><br><span class="line">        <span class="keyword">elif</span> l.find(<span class="string">'Transfer/sec:'</span>) == <span class="number">0</span>:</span><br><span class="line">            ret[<span class="string">'mbps'</span>] = mb(l[len(<span class="string">'Transfer/sec:'</span>):].strip())</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/Users/chenyuan/Desktop/report_mock.127.0.0.1.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    all = f.read().strip()</span><br><span class="line">    out = []</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> all.split(<span class="string">'----------------------------------------------------\n'</span>):</span><br><span class="line">        r = parse_one(one)</span><br><span class="line">        out.append((r[<span class="string">'host'</span>], r[<span class="string">'size'</span>], r[<span class="string">'conns'</span>], r[<span class="string">'l_avg'</span>], r[<span class="string">'l_50'</span>], r[<span class="string">'l_90'</span>], r[<span class="string">'l_99'</span>], r[<span class="string">'qps'</span>], r[<span class="string">'mbps'</span>]))</span><br><span class="line">    out.sort()</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> out:</span><br><span class="line">        print(<span class="string">'\t'</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> o]))</span><br></pre></td></tr></table></figure><p>最终你可以再在文本里面利用列操作的方式，将内容归整到Excel中去。你就可以很好的汇报与分享给他人了~</p><p><img src="http://static.cyblogs.com/Jietu20211023-160325.jpg" alt="http://static.cyblogs.com/Jietu20211023-160325.jpg"></p><h4 id="如何利用Jmeter进行压测？"><a href="#如何利用Jmeter进行压测？" class="headerlink" title="如何利用Jmeter进行压测？"></a>如何利用Jmeter进行压测？</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。</p><p>Apache jmeter 可以用于对静态的和动态的资源（文件，Servlet，Perl脚本，java 对象，数据库和查询，FTP服务器等等）的性能进行测试。它可以用于对服务器、网络或对象模拟繁重的负载来测试它们的强度或分析不同压力类型下的整体性能。你可以使用它做性能的图形分析或在大并发负载测试你的服务器/脚本/对象。</p><p>Jmeter也是在进行压测中使用场景很多的软件，图形界面操作起来非常的友好。简单的写一个Demo流程出来。</p><h5 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h5><p>官网：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a> </p><p><img src="http://static.cyblogs.com/Jietu20211023-160918.jpg" alt="http://static.cyblogs.com/Jietu20211023-160918.jpg"></p><p>下载解压完毕后大概的一个目录结构，可以把bin配置到path中就可以直接通过jmeter密令激活软件了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  jmeter pwd</span><br><span class="line">/Users/chenyuan/Tools/jmeter</span><br><span class="line">➜  jmeter ll</span><br><span class="line">total 64</span><br><span class="line">-rw-rw-r--@   1 chenyuan  staff    15K  1  2  1970 LICENSE</span><br><span class="line">-rw-rw-r--@   1 chenyuan  staff   167B  1  2  1970 NOTICE</span><br><span class="line">-rw-rw-r--@   1 chenyuan  staff   9.6K  1  2  1970 README.md</span><br><span class="line">drwxrwxr-x@  43 chenyuan  staff   1.3K  1  2  1970 bin</span><br><span class="line">drwxr-xr-x@   6 chenyuan  staff   192B  1  2  1970 docs</span><br><span class="line">drwxrwxr-x@  22 chenyuan  staff   704B  1  2  1970 extras</span><br><span class="line">drwxrwxr-x@ 104 chenyuan  staff   3.3K  1  2  1970 lib</span><br><span class="line">drwxrwxr-x@ 104 chenyuan  staff   3.3K  1  2  1970 licenses</span><br><span class="line">drwxr-xr-x@  19 chenyuan  staff   608B  1  2  1970 printable_docs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我这里直接运行，最好配置PATH，后续更加的方便</span></span><br><span class="line">➜  jmeter ./bin/jmeter</span><br><span class="line">================================================================================</span><br><span class="line">Don't use GUI mode for load testing !, only for Test creation and Test debugging.</span><br><span class="line">For load testing, use CLI Mode (was NON GUI):</span><br><span class="line">   jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]</span><br><span class="line">&amp; increase Java Heap to meet your test requirements:</span><br><span class="line">   Modify current env variable HEAP="-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m" in the jmeter batch file</span><br><span class="line">Check : https://jmeter.apache.org/usermanual/best-practices.html</span><br><span class="line">================================================================================</span><br><span class="line"><span class="meta">#</span><span class="bash"> 就这代表已经启动了，运行期间不要终端命令框。</span></span><br></pre></td></tr></table></figure><h5 id="创建测试"><a href="#创建测试" class="headerlink" title="创建测试"></a>创建测试</h5><p>先看一张整体的图吧，对它有一个比较整体的认识：</p><p><img src="http://static.cyblogs.com/Jietu20211023-161956.jpg" alt="http://static.cyblogs.com/Jietu20211023-161956.jpg"></p><p>我们可以按照<a href="https://www.cnblogs.com/stulzq/p/8971531.html" target="_blank" rel="noopener">https://www.cnblogs.com/stulzq/p/8971531.html</a> 的步骤一步的去做。我这里就不做太多重复的介绍。因为相对比wrk来的简单。</p><p>最后可以点击运行来跑单测，一般我们会调整线程数的大小、发送的频率来进行压测看结果。</p><p><img src="http://static.cyblogs.com/Jietu20211023-162302.jpg" alt="http://static.cyblogs.com/Jietu20211023-162302.jpg"></p><p>我们在断言的地方是可以做很多的事情的，因为什么样的结果是正确的，什么样的结果是失败的。获取需要从Response中、Header里截取一些关键的key与value来做逻辑。这些可以通过编写脚本来去做到，那就算相对高阶一点的操作了。后续可以继续深入一下~ </p><p>最后可以在汇总报告里可以看出来我们的一个性能情况，SLA的比例等。</p><p>作为一名后端开发，对自己写出来的服务进行一个非常全面的性能压测是很有必要的。对于系统的一个QPS、TPS、SLA这些数字应该随口就能说出来。哪些地方存在性能瓶颈？然后再去找相应的方案去优化掉。很多时候，性能可能就会是一个最大的风险，它会导致我们的服务整体的瘫痪、不可用。这些很有可能就跟我们的KPI、奖金挂钩~</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.jianshu.com/p/aa76ffd6d894" target="_blank" rel="noopener">https://www.jianshu.com/p/aa76ffd6d894</a></li><li><a href="https://www.cnblogs.com/stulzq/p/8971531.html" target="_blank" rel="noopener">https://www.cnblogs.com/stulzq/p/8971531.html</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在新做项目的时候，需要对我们的服务有有一些性能指标，比如：&lt;code&gt;SLA&lt;/code&gt;（需要达到多少个9）、&lt;code&gt;QPS&lt;/code&gt;、&lt;code&gt;TPS&lt;/code&gt;等。因为这些量化的数字让我们更加的了解我们的系统。&lt;/p&gt;
&lt;p&gt;我们如何压测？其实个人觉得
      
    
    </summary>
    
    
      <category term="性能压测" scheme="http://www.cyblogs.com/categories/%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/"/>
    
    
      <category term="wrk" scheme="http://www.cyblogs.com/tags/wrk/"/>
    
      <category term="Jmeter" scheme="http://www.cyblogs.com/tags/Jmeter/"/>
    
  </entry>
  
  <entry>
    <title>【go学习】地址符&amp;与指针*的差别</title>
    <link href="http://www.cyblogs.com/2021/10/15/2021/10/%E3%80%90go%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9C%B0%E5%9D%80%E7%AC%A6&amp;%E4%B8%8E%E6%8C%87%E9%92%88*%E7%9A%84%E5%B7%AE%E5%88%AB/"/>
    <id>http://www.cyblogs.com/2021/10/15/2021/10/%E3%80%90go%E5%AD%A6%E4%B9%A0%E3%80%91%E5%9C%B0%E5%9D%80%E7%AC%A6&amp;%E4%B8%8E%E6%8C%87%E9%92%88*%E7%9A%84%E5%B7%AE%E5%88%AB/</id>
    <published>2021-10-14T16:00:00.000Z</published>
    <updated>2021-10-15T12:54:05.309Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>项目中开始用<code>Go</code>，最近写了一下<code>Demo</code>，发现语法还是非常好用，大部分比<code>Java</code>还是简洁很多，也有一些很细节的约定。比如：</p><ul><li>字母大小写控制是全包还是本包内访问</li><li>变量定义了就一定要使用，否则就会编译不通过等等</li></ul><p>更好的就是方法可以返回多个值，这个跟<code>Java</code>比较就是减少很多的封装。因为<code>Go</code>的线程模型特点，用来写一些需要高并发、高性能的项目还是非常好的。所以，趁这个机会也好好的深入了解下。现在也是把<code>Python</code>、<code>PHP</code>、<code>Go</code>等都学习一遍，每种语言都有它的优缺点，其实都还挺不错的。</p><p>针对于<code>Go</code>语言里：<code>&amp;</code>与<code>*</code>的区别，什么时候该用什么做一个总结。</p><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>我们经常会听到别人说<code>Go</code>是值传递，某某某是引用传递，某某某是指针传递，等等各种各样的说法。</p><p>那么首先他们的区别是什么呢？什么是指针？指针其实也是一个变量，只不过这个变量里面存的不是<code>int</code>，<code>float</code>，<code>struct</code>，而是一个地址<code>address</code>，然后在这个<code>address</code>上所存储的数据可以通过指针来被阅读到。</p><p><code>OK</code>，指针变量存储的是一个地址，地址从哪里来的？那就得问一个变量的地址怎么取得呢？在变量前面加上一个&amp;符号就行。</p><p>好的，指针变量存储了这个地址了，那这个地址所存储的值怎么被阅读到呢？也就是指针所指向的值怎么拿到呢？在指针变量前面加上一个<code>*</code>符号就行。</p><p>怎么修改指针所指向的数据呢？在前面加上<code>*</code>符号之后再赋一个新的值就可以了。</p><p>我们来看一个栗子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="string">"vernonchen"</span></span><br><span class="line">b := &amp;a</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"a的值"</span>, a)</span><br><span class="line">fmt.Println(<span class="string">"a的地址"</span>, b)</span><br><span class="line">fmt.Println(<span class="string">"b的值"</span>, b)</span><br><span class="line">fmt.Println(<span class="string">"b的指针指向"</span>, *b)</span><br><span class="line"></span><br><span class="line">*b = <span class="string">"not vernonchen"</span></span><br><span class="line">fmt.Println(<span class="string">"修改后，b的指针指向"</span>, *b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出的结果是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a的值 vernonchen</span><br><span class="line">a的地址 0xc00008e1e0 // 使用的是b</span><br><span class="line">b的值 0xc00008e1e0</span><br><span class="line">b的指针指向 vernonchen //使用的是指针</span><br><span class="line">修改后，b的指针指向 not vernonchen // 重新指向新的值</span><br></pre></td></tr></table></figure><h4 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h4><p>为什么要有指针这个东西？它有什么关键性的作用呢？</p><p>我们来看下面这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">userName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(user User)</span></span> &#123;</span><br><span class="line">user.userName = <span class="string">"vernonchen2222"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyWithPoint</span><span class="params">(user *User)</span></span> &#123;</span><br><span class="line">user.userName = <span class="string">"vernonchen3333"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">user := User&#123;userName: <span class="string">"vernonchen"</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"userName = "</span>, user.userName)</span><br><span class="line"></span><br><span class="line">modify(user)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"userName = "</span>, user.userName)</span><br><span class="line"></span><br><span class="line">modifyWithPoint(&amp;user)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"userName = "</span>, user.userName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完后，输出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userName =  vernonchen</span><br><span class="line">userName =  vernonchen // 没有被替换</span><br><span class="line">userName =  vernonchen3333 // 被替换</span><br></pre></td></tr></table></figure><p>所以指针的作用:</p><ol><li><p>指针不但可以帮助函数内部修改外部变量的值，还可以帮助我们在任何地方修改其所指向数据的值；</p></li><li><p>传递指针参数可以节省拷贝大结构体的内存开销；</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>指针也是变量，只不过存储的是地址</li><li>通过指针可以去修改其指向数据的值</li><li>指针可以帮助我们在任何地方修改其所指向数据的值</li><li>传递指针参数可以节省拷贝大结构体的内存开销</li></ul><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://studygolang.com/articles/32103" target="_blank" rel="noopener">https://studygolang.com/articles/32103</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;项目中开始用&lt;code&gt;Go&lt;/code&gt;，最近写了一下&lt;code&gt;Demo&lt;/code&gt;，发现语法还是非常好用，大部分比&lt;code&gt;Jav
      
    
    </summary>
    
    
      <category term="Go" scheme="http://www.cyblogs.com/categories/Go/"/>
    
    
      <category term="Go" scheme="http://www.cyblogs.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>pt-online-schema-change使用</title>
    <link href="http://www.cyblogs.com/2021/09/15/2021/09/pt-online-schema-change%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.cyblogs.com/2021/09/15/2021/09/pt-online-schema-change%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-14T16:00:00.000Z</published>
    <updated>2021-10-17T16:16:10.912Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>如果说你的数据量并发量不大，或者你的数据量很少没有到千万级别，也许<code>pt-osc</code>、<code>gh-osc</code>，online-ddl这些工具都用不着。但是，如果你的数据量很大，数据又很热。如果你没有这些工具，你可能无法完成对一个数据库新增一个字段或者任何一个简单的<code>DDL</code>语句。</p><p>简单的分析一下，为了保证数据一致性问题，我们在哪儿都会遇到锁的问题，锁是用来保证顺序性的。谁先拥有锁，谁就可以先执行。锁也会存在力度问题，它跟你要做的一件事情息息相关，我们也会在性能上去做取舍，所有就好了行锁、表锁等。</p><h4 id="Waiting-for-table-metadata-lock"><a href="#Waiting-for-table-metadata-lock" class="headerlink" title="Waiting for table metadata lock"></a>Waiting for table metadata lock</h4><p>说一下我遇到的这个场景，数据量数据大概在800W左右，但是表非常的热，长事务也很多。当我要对一个表新增字段的时候，这个时候如果你经验不够足，可能就会“量成大祸”。一般在做<code>DDL</code>会出现：Waiting for table metadata lock。</p><p>如果长时间获取不到锁的话，就出现一个可怕的情况：</p><ul><li>如果前面的事务未提交，当前是获取不到锁，就不可以执行<code>DDL</code>语句</li><li>在<code>DDL</code>语句未执行之前，后面的请求全部是被hold住的</li></ul><p>这样子就会导致一前一后同时夹击，导致整个业务不可用。那么出现Waiting for table metadata lock可能是由哪些原因导致的？</p><h6 id="场景一：长事物运行，阻塞DDL，继而阻塞所有同表的后续操作"><a href="#场景一：长事物运行，阻塞DDL，继而阻塞所有同表的后续操作" class="headerlink" title="场景一：长事物运行，阻塞DDL，继而阻塞所有同表的后续操作"></a>场景一：长事物运行，阻塞DDL，继而阻塞所有同表的后续操作</h6><p>通过<code>show processlist</code>可以看到<code>TableA</code>上有正在进行的操作（包括读），此时alter table语句无法获取到<code>metadata</code> 独占锁，会进行等待。</p><p>这是最基本的一种情形，这个和<code>mysql 5.6</code>中的<code>online ddl</code>并不冲突。一般<code>alter table</code>的操作过程中，在<code>after create</code>步骤会获取<code>metadata</code> 独占锁，当进行到<code>altering table</code>的过程时（通常是最花时间的步骤），对该表的读写都可以正常进行，这就是<code>online ddl</code>的表现，并不会像之前在整个<code>alter table</code>过程中阻塞写入。（当然，也并不是所有类型的alter操作都能online的，具体可以参见官方手册：<a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html）" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html）</a><br><strong>处理方法：</strong> kill 掉 DDL所在的session.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出所有执行时间超过 5 分钟的线程，拼凑出 kill 语句，方便后面查杀</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'kill '</span>, <span class="keyword">id</span>, <span class="string">';'</span>)</span><br><span class="line"><span class="keyword">from</span> information_schema.processlist</span><br><span class="line"><span class="keyword">where</span> Command != <span class="string">'Sleep'</span> <span class="keyword">AND</span> COMMAND != <span class="string">'Binlog Dump GTID'</span> <span class="keyword">AND</span> COMMAND != <span class="string">'Binlog Dump'</span></span><br><span class="line">  <span class="keyword">and</span> <span class="built_in">Time</span> &gt; <span class="number">300</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">Time</span> <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h6 id="场景二：未提交事物，阻塞DDL，继而阻塞所有同表的后续操作"><a href="#场景二：未提交事物，阻塞DDL，继而阻塞所有同表的后续操作" class="headerlink" title="场景二：未提交事物，阻塞DDL，继而阻塞所有同表的后续操作"></a>场景二：未提交事物，阻塞DDL，继而阻塞所有同表的后续操作</h6><p>通过<code>show processlist</code>看不到<code>TableA</code>上有任何操作，但实际上存在有未提交的事务，可以在 <strong>information_schema.innodb_trx</strong>中查看到。在事务没有完成之前，TableA上的锁不会释放，<code>alter table</code>同样获取不到<code>metadata</code>的独占锁。</p><p>处理方法：通过 <code>select * from information_schema.innodb_trx\G</code>, 找到未提交事物的<code>sid</code>, 然后 <code>kill</code> 掉，让其回滚。</p><h6 id="场景三：显示事务失败未提交"><a href="#场景三：显示事务失败未提交" class="headerlink" title="场景三：显示事务失败未提交"></a>场景三：显示事务失败未提交</h6><p>通过<code>show processlist</code>看不到<code>TableA</code>上有任何操作，在<code>information_schema.innodb_trx</code>中也没有任何进行中的事务。这很可能是因为在一个显式的事务中，对<code>TableA</code>进行了一个失败的操作（比如查询了一个不存在的字段），这时事务没有开始，但是失败语句获取到的锁依然有效，没有释放。从<code>performance_schema.events_statements_current</code>表中可以查到失败的语句。</p><p>官方手册上对此的说明如下：</p><p>If the server acquires metadata locks for a statement that is syntactically valid but fails during execution, it does not release the locks early. Lock release is still deferred to the end of the transaction because the failed statement is written to the binary log and the locks protect log consistency.</p><p>也就是说除了语法错误，其他错误语句获取到的锁在这个事务提交或回滚之前，仍然不会释放掉。because the failed statement is written to the binary log and the locks protect log consistency 但是解释这一行为的原因很难理解，因为错误的语句根本不会被记录到二进制日志。</p><p><strong>处理方法：</strong>通过performance_schema.events_statements_current找到其sid, kill 掉该session. 也可以 <code>kill</code> 掉<code>DDL</code>所在的<code>session</code>.</p><p>上述是手动操作，毕竟是一个比手速的过程，而且也不能保证保证100%，还需要经常的kill进程才行。</p><h4 id="gt-osc使用"><a href="#gt-osc使用" class="headerlink" title="gt-osc使用"></a>gt-osc使用</h4><p>请看参考地址，对于一些online ddl工具研究后，对gt-osc做了一个初步的使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pt-online-schema-change --host=xxx -uxxx -pxxx \</span><br><span class="line">--alter "add xxx int(1) NOT NULL DEFAULT '0'  COMMENT 'xxx', add xxx varchar(10) NOT NULL DEFAULT '0'  COMMENT 'xxx' , lock=none"  D=xxx,t='xxx' \</span><br><span class="line">--execute \</span><br><span class="line">--print \</span><br><span class="line">--statistics \</span><br><span class="line">--no-check-alter</span><br></pre></td></tr></table></figure><p>执行后其实它做了这些工作，具体如下：</p><ol><li>相关环境参数检查</li><li>检查该表格是否存在</li><li>show create table xxx</li><li>create table _xxx_new</li><li>alter table _xxx_new</li><li>创建删除触发器 pt_osc_db_table_name_del </li><li>创建更新触发器 pt_osc_db_table_name_upd</li><li>创建插入触发器 pt_osc_db_table_name_ins</li><li>按块拷贝数据到新表，拷贝过程对数据行持有S锁</li><li>analyze 新表</li><li>rename 表名，RENAME TABLE <code>db</code>.<code>table_name</code> TO <code>db</code>.<code>_table_name_old</code>, <code>db</code>.<code>_table_name_new</code> TO <code>db</code>.<code>table_name</code></li><li>删除旧表</li><li>删除新表上的删除、更新、插入 触发器</li></ol><p>可以去看一下网站的说明：<a href="https://www.percona.com/blog/2019/06/07/how-pt-online-schema-change-handles-foreign-keys/" target="_blank" rel="noopener">https://www.percona.com/blog/2019/06/07/how-pt-online-schema-change-handles-foreign-keys/</a></p><p><img src="http://static.cyblogs.com/Jietu20211018-000822.jpg" alt="http://static.cyblogs.com/Jietu20211018-000822.jpg"></p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://cloud.tencent.com/developer/article/1500170" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1500170</a></li><li><a href="https://cloud.tencent.com/developer/article/1508051" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1508051</a></li><li><a href="https://huangzhw.github.io/2018/09/20/mysql-online-ddl/#%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">https://huangzhw.github.io/2018/09/20/mysql-online-ddl/#%E5%B0%8F%E7%BB%93</a></li><li><a href="https://www.cnblogs.com/digdeep/p/4892953.html" target="_blank" rel="noopener">https://www.cnblogs.com/digdeep/p/4892953.html</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;如果说你的数据量并发量不大，或者你的数据量很少没有到千万级别，也许&lt;code&gt;pt-osc&lt;/code&gt;、&lt;code&gt;gh-osc&lt;/cod
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.cyblogs.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://www.cyblogs.com/tags/MySQL/"/>
    
      <category term="数据库" scheme="http://www.cyblogs.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>批量操作脚本让你5mins搞定发版</title>
    <link href="http://www.cyblogs.com/2021/04/15/2021/04/%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E8%84%9A%E6%9C%AC%E8%AE%A9%E4%BD%A05mins%E6%90%9E%E5%AE%9A%E5%8F%91%E7%89%88/"/>
    <id>http://www.cyblogs.com/2021/04/15/2021/04/%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E8%84%9A%E6%9C%AC%E8%AE%A9%E4%BD%A05mins%E6%90%9E%E5%AE%9A%E5%8F%91%E7%89%88/</id>
    <published>2021-04-14T16:00:00.000Z</published>
    <updated>2021-04-15T07:54:49.063Z</updated>
    
    <content type="html"><![CDATA[<h4 id="代码分支管理"><a href="#代码分支管理" class="headerlink" title="代码分支管理"></a>代码分支管理</h4><p>大家在做微服务拆分后，难免会导致<code>Application</code>项目以及一些二房包的数量加剧，<code>10+</code>个项目我想应该是很容易的超过。然后这些细粒度的拆分后就会导致发布版本时候的麻烦。</p><p>展示一下现阶段我们的一个<code>git</code>的分支流程图，仅供参考。</p><p><img src="http://static.cyblogs.com/git_flow_publish_20210415.jpg" alt="http://static.cyblogs.com/git_flow_publish_20210415.jpg"></p><p>简单说明一下：</p><ul><li><code>dev</code>环境每次都是从<code>master</code>拉取一个分支，取名为<code>dev-{发布日期}-{sequenceId}</code>，<code>sequenceId</code>从<code>01</code>开始叠加，避免一个版本需要反复拉取多次。</li><li>到了<code>test</code>阶段，也是为了收敛（前期严格一点）。提测的时候代码需要合并到<code>test</code>分支来。</li><li>到<code>UAT</code>阶段，还是需要从<code>master</code>拉取分支，如果出现要重新拉取分支的情况下，还是严格拉取<code>master</code>分支的代码。主要是为了与<code>master</code>保持一致，避免把别人的覆盖掉。取名为<code>release-{发布日期}-{sequenceId}</code>，规则同上。</li><li>上生产后，验证完毕后需要把代码合并到<code>master</code>分支，并且打包<code>tag</code>。</li></ul><p>但是在这个过程中，需要有拉取新分支，合并分支，批量删除分支，打<code>tag</code>等等繁琐的操作，项目一多如果有一个批量脚本就更好了。下面我就列举一些平时使用最多的几个，仅供参考：</p><h4 id="批量脚本"><a href="#批量脚本" class="headerlink" title="批量脚本"></a>批量脚本</h4><h5 id="01-批量拉取新分支"><a href="#01-批量拉取新分支" class="headerlink" title="01-批量拉取新分支"></a>01-批量拉取新分支</h5><p>比如一个新的迭代要开始了，就需要从<code>master</code>拉取<code>dev</code>分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">OLD_BR_NAME="$1"</span><br><span class="line">NEW_BR_NAME="$2"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $OLD_BR_NAME ]; then</span><br><span class="line">    echo "Please input your old branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f $NEW_BR_NAME ]; then</span><br><span class="line">    echo "Please input your new branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function gitCheckoutBrachAndPushRemote() &#123;</span><br><span class="line">    echo "-------- $1 --------"</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git checkout $OLD_BR_NAME</span><br><span class="line">git fetch</span><br><span class="line">git pull</span><br><span class="line">git checkout -b $NEW_BR_NAME $OLD_BR_NAME</span><br><span class="line">git push --set-upstream origin $NEW_BR_NAME</span><br><span class="line">echo "success push branch " $NEW_BR_NAME " to remote"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        gitCheckoutBrachAndPushRemote "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>具体使用，比如以<code>master</code>为基础拉取一个新分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./git_batch_co_push_remote.sh master dev-20210419-01</span><br></pre></td></tr></table></figure><h5 id="02-批量切换分支"><a href="#02-批量切换分支" class="headerlink" title="02-批量切换分支"></a>02-批量切换分支</h5><p>做不同的需求时候，需要来回的切换分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">BR_NAME="$1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $BR_NAME ]; then</span><br><span class="line">    echo "Please input your branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function gitCheckoutBrach() &#123;</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git fetch</span><br><span class="line">git checkout $BR_NAME</span><br><span class="line">echo "success checkout to " $BR_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        gitCheckoutBrach "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>具体的使用，先切换成<code>master</code>分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./git_batch_co_brach.sh dev-20210412-01</span><br></pre></td></tr></table></figure><h5 id="03-批量删除远程分支"><a href="#03-批量删除远程分支" class="headerlink" title="03-批量删除远程分支"></a>03-批量删除远程分支</h5><p>有时候不小心写错了分支名字，或者分支太多，需要删除批量删除远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">BR_NAME="$1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $BR_NAME ]; then</span><br><span class="line">    echo "Please input your branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git fetch</span><br><span class="line">git push origin --delete $BR_NAME</span><br><span class="line">echo "success delete remote branch: " $BR_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        doSomething "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>具体的使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./git_batch_delete_remote.sh dev-20210412-01</span><br></pre></td></tr></table></figure><p>结果就是可以把远程分支<code>dev-20210412-01</code>一次性全部删除掉。</p><h5 id="04-批量合并分支代码"><a href="#04-批量合并分支代码" class="headerlink" title="04-批量合并分支代码"></a>04-批量合并分支代码</h5><p>从一个环境到另外也跟环境，就需要大量的<code>merge</code>操作。其实<code>Git</code>的<code>merge</code>操作比SVN的要好很多。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">BR_NAME="$1"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $BR_NAME ]; then</span><br><span class="line">    echo "Please input your branch name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function gitCheckoutBrach() &#123;</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git merge $BR_NAME</span><br><span class="line">    git push</span><br><span class="line">    echo "success merge from branch" $BR_NAME " and push remote"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        gitCheckoutBrach "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>具体使用，记得要先更新相关的代码哦~ </p><p>比如是从<code>dev</code>合并到<code>test</code>，那么先更新对应的代码，然后<code>co</code>到test的目录去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./git_batch_co_merge_push_remote.sh dev-20210412-01</span><br></pre></td></tr></table></figure><h5 id="05-批量给分支打tag"><a href="#05-批量给分支打tag" class="headerlink" title="05-批量给分支打tag"></a>05-批量给分支打tag</h5><p>比如我们的流程是在上生产后为master打一个新的tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤目录</span></span><br><span class="line">EXCLUDE_DIR_OR_FILE=("cr-test-demo" "git_batch_co_brach.sh" "git_batch_co_push_remote.sh" "git_batch_co_merge_push_remote.sh")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分支名字</span></span><br><span class="line">TAG_NAME=$1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验参数</span></span><br><span class="line">if [ -f $TAG_NAME ]; then</span><br><span class="line">    echo "Please input your tag name."</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到某个分支</span></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    cd "$1"</span><br><span class="line">    pwd</span><br><span class="line">    git fetch</span><br><span class="line">git checkout master</span><br><span class="line">    git tag -a $TAG_NAME -m "创建分支$TAG_NAME"</span><br><span class="line">echo "success create tag " $TAG_NAME</span><br><span class="line">    git push origin --tags</span><br><span class="line">    echo "success push tag to remote" $TAG_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in `ls "$WORK_DIR"`;do</span><br><span class="line">    cd "$WORK_DIR"</span><br><span class="line">    if [[ -d $i ]] &amp;&amp; [[ ! "$&#123;EXCLUDE_DIR_OR_FILE[@]&#125;"  =~ "$&#123;i&#125;" ]];then</span><br><span class="line">        doSomething "$i"</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>具体使用，首先切换为<code>master</code>分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./git_batch_tag_push.sh v1.0.0</span><br></pre></td></tr></table></figure><h5 id="06-批量mvn打包"><a href="#06-批量mvn打包" class="headerlink" title="06-批量mvn打包"></a>06-批量mvn打包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录空间</span></span><br><span class="line">HOME_DIR="/Users/chenyuan"</span><br><span class="line">WORK_DIR=$HOME_DIR"/Workspaces/xxx" // 替换为你的工作目录</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要deploy的工程</span></span><br><span class="line">NEED_DEPLOY_DIR_OR_FILE=("xxxx") // 这里添加你要打包的项目名称，空格分开</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># get all folder in "$WORK_DIR"</span></span></span><br><span class="line">for i in "$&#123;NEED_DEPLOY_DIR_OR_FILE[@]&#125;";do</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">cd</span> <span class="string">"<span class="variable">$WORK_DIR</span>"</span></span></span><br><span class="line">echo "$WORK_DIR/$i";</span><br><span class="line">cd "$WORK_DIR/$i";</span><br><span class="line">git pull</span><br><span class="line">mvn install deploy -Dpmd.skip=true -Dcheckstyle.skip=true -Dmaven.test.skip=true</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>具体使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./git_batch_deploy_snapshot.sh</span><br></pre></td></tr></table></figure><p>上面的这些脚本也是因为当时自己要发布版本，总共写脚本花费了<code>20~30mins</code>的时候，发布时间也才<code>30mins</code>。如果那天我不写这个脚本，业务我每次都要花费<code>60+mins</code>去做，而且其他不熟悉的人做发布的时候肯定会花费更多的时间。开发就应该把那些重复的事情标准化与产品化。能够真的做到可持续~ </p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li>推荐一本书《持续交付2.0》，地址：<a href="https://item.jd.com/12512514.html" target="_blank" rel="noopener">https://item.jd.com/12512514.html</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;代码分支管理&quot;&gt;&lt;a href=&quot;#代码分支管理&quot; class=&quot;headerlink&quot; title=&quot;代码分支管理&quot;&gt;&lt;/a&gt;代码分支管理&lt;/h4&gt;&lt;p&gt;大家在做微服务拆分后，难免会导致&lt;code&gt;Application&lt;/code&gt;项目以及一些二房包的数量加剧
      
    
    </summary>
    
    
      <category term="Git" scheme="http://www.cyblogs.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.cyblogs.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>0-1背包问题Knapsack Problem</title>
    <link href="http://www.cyblogs.com/2021/03/29/2021/03/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98Knapsack%20Problem/"/>
    <id>http://www.cyblogs.com/2021/03/29/2021/03/0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98Knapsack%20Problem/</id>
    <published>2021-03-28T16:00:00.000Z</published>
    <updated>2021-03-29T13:22:40.419Z</updated>
    
    <content type="html"><![CDATA[<p>背包问题<code>(Knapsack Problem, KP)</code>是<code>NP</code>完全问题，也是一类重要 的组合优化问题 ，在工业 、经济 、通信、金融与计算机 等领域的资 源分配 、 资金预算 、 投资决策 、 装载问题 、 整数规划 、 分布式系统 与密码系统中具有重要的理论和应用价值。</p><p><strong>通俗说法</strong></p><p>贼，夜入豪宅，可偷之物甚多，而负重能力有限，偷哪些才更加不枉此行？</p><p><strong>抽象说法</strong></p><p>给定一组多个（<img src="https://www.zhihu.com/equation?tex=n" alt="[公式]">)）物品，每种物品都有自己的重量（<img src="https://www.zhihu.com/equation?tex=w_i" alt="[公式]">)）和价值（<img src="https://www.zhihu.com/equation?tex=v_i" alt="[公式]">)），在限定的总重量/总容量（<img src="https://www.zhihu.com/equation?tex=C" alt="[公式]">）内，选择其中若干个（也即每种物品可以选0个或1个），设计选择方案使得物品的总价值最高。</p><p><strong>更加抽象的说法</strong></p><p>给定正整数<img src="https://www.zhihu.com/equation?tex=%5C%7B%28w_i%2Cv_i%29%5C%7D_%7B1%5Cleq+i%5Cleq+n%7D" alt="[公式]">)、给定正整数<img src="https://www.zhihu.com/equation?tex=C" alt="[公式]">，求解0-1规划问题：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmax+%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7Bx_iv_i%7D" alt="[公式]"> ， s.t. <img src="https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7Bx_iw_i%7D%5Cleq+C" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=x_i%5Cin%5C%7B0%2C1%5C%7D" alt="[公式]"> 。</p><h4 id="0-1背包问题的递推关系"><a href="#0-1背包问题的递推关系" class="headerlink" title="0-1背包问题的递推关系"></a>0-1背包问题的递推关系</h4><p>定义子问题 <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7B%5Ctext%7BP%28i%2C+W%29%7D%7D" alt="[公式]"> 为：在前 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 个物品中挑选总重量不超过 <img src="https://www.zhihu.com/equation?tex=W" alt="[公式]"> 的物品，每种物品至多只能挑选1个，使得总价值最大；这时的最优值记作 <img src="https://www.zhihu.com/equation?tex=m%28i%2CW%29" alt="[公式]"> ，其中 <img src="https://www.zhihu.com/equation?tex=1%5Cleq+i%5Cleq+n" alt="[公式]"> ， <img src="https://www.zhihu.com/equation?tex=1%5Cleq+W%5Cleq+C" alt="[公式]"> 。</p><p>考虑第 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 个物品，无外乎两种可能：选，或者不选。</p><ul><li>不选的话，背包的容量不变，改变为问题 <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7B%7BP%28i-1%2C+W%29%7D%7D" alt="[公式]"> ；</li><li>选的话，背包的容量变小，改变为问题 <img src="https://www.zhihu.com/equation?tex=%5Cmathbf%7B%7BP%28i-1%2C+W-w_i%29%7D%7D" alt="[公式]"> 。</li></ul><p>最优方案就是比较这两种方案，哪个会更好些：</p><p><img src="https://www.zhihu.com/equation?tex=m%28i%2CW%29%3D%5Cmax%5C%7Bm%28i-1%2CW%29%2Cm%28i-1%2CW-w_i%29%2Bv_i%5C%7D" alt="[公式]"> 。</p><p><img src="http://static.cyblogs.com/v2-1d8090c991ca13cee3cb43c027b72304_1440w.jpg" alt="http://static.cyblogs.com/v2-1d8090c991ca13cee3cb43c027b72304_1440w.jpg"></p><p>得到</p><p><img src="https://www.zhihu.com/equation?tex=%5C%5Bm%28i%2CW%29%3D%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%7B55%7D%7Bl%7D%7D+0+%26+%5Ctext%7Bif+%7D+i%3D%5Ctext%7B0%7D+%5C%5C+0+%26+%5Ctext%7Bif+%7D+W%3D%5Ctext%7B0%7D+%5C%5C+m%28i-1%2CW%29+%26+%5Ctext%7Bif+%7D%7Bw_i%3EW%7D+%5C%5C+%5Cmax+%5Cleft%5C%7B+m%28i-1%2CW%29%2C%7B%7Bv%7D_%7Bi%7D%7D%2Bm%28i-1%2CW-%7B%7Bw%7D_%7Bi%7D%7D%29+%5Cright%5C%7D+%26+%5Ctext%7Botherwise%7D+%5C%5C+%5Cend%7Barray%7D+%5Cright.%5C%5D+" alt="[公式]"> 。</p><h4 id="“填二维表”的动态规划方法"><a href="#“填二维表”的动态规划方法" class="headerlink" title="“填二维表”的动态规划方法"></a>“填二维表”的动态规划方法</h4><p><img src="https://www.zhihu.com/equation?tex=m%28i%2CW%29%3Dm%28i-1%2CW-w_i%29%2Bv_i" alt="[公式]"> 时才会有“取第 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]"> 件物品”发生。</p><p>所以从表格右下角“往回看”如果是“垂直下降”就是发生了 <img src="https://www.zhihu.com/equation?tex=m%28i%2CW%29%3Dm%28i-1%2CW%29" alt="[公式]"> ，而只有“走斜线”才是“取了”物品。</p><p><img src="http://static.cyblogs.com/v2-7bd4c72ec3b5f104e4db3c4aad98cc66_1440w.png" alt="http://static.cyblogs.com/v2-7bd4c72ec3b5f104e4db3c4aad98cc66_1440w.png"></p><p>这个算法的复杂度就很容易算了——每一个格子都要填写数字，所以时间复杂度和空间复杂度都是 <img src="https://www.zhihu.com/equation?tex=%5COmega%28nC%29" alt="[公式]"> 。当” <img src="https://www.zhihu.com/equation?tex=C%3E2%5En" alt="[公式]"> “时（就不严谨地使用渐近分析的语言了），复杂度是 <img src="https://www.zhihu.com/equation?tex=%5COmega%28n2%5En%29" alt="[公式]"> 。</p><h4 id="手撕Java版本代码"><a href="#手撕Java版本代码" class="headerlink" title="手撕Java版本代码"></a>手撕Java版本代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with leetcode-cn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 0-1 背包问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/3/29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 10:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">6</span>, W = <span class="number">21</span>;</span><br><span class="line">        <span class="comment">// 重量</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">// 价值</span></span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="comment">// 重量 * 价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] B = <span class="keyword">new</span> <span class="keyword">int</span>[N][W];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k,C;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; N; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (C = <span class="number">1</span>; C &lt; W; C++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[k] &gt; C) &#123;</span><br><span class="line">                    B[k][C] = B[k-<span class="number">1</span>][C];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 装进书包</span></span><br><span class="line">                    <span class="keyword">int</span> value1 = B[k-<span class="number">1</span>][C-w[k]] + v[k];</span><br><span class="line">                    <span class="comment">// 不装进书包</span></span><br><span class="line">                    <span class="keyword">int</span> value2 = B[k-<span class="number">1</span>][C];</span><br><span class="line">                    <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">                        B[k][C] = value1;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        B[k][C] = value2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(B[<span class="number">5</span>][<span class="number">20</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出的结果是：26。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.bilibili.com/video/BV1U5411s7d7?t=1899" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1U5411s7d7?t=1899</a></li><li><a href="https://zhuanlan.zhihu.com/p/30959069" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30959069</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;背包问题&lt;code&gt;(Knapsack Problem, KP)&lt;/code&gt;是&lt;code&gt;NP&lt;/code&gt;完全问题，也是一类重要 的组合优化问题 ，在工业 、经济 、通信、金融与计算机 等领域的资 源分配 、 资金预算 、 投资决策 、 装载问题 、 整数规划 、 分布
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.cyblogs.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.cyblogs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令 kill -9 的原理</title>
    <link href="http://www.cyblogs.com/2021/03/28/2021/03/Linux%E5%91%BD%E4%BB%A4%20kill%20-9%20%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://www.cyblogs.com/2021/03/28/2021/03/Linux%E5%91%BD%E4%BB%A4%20kill%20-9%20%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2021-03-27T16:00:00.000Z</published>
    <updated>2021-03-28T12:51:15.154Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>相信很多程序员对于 <code>Linux</code> 系统都不陌生，即使自己的日常开发机器不是 <code>Linux</code>，那么线上服务器也大部分都是的，所以，掌握常用的 <code>Linux</code> 命令也是程序员必备的技能。</p><p>但是，怕就怕很多人对于部分命令只是一知半解，使用不当就能导致线上故障。</p><p>前段时间，我们的线上应用报警，频繁 <code>FGC</code>，需要紧急处理问题，于是有同事去线上重启机器（正常程序应该是先采集堆 <code>dump</code>，然后再重启，方便排查是否存在内存泄露等问题）。</p><p>但是在重启过程中，同事发现正常的重启命令应用无反应，然后尝试使用 <code>kill</code> 命令 “杀” 掉 <code>Java</code> 进程，但是仍然无效。于是他私自决定使用 “<code>kill -9</code>“ 结束了进程的生命。</p><p>虽然应用进程被干掉了，但是随之而来带来了很多问题，首先是上游系统突然发生大量报警，对应开发找过来说调用我们的 <code>RPC</code> 服务无响应，频繁超时。</p><p>后来，我们又发现系统中存在部分脏数据，有些在同一个事务中需要完整更新的数据，只更新了一半…</p><p>为什么正常的 <code>kill</code> 无法 “杀掉” 进程，而 <code>kill -9</code> 就可以？为什么 <code>kill -9</code> 会引发这一连串连锁反应？正常的 <code>kill</code> 执行时，JVM 会如何处理的呢？</p><p>要搞清楚这些问题，我们要先从 <code>kill</code> 命令说起。</p><h4 id="kill-命令"><a href="#kill-命令" class="headerlink" title="kill 命令"></a>kill 命令</h4><p>我们都知道，想要在 <code>Linux</code> 中终止一个进程有两种方式，如果是前台进程可以使用 <code>Ctrl+C</code> 键进行终止；如果是后台进程，那么需要使用 <code>kill</code> 命令来终止。（其实 <code>Ctrl+C</code> 也是 <code>kill</code> 命令）</p><p><code>kill</code> 命令的格式是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kill [参数] [进程号]</span><br><span class="line">如：</span><br><span class="line">kill 90124</span><br><span class="line">kill -9  90124</span><br></pre></td></tr></table></figure><p>其中 [参数] 是可选的，进程号可以通过 <code>jps/ps/pidof/pstree/top</code> 等工具获取。</p><p><code>kill</code> 的命令参数有以下几种：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="line"></span><br><span class="line">-a 当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="line"></span><br><span class="line">-p 指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="line"></span><br><span class="line">-s 指定发送信号</span><br><span class="line"></span><br><span class="line">-u 指定用户</span><br></pre></td></tr></table></figure><p>通常情况下，我们使用的 <code>- l</code>(信号) 的时候比较多，如我们前文提到的 <code>kill -9</code> 中的 <code>9</code> 就是信号。</p><p>信号如果没有指定的话，默认会发出终止信号 (<code>15</code>)。常用的信号如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HUP 1 终端断线</span><br><span class="line"></span><br><span class="line">INT 2 中断（同 Ctrl + C）</span><br><span class="line"></span><br><span class="line">QUIT 3 退出（同 Ctrl + \）</span><br><span class="line"></span><br><span class="line">TERM 15 终止</span><br><span class="line"></span><br><span class="line">KILL 9 强制终止</span><br><span class="line"></span><br><span class="line">CONT 18 继续（与STOP相反， fg/bg命令）</span><br><span class="line"></span><br><span class="line">STOP 19 暂停（同 Ctrl + Z）</span><br></pre></td></tr></table></figure><p>比较常用的就是<code>强制终止信号：9</code> 和<code>终止信号：15</code>，另外，<code>中断信号：2</code> 其实就是我们前文提到的 <code>Ctrl + C</code> 结束前台进程。</p><p>那么，<code>kill -9</code> 和 <code>kill -15</code> 到底有什么区别呢？该如何选择呢？</p><h4 id="kill-9-和-kill-15-的区别"><a href="#kill-9-和-kill-15-的区别" class="headerlink" title="kill -9 和 kill -15 的区别"></a>kill -9 和 kill -15 的区别</h4><p><code>kill</code> 命令默认的信号就是 <code>15</code>，首先来说一下这个默认的 <code>kill -15</code> 信号。</p><p>当使用 <code>kill -15</code> 时，系统会发送一个 <code>SIGTERM</code> 的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。</p><p>这时候，应用程序可以选择：</p><ul><li>1、立即停止程序</li><li>2、释放响应资源后停止程序</li><li>3、忽略该信号，继续执行程序</li></ul><p>因为 <code>kill -15</code> 信号只是通知对应的进程要进行 “安全、干净的退出”，程序接到信号之后，退出前一般会进行一些 “准备工作”，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。</p><p>但是，如果在 “准备工作” 进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。</p><p>这也就是为什么我们有的时候使用 <code>kill</code> 命令是没办法 “杀死” 应用的原因，因为默认的 <code>kill</code> 信号是 <code>SIGTERM（15）</code>，而 <code>SIGTERM（15）</code>的信号是可以被阻塞和忽略的。</p><p>和 <code>kill -15</code> 相比，<code>kill -9</code> 就相对强硬一点，系统会发出 SIGKILL 信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。</p><p>所以，相比于 <code>kill -15</code> 命令，<code>kill -9</code> 在执行时，应用程序是没有时间进行 “准备工作” 的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。</p><h4 id="Java-是如何处理-SIGTERM（15）"><a href="#Java-是如何处理-SIGTERM（15）" class="headerlink" title="Java 是如何处理 SIGTERM（15）"></a>Java 是如何处理 SIGTERM（15）</h4><p>我们都知道，在 <code>Linux</code> 中，<code>Java</code> 应用是作为一个独立进程运行的，<code>Java</code> 程序的终止运行是基于 <code>JVM</code> 的关闭实现的，JVM 关闭方式分为 3 种：</p><ul><li>正常关闭：当最后一个非守护线程结束或者调用了 <code>System.exit</code> 或者通过其他特定平台的方法关闭（接收到 <code>SIGINT（2）</code>、<code>SIGTERM</code>（15）信号等）</li><li>强制关闭：通过调用 <code>Runtime.halt</code> 方法或者是在操作系统中强制 <code>kill</code>（接收到 <code>SIGKILL（9）</code>信号)</li><li>异常关闭：运行中遇到 <code>RuntimeException</code> 异常等</li></ul><p><code>JVM</code> 进程在接收到 <code>kill -15</code> 信号通知的时候，是可以做一些清理动作的，比如删除临时文件等。</p><p>当然，开发者也是可以自定义做一些额外的事情的，比如让 <code>tomcat</code> 容器停止，让 <code>dubbo</code> 服务下线等。</p><p>而这种自定义 <code>JVM</code> 清理动作的方式，是通过 <code>JDK</code> 中提供的 <code>shutdown hook</code> 实现的。<code>JDK</code> 提供了 <code>Java.Runtime.addShutdownHook(Thread hook)</code> 方法，可以注册一个 JVM 关闭的钩子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with leetcode-cn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/3/28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span>: 20:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"hook execute..."</span>);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="comment">// app is runing</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"main thread execute end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令：</p><p><img src="http://static.cyblogs.com/Jietu20210328-204711.jpg" alt="http://static.cyblogs.com/Jietu20210328-204711.jpg"></p><p>控制台输出内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hook execute...</span><br><span class="line">Process finished with exit code 143 (interrupted by signal 15: SIGTERM)</span><br></pre></td></tr></table></figure><p>可以看到，当我们使用 <code>kill</code>（默认 <code>kill -15</code>）关闭进程的时候，程序会先执行我注册的 <code>shutdownHook</code>，然后再退出，并且会给出一个提示：<code>interrupted by signal 15: SIGTERM</code></p><p>如果我们执行命令 <code>kill -9</code>：</p><p><img src="http://static.cyblogs.com/Jietu20210328-204851.jpg" alt="http://static.cyblogs.com/Jietu20210328-204851.jpg"></p><p>控制台输出内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process finished with exit code 137 (interrupted by signal 9: SIGKILL)</span><br></pre></td></tr></table></figure><p>可以看到，当我们使用 <code>kill -9</code> 强制关闭进程的时候，程序并没有执行 <code>shutdownHook</code>，而是直接退出了，并且会给出一个提示：<code>interrupted by signal 9: SIGKILL</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>kill</code> 命令用于终止 <code>Linux</code> 进程，默认情况下，如果不指定信号，<code>kill</code> 等价于 <code>kill -15</code>。</p><p><code>kill -15</code> 执行时，系统向对应的程序发送 <code>SIGTERM（15）</code>信号，该信号是可以被执行、阻塞和忽略的，所以应用程序接收到信号后，可以做一些准备工作，再进行程序终止。</p><p>有的时候，<code>kill -15</code> 无法终止程序，因为他可能被忽略，这时候可以使用 <code>kill -9</code>，系统会发出 <code>SIGKILL（9）</code>信号，该信号不允许忽略和阻塞，所以应用程序会立即终止。</p><p>这也会带来很多副作用，如数据丢失等，所以，在非必要时，不要使用 <code>kill -9</code> 命令，尤其是那些 <code>web</code> 应用、提供 <code>RPC</code> 服务、执行定时任务、包含长事务等应用中，因为 <code>kill -9</code> 没给 <code>spring</code> 容器、<code>tomcat</code> 服务器、<code>dubbo</code> 服务、流程引擎、状态机等足够的时间进行收尾。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/windforce828/article/details/106119445" target="_blank" rel="noopener">https://blog.csdn.net/windforce828/article/details/106119445</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;相信很多程序员对于 &lt;code&gt;Linux&lt;/code&gt; 系统都不陌生，即使自己的日常开发机器不是 &lt;code&gt;Linux&lt;/code&gt;，那
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.cyblogs.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.cyblogs.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Kafka消费者组是什么？</title>
    <link href="http://www.cyblogs.com/2021/03/25/2021/03/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://www.cyblogs.com/2021/03/25/2021/03/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2021-03-25T04:36:15.432Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Kafka消费者组是什么？"><a href="#一、Kafka消费者组是什么？" class="headerlink" title="一、Kafka消费者组是什么？"></a>一、Kafka消费者组是什么？</h4><p><code>Consumer Group</code> 是<code>Kafka</code>提供的可扩展且具有容错性的消费者机制。在组内多个消费者实例(<code>Consumer Instance</code> ),它们共享一个公共的ID即 <code>Group ID</code> 。组内的所有消费者协调在一起消费订阅主题（<code>Subscribed Topics</code>）的所有分区(<code>Partition</code>)。当然一个分区只能有同一个消费者组的一个<code>Consumer</code> 实例消费。<br><code>Consumer Group</code> 有三个特性：</p><ul><li><code>Consumer Group</code> 下可以有一个或多个<code>Consumer</code> 实例。 这里的实例可以是一个单独的进程，也可以是同一进程下的线程；</li><li><code>Group ID</code> 是一个字符串， 在Kafka集群中唯一标识，<code>Consumer Group</code>；</li><li><code>Consumer Group</code><br>下所有实例订阅主体的单个分区，只能分配给组内某个<code>Consumer</code>实例消费。同一个分区消息可能被多个<code>Group</code> 消费。</li></ul><h4 id="二、Kafka消费者组解决了哪些问题？"><a href="#二、Kafka消费者组解决了哪些问题？" class="headerlink" title="二、Kafka消费者组解决了哪些问题？"></a>二、Kafka消费者组解决了哪些问题？</h4><p>传统的消息系统中，有两种消息引擎模型：点对点模型（消息队列）、发布/订阅模型<br>传统的两种消息系统各有优势，我们里对比一下：</p><ul><li>传统的消息队列模型的缺陷在于消息一旦被消费，就会从队列中删除，而且只能被下游的一个<code>Consumer</code>消费。严格的说这不是它的缺陷，<br>这是它的一个特性。但很显然这种模型的伸缩性（<code>Scalability</code>）很差，因为下游的多个<code>Consumer</code> 都要“抢”<br>这个共享消息队列的消息；</li><li>发布/订阅模型,允许消息被多个<code>Consumer</code> 消费，但它的问题也是伸缩性不高，因为订阅者都必须订阅所有主体的所有分区。</li></ul><p><code>Kafka</code> 为规避传统消息两种模型的缺点，引入了 <code>Consumer Group</code> 机制：</p><ul><li>当 <code>Consumer Group</code> 订阅多个主题后，组内的每个实例不要求一定要订阅主题的所有分区，它只会消费部分分区中的消息；</li><li><code>Consumer Group</code> 之间彼此队里，互不影响，它们可以订阅同一组主题而互不干涉。加上<code>Broker</code>端的消息留存机制，<code>Kafka</code>的<code>Consumer Group</code> 完美的避开了伸缩性差的问题；</li><li><code>kafka</code> 是用<code>Consumer Group</code>机制，实现了，传统两大消息引擎。如果所有实例属于同一个<code>Group</code>，那么它实现的就是消息队列模型；如果所有实例分别属于不同的<code>Group</code>，且订阅了相同的主题，那么它就实现了发布/订阅模型；</li></ul><h4 id="三、Consumer-Group-实例数量多少才合理？"><a href="#三、Consumer-Group-实例数量多少才合理？" class="headerlink" title="三、Consumer Group 实例数量多少才合理？"></a>三、Consumer Group 实例数量多少才合理？</h4><p>最理想的情况是<code>Consumer</code>实例的数量应该等于该<code>Group</code>订阅主题的分区总数。例如：<code>Consumer Group</code> 订阅了 3个主题，分别是<code>A、B、C</code>，它们的分区数依次是<code>1、2、3</code>，那么通常情况下，为该<code>Group</code> 设置<code>6</code>个<code>Consumer</code>实例是比较理想的情形。</p><p>如果设置小于或大于<code>6</code>的实例可以吗？当然可以，如果你有<code>3</code>个实例，那么平均下来每个实例大约消费<code>2</code>个分区<code>（6/3=2）</code>;如果你设置了<code>9</code>个实例，那么很遗憾，有<code>3</code>个实例（<code>9-6=3</code>）将不会被分配任何分区，它们永远处于空闲状态。</p><h4 id="四、消费位移"><a href="#四、消费位移" class="headerlink" title="四、消费位移"></a>四、消费位移</h4><p>消费者在消费的过程中要记录自己消费了多少数据，即消费位置信息，在<code>Kafka</code>中叫：位移（<code>offset</code>）。<br>看上去该Offset就是一个数字而已，其实对于Consumer Group 而言，它是一组KV对，Key是分区，V对应Consumer 消费该分区的最新位移。<br>老版本的<code>Consumer Group</code>把位移保存在<code>Zookeeper</code>中。将位移保存在<code>Zookeeper</code>外部系统显然好处是减少了<code>Kafka Broker</code> 端的状态保存开销。现在比较流行的提法是将服务器节点做成无状态的， 这样可以自由扩缩容，实现超强的伸缩性。不过在实际使用场景中，发现<code>ZooKeeper</code> 这类元框架并不是适合进行频繁的写更新，而<code>Consumer Group</code> 的位移更新却是一个非常频繁的操作。 这种大吞吐量的写操作极大的拖慢了<code>ZooKeeper</code> 集群的性能，在新版本的<code>Consumer Group</code> 中，<code>Kafka</code> 社区采用了将<code>Consumer Group</code> 位移保存在<code>Broker</code> 端的内部主题中。</p><h4 id="五、Rebalance"><a href="#五、Rebalance" class="headerlink" title="五、Rebalance"></a>五、Rebalance</h4><p><code>Rebalance</code> 本质上是一种协议，规定了一个<code>Consumer Group</code> 下所有<code>Consumer</code> 如何达成一致，来分配订阅<code>Topic</code>的每个分区。比如：某个<code>Group</code> 下有20个<code>Consumer</code> 实例， 它订阅了一个具有100个分区的<code>Topic</code>。正常情况下，Kafka 平均会为每个<code>Consumer</code> 分配5个分区。这个分配的过程叫<code>Rebalance</code>。<br><code>Consumer Group</code>触发 <code>Rebalance</code>有三种情况：</p><ul><li>组成员数量发生变化，比如有新的<code>Consumer</code> 实例加入组或离开组，抑或是有<code>Consumer</code>实例崩溃被“踢出”组。</li><li>订阅主题数量发生变更。 <code>Consumer Group</code> 可以使用正则表达式订阅主题，比如<br><code>consumer.subscribe(Pattern.complile(“t.*c”))</code>就表明该<code>Group</code>订阅所有<code>t</code>开头，字母<code>c</code>结尾的主题。在<code>Consumer Group</code> 运行时，新创建一个满足这样条件的主题，那么会触发订阅该主题所有<code>Group</code> 开始<code>Rebalance</code>。</li><li>订阅主题分区数发生变化，<code>Kakfka</code> 一个主题，当分区数增加时，就会触发订阅该主题的所有<code>Group</code>开启<code>Rebalance</code>。</li></ul><p><code>Consumer Group</code> 发生<code>Rebalance</code> 的过程：某个 <code>Consumer Group</code> 下有两个<code>Consumer</code> ，比如<code>A</code>和<code>B</code>，当第三个成员<code>C</code>加入时，<code>Kafka</code>会触发<code>Rebalance</code>，并根据默认的分配策重新分配<code>A、B、C</code>分配分区，如下图：<br><img src="http://static.cyblogs.com/kafka_rebalance.png" alt="http://static.cyblogs.com/kafka_rebalance.png"></p><p>注意：目前<code>Rebalance</code> 的设计是所有<code>Consumer</code>实例共同参与，全部重新分配所有分区，<code>Rebalance</code>过程所有<code>Consumer</code> 实例都会停止消费，等待<code>Rebalance</code> 完成。<code>Rebalance</code> 很慢，一个<code>Group</code> 内有几百个<code>Consumer</code>实例，成功进行一次<code>Rebalance</code>需要好几个小时。 目前社区没有终极解决方案，最好的解决方案是规避<code>Rebalane</code>的发生。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/qq_36918149/article/details/99656156" target="_blank" rel="noopener">https://blog.csdn.net/qq_36918149/article/details/99656156</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、Kafka消费者组是什么？&quot;&gt;&lt;a href=&quot;#一、Kafka消费者组是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、Kafka消费者组是什么？&quot;&gt;&lt;/a&gt;一、Kafka消费者组是什么？&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Consumer Gro
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://www.cyblogs.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://www.cyblogs.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>为什么会有重排序？</title>
    <link href="http://www.cyblogs.com/2021/03/01/2021/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.cyblogs.com/2021/03/01/2021/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E9%87%8D%E6%8E%92%E5%BA%8F/</id>
    <published>2021-02-28T16:00:00.000Z</published>
    <updated>2021-03-27T10:27:40.258Z</updated>
    
    <content type="html"><![CDATA[<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>在讲重排序之前，先来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cyblogs.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with leetcode-cn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 验证重排序代码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: chenyuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/3/26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 15:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileSerialCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// 用set来保存数据，保证不会重复</span></span><br><span class="line">        Set&lt;String&gt; resultSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">            b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                a = y;</span><br><span class="line">                x = <span class="number">1</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Thread two = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                b = x;</span><br><span class="line">                y = <span class="number">1</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            one.start();</span><br><span class="line">            two.start();</span><br><span class="line">            one.join();</span><br><span class="line">            two.join();</span><br><span class="line">          <span class="comment">// 等待2个线程都跑完了再把结果添加到Set中去</span></span><br><span class="line">            resultSet.add(<span class="string">"a="</span> + a + <span class="string">",b="</span> + b);</span><br><span class="line">            System.out.println(resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面一段代码是非常经典来讲CPU对指令重排序的案例。因为我们经过一段时间的Run出的结果很惊讶：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a=0,b=0, a=1,b=0, a=0,b=1, a=1,b=1]</span><br></pre></td></tr></table></figure><p>对于<code>a=1,b=1</code>的出现，是会让人非常的奇怪的。出现这个情况，那代码执行的顺序可能是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">     a = y; <span class="comment">// 第3步</span></span><br><span class="line">     x = <span class="number">1</span>; <span class="comment">// 第1步</span></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> Thread two = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">     b = x; <span class="comment">// 第4步</span></span><br><span class="line">     y = <span class="number">1</span>; <span class="comment">// 第2步</span></span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">// 也就是说，在2个线程中，都出现了下面的代码执行到了上面的代码前面去了。</span></span><br></pre></td></tr></table></figure><p>如果是这样子的话，那我们还敢写多线程的代码吗？如果没有一定的规范与约定，那肯定是没人可以写好代码。</p><p>其实这些约定都是在<code>JSR-133内存模型与线程规范</code>里面，它就像是Java的产品需求文档或者说明书。</p><p><img src="http://static.cyblogs.com/Jietu20210327-174611.jpg" alt="http://static.cyblogs.com/Jietu20210327-174611.jpg"></p><p>百度云盘：链接: <a href="https://pan.baidu.com/s/1cO5d95Za8lyz8dMaN0i9lA" target="_blank" rel="noopener">https://pan.baidu.com/s/1cO5d95Za8lyz8dMaN0i9lA</a>  密码: l08w ,大家可以去下载查阅，这些都比较底层，并不能几句话，几篇文章可以讲清楚。</p><h4 id="为什么会重排序"><a href="#为什么会重排序" class="headerlink" title="为什么会重排序?"></a>为什么会重排序?</h4><p>看完上面，你可能会有疑问，为什么会有重排序呢?</p><p>我的程序按照我自己的逻辑写下来好好的没啥问题， Java 虚拟机为什么动我的程序逻辑?</p><p>你想想 <code>CPU</code> 、内存这些都是非常宝贵的资源， Java 虚拟机如果在重排序之后没啥效果，肯定也不会做这种费力不讨好的事情。</p><p>Java 虚拟机之所以要进行重排序就是为了提高程序的性能。你写的程序，简简单单一行代码，到底层可能需要使用不同的硬件，比如一个指令需要同时使用 <code>CPU</code> 和打印机设备，但是此时 CPU 的任务完成了，打印机的任务还没完成，这个时候怎么办呢? 不让 CPU 执行接下来的指令吗? CPU 的时间那么宝贵，你不让它工作，确定不是在浪费它的生命?</p><p>重排序：重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p><p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如下图所示：</p><p><img src="http://static.cyblogs.com/20180326170243607.png" alt="http://static.cyblogs.com/20180326170243607.png"></p><ul><li>上述的1属于编译器重排序</li><li>2和3属于处理器重排序</li></ul><p>这些重排序可能会导致多线程程序出现内存可见性问题。在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是<code>as-if-serial</code>语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h4 id="重排序带来的问题"><a href="#重排序带来的问题" class="headerlink" title="重排序带来的问题"></a>重排序带来的问题</h4><p>回到文章刚开始举的那个例子，重排序提高了 CPU 的利用率没错，提高了程序性能没错，但是我的程序得到的结果可能是错误的啊，这是不是就有点儿得不偿失了?</p><p>因为重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</p><p>凡是问题，都有办法解决，要是没有，那就再想想。</p><p>它是怎么解决的呢? 这就需要来说说，顺序一致性<strong>内存模型</strong>和 <strong>JMM (Java Memory Model ， Java 内存模型)</strong></p><p>我们知道Java线程的所有操作都是在工作区进行的，那么工作区和主存之间的变量是怎么进行交互的呢，可以用下面的图来表示。</p><p><img src="http://static.cyblogs.com/e0e01e43ly1g186enjfwfj20k80degmr.jpg" alt="http://static.cyblogs.com/e0e01e43ly1g186enjfwfj20k80degmr.jpg"><br>Java通过几种原子操作完成<strong>工作区内存</strong>和<strong>主存</strong>的交互</p><ol><li>lock：作用于主存，把变量标识为线程独占状态。</li><li>unlock：作用于主存，解除变量的独占状态。</li><li>read：作用于主存，把一个变量的值通过主存传输到线程的工作区内存。</li><li>load：作用于工作区内存，把<code>read</code>操作传过来的变量值储存到工作区内存的变量副本中。</li><li>use：作用于工作内存，把工作区内存的变量副本传给执行引擎。</li><li>assign：作用于工作区内存，把从执行引擎传过来的值赋值给工作区内存的变量副本。</li><li>store：作用于工作区内存，把工作区内存的变量副本传给主存。</li><li>write：作用于主存，把<code>store</code>操作传过来的值赋值给主存变量。</li></ol><h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p><code>as-if-serial</code>语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器、<code>runtime</code>和处理器都必须遵守<code>as-if-serial</code>语义。</p><p>为了遵守<code>as-if-serial</code>语义，编译器和处理器不会对存在数据依赖关系的操作做重排序。<code>as-if-serial</code>语义把单线程程序保护了起来，<code>as-if-serial</code>语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>终于讲到了 <code>happens-before</code> ,先来看 <code>happens-before</code> 关系的定义：</p><ul><li>如果一个操作 <code>happens-before</code> 另一个操作，那么第一个操作的执行结果就会对第二个操作可见</li><li>两个操作之间如果存在 <code>happens-before</code> 关系，并不意味着 <code>Java</code> 平台的具体实现就必须按照 <code>happens-before</code> 关系指定的顺序来执行。如果重排序之后的执行结果，与按照 <code>happens-before</code> 关系来执行的结果一直，那么 <code>JMM</code> 也允许这样的重排序</li></ul><p>看到这儿，你是不是觉得，这个怎么和 <code>as-if-serial</code> 语义一样呢。没错， <code>happens-before</code> 关系本质上和 <code>as-if-serial</code> 语义是一回事。</p><p><code>as-if-serial</code> 语义保证的是单线程内重排序之后的执行结果和程序代码本身应该出现的结果是一致的， <code>happens-before</code> 关系保证的是正确同步的多线程程序的执行结果不会被重排序改变。</p><p>一句话来总结就是：如果操作 A <code>happens-before</code> 操作 B ，那么操作 A 在内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。</p><p>在 <code>Java</code> 中，对于 <code>happens-before</code> 关系，有以下规定：</p><ul><li>程序顺序规则：一个线程中的每一个操作， <code>happens-before</code> 于该线程中的任意后续操作</li><li>监视器锁规则：对一个锁的解锁， <code>happens-before</code> 于随后对这个锁的加锁</li><li><code>volatile</code> 变量规则：对一个 <code>volatile</code> 域的写， <code>happens-before</code> 与任意后续对这个 <code>volatile</code> 域的读</li><li>传递性：如果 A <code>happens-before</code> B ， 且 B <code>happens-before</code> C ，那么 A <code>happens-before</code> C</li><li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>（启动线程B），那么A线程的<code>ThreadB.start()</code>操作<code>happens-before</code>于线程B中的任意操作。</li><li><code>join()</code>规则：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作<code>happens-before</code>于线程A从ThreadB.join()操作成功返回。</li></ul><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://developer.51cto.com/art/202005/617587.htm" target="_blank" rel="noopener">https://developer.51cto.com/art/202005/617587.htm</a></li><li><a href="https://blog.csdn.net/ym123456677/article/details/79700623" target="_blank" rel="noopener">https://blog.csdn.net/ym123456677/article/details/79700623</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;举个例子&quot;&gt;&lt;a href=&quot;#举个例子&quot; class=&quot;headerlink&quot; title=&quot;举个例子&quot;&gt;&lt;/a&gt;举个例子&lt;/h4&gt;&lt;p&gt;在讲重排序之前，先来看一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.cyblogs.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>第一次这么通俗易懂的讲Paxos算法</title>
    <link href="http://www.cyblogs.com/2021/02/27/2021/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%99%E4%B9%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%AE%B2Paxos%E7%AE%97%E6%B3%95/"/>
    <id>http://www.cyblogs.com/2021/02/27/2021/02/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%99%E4%B9%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%AE%B2Paxos%E7%AE%97%E6%B3%95/</id>
    <published>2021-02-26T16:00:00.000Z</published>
    <updated>2021-02-28T14:49:58.577Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Paxos解决什么问题"><a href="#Paxos解决什么问题" class="headerlink" title="Paxos解决什么问题"></a>Paxos解决什么问题</h4><p>大家对<code>Paxos</code>的看法基本是“晦涩难懂”，虽然论文和网上文章也很多，但总觉得“云山雾罩”，也不知道其具体原理以及到底能解决什么问题。</p><p>究其原因，一方面是很多<code>Paxos</code>的资料都是在通过形式化的证明去论证算法的正确性，自然艰深晦涩；另一方面，基于<code>Paxos</code>的成熟工程实践并不多。本章试图由浅入深，从问题出发，一点点地深入<code>Paxos</code>的世界。</p><h5 id="一个基本的并发问题"><a href="#一个基本的并发问题" class="headerlink" title="一个基本的并发问题"></a>一个基本的并发问题</h5><p>先看一个基本的并发问题，如图116所示。假设有一个KV存储集群，三个客户端并发地向集群发送三个请求。请问，最后在get（X）的时候，X应该等于几？</p><p><img src="http://static.cyblogs.com/Jietu20210228-000345.jpg" alt="http://static.cyblogs.com/Jietu20210228-000345.jpg"></p><p>图116（K，V）集群多写答案是：X=1、X=3或X=5都是对的！但X=4是错的！因为从客户端角度来看，三个请求是并发的，但三个请求到达服务器的顺序是不确定的，所以最终三个结果都有可能。</p><p>这里有很关键的一点：把答案换一种说法，即如果最终集群的结果是X=1，那么当Client1发送X=1的时候，服务器返回X=1；当Client2发送X=3的时候，服务器返回X=1；当Client3发送X=5的时候，服务器返回X=1。相当于Client1的请求被接受了，Client2、Client3的请求被拒绝了。如果集群最终结果是X=3或者X=5，是同样的道理。而这正是<code>Paxos</code>协议的一个特点。</p><h5 id="什么是“时序”"><a href="#什么是“时序”" class="headerlink" title="什么是“时序”"></a>什么是“时序”</h5><p>把问题进一步细化：假设KV集群有三台机器，机器之间互相通信，把自己的值传播给其他机器，三个客户端分别向三台机器发送三个请求，如图117所示。</p><p><img src="http://static.cyblogs.com/Jietu20210228-000644.jpg" alt="http://static.cyblogs.com/Jietu20210228-000644.jpg"></p><p>图117三台机器组成的（K，V）集群多写示意图假设每台机器都把收到的请求按日志存下来（包括客户端的请求和其他Node的请求）。当三个请求执行完毕后，三台机器的日志分别应该是什么顺序？</p><p>结论是：不管顺序如何，只要三台机器的日志顺序是一样的，结果就是正确的。如图118所示，总共有3的全排列，即6种情况，都是正确的。比如第1种情况，三台机器存储的日志顺序都是X=1、X=3、X=5，在最终集群里，X的值肯定等于5。其他情况类似。</p><p><img src="http://static.cyblogs.com/Jietu20210228-000811.jpg" alt="http://static.cyblogs.com/Jietu20210228-000811.jpg"></p><p>而下面的情况就是错误的：机器1的日志顺序是1、3、5，因此最终的值就是X=5；机器2是3、5、1，最终值是X=1；机器3的日志顺序是1、5、3，最终值是X=3。三台机器关于X的值不一致，如图109所示。</p><p><img src="http://static.cyblogs.com/Jietu20210228-000852.jpg" alt="http://static.cyblogs.com/Jietu20210228-000852.jpg"></p><p>通过这个简单的例子就能对“时序”有一个直观的了解：虽然三个客户端是并发的，没有先后顺序，但到了服务器的集群里必须保证三台机器的日志顺序是一样的，这就是所谓的“分布式一致性”。</p><h5 id="Paxos解决什么"><a href="#Paxos解决什么" class="headerlink" title="Paxos解决什么"></a>Paxos解决什么</h5><p>问题在例子中，Node1收到了X=1之后，复制给Node2和Node3；Node2收到X=3之后，复制给Node1和Node3；Node3收到X=5之后，复制给Node1和Node2。</p><p>客户端是并发的，三个Node之间的复制也是并发的，如何保证三个Node最终的日志顺序是一样的呢？也就是图118中6种正确情况中的1种。</p><p>比如Node1先收到客户端的X=1，之后收到Node3的X=5，最后收到Node2的X=3；Node2先收到客户端的X=3，之后收到Node1的X=1，最后收到Node3的X=5……</p><p>如何保证三个Node中存储的日志顺序一样呢？这正是接下来要讲的<code>Paxos</code>要解决的问题！</p><h4 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h4><p>在上文谈到了复制日志的问题，每个Node存储日志序列，Node之间保证日志完全一样。可能有人会问：为何要存储日志，直接存储最终的数据不就行了吗？</p><p>可以把一个变量X或一个对象看成一个状态机。每一次写请求，就是一次导致状态机发生变化的事件，也就是日志。</p><p>以上文中最简单的一个变量X为例，假设只有一个Node，3个客户端发送了三个修改X的指令，最终X的状态就是6，如图1110所示。</p><p><img src="http://static.cyblogs.com/Jietu20210228-001101.jpg" alt="http://static.cyblogs.com/Jietu20210228-001101.jpg"></p><p>图1110状态机X示意图把变量X扩展成MySQL数据库，客户端发送各种DML操作，这些操作落盘成Binlog。然后Binlog被应用，生成各种数据库表格（状态机），如图1111所示。</p><p><img src="http://static.cyblogs.com/Jietu20210228-001145.jpg" alt="http://static.cyblogs.com/Jietu20210228-001145.jpg"></p><p>这里涉及一个非常重要的思想：要选择持久化变化的“事件流（也就是日志流）”，而不是选择持久化“数据本身”（也就是状态机）。为何要这么做呢？原因有很多，列举如下：</p><p>（1）日志只有一种操作，就是append。而数据或状态一直在变化，可以add、delete、update。把三种操作转换成了一种，对于持久化存储来说简单了很多！</p><p>（2）假如要做多机之间数据同步，如果直接同步状态，状态本身可能有一个很复杂的数据结构（比如关系数据库的关联表、树、图），并且状态也一直在变化，要保证多个机器数据一致，要做数据比对，就很麻烦；而如果同步日志，日志是一个一维的线性序列，要做数据比对，则非常容易！</p><p>总之，无论从持久化，还是数据同步角度来看，存储状态机的输入事件流（日志流），都比存储状态机本身更容易。</p><p>基于这种思路，可以把状态机扩展为复制状态机。状态机的原理是：一样的初始状态+一样的输入事件=一样的最终状态。因此，要保证多个Node的状态完全一致，只要保证多个Node的日志流是一样的即可！即使这个Node宕机，只需重启和重放日志流，就能恢复之前的状态，如图1012所示。</p><p><img src="http://static.cyblogs.com/Jietu20210228-001253.jpg" alt="http://static.cyblogs.com/Jietu20210228-001253.jpg"></p><p>因此，就回到了上文最后的问题：复制日志！复制日志=复制任何数据（复制任何状态机）。因为任何复杂的数据（状态机）都可以通过日志生成！</p><h4 id="一个朴素而深刻的思想"><a href="#一个朴素而深刻的思想" class="headerlink" title="一个朴素而深刻的思想"></a>一个朴素而深刻的思想</h4><p><code>Paxos</code>的出现先经过了<code>Basic Paxos</code>的形式化证明，之后再有<code>Multi Paxos</code>，最后是应用场景。因为最开始没有先讲应用场景，所以直接看<code>Basic Paxos</code>的证明会很晦涩。本文将反过来，就以上文最后提出的问题为例，先介绍应用场景，再一步步倒推出<code>Paxos</code>和<code>Multi Paxos</code>。</p><p>当三个客户端并发地发送三个请求时，图118所示的6种可能的结果都是对的。因此，要找一种算法保证虽然每个客户端是并发地发送请求，但最终三个Node记录的日志的顺序是相同的，也就是图108所示的任取一种场景即可。</p><p>这里提出一个朴素而深刻的说法：全世界对数字1，2，3，4，5，……顺序的认知是一样的！所有人、所有机器，对这个的认知都是一样的！</p><p>当我说2的时候，全世界的人，都知道2排在1的后面、3的前面！2代表一个位置，这个位置一定在（1，3）之间。</p><p>把这个朴素的想法应用到计算机里面多个Node之间复制日志，会变成如下这样。当Node1收到X=1的请求时，假设要把它存放到日志中1号位置，存放前先询问另外两台机器1号位置是否已经存放了X=3或X=5；如果1号位置被占了，则询问2号位置……依此类推。如果1号位置没有被占，就把X=1存放到1号位置，同时告诉另外两个Node，把X=1存放到它们各自的1号位置！同样，Node2和Node3按此执行。</p><p>这里的关键思想是：虽然每个Node接收到的请求顺序不同，但它们对于日志中1号位置、2号位置、3号位置的认知是一样的，大家一起保证1号位置、2号位置、3号位置存储的数据一样！</p><p>在例子中可以看到，每个Node在存储日志之前先要问一下其他Node，之后再决定把这条日志写到哪个位置。这里有两个阶段：先问，再做决策，也就是<code>Paxos</code>2PC的原型！</p><p>把问题进一步拆解，不是复制三条日志，只复制一条。先确定三个Node的第1号日志，看有什么问题？</p><p>Node1询问后发现1号位置没有被占，因此它打算把X=1传播给Node2和Node3；同一时刻，Node2询问后发现1号位置也没有被占，因此它打算把X=3传播给Node1和Node3；同样，Node3也打算把X=5传播给Node1和Node2。</p><p>结果不就冲突了吗？会发现不要说多条日志，就算是只确定第1号位置的日志，都是个问题！</p><p>而Basic<code>Paxos</code>正是用来解决这个问题的。</p><p>首先，1号位置要么被Node1占领，大家都存放X=1；要么被Node2占领，大家都存放X=3；要么是被Node3占领，大家都存放X=5，少数服从多数！为了达到这个目的，Basic<code>Paxos</code>提出了一个方法，这个方法包括两点：</p><p>第1，Node1在填充1号位置的时候，发现1号位置的值被大多数确定了，比如是X=5（node3占领了1号位置，Node2跟从了Node3），则Node1就接受这个事实：1号位置不能用了，也得把自己的1号位置赋值成X=5。然后看2号位置能否把X=1存进去。同样地，如果2号也被占领了，就只能把它们的值拿过来填在自己的2号位置。只能再看3号位置是否可行……</p><p>第2，当发现1号位置没有被占，就锁定这个位置，不允许其他Node再占这个位置！除非它的权利更大。如果发现1号位置为空，在提交的时候发现1号位置被其他Node占了，就会提交失败，重试，尝试第二个位置，第三个位置……</p><p>所以，为了让1号位置日志一样，可能要重试好多次，每个节点都会不断重试2PC。这样不断重试2PC，直到最终各方达成一致的过程，就是<code>Paxos</code>协议执行的过程，也就是一个<code>Paxos</code>instance，最终确定一个值。而Multi<code>Paxos</code>就是重复这个过程，确定一系列值，也就是日志中的每一条！</p><p>接下来将基于这种思想详细分析<code>Paxos</code>算法本身。</p><h4 id="BasicPaxos算法"><a href="#BasicPaxos算法" class="headerlink" title="BasicPaxos算法"></a>Basic<code>Paxos</code>算法</h4><p>在前面的场景中提到三个Client并发地向三个Node发送三条写指令。对应到<code>Paxos</code>协议，就是每个Node同时充当了两个角色：Proposer和Acceptor。在实现过程中，一般这两个角色是在同一个进程里面的。</p><p>当Node1收到Client1发送的X=1的指令时，Node1就作为一个Proposer向所有的Acceptor（自己和其他两个Node）提议把X=1日志写到三个Node上面。</p><p>同理，当Node2收到Client2发送的X=3的指令，Node2就作为一个Proposer向所有的Acceptor提议；Node3同理。</p><p>下面详细阐述<code>Paxos</code>的算法细节。首先，每个Acceptor需要持久化三个变量（minProposalId，acceptProposalId，acceptValue）。在初始阶段：minProposalId=acceptProposalId=0，acceptValue=null。然后，算法有两个阶段：P1（Prepare阶段）和P2（Accept阶段）。</p><h5 id="P1（Prepare阶段）"><a href="#P1（Prepare阶段）" class="headerlink" title="P1（Prepare阶段）"></a>P1（Prepare阶段）</h5><p><img src="http://static.cyblogs.com/Jietu20210227-234242.jpg" alt="http://static.cyblogs.com/Jietu20210227-234242.jpg"></p><p>Prepare阶段P1a：Proposer广播prepare（n），其中n是本机生成的一个自增ID，不需要全局有序，比如可以用时间戳+IP。P1b：Acceptor收到prepare（n），做如下决策：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n &gt; minProposalId，回复Yes</span><br><span class="line">同时，minProposalId=n（持久化）</span><br><span class="line">返回(acceptProposalId，acceptValue)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">回复 No</span><br></pre></td></tr></table></figure><p>P1c：Proposer如果收到半数以上的yes，则取acceptorProposalId最大的acceptValue作为v，进入第二个阶段，即开始广播accept（n，v）。如果acceptor返回的都是null，则取自己的值作为v，进入第二个阶段！否则，n自增，重复P1a。</p><h5 id="P2（Accept阶段）"><a href="#P2（Accept阶段）" class="headerlink" title="P2（Accept阶段）"></a>P2（Accept阶段）</h5><p><img src="http://static.cyblogs.com/Jietu20210227-234722.jpg" alt="http://static.cyblogs.com/Jietu20210227-234722.jpg"></p><p>P2a：Proposer广播accept（n，v）。这里的n就是P1阶段的n，v可能是自己的值，也可能是第1阶段的acceptValue。P2b：Acceptor收到accept（n，v），做如下决策：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n &gt; minProposalId，回复Yes。同时</span><br><span class="line">minProposalId=acceptProposalId=n（持久化）</span><br><span class="line">acceptValue=value</span><br><span class="line"><span class="keyword">return</span> minProposalId</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">回复 No</span><br></pre></td></tr></table></figure><p>P2c：Proposer如果收到半数以上的yes，并且minProposalId=n，则算法结束。否则，n自增，重复P1a。</p><p>通过分析算法，会发现Basic<code>Paxos</code>有两个问题：</p><p>（1）<code>Paxos</code>是一个“不断循环”的2PC。在P1C或者P2C阶段，算法都可能失败，重新进行P1a。这就是通常所说的“活锁”问题，即可能陷入不断循环。</p><p>（2）每确定一个值，至少需要两次RTT（两个阶段，两个网络来回）+两次写盘，性能也是个问题。而接下来要讲的Multi<code>Paxos</code>就是要解决这两个问题。</p><h4 id="MultiPaxos算法"><a href="#MultiPaxos算法" class="headerlink" title="MultiPaxos算法"></a>Multi<code>Paxos</code>算法</h4><h5 id="问题1：活锁问题"><a href="#问题1：活锁问题" class="headerlink" title="问题1：活锁问题"></a>问题1：活锁问题</h5><p>在前面已经知道，Basic<code>Paxos</code>是一个不断循环的2PC。所以如果是多个客户端写多个机器，每个机器都是Proposer，会导致并发冲突很高，也就是每个节点都可能执行多次循环才能确定一条日志。极端情况是每个节点都在无限循环地执行2PC，也就是所谓的“活锁问题”。</p><p>为了减少并发冲突，可以变多写为单写，选出一个Leader，只让Leader充当Proposer。其他机器收到写请求，都把写请求转发给Leader；或者让客户端把写请求都发给Leader。</p><p>Leader的选举方法很多，下面列举两种：</p><p><strong>方案1：无租约的Leader选举</strong></p><p>Lamport在他的论文中给出了一个Leader选举的简单算法，算法如下：</p><p>（1）每个节点有一个编号，选取编号最大的节点为Leader；</p><p>（2）每个节点周期性地向其他节点发送心跳，假设周期为Tms；</p><p>（3）如果一个节点在最近的2Tms内还没有收到比自己编号更大的节点发来的心跳，则自己变为Leader；</p><p>（4）如果一个节点不是Leader，则收到请求之后转发给Leader。可以看出，这个算法很简单，但因为网络超时原因，很可能出现多个Leader，但这并不影响Multi<code>Paxos</code>协议的正确性，只是增大并发写冲突的概率。我们的算法并不需要强制保证，任意时刻只能有一个Leader。</p><p><strong>方案2：有租约的Leader选举</strong></p><p>另外一种方案是严格保证任意时刻只能有一个leader，也就是所谓的“租约”。租约的意思是在一个限定的期限内，某台机器一直是Leader。即使这个机器宕机，Leader也不能切换。必须等到租期到期之后，才能开始选举新的Leader。这种方式会带来短暂的不可用，但保证了任意时刻只会有一个Leader。具体实现方式可以参见<code>Paxos</code>Lease。</p><h5 id="问题2：性能问题"><a href="#问题2：性能问题" class="headerlink" title="问题2：性能问题"></a>问题2：性能问题</h5><p>我们知道Basic<code>Paxos</code>是一个无限循环的2PC，一条日志的确认至少需要两个RTT+两次落盘（一次是Prepare的广播与回复，一次是Accept的广播与回复）。如果每条日志都要两个RTT+两次落盘，这个性能就很差了。而Multi<code>Paxos</code>在选出Leader之后，可以把2PC优化成1PC，也就只需要一个RTT+一次落盘了。</p><p>基本思路是当一个节点被确认为Leader之后，它先广播一次Prepare，一旦超过半数同意，之后对于收到的每条日志直接执行Accept操作。在这里，Perpare不再是对一条日志的控制了，而是相对于拿到了整个日志的控制权。一旦这个Leader拿到了整个日志的控制权，后面就直接略过Prepare，直接执行Accept。</p><p>如果有新的Leader出现怎么办呢？新的Leader肯定会先发起Prepare，导致minProposalId变大。这时旧的Leader的广播Accept肯定会失败，旧的Leader会自己转变成一个普通的Acceptor，新的Leader把旧的顶替掉了。</p><p>下面是具体的实现细节：在Basic<code>Paxos</code>中，2PC的具体参数形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepare(n)</span><br><span class="line">accept(n,v)</span><br></pre></td></tr></table></figure><p>在Multi<code>Paxos</code>中，增加一个日志的index参数，即变成了如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepare(n,index)</span><br><span class="line">accept(n,v,index)</span><br></pre></td></tr></table></figure><h5 id="问题3：被choose的日志，状态如何同步给其他机器"><a href="#问题3：被choose的日志，状态如何同步给其他机器" class="headerlink" title="问题3：被choose的日志，状态如何同步给其他机器"></a>问题3：被choose的日志，状态如何同步给其他机器</h5><p>对于一条日志，当Proposer（也就是Leader）接收到多数派对Accept请求的同意后，就知道这条日志被“choose”了，也就是被确认了，不能再更改！</p><p>但只有Proposer知道这条日志被确认了，其他的Acceptor并不知道这条日志被确认了。如何把这个信息传递给其他Accepotor呢？</p><p><strong>方案1：Proposer主动通知</strong></p><p>给accept再增加一个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept(n,v,index,firstUnchooseIndex)</span><br></pre></td></tr></table></figure><p>Proposer在广播accept的时候，额外带来一个参数firstUnchosenIndex=7。意思是7之前的日志都已经“choose”了。Acceptor收到这种请求后，检查7之前的日志，如果发现7之前的日志符合以下条件：acceptedProposal[i]==request.proposal（也就是第一个参数n），就把该日志的状态置为choose。</p><p><strong>解决方案2：Acceptor被动查询</strong></p><p>当一个Acceptor被选为Leader后，对于所有未确认的日志，可以逐个再执行一遍<code>Paxos</code>，来判断该条日志被多数派确</p><p>认的值是多少。</p><p>因为Basic<code>Paxos</code>有一个核心特性：一旦一个值被确定后，无论再执行多少遍<code>Paxos</code>，该值都不会改变！因此，再执行1遍<code>Paxos</code>，相当于向集群发起了一次查询！</p><p>至此，Multi<code>Paxos</code>算法就介绍完了。回顾这个算法，有两个精髓：</p><p><strong>精髓之1：一个强一致的“P2P网络”</strong></p><p>任何一条日志，只有两种状态（choose，unchoose）。当然，还有一种状态就是applied，也就是被确认的日志被apply到状态机。这种状态跟<code>Paxos</code>协议关系不大。</p><p>choose状态就是这条日志，被多数派接受，不可更改；</p><p>unchoose就是还不确定，引用阿里OceanBase团队某工程师的话，就是“薛定谔的猫”，或者“最大commit原则”。一条unchoose的日志可能是已经被choose了，只是该节点还不知道；也可能是还没有被choose。要想确认，那就再执行一次<code>Paxos</code>，也就是所谓的“最大commit原则”。</p><p>整个Multi<code>Paxos</code>就是类似一个P2P网络，所有节点互相双向同步，对所有unchoose的日志进行不断确认的过程！在这个网络中可以出现多个Leader，可能出现多个Leader来回切换的情况，这都不影响算法的正确性！</p><p><strong>精髓之2：“时序”</strong></p><p>Multi<code>Paxos</code>保证了所有节点的日志顺序一模一样，但对于每个节点自身来说，可以认为它的日志并没有所谓的“顺序”。什么意思呢？</p><p>（1）假如一个客户端连续发送了两条日志a，b（a没有收到回复，就发出了b）。对于服务器来讲，存储顺序可能是a、b，也可能是b、a，还可能在a、b之间插入了其他客户端发来的日志！</p><p>（2）假如一个客户端连续发送了两条日志a、b（a收到回复之后，再发出的b）。对于服务器来讲，存储顺序可能是a、b；也可能是a、xxx、b（a与b之间插入了其他客户端的日志），但不会出现b在a的前面。</p><p>所以说，所谓的“时序”，只有在单个客户端串行地发送日志时，才有所谓的顺序。多个客户端并发地写，服务器又是并发地对每条日志执行<code>Paxos</code>，整体看起来就没有所谓的“顺序”。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li>文章摘自《软件架构设计》余春龙/著</li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Paxos解决什么问题&quot;&gt;&lt;a href=&quot;#Paxos解决什么问题&quot; class=&quot;headerlink&quot; title=&quot;Paxos解决什么问题&quot;&gt;&lt;/a&gt;Paxos解决什么问题&lt;/h4&gt;&lt;p&gt;大家对&lt;code&gt;Paxos&lt;/code&gt;的看法基本是“晦涩难懂”，
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.cyblogs.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Paxos" scheme="http://www.cyblogs.com/tags/Paxos/"/>
    
      <category term="算法" scheme="http://www.cyblogs.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>拥有一套属于自己的Spring源码环境</title>
    <link href="http://www.cyblogs.com/2021/02/19/2021/02/%E6%8B%A5%E6%9C%89%E4%B8%80%E5%A5%97%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.cyblogs.com/2021/02/19/2021/02/%E6%8B%A5%E6%9C%89%E4%B8%80%E5%A5%97%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83/</id>
    <published>2021-02-18T16:00:00.000Z</published>
    <updated>2021-02-20T01:15:52.604Z</updated>
    
    <content type="html"><![CDATA[<p><code>Spring</code>是一个非常优秀的开源项目，而且基本是互联网的标配。随着这几年的源码阅读习惯，有用一套自己的源码阅读笔记项目已经是水到渠成。今天就来在本地编译一份，以便于后面记录核心笔记用。</p><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><h5 id="1-准备好源代码"><a href="#1-准备好源代码" class="headerlink" title="1.准备好源代码"></a>1.准备好源代码</h5><ul><li><a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">https://spring.io/projects/spring-framework</a></li><li><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a></li><li><a href="https://gitee.com/mirrors/Spring-Framework" target="_blank" rel="noopener">https://gitee.com/mirrors/Spring-Framework</a> (推荐，毕竟速度快，而且每天会跟<code>github</code>同步一次)</li><li><a href="https://gitee.com/vernon/Spring-Framework" target="_blank" rel="noopener">https://gitee.com/vernon/Spring-Framework</a> (为了自己可以提交代码，必须要<code>fork</code>一份)</li></ul><p>为什么贴这些<code>url</code>地址，是因为提醒我们所有人，官网与<code>github</code>是我们最先关注的地方。</p><p><code>gradle.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version</span>=<span class="string">5.3.5-SNAPSHOT</span></span><br><span class="line"><span class="meta">org.gradle.jvmargs</span>=<span class="string">-Xmx1536M</span></span><br><span class="line"><span class="meta">org.gradle.caching</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">org.gradle.parallel</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">kotlin.stdlib.default.dependency</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>从上面可以看出来，我们现在用到是<code>spring 5.3.5-SNAPSHOT</code>版本。后面会遇到一些编译问题，避免大家踩坑，我直接说。这里依赖的JDK需要在JDK11。</p><h5 id="2-JDK准备"><a href="#2-JDK准备" class="headerlink" title="2.JDK准备"></a>2.JDK准备</h5><p>下载<code>JDK11</code>的版本：<a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk11-downloads.html</a></p><p>但是，但是，但是官网的实在是太慢了，所以我这里就直接改为<code>openjdk11</code>了。传送门：<a href="https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/</a> 下载速度就看你家里的带宽了，我基本在<code>3M+</code>左右~ </p><p><img src="http://static.cyblogs.com/Jietu20210219-223632.jpg" alt="http://static.cyblogs.com/Jietu20210219-223632.jpg"></p><p>没有对比就没有伤害啊。</p><p><img src="http://static.cyblogs.com/Jietu20210219-223756.jpg" alt="http://static.cyblogs.com/Jietu20210219-223756.jpg"></p><p>配置好项目中使用的<code>JDK</code>版本，这边因为诉求不一样，平时基本还是用的<code>JDK8</code>。</p><h5 id="3-Gradle安装"><a href="#3-Gradle安装" class="headerlink" title="3.Gradle安装"></a>3.Gradle安装</h5><p>因为我这里是<code>Mac</code>系统，所以一般的软件我都会采用<code>brew</code>来实现，因为实在太方便了。一行命令搞定~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gradle</span><br></pre></td></tr></table></figure><p>下面是我安装的gradle信息，是最新的版本6.7。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ gradle -v</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 6.7</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Build time:   2020-10-14 16:13:12 UTC</span><br><span class="line">Revision:     312ba9e0f4f8a02d01854d1ed743b79ed996dfd3</span><br><span class="line">Kotlin:       1.3.72</span><br><span class="line">Groovy:       2.5.12</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.8 compiled on May 10 2020</span><br><span class="line">JVM:          1.8.0_172 (Oracle Corporation 25.172-b11)</span><br><span class="line">OS:           Mac OS X 10.15.7 x86_64</span><br></pre></td></tr></table></figure><h5 id="4-Intellij-IDEA-2020"><a href="#4-Intellij-IDEA-2020" class="headerlink" title="4.Intellij IDEA 2020"></a>4.Intellij IDEA 2020</h5><p>因为<code>spring</code>在代码中有对<code>Kotlin</code>有一些依赖（低版本的可能会出现依赖问题），建议搭建升级到比价新的版本。</p><p><img src="http://static.cyblogs.com/Jietu20210219-224353@2x.jpg" alt="http://static.cyblogs.com/Jietu20210219-224353@2x.jpg"></p><h4 id="构建源码"><a href="#构建源码" class="headerlink" title="构建源码"></a>构建源码</h4><p>因为<code>spring</code>依赖与<code>gradle</code>，而且都是国外的网站，相对来说网速会非常的慢。这里也是采用更换镜像的方式来加速处理。</p><p><code>build.gradle</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line"><span class="comment">// 优先本地</span></span><br><span class="line">mavenLocal()</span><br><span class="line">maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/groups/public/'</span> &#125; <span class="comment">//阿里云</span></span><br><span class="line">maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/repositories/jcenter'</span> &#125;</span><br><span class="line">maven &#123; url <span class="string">"https://repo.spring.io/snapshot"</span> &#125; <span class="comment">// Reactor</span></span><br><span class="line"></span><br><span class="line">mavenCentral()</span><br><span class="line">maven &#123; url <span class="string">"https://repo.spring.io/libs-spring-framework-build"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>settings.gradle</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line"><span class="comment">// 新增配置</span></span><br><span class="line">maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/groups/public/'</span> &#125; <span class="comment">//阿里云</span></span><br><span class="line">maven &#123; url <span class="string">'https://maven.aliyun.com/nexus/content/repositories/jcenter'</span> &#125;</span><br><span class="line">maven &#123; url <span class="string">"https://repo.spring.io/snapshot"</span> &#125;</span><br><span class="line"></span><br><span class="line">gradlePluginPortal()</span><br><span class="line">maven &#123; url <span class="string">'https://repo.spring.io/plugins-release'</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置一下<code>gradle</code>的参数</p><p><img src="http://static.cyblogs.com/Jietu20210219-224901.jpg" alt="http://static.cyblogs.com/Jietu20210219-224901.jpg"></p><h4 id="构建成功验证"><a href="#构建成功验证" class="headerlink" title="构建成功验证"></a>构建成功验证</h4><p>找到<code>ApplicationContext</code>接口，显示它的一个类关系图。如果出现下图所示类图界面说明构建成功了！(构建过程就是找依赖对象的过程)</p><p><img src="http://static.cyblogs.com/Jietu20210219-173001@2x.jpg" alt="http://static.cyblogs.com/Jietu20210219-173001@2x.jpg"></p><h4 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h4><p>查看官方<a href="https://github.com/spring-projects/spring-framework/blob/master/import-into-idea.md" target="_blank" rel="noopener">import-into-idea.md</a>文档，如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Precompile spring-oxm with ./gradlew :spring-oxm:compileTestJava</span><br><span class="line">2.Import into IntelliJ (File -&gt; New -&gt; Project from Existing Sources -&gt; Navigate to directory -&gt; Select build.gradle)</span><br><span class="line">3.When prompted exclude the spring-aspects module (or after the import via File-&gt; Project Structure -&gt; Modules)</span><br><span class="line">4.Code away</span><br></pre></td></tr></table></figure><h5 id="1-编译spring-oxm模块"><a href="#1-编译spring-oxm模块" class="headerlink" title="1.编译spring-oxm模块"></a>1.编译spring-oxm模块</h5><p>先编译<code>spring-oxm</code>下的<code>compileTestjava</code>，点击右上角<code>gradle</code>打开编译视图，找到<code>spring-oxm</code>模块，然后在<code>other</code>下找到<code>compileTestjava</code>，双击即可！</p><p><img src="http://static.cyblogs.com/Jietu20210219-225904.jpg" alt="http://static.cyblogs.com/Jietu20210219-225904.jpg"></p><h5 id="2-编译spring-core模块"><a href="#2-编译spring-core模块" class="headerlink" title="2.编译spring-core模块"></a>2.编译spring-core模块</h5><p>利用同样的方式，编译<code>spring-core</code>模块，出现<code>BUILD SUCCESSFUL</code>代码成功。</p><p><img src="http://static.cyblogs.com/Jietu20210219-230123.jpg" alt="http://static.cyblogs.com/Jietu20210219-230123.jpg"></p><h5 id="3-都编译完成且成功之后，开始编译整个工程"><a href="#3-都编译完成且成功之后，开始编译整个工程" class="headerlink" title="3.都编译完成且成功之后，开始编译整个工程"></a>3.都编译完成且成功之后，开始编译整个工程</h5><p>打开右侧<code>Gradle</code>插件 <code>spring-&gt;build-&gt;build</code>。<br>编译时间，每个人电脑的性能不一样，所需时间也不一样。</p><p><img src="http://static.cyblogs.com/Jietu20210219-231519.jpg" alt="http://static.cyblogs.com/Jietu20210219-231519.jpg"></p><p>我这里基本上全部成功，但是在<code>Task :spring-webflux:test</code>模块有一个<code>test</code>跑失败。算是有一点小瑕疵，但不影响整个编译。</p><p><img src="http://static.cyblogs.com/Jietu20210219-231701.jpg" alt="http://static.cyblogs.com/Jietu20210219-231701.jpg"></p><h4 id="源码测试"><a href="#源码测试" class="headerlink" title="源码测试"></a>源码测试</h4><p>构建成功了，源码编译成功了，能否用还不知道，还要测试通过才说明源码可以用了。直接在<code>spring-context</code>里面创建我们的一个<code>service</code>，然后通过<code>ApplicationContext</code>去获取它，并执行它的一个方法。</p><p><img src="http://static.cyblogs.com/Jietu20210220-090140.jpg" alt="http://static.cyblogs.com/Jietu20210220-090140.jpg"></p><p>代码部分我已经<code>push</code>上去了：<a href="https://gitee.com/vernon/Spring-Framework，后续就可以自由自在的在上面标注以及验证了。" target="_blank" rel="noopener">https://gitee.com/vernon/Spring-Framework，后续就可以自由自在的在上面标注以及验证了。</a> </p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/weixin_44730681/article/details/107390331" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44730681/article/details/107390331</a></li><li><a href="https://zhuanlan.zhihu.com/p/122732323" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/122732323</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;是一个非常优秀的开源项目，而且基本是互联网的标配。随着这几年的源码阅读习惯，有用一套自己的源码阅读笔记项目已经是水到渠成。今天就来在本地编译一份，以便于后面记录核心笔记用。&lt;/p&gt;
&lt;h4 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://www.cyblogs.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.cyblogs.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Redis二值状态统计的巧妙使用</title>
    <link href="http://www.cyblogs.com/2021/01/31/2021/01/Redis%E4%BA%8C%E5%80%BC%E7%8A%B6%E6%80%81%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.cyblogs.com/2021/01/31/2021/01/Redis%E4%BA%8C%E5%80%BC%E7%8A%B6%E6%80%81%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2021-02-01T00:56:47.830Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h4><p>这里的二值状态就是指集合元素的取值就只有 0 和 1 两种。在签到打卡的场景中，我们只用记录：</p><ul><li>签到（1）</li><li>未签到（0）</li></ul><p>所以它就是非常典型的二值状态，在签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p><p>这个时候，我们就可以选择 <code>Bitmap</code>。这是 <code>Redis</code> 提供的扩展数据类型。我来给你解释一下它的实现原理。<code>Bitmap</code> 本身是用 <code>String</code> 类型作为底层数据结构实现的一种统计二值状态的数据类型。<code>String</code> 类型是会保存为二进制的字节数组，所以，<code>Redis</code> 就把字节数组的每个 <code>bit</code> 位利用起来，用来表示一个元素的二值状态。</p><p>你可以把 <code>Bitmap</code> 看作是一个 <code>bit</code> 数组。<code>Bitmap</code> 提供了 <code>GETBIT/SETBIT</code> 操作，使用一个偏移值 <code>offset</code> 对 <code>bit</code> 数组的某一个 <code>bit</code> 位进行读和写。不过，需要注意的是，<code>Bitmap</code> 的偏移量是从 0 开始算的，也就是说 <code>offset</code> 的最小值是 0。当使用 <code>SETBIT</code> 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。</p><p>Bitmap 还提供了 <code>BITCOUNT</code> 操作，用来统计这个 bit 数组中所有“1”的个数。那么，具体该怎么用 <code>Bitmap</code> 进行签到统计呢？我还是借助一个具体的例子来说明。</p><h4 id="统计一个人签到"><a href="#统计一个人签到" class="headerlink" title="统计一个人签到"></a>统计一个人签到</h4><p>假设我们要统计 <code>ID 3000</code> 的用户在 2020 年 8 月份的签到情况，就可以按照下面的步骤进行操作。</p><ul><li><p>第一步，执行下面的命令，记录该用户 8 月 3 号已签到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT uid:sign:3000:202008 2 1</span><br></pre></td></tr></table></figure></li><li><p>第二步，检查该用户 8 月 3 日是否签到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT uid:sign:3000:202008 2</span><br></pre></td></tr></table></figure></li><li><p>第三步，统计该用户在 8 月份的签到次数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT uid:sign:3000:202008</span><br></pre></td></tr></table></figure></li></ul><p>这样，我们就知道该用户在 8 月份的签到情况了，是不是很简单呢？</p><h4 id="1-亿个用户-10-天的签到"><a href="#1-亿个用户-10-天的签到" class="headerlink" title="1 亿个用户 10 天的签到"></a>1 亿个用户 10 天的签到</h4><p>接下来，你可以再思考一个问题：如果记录了 1 亿个用户 10 天的签到情况，你有办法统计出这 10 天连续签到的用户总数吗？</p><p>在介绍具体的方法之前，我们要先知道，<code>Bitmap</code> 支持用 <code>BITOP</code> 命令对多个 <code>Bitmap</code> 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 <code>Bitmap</code> 中。</p><p>我以按位“与”操作为例来具体解释一下。从下图中，可以看到，三个 <code>Bitmap</code>： <code>bm1</code>、<code>bm2</code> 和 <code>bm3</code>，对应 bit 位做“与”操作，结果保存到了一个新的 Bitmap 中（示例中，这个结果 Bitmap 的 key 被设为“resmap”）。</p><p><img src="https://static001.geekbang.org/resource/image/41/7a/4151af42513cf5f7996fe86c6064f97a.jpg" alt="https://static001.geekbang.org/resource/image/41/7a/4151af42513cf5f7996fe86c6064f97a.jpg"></p><p>回到刚刚的问题，在统计 1 亿个用户连续 10 天的签到情况时，你可以把每天的日期作为 key，每个 key 对应一个 1 亿位的 <code>Bitmap</code>，每一个 bit 对应一个用户当天的签到情况。</p><p>接下来，我们对 10 个 <code>Bitmap</code> 做“与”操作，得到的结果也是一个 <code>Bitmap</code>。在这个 <code>Bitmap</code> 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。最后，我们可以用 <code>BITCOUNT</code> 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。</p><p>现在，我们可以计算一下记录了 10 天签到情况后的内存开销。每天使用 1 个 1 亿位的 <code>Bitmap</code>，大约占 <code>12MB</code> 的内存（10^8/8/1024/1024），10 天的 <code>Bitmap</code> 的内存开销约为 <code>120MB</code>，内存压力不算太大。不过，在实际应用时，最好对 Bitmap 设置过期时间，让 <code>Redis</code> 自动删除不再需要的签到记录，以节省内存开销。</p><p>所以，如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。在记录海量数据时，<code>Bitmap</code> 能够有效地节省内存空间。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://time.geekbang.org/column/article/280680" target="_blank" rel="noopener">https://time.geekbang.org/column/article/280680</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;二值状态统计&quot;&gt;&lt;a href=&quot;#二值状态统计&quot; class=&quot;headerlink&quot; title=&quot;二值状态统计&quot;&gt;&lt;/a&gt;二值状态统计&lt;/h4&gt;&lt;p&gt;这里的二值状态就是指集合元素的取值就只有 0 和 1 两种。在签到打卡的场景中，我们只用记录：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>了解一下MYSQL官方数据库Sakila</title>
    <link href="http://www.cyblogs.com/2021/01/27/2021/01/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BMYSQL%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E5%BA%93Sakila/"/>
    <id>http://www.cyblogs.com/2021/01/27/2021/01/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BMYSQL%E5%AE%98%E6%96%B9%E6%95%B0%E6%8D%AE%E5%BA%93Sakila/</id>
    <published>2021-01-26T16:00:00.000Z</published>
    <updated>2021-01-28T06:04:28.764Z</updated>
    
    <content type="html"><![CDATA[<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>我们通过Docker快速的拉取一个环境，这样子对于学习来说成本比价低。直接参照<a href="https://hub.docker.com/r/mysql/mysql-server/" target="_blank" rel="noopener">https://hub.docker.com/r/mysql/mysql-server/</a> 来做就好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 快速拉取一个mysql的image</span></span><br><span class="line">➜  ~ docker pull mysql/mysql-server</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from mysql/mysql-server</span><br><span class="line">501550cfd5c0: Pull complete</span><br><span class="line">e0509d775110: Pull complete</span><br><span class="line">d5a01765d011: Pull complete</span><br><span class="line">970507e942eb: Pull complete</span><br><span class="line">Digest: sha256:0bb21c0f1aa9296e7deafacec5703b80e4d923dfdfcaa2efbe0c8377a8592128</span><br><span class="line">Status: Downloaded newer image for mysql/mysql-server:latest</span><br><span class="line">docker.io/mysql/mysql-server:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动mysql容器</span></span><br><span class="line">➜  ~ docker run --name=mysql1 -d mysql/mysql-server:latest</span><br><span class="line">780c312f6fa1d3b001cb7c97fddb7df39fea61f27732b5fb9b59d5a29b12cfde</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看CONTAINER</span></span><br><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS                       NAMES</span><br><span class="line">780c312f6fa1        mysql/mysql-server:latest   "/entrypoint.sh mysq…"   59 seconds ago      Up 58 seconds (healthy)   3306/tcp, 33060-33061/tcp   mysql1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看默认的密码</span></span><br><span class="line">➜  ~ docker logs mysql1 2&gt;&amp;1 | grep GENERATED</span><br><span class="line">[Entrypoint] GENERATED ROOT PASSWORD: enohmYS*ecvISAqYh@GafRoDP3v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接登录进去</span></span><br><span class="line">➜  ~ docker exec -it mysql1 mysql -uroot -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 17</span><br><span class="line">Server version: 8.0.23</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改一下容易记忆的密码，方便下次来使用</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'root'</span>;</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>这是我认为非常快速的一个环境搭建的方式。</p><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>一般像Orace、MySQL这些好的软件都会提供一些官网的数据来让方便学习着来学习。<a href="https://dev.mysql.com/doc/index-about.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/index-about.html</a> </p><p><img src="http://static.cyblogs.com/Jietu20210127-205659@2x.jpg" alt="http://static.cyblogs.com/Jietu20210127-205659@2x.jpg"></p><p>那我们就下载<code>sakila database</code>来学习一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> show tables;</span></span><br><span class="line">+----------------------------+</span><br><span class="line">| Tables_in_sakila           |</span><br><span class="line">+----------------------------+</span><br><span class="line">| actor                      |//演员表</span><br><span class="line">| address                    |//地址表</span><br><span class="line">| category                   |//影片的分类</span><br><span class="line">| city                       |//城市信息</span><br><span class="line">| country                    |//国家信息</span><br><span class="line">| customer                   |//观看影片的用户信息</span><br><span class="line">| film                       |//影片信息</span><br><span class="line">| film_actor                 |//影片演员关联表</span><br><span class="line">| film_category              |//影片分类关联表</span><br><span class="line">| film_text                  |//影片的文本信息，更新film的时候通过触发器保持film_text的同步</span><br><span class="line">| inventory                  |//库存信息</span><br><span class="line">| language                   |//影片的语言</span><br><span class="line">| payment                    |//租赁付款信息</span><br><span class="line">| rental                     |//某个影片库存的租赁信息</span><br><span class="line">| staff                      |//商店员工信息</span><br><span class="line">| store                      |//影片的商店信息</span><br><span class="line">+----------------------------+</span><br><span class="line">22 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>整体的来看一下数据的一个关系</p><p><img src="http://static.cyblogs.com/sakila.png" alt="http://static.cyblogs.com/sakila.png"></p><h4 id="通过Sakila了解一些索引问题"><a href="#通过Sakila了解一些索引问题" class="headerlink" title="通过Sakila了解一些索引问题"></a>通过Sakila了解一些索引问题</h4><p><img src="http://static.cyblogs.com/Jietu20210127-213735.jpg" alt="http://static.cyblogs.com/Jietu20210127-213735.jpg"></p><p>这里会有一个非常奇怪的问题，就是第一条sql竟然走了<code>idx_actor_last_name</code>索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>可以理解为是走的B+树，叶子节点里面刚好存储的是主键，而主键刚好是actor_id，select的时候刚好是主键一个值吗？</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/50682992" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50682992</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h4&gt;&lt;p&gt;我们通过Docker快速的拉取一个环境，这样子对于学习来说成本比价低。直接参照&lt;a href=&quot;https://hub.do
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.cyblogs.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.cyblogs.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://www.cyblogs.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>写在2020年最后一天</title>
    <link href="http://www.cyblogs.com/2020/12/31/2020/12/%E5%86%99%E5%9C%A82020%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/"/>
    <id>http://www.cyblogs.com/2020/12/31/2020/12/%E5%86%99%E5%9C%A82020%E5%B9%B4%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/</id>
    <published>2020-12-30T16:00:00.000Z</published>
    <updated>2020-12-31T15:03:06.802Z</updated>
    
    <content type="html"><![CDATA[<p>2020年，感觉真的是一个不平凡的年。是时间流逝非常快的一年，也是成长最快的一年。感谢身边所有的人~</p><h4 id="谈口罩"><a href="#谈口罩" class="headerlink" title="谈口罩"></a>谈口罩</h4><p>还记得年初的时候，怕被疫情隔在家里了，正月初三就开车到了深圳。那时候听新闻说可能要带半年或者一年的口罩，当时感觉不可思议，根本不可能。现在一年已经已经过去了，但口罩还依然要继续……</p><p>说到口罩，记得刚刚开始在老家带口罩的时候，家里好多人不理解，为什么要戴口罩？（估计跟很多老美一样，觉得不尊重，觉得自己没病等）到了“恐慌”的时候，家里人比我们更着急，更加上心。在这次疫情中，真的也是感受到了人间百态，看到了白衣天使的伟大，看到了一些黑心的商家，看到了那些平凡的人做着不平凡的事儿，感受到了近些年来祖国的伟大（非常感谢国内短视频）。</p><p>今年给我最大的感受是繁忙、成长、充实，总的来说是收获的一年吧。</p><h4 id="写作与公众号"><a href="#写作与公众号" class="headerlink" title="写作与公众号"></a>写作与公众号</h4><p>年初的时候开启了我的个人公共账号「简栈文化」，一共发表了文章112篇，几乎全部都是跟技术相关的，在编写与梳理这些知识的时候，内心是充满热情与喜悦的。特别是大家去催更的时候，或者有问题请教你的时候，跟你讨论的时候，所有的熬夜与辛苦都是值得的，因为你获得的知识与朋友。后面也是因为工作原因，更新就慢慢的停了下来，但内心一直牵挂着写作这件事儿。</p><h4 id="谈工作"><a href="#谈工作" class="headerlink" title="谈工作"></a>谈工作</h4><p>今年可以说自己是换了工作，也可以说自己没有换工作，因为做的事情不同了，从楼上换到了楼下，但最大的老板还是同样的老板。不过，还是真的很感谢保险与国际的同事，都给了我很大的帮助、鼓励、肯定。在保险从事的是信贷相关的业务，从小白变成了有一丝丝信贷经验的从业者，也有着自己的小团队，而且氛围非常好，非常的优秀。到国际做的是证券业务，团队又是从0开始搭建，业务又不是很熟悉，感觉一下突然回到了4年前。经过了4个月左右的时间，终于又把团队搭建起来了，同时也在努力的去学习业务与技术。更重要的，我自己对自己的要求更高了，想做的更好。这次的团队跟之前一样，无可挑剔，更加的棒~</p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>这一年虽然看的书籍不是特别多（差不多12本），但是因为这一年的写作原因，内心是非常愿意静下来去好好看一本的。不管是技术的书籍，还是人物传记的书籍，总能在从中学到一些东西，哪怕只有其中只有某一句话、一件事儿、一个技术难点、一个技巧也是非常开心的。现在看书主要是在Kindle上面，技术书籍就会买纸质版本的，非常棒的书籍纸质版与电子版都买，还是为了图方便。不管如何，只要找到自己喜欢的方式，做任何事情都是对的~</p><h4 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h4><p>这一年，跟我老婆吵架非常的少，但记忆中好像也有这么1<del>2次是比较严重的，但都能很快过去。都说一个成功男人的背后一定有一个优秀的女人，我非常赞同。我觉得在思想上，我家那位比我要强，我是属于追赶她的情况。今年，一起去南京休闲游完了几天，特别喜欢这种慢悠悠，自由自在的旅行。一转眼，我们已经认识了10年，本想2人在很久以前就一直筹划着要过一个非常难忘的10周年，为此要做很多的准备，也是因为工作忙碌的原因，算是过了一个开心的10周年吧。这一年我从以前什么都不管慢慢开始的变为想去用心准备点什么，付出一点什么。为了明年去更多的没有去过的地方，特此还跟我老婆买了南航的随心飞，希望能去更多的地方看看这个美好的世界，去更多的地方打打卡。这几天还对摄影有点兴趣，日后可以好好学习学习</del></p><h4 id="健康-amp-保险"><a href="#健康-amp-保险" class="headerlink" title="健康&amp;保险"></a>健康&amp;保险</h4><p>最近2年左右的时间，真的听说了太多太多亲人们身体不好做手术的，家里的老奶奶、舅姥姥等去世的消息。其实人到30~40岁之间，应该是蛮有经济压力的，自己的梦想还有很多未实现，爸爸妈妈的年纪也开始慢慢到了一个体质变弱、疾病变多的情况，所以今年我们为2边的家人都配置了意外险、百万医疗险，为自己也配置了这些，也终于在2020年的最后一天为我们俩配置了重疾险（本来想着买港险的，可这疫情一拖就是一年）。虽然这些保险远远还不够，但是也不用太着急，首先有了基本的保障，后面再慢慢的去添加就好了。起码，真的哪天有意外来临，也不会变得很被动。</p><h4 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h4><p>今年一年跟我老婆也获得一些新朋友，特别是公共的朋友。在深圳这个城市，能够找到一些私下要好的朋友是很难的，因为大家的生活节奏都很快，大部分都不认识隔壁的邻居是谁，每天都是很早的去上班，很晚才回家来。如果有一些私下的朋友，节假日的时候可以一起凑个饭局，一起郊游，一起钓个鱼什么的都是一件很幸福的事情。所以，珍惜现在已有的好朋友，结交更多更优秀的人。</p><p>我知道立再多的flag也不如把一个flag做好来的重要，我希望自己在2021年里能更多知道自己的内心，知道自己追求的是什么？如何让自己的内心世界丰富起来，如果让自己做任何的事情都不会被别人牵着鼻子走，如何去影响、号召更多的其他人一起来做事。</p><p>2021年给自己的目的是：抓重点、求突破、顾家庭。</p><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年，感觉真的是一个不平凡的年。是时间流逝非常快的一年，也是成长最快的一年。感谢身边所有的人~&lt;/p&gt;
&lt;h4 id=&quot;谈口罩&quot;&gt;&lt;a href=&quot;#谈口罩&quot; class=&quot;headerlink&quot; title=&quot;谈口罩&quot;&gt;&lt;/a&gt;谈口罩&lt;/h4&gt;&lt;p&gt;还记得年初的时候
      
    
    </summary>
    
    
      <category term="总结" scheme="http://www.cyblogs.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2020" scheme="http://www.cyblogs.com/tags/2020/"/>
    
      <category term="总结" scheme="http://www.cyblogs.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Controller里面方法不小心写成了private的问题</title>
    <link href="http://www.cyblogs.com/2020/12/04/2020/12/Controller%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%86%99%E6%88%90%E4%BA%86private%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://www.cyblogs.com/2020/12/04/2020/12/Controller%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%86%99%E6%88%90%E4%BA%86private%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-12-03T16:00:00.000Z</published>
    <updated>2020-12-04T01:23:10.885Z</updated>
    
    <content type="html"><![CDATA[<h4 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h4><p>今天本来是为了解决一个<code>Apollo</code>配置与<code>Code</code>同时变更不一致问题，我需要去通过<code>SPI</code>的方式去重写<code>Apollo</code>刷新<code>Remote</code>配置。所以，我就写一个很小的<code>DEMO</code>来验证每次变更<code>Apollo</code>配置对我服务端的取数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarketConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;market.test.chenyuan&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String testName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应在<code>Apollo</code>的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">market.test.name</span> = <span class="string">Test1111</span></span><br></pre></td></tr></table></figure><p><code>Controller</code>层的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MarketConfig marketConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/sayHello"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123; <span class="comment">// 注意，这里由于我的不小心写成了private</span></span><br><span class="line">    <span class="keyword">return</span> marketConfig.getMarketTestName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我就发起请求来验证我的取数，结果给我报了<code>NullpointException</code>的异常。因为这种代码几乎每天都在写，一下次说我的<code>Bean</code>没有注入进来，还有点方。</p><p>然后，我细心的<code>debug</code>了看了一下。如图所示：</p><p><img src="http://static.cyblogs.com/Jietu20201204-085800.jpg" alt="http://static.cyblogs.com/Jietu20201204-085800.jpg"></p><p>图片可以说明：</p><ul><li><p><code>Spring</code>容器100%已经存在了<code>MarketConfig</code>的<code>Bean</code>对象；</p></li><li><p>但是<code>MarketConfig</code>在该<code>Controller</code>里面100%没有注入进来 ；</p></li><li><p><code>this</code>显示出了一个代理的路径；</p><p>于是，我在同样的<code>Controller</code>去请求另外一个<code>Method</code>，但可以正常访问。</p></li></ul><p><img src="http://static.cyblogs.com/Jietu20201204-090305.jpg" alt="http://static.cyblogs.com/Jietu20201204-090305.jpg"></p><ul><li><code>Spring</code>容器100%已经存在了<code>MarketConfig</code>的<code>Bean</code>对象；</li><li>而且是可以确定这次<code>MarketConfig</code>是有注入进来的（没有展示图，不太方便）</li><li><code>this</code>直接是显示的自己的地址</li></ul><p>由于我就比较了一下方法的区别，最主要的区别点就是在于一个是<code>private</code>，另外一个是<code>public</code>。</p><p>其实，这里我就很快明白了。因为我们这边在<code>Controller</code>层做了一些AOP来做监控与埋点。现阶段主要用的是<code>CAT</code>（现在做了很多的一些封装，后面可以分享下，如何做到无浸入性以及与<code>Apollo</code>的打通）。</p><p><code>AOP</code> 里面用的是反射机制，用<code>private</code>修饰的类是注入失败的，因为拿不到，只能用<code>public</code>或者<code>protected</code>修饰。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/qq_31451081/article/details/84100575" target="_blank" rel="noopener">https://blog.csdn.net/qq_31451081/article/details/84100575</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;发现问题&quot;&gt;&lt;a href=&quot;#发现问题&quot; class=&quot;headerlink&quot; title=&quot;发现问题&quot;&gt;&lt;/a&gt;发现问题&lt;/h4&gt;&lt;p&gt;今天本来是为了解决一个&lt;code&gt;Apollo&lt;/code&gt;配置与&lt;code&gt;Code&lt;/code&gt;同时变更不一致问题，我需
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://www.cyblogs.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.cyblogs.com/tags/Spring/"/>
    
      <category term="AOP" scheme="http://www.cyblogs.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库隔离级别到底是RC还是RR？</title>
    <link href="http://www.cyblogs.com/2020/11/24/2020/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%B0%E5%BA%95%E6%98%AFRC%E8%BF%98%E6%98%AFRR%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/11/24/2020/11/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%88%B0%E5%BA%95%E6%98%AFRC%E8%BF%98%E6%98%AFRR%EF%BC%9F/</id>
    <published>2020-11-23T16:00:00.000Z</published>
    <updated>2021-01-28T06:05:14.497Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h4><p><code>MySQL</code> 的默认事务隔离级别为 <code>Repeatable Read</code>。而 <code>ORACLE</code>、<code>SQLServer</code> 等的默认隔离级别使用的是 <code>Read Committed</code> 模式，为什么呢？</p><p>开始我们的内容，相信大家一定遇到过下面的一个面试场景</p><blockquote><p>面试官：“讲讲 mysql 有几个事务隔离级别？”</p><p>你：“读未提交，读已提交，可重复读，串行化四个！默认是可重复读”<br>面试官：“为什么 mysql 选可重复读作为默认的隔离级别？”<br>(你面露苦色，不知如何回答！)<br>面试官:“你们项目中选了哪个隔离级别？为什么？”<br>你：“当然是默认的可重复读，至于原因…呃…”<br>(然后你就可以回去等通知了！)</p></blockquote><p>为了避免上述尴尬的场景，请继续往下阅读！<br><code>Mysql</code> 默认的事务隔离级别是可重复读 (<code>Repeatable Read</code>)，那互联网项目中 <code>Mysql</code> 也是用默认隔离级别，不做修改么？<br><code>OK</code>，不是的，我们在项目中一般用读已提交 (<code>Read Commited</code>) 这个隔离级别！<br><code>what</code>！居然是读已提交，网上不是说这个隔离级别存在不可重复读和幻读问题么？不用管么？好，带着我们的疑问开始本文！</p><p>我们先来思考一个问题，在 <code>Oracle</code>，<code>SqlServer</code> 中都是选择读已提交 (Read Commited) 作为默认的隔离级别，为什么 <code>Mysql</code> 不选择读已提交 (<code>Read Commited</code>) 作为默认隔离级别，而选择可重复读 (<code>Repeatable Read</code>) 作为默认的隔离级别呢？</p><h4 id="Why-Why-Why"><a href="#Why-Why-Why" class="headerlink" title="Why?Why?Why?"></a>Why?Why?Why?</h4><p>这个是有历史原因的，当然要从我们的主从复制开始讲起了！<br>主从复制，是基于什么复制的？<br>是基于 <code>binlog</code> 复制的！这里不想去搬 <code>binlog</code> 的概念了，就简单理解为 <code>binlog</code> 是一个记录数据库更改的文件吧～<br><code>binlog</code> 有几种格式？<br>OK，三种，分别是：</p><ul><li><code>statement</code>: 记录的是修改 <code>SQL</code> 语句</li><li>row：记录的是每行实际数据的变更</li><li><code>mixed</code>：statement 和 <code>row</code> 模式的混合</li></ul><p>那 <code>Mysql</code> 在 5.0 这个版本以前，<code>binlog</code> 只支持 <code>STATEMENT</code> 这种格式！而这种格式在读已提交 (<code>Read Commited</code>) 这个隔离级别下主从复制是有 <code>bug</code> 的，因此 <code>Mysql</code> 将可重复读 (<code>Repeatable Read</code>) 作为默认的隔离级别！<br>接下来，就要说说当 <code>binlog</code> 为 <code>STATEMENT</code> 格式，且隔离级别为读已提交 (<code>Read Commited</code>) 时，有什么 <code>bug</code> 呢？如下图所示，在主 (master) 上执行如下事务</p><p><img src="http://static.cyblogs.com/image_editor_38dbfa43-6a3f-4812-a26c-c9dc984d4ccc.jpg" alt="http://static.cyblogs.com/image_editor_38dbfa43-6a3f-4812-a26c-c9dc984d4ccc.jpg"></p><p>此时在主 (<code>master</code>) 上执行下列语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>；</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">±–+</span><br><span class="line">| b |</span><br><span class="line">±–+</span><br><span class="line">| 3 |</span><br><span class="line">±–+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>但是，你在此时在从 (<code>slave</code>) 上执行该语句，得出输出如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Empty set</span><br></pre></td></tr></table></figure><p>这样，你就出现了主从不一致性的问题！原因其实很简单，就是在 <code>master</code> 上执行的顺序为先删后插！而此时 <code>binlog</code> 为 STATEMENT 格式，它记录的顺序为先插后删！从 (<code>slave</code>) 同步的是 <code>binglog</code>，因此从机执行的顺序和主机不一致！就会出现主从不一致！</p><h4 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>解决方案有两种！</p><ul><li>隔离级别设为可重复读 (<code>Repeatable Read</code>), 在该隔离级别下引入间隙锁。当 <code>Session 1</code> 执行 <code>delete</code> 语句时，会锁住间隙。那么，<code>Ssession 2</code> 执行插入语句就会阻塞住！</li><li>将 binglog 的格式修改为 <code>row</code> 格式，此时是基于行的复制，自然就不会出现 sql 执行顺序不一样的问题！奈何这个格式在 <code>mysql5.1</code> 版本开始才引入。因此由于历史原因，<code>mysql</code> 将默认的隔离级别设为可重复读 (<code>Repeatable Read</code>)，保证主从复制不出问题！</li></ul><p>那么，当我们了解完 <code>mysql</code> 选可重复读 (<code>Repeatable Read</code>) 作为默认隔离级别的原因后，接下来我们将其和读已提交 (<code>Read Commited</code>) 进行对比，来说明为什么在互联网项目为什么将隔离级别设为读已提交(<code>Read Commited</code>)！</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>OK，我们先明白一点！项目中是不用读未提交 (<code>Read UnCommitted</code>) 和串行化 (Serializable) 两个隔离级别，原因有二</p><p>采用读未提交 (<code>Read UnCommitted</code>), 一个事务读到另一个事务未提交读数据，这个不用多说吧，从逻辑上都说不过去！<br>采用串行化 (<code>Serializable</code>)，每个次读操作都会加锁，快照读失效，一般是使用 <code>mysql</code> 自带分布式事务功能时才使用该隔离级别！(笔者从未用过 <code>mysql</code> 自带的这个功能，因为这是 <code>XA</code> 事务，是强一致性事务，性能不佳！互联网的分布式方案，多采用最终一致性的事务解决方案！)<br>也就是说，我们该纠结都只有一个问题，究竟隔离级别是用读已经提交呢还是可重复读？<br>接下来对这两种级别进行对比，讲讲我们为什么选读已提交 (<code>Read Commited</code>) 作为事务隔离级别！<br>假设表结构如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`color`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure><p>数据如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">±—±------+</span><br><span class="line">| id | color |</span><br><span class="line">±—±------+</span><br><span class="line">| 1 | red |</span><br><span class="line">| 2 | white |</span><br><span class="line">| 5 | red |</span><br><span class="line">| 7 | white |</span><br><span class="line">±—±------+</span><br></pre></td></tr></table></figure><p>为了便于描述，下面将</p><ul><li>可重复读 (<code>Repeatable Read</code>)，简称为 <code>RR</code>；</li><li>读已提交 (Read Commited)，简称为 <code>RC</code>；</li></ul><p><strong>缘由一</strong></p><p>在 <code>RR</code> 隔离级别下，存在间隙锁，导致出现死锁的几率比 <code>RC</code> 大的多！<br>此时执行语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>在 <code>RR</code> 隔离级别下，存在间隙锁，可以锁住 <code>(2,5)</code> 这个间隙，防止其他事务插入数据！而在 <code>RC</code> 隔离级别下，不存在间隙锁，其他事务是可以插入数据！</p><p>在 <code>RC</code> 隔离级别下并不是不会出现死锁，只是出现几率比 <code>RR</code> 低而已！</p><p><strong>缘由二</strong></p><p>在 <code>RR</code> 隔离级别下，条件列未命中索引会锁表！而在 <code>RC</code> 隔离级别下，只锁行<br>此时执行语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> color = <span class="string">'blue'</span> <span class="keyword">where</span> color = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure><p>在 <code>RC</code> 隔离级别下，其先走聚簇索引，进行全部扫描。加锁如下：</p><p><img src="http://static.cyblogs.com/image_editor_4485ac7d-e85b-4b76-962e-5d420e1ac0a4.png" alt="http://static.cyblogs.com/image_editor_4485ac7d-e85b-4b76-962e-5d420e1ac0a4.png"></p><p>但在实际中，<code>MySQL</code> 做了优化，在 <code>MySQL Server</code> 过滤条件，发现不满足后，会调用 <code>unlock_row</code> 方法，把不满足条件的记录放锁。<br>实际加锁如下</p><p><img src="http://static.cyblogs.com/image_editor_d329942e-3fd7-4a88-b6ae-b294989c34b5.png" alt="http://static.cyblogs.com/image_editor_d329942e-3fd7-4a88-b6ae-b294989c34b5.png"></p><p>然而，在 <code>RR</code> 隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上，如下所示</p><p><img src="http://static.cyblogs.com/image_editor_b504b652-9960-495a-a5ce-37826d0acdc7.jpg" alt="http://static.cyblogs.com/image_editor_b504b652-9960-495a-a5ce-37826d0acdc7.jpg"></p><p><strong>缘由三</strong></p><p>在 <code>RC</code> 隔离级别下，半一致性读 (<code>semi-consistent</code>) 特性增加了 <code>update</code> 操作的并发性！<br>在 <code>5.1.15</code> 的时候，<code>innodb</code> 引入了一个概念叫做 “<code>semi-consistent</code>”，减少了更新同一行记录时的冲突，减少锁等待。<br>所谓半一致性读就是，一个 <code>update</code> 语句，如果读到一行已经加锁的记录，此时 <code>InnoDB</code> 返回记录最近提交的版本，由 <code>MySQL</code> 上层判断此版本是否满足 <code>update</code> 的 <code>where</code> 条件。若满足 (需要更新)，则 <code>MySQL</code> 会重新发起一次读操作，此时会读取行的最新版本 (并加锁)！<br>具体表现如下:<br>此时有两个 <code>Session</code>：<code>Session1</code> 和 <code>Session2</code>！<br><code>Session1</code> 执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> color = <span class="string">'blue'</span> <span class="keyword">where</span> color = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure><p>先不 <code>Commit</code> 事务！<br>与此同时 <code>Ssession2</code> 执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> color = <span class="string">'blue'</span> <span class="keyword">where</span> color = <span class="string">'white'</span>;</span><br></pre></td></tr></table></figure><p><code>Session2</code> 尝试加锁的时候，发现行上已经存在锁，<code>InnoDB</code> 会开启 <code>semi-consistent read</code>，返回最新的 <code>committed</code> 版本 (1,red)，(2，white)，(5,red)，(7,white)。<code>MySQL</code> 会重新发起一次读操作，此时会读取行的最新版本 (并加锁)!<br>而在 <code>RR</code> 隔离级别下，<code>Session2</code> 只能等待！</p><h4 id="两个疑问"><a href="#两个疑问" class="headerlink" title="两个疑问"></a>两个疑问</h4><p>在 <code>RC</code> 级别下，不可重复读问题需要解决么？<br>不用解决，这个问题是可以接受的！毕竟你数据都已经提交了，读出来本身就没有太大问题！<code>Oracle</code> 的默认隔离级别就是 <code>RC</code>，你们改过 Oracle 的默认隔离级别么？</p><p>在 <code>RC</code> 级别下，主从复制用什么 <code>binlog</code> 格式？<br>OK, 在该隔离级别下，用的 <code>binlog</code> 为 <code>row</code> 格式，是基于行的复制！<code>Innodb</code> 的创始人也是建议 <code>binlog</code> 使用该格式！</p><h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><ul><li>数据库默认隔离级别: <code>mysql —repeatable、oracle，sql server —read commited</code></li><li><code>mysql binlog</code> 的格式三种：<code>statement</code>、<code>row</code>、<code>mixed</code></li><li>为什么 <code>mysql</code> 用的是 <code>repeatable</code> 而不是 <code>read committed:</code> 在 <code>5.0</code> 之前只有 <code>statement</code> 一种格式，而主从复制存在了大量的不一致（<code>bug</code>），故选用 <code>repeatable</code>。</li><li>为什么其他数据库默认的隔离级别都会选用 <code>read commited</code> 原因有二：<code>repeatable</code> 存在间隙锁会使死锁的概率增大，在 <code>RR</code> 隔离级别下，条件列未命中索引会锁表！而在 <code>RC</code> 隔离级别下，只锁行</li><li>在 <code>RC</code> 级用别下，主从复制用什么 <code>binlog</code> 格式：<code>row</code> 格式，是基于行的复制！如果使用 <code>statement</code> 格式，会导致主从不一致。</li></ul><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://www.cnblogs.com/rjzheng/p/10510174.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/10510174.html</a></li><li><a href="https://www.cnblogs.com/digdeep/p/4968453.html" target="_blank" rel="noopener">https://www.cnblogs.com/digdeep/p/4968453.html</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前奏&quot;&gt;&lt;a href=&quot;#前奏&quot; class=&quot;headerlink&quot; title=&quot;前奏&quot;&gt;&lt;/a&gt;前奏&lt;/h4&gt;&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt; 的默认事务隔离级别为 &lt;code&gt;Repeatable Read&lt;/code&gt;。而 &lt;code&gt;ORA
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.cyblogs.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.cyblogs.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>2020/11/带你看Eureka源代码</title>
    <link href="http://www.cyblogs.com/2020/11/17/2020/11/%E5%B8%A6%E4%BD%A0%E7%9C%8BEureka%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    <id>http://www.cyblogs.com/2020/11/17/2020/11/%E5%B8%A6%E4%BD%A0%E7%9C%8BEureka%E6%BA%90%E4%BB%A3%E7%A0%81/</id>
    <published>2020-11-16T16:00:00.000Z</published>
    <updated>2020-11-17T01:44:46.604Z</updated>
    
    <content type="html"><![CDATA[<p>首先，我们来看一下Eureka的架构图，有一个整体的认识。传送门：<a href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance" target="_blank" rel="noopener">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a></p><p><img src="http://static.cyblogs.com/eureka_architecture.png" alt="http://static.cyblogs.com/eureka_architecture.png"></p><h4 id="Eureka核心功能"><a href="#Eureka核心功能" class="headerlink" title="Eureka核心功能"></a>Eureka核心功能</h4><p><strong>服务注册</strong></p><p>在微服务启动时，首先，服务提供者需要将自己的服务注册到服务注册中心，服务提供者在启动的时候会发送<code>REST</code>请求将自己注册到服务注册中心上，并带上一些元信息。服务注册中心接收到<code>REST</code>请求，会将元信息存储在一个双层<code>Map</code>中，第一层<code>key</code>是服务名，第二层<code>key</code>是具体服务的实例名。</p><p>注意：在服务注册时，需要确认一下<code>eureka.client.register-with-eureka=true</code>是否正确，如果为false是禁止向服务注册中心注册的。</p><p><strong>服务同步</strong></p><p>当服务成功的注册到了注册中心之后，由于注册中心可能是高可用的集群，那么我们的服务可能只注册到了一个集群中的一个注册中心上，被一个注册中心所维护，而不被另外一个注册中心所维护，那么这个时候，我们就需要将这个注册中心的信息同步给集群中其他的注册中心，这就叫服务同步。那么他是如何实现的呢？</p><p>由于在集群中，一个注册中心互为其他注册中心的服务，当服务提供者请求到一个服务注册中心后，它会将请求转发到其他服务注册中心，实现注册中心之间的服务同步。</p><p>通过服务同步，服务提供者的服务信息可以通过集群中的任何一个服务注册中心获取。</p><p><strong>服务续约</strong></p><p>在注册完成后。服务提供者会维护一个心跳告诉注册中心服务，心跳间隔大约是<code>30S</code>，防止注册中心剔除服务， 正常情况下，如果<code>Eureka Server</code>在<code>90秒</code>没有收到<code>Eureka</code>客户的续约，它会将实例从其注册表中删除。这个过程称为服务续约。</p><p><strong>服务获取</strong></p><p>当一切的注册相关工作完成后，我们自然要获取服务清单，那么如何获取服务呢？ 启动服务消费者后，消费者会发送一个<code>REST</code>请求给服务注册中心，来获取上面注册的服务清单。 而服务注册中心会维护一份只读清单返回给消费者客户端，该缓存清单<code>30s</code>更新一次。</p><p><strong>服务调用</strong></p><p>消费者获取服务清单后，可以通过服务名获取到具体服务实例与实例的元数据信息。这个时候，我们可以通过<code>Ribbon</code>调用我们的目标服务，默认采用轮询的方式，从而实现负载均衡。</p><p><strong>服务下线</strong></p><p>当我们需要对服务实例进行正常的关闭操作时，它会触发一个服务下线的<code>REST</code>请求给服务端。注册中心接收到请求后，将该服务状态置为<code>DOWN</code>，并把下线时间传播出去。</p><p><strong>失效剔除</strong></p><p>有的时候，我们的服务意外挂掉了，那么<code>Eureka</code>如何识别出我们异常的服务，并将其剔除呢？</p><p>服务注册中心启动时会创建定时任务，默认<code>60s</code>一次，将当前清单中超时（<code>90s</code>）没有续约的服务剔除。</p><p><strong>自我保护</strong></p><p>当失效剔除机制引入的时候，就会有一个问题，如果一个地区网络特别不稳定，那么服务可能不会续约，但我们还需要这个服务存在。这个时候，我们怎么解决呢？</p><p>还好，<code>Eureka</code>拥有自我保护机制，可以很好的解决这个问题。<code>Eureka Server</code>在运行期间，会统计心跳失败的比例在<code>15分钟</code>之内是否低于<code>85%</code>，如果低于，就会将当前实例注册信息保护起来，同时提示一个警告，一旦进入保护模式，<code>Eureka Server</code>将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据。也就是不会注销任何微服务。 但是保护机制也有可能会出现问题，导致服务实例不能够被正确剔除。比如在保护期间，实例出现问题，那么客户端很容易拿到实际已经不存在的服务实例，会出现调用失败。 </p><h4 id="源码细节与验证"><a href="#源码细节与验证" class="headerlink" title="源码细节与验证"></a>源码细节与验证</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  renewsLastMin.start();</span><br><span class="line">  <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    evictionTaskRef.get().cancel();</span><br><span class="line">  &#125;</span><br><span class="line">  evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</span><br><span class="line">  <span class="comment">// 服务剔除，private long evictionIntervalTimerInMs = 60 * 1000;</span></span><br><span class="line">  evictionTimer.schedule(evictionTaskRef.get(),</span><br><span class="line">                         serverConfig.getEvictionIntervalTimerInMs(),</span><br><span class="line">                         serverConfig.getEvictionIntervalTimerInMs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance" target="_blank" rel="noopener">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a></li><li><a href="https://zhuanlan.zhihu.com/p/98572822" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98572822</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，我们来看一下Eureka的架构图，有一个整体的认识。传送门：&lt;a href=&quot;https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https
      
    
    </summary>
    
    
      <category term="Eureka" scheme="http://www.cyblogs.com/categories/Eureka/"/>
    
    
      <category term="源码" scheme="http://www.cyblogs.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Eureka" scheme="http://www.cyblogs.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>你是如何玩Git分支模型的呢？</title>
    <link href="http://www.cyblogs.com/2020/11/12/2020/11/%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%8E%A9Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%91%A2%EF%BC%9F/"/>
    <id>http://www.cyblogs.com/2020/11/12/2020/11/%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%8E%A9Git%E5%88%86%E6%94%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%91%A2%EF%BC%9F/</id>
    <published>2020-11-11T16:00:00.000Z</published>
    <updated>2020-11-12T11:35:11.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>总览(一张流程图给大家先镇镇惊)</p><p><img src="http://static.cyblogs.com/git%E5%88%86%E6%94%AF%E6%80%BB%E5%9B%BE%E6%A6%82%E8%A7%88.jpg" alt="http://static.cyblogs.com/git分支总图概览.jpg"></p><p>它主要体现了<code>Git</code>对我们源代码版本的管理。</p><p>（转载者加）一般情况：</p><ul><li><code>master</code>和<code>develop</code>并行。 </li><li><code>master</code>上始终是最稳定的代码，<code>develop</code>是正在开发的代码。 </li><li><code>feature</code>则是某个开发为了自己的功能拉的分支。<br>不一般情况： </li><li><code>develop</code>正在开发，如果你上线突然被拒绝了，这时候就要从master上开一个热分支，或者<code>release</code>分支也行，改好之后在分别合并到其他分支。但，本人感觉release通常意味着终止。别在从<code>release</code>上拉分支了。</li></ul><h4 id="为何是Git？"><a href="#为何是Git？" class="headerlink" title="为何是Git？"></a>为何是Git？</h4><p>​        对于<code>Git</code>与其他集中式代码管理工具相比的优缺点的全面讨论，请参见这里。这样的争论总是喋喋不休。作为一个开发者，与现今的其他开发工具相比较，我更喜欢<code>Git</code>。<code>Git</code>真得改变了开发者对于合并和分支的思考。我曾经使用经典的<code>CVS/Subversion</code>，然而每次的合并/分支和其他行为总让人担惊受怕（“小心合并里的冲突，简直要命！”）。<br>但是对于<code>Git</code>来说，这些行为非常简单和搞笑，它们被认为是日常工作中的核心部分。例如，在很多<code>CVS/Subversion</code>书里，分支与合并总是在后面的章节中被讨论（对于高级用户使用），然而在每个<code>Git</code>书中，在第3章就已经完全涵盖了（作为基础）。<br>简单和重复的特性带来的结果是：分支与合并不再是什么可以害怕的东西。分支/合并被认为对于版本管理工具比其他功能更重要。<br>关于工具，不再多说，让我们直接看开发模型吧。这个模型并不是如下模型：在管理软件开发进度方面，面对每个开发过程，每个队员必须按一定次序开发。</p><h4 id="分布式而非集中式"><a href="#分布式而非集中式" class="headerlink" title="分布式而非集中式"></a>分布式而非集中式</h4><p>​        对于这种分支模型，我们设置了一个版本库，它运转良好，这是一个”事实上” 版本库。不过请注意，这个版本库只是被认为是中心版本库（因为<code>Git</code>是一个分布式版本管理系统，从技术上来讲，并没有一个中心版本库）。我们将把这个版本库称为原始库，这个名字对所有的Git用户来说都很容易理解。</p><p><img src="http://static.cyblogs.com/git%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E4%B8%AD%E5%BC%8F.jpg" alt="http://static.cyblogs.com/git分布式集中式.jpg"></p><p>每个开发者都对<code>origin</code>库拉代码和提交代码。但是除了集中式的存取代码关系，每个开发者也可以从子团队的其他队友那里获得代码版本变更。例如，对于2个或多个开发者一起完成的大版本变更，为了防止过早地向<code>origin</code>库提交工作内容，这种机制就变得非常有用。在上述途中，有如下子团队：<code>Alice</code>和Bob，<code>Alice</code>和<code>David</code>，<code>Clair</code>和<code>David</code>。<br>从技术上将，这意味着，<code>Alice</code>创建了一个<code>Git</code>的远程节点，而对于<code>Bob</code>，该节点指向了<code>Bob</code>的版本库，反之亦然。</p><h4 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h4><p><img src="http://static.cyblogs.com/develop%E4%B8%8Emaster%E5%88%86%E6%94%AF%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="http://static.cyblogs.com/develop与master分支的关系.jpg"></p><p>在核心部分，研发模型很大程度上靠其他现有模型支撑的。中心库有2个可一直延续的分支： </p><ul><li>master分支 </li><li>develop分支 </li></ul><p>每个<code>Git</code>用户都要熟悉原始的<code>master</code>分支。与master分支并行的另一个分支，我们称之为<code>develop</code>分支。<br>我们把原始库/<code>master</code>库认作为主分支，HEAD的源代码存在于此版本中，并且随时都是一个预备生产状态。 </p><p>我们把<code>origin/develop</code>库认为是主分支，该分支<code>HEAD</code>源码始终体现下个发布版的最新软件变更。有人称这个为“集成分支”，而这是每晚自动构建得来的。<br>当<code>develop</code>分支的源码到达了一个稳定状态待发布，所有的代码变更需要以某种方式合并到master分支，然后标记一个版本号。如何操作将在稍后详细介绍。<br>所以，每次变更都合并到了<code>master</code>，这就是新产品的定义。在这一点，我们倾向于严格执行这一点，从而，理论上，每当对<code>master</code>有一个提交操作，我们就可以使用<code>Git</code>钩子脚本来自动构建并且发布软件到生产服务器。</p><h4 id="辅助性分支"><a href="#辅助性分支" class="headerlink" title="辅助性分支"></a>辅助性分支</h4><p>我们的开发模型使用了各种辅助性分支，这些分支与关键分支（master和develop）一起，用来支持团队成员们并行开发，使得易于追踪功能，协助生产发布环境准备，以及快速修复实时在线问题。与关键分支不同，这些分支总是有一个有限的生命期，因为他们最终会被移除。<br>我们用到的分支类型包括： </p><ul><li>功能分支 </li><li>发布分支 </li><li>热修复分支 </li></ul><p>每一种分支有一个特定目的，并且受限于严格到规则，比如：可以用哪些分支作为源分支，哪些分支能作为合并目标。我们马上将进行演练。<br>从技术角度来看，这些分支绝不是特殊分支。分支的类型基于我们使用的方法来进行分类。它们理所当然是普通的Git分支。</p><h4 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h4><p><img src="http://static.cyblogs.com/20181126103335995_580-0.jpg" alt="http://static.cyblogs.com/20181126103335995_580-0.jpg"></p><p>可能是<code>develop</code>分支的分支版本，最终必须合并到<code>develop</code>分支中。<br>分支命名规则：除了<code>master</code>、<code>develop</code>、<code>release-</code>、<code>hotfix-</code>之外，其他命名均可。<br>功能分支（有时被称为<code>topic</code>分支）通常为即将发布或者未来发布版开发新的功能。当新功能开始研发，包含该功能的发布版本在这个还是无法确定发布时间的。功能版本的实质是只要这个功能处于开发状态它就会存在，但是最终会或合并到<code>develop</code>分支（确定将新功能添加到不久的发布版中）或取消（譬如一次令人失望的测试）。<br>功能分支通常存在于开发者的软件库，而不是在源代码库中。<br><strong>创建一个功能分支</strong><br>开始一项功能的开发工作时，基于<code>develop</code>创建分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b myfeature develop</span></span><br><span class="line">Switched to a new branch "myfeature"</span><br></pre></td></tr></table></figure><p><strong>合并一个功能到develop分支</strong><br>完成的功能可以合并进develop分支，以明确加入到未来的发布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line">Switched to branch 'develop'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff myfeature</span></span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d myfeature</span></span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br></pre></td></tr></table></figure><p><code>--no-ff</code>标志导致合并操作创建一个新<code>commit</code>对象，即使该合并操作可以<code>fast-forward</code>。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。 比较:</p><p><img src="http://static.cyblogs.com/t_70_580-0.jpg" alt="http://static.cyblogs.com/t_70_580-0.jpg"></p><p>后一种情况，不可能从<code>Git</code>历史中看到哪些提交一起实现了一个功能——你必须手工阅读全部的日志信息。如果对整个功能进行回退 (比如一组提交)，后一种方式会是一种真正头痛的问题，而使用<code>--no-ff flag</code>的情况则很容易.<br>是的，它会创建一个新的（空）提交对象，但是收益远大于开销。<br>不幸的是，我还没找到一种方法，让–no-ff时作为合并操作的默认选项，但它应该是可行的。</p><h4 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a>Release 分支</h4><p><code>Release</code>分支可能从<code>develop</code>分支分离而来，但是一定要合并到<code>develop</code>和master分支上，它的习惯命名方式为：<code>release-*</code>。<br><code>Release</code>分支是为新产品的发布做准备的。它允许我们在最后时刻做一些细小的修改。他们允许小bugs的修改和准备发布元数据（版本号，开发时间等等）。当在<code>Release</code>分支完成这些所有工作以后，对于下一次打的发布，develop分支接收<code>features</code>会更加明确。<br>从<code>develop</code>分支创建新的<code>Release</code>分支的关键时刻是<code>develop</code>分支达到了发布的理想状态。至少所有这次要发布的<code>features</code>必须在这个点及时合并到develop分支。对于所有未来准备发布的<code>features</code>必须等到Release分支创建以后再合并。<br>在<code>Release</code>分支创建的时候要为即将发行版本分配一个版本号，一点都不早。直到那时，<code>develop</code>分支反映的变化都是为了下一个发行版，但是在<code>Release</code>分支创建之前，下一个发行版到底叫<code>0.3</code>还是<code>1.0</code>是不明确的。这个决定是在<code>Release</code>分支创建时根据项目在版本号上的规则制定的。</p><p><strong>创建一个release分支</strong><br><code>Release</code>分支是从<code>develop</code>分支创建的。例如，当前产品的发行版本号为<code>1.1.5</code>，同事我们有一个大的版本即将发行。<code>develop</code> 分支已经为下次发行做好了准备，我们得决定下一个版本是<code>1.2</code>（而不是<code>1.1.6</code>或者<code>2.0</code>）。所以我们将<code>Release</code>分支分离出来，给一个能够反映新版本号的分支名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b release-1.2 develop</span></span><br><span class="line">Switched to a new branch "release-1.2"</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bump-version.sh 1.2</span></span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">"Bumped version number to 1.2"</span></span></span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>创建新分支以后，切换到该分支，添加版本号。这里，<code>bump-version.sh</code> 是一个虚构的<code>shell</code>脚本，它可以复制一些文件来反映新的版本（这当然可以手动改变–目的就是修改一些文件）。然后版本号被提交。<br>这个新分支可能会存在一段时间，直到该发行版到达它的预定目标。在此期间，bug的修复可能被提交到该分支上（而不是提交到<code>develop</code>分支上）。在这里严格禁止增加大的新<code>features</code>。他们必须合并到<code>develop</code>分支上，然后等待下一次大的发行版。</p><p><strong>完成一个release分支</strong><br>当一个<code>release</code>分支准备好成为一个真正的发行版的时候，有一些工作必须完成。首先，release分支要合并到<code>master</code>上（因为每一次提交到<code>master</code>上的都是一个新定义的发行版，记住）。然后，提交到<code>master</code>上必须打一个标签，以便以后更加方便的引用这个历史版本。最后，在<code>release</code>分支上的修改必须合并到develop分支上，以便未来发行版也包含这些<code>bugs</code>的修复。<br>在<code>Git</code>中的前两步是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release-1.2</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a 1.2</span></span><br></pre></td></tr></table></figure><p>发行版现在已经完成，为以后引用打上标签。<br><strong>编辑：</strong>你可能也想使用<code>the-sor-u &lt;key&gt;flags</code>来标记你的标签。<br>为了是修改保持在<code>release</code>分支上，我们需要合并这些到<code>develop</code>分支上去，在<code>Git</code>上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line">Switched to branch 'develop'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release-1.2</span></span><br><span class="line">Merge made by recursive.</span><br></pre></td></tr></table></figure><p>(Summary of changes)<br>这个步骤可能会导致合并冲突（可能由于改变版本号更是如此）。如果是这样，修复它然后提交。<br>现在我们真正的完成了，这个<code>release</code>分支将被删除，因为我们不再需要它了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d release-1.2</span></span><br><span class="line">Deleted branch release-1.2 (was ff452fe).</span><br></pre></td></tr></table></figure><h4 id="热修复分支"><a href="#热修复分支" class="headerlink" title="热修复分支"></a>热修复分支</h4><p><img src="http://static.cyblogs.com/t_70_580-1.jpg" alt="http://static.cyblogs.com/t_70_580-1.jpg"></p><p>可以基于<code>master</code>分支，必须合并回<code>develop</code>和<code>master</code>分支。<br>分支名约定：<code>hotfix-*</code><br>热修复分支与发布分支很相似，他们都为新的生成环境发布做准备，尽管这是未经计划的。他们来自生产环境的处于异常状态压力。当生成环境验证缺陷必须马上修复是，热修复分支可以基于<code>master</code>分支上对应与线上版本的<code>tag</code>创建。<br>其本质是团队成员（在<code>develop</code>分支上）的工作可以继续，而另一个人准备生产环境的快速修复。<br><strong>创建修补bug分支</strong><br><code>hotfix branch</code>(修补bug分支)是从<code>Master</code>分支上面分出来的。例如，1.2版本是当前生产环境的版本并且有<code>bug</code>。但是开发分支（<code>develop</code>）变化还不稳定。我们需要分出来一个修补<code>bug</code>分支（<code>hotfix branch</code>）来解决这种情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b hotfix-1.2.1 master</span></span><br><span class="line">Switched to a new branch "hotfix-1.2.1"</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bump-version.sh 1.2.1</span></span><br><span class="line">Files modified successfully, version bumped to 1.2.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">"Bumped version number to 1.2.1"</span></span></span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure><p>分支关闭的时侯不要忘了更新版本号(<code>bump the version</code>)<br>然后，修复<code>bug</code>，一次提交或者多次分开提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"Fixed severe production problem"</span></span></span><br><span class="line">[hotfix-1.2.1 abbe5d6] Fixed severe production problem</span><br><span class="line">5 files changed, 32 insertions(+), 17 deletions(-)</span><br></pre></td></tr></table></figure><p><strong>完成一个hotfix分支</strong><br>完成一个<code>bugfix</code>之后，需要把<code>butfix</code>合并到<code>master</code>和develop分支去，这样就可以保证修复的这个<code>bug</code>也包含到下一个发行版中。这一点和完成<code>release</code>分支很相似。<br>首先，更新<code>master</code>并对<code>release</code>打上<code>tag</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a 1.2.1</span></span><br></pre></td></tr></table></figure><p>编辑：你可能也会想使用 <code>-sor-u &lt;key&gt;</code>参数来对你的tag进行加密<br>下一步，把<code>bugfix</code>添加到<code>develop</code>分支中： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop </span></span><br><span class="line">Switched to branch 'develop' </span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix-1.2.1 </span></span><br><span class="line">Merge made by recursive.</span><br></pre></td></tr></table></figure><p>(Summary of changes)<br>规则的一个例外是： <strong>如果一个<code>release</code>分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支</strong>。当<code>release</code>分支完成后， 将<code>bugfix</code>分支合并回<code>release</code>分支也会使得<code>bugfix</code>被合并到<code>develop</code>分支。（如果在<code>develop</code>分支的工作急需这个<code>bugfix</code>，等不到<code>release</code>分支的完成，那你也可以把<code>bugfix</code>合并到develop分支）<br>最后，删除临时分支：</p><p>(Summary of changes)<br>规则的一个例外是： <strong>如果一个release分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支</strong>。当release分支完成后， 将bugfix分支合并回release分支也会使得bugfix被合并到develop分支。（如果在develop分支的工作急需这个bugfix，等不到release分支的完成，那你也可以把bugfix合并到develop分支）<br>最后，删除临时分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix-1.2.1</span></span><br><span class="line">Deleted branch hotfix-1.2.1 (was abbe5d6).</span><br></pre></td></tr></table></figure><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>尽管这个分支模型没有任何震撼的新东西, 文章开头的图表在我们的项目中表现出惊人的实用性。它形成了一个优雅的思维模型，易于领悟并使团队成员发展出对分支和发布过程的共同理解。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/hj7jay/article/details/84527062" target="_blank" rel="noopener">https://blog.csdn.net/hj7jay/article/details/84527062</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：chengcheng222e，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h4&gt;&lt;p&gt;总览(一张流程图给大家先镇镇惊)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cyblogs.com/gi
      
    
    </summary>
    
    
      <category term="Git" scheme="http://www.cyblogs.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.cyblogs.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>RedisTemplate和StringRedisTemplate的区别</title>
    <link href="http://www.cyblogs.com/2020/11/10/2020/11/RedisTemplate%E5%92%8CStringRedisTemplate%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.cyblogs.com/2020/11/10/2020/11/RedisTemplate%E5%92%8CStringRedisTemplate%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2020-11-10T01:51:04.917Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h4><p>简单的说，<code>RedisTemplate</code>和<code>StringRedisTemplate</code>的关系如下：</p><blockquote><p>1.<code>StringRedisTemplate</code>是<code>RedisTemplate</code>的子类。</p><p>2.<code>StringRedisTemplate</code>的各个序列化策略都是<code>StringRedisSerializer</code>，而<code>RedisTemplate</code>用的是<code>JdkSerializationRedisSerializer</code>。</p></blockquote><h4 id="二-RedisTemplate和StringRedisTemplate的代码结构"><a href="#二-RedisTemplate和StringRedisTemplate的代码结构" class="headerlink" title="二.RedisTemplate和StringRedisTemplate的代码结构"></a>二.RedisTemplate和StringRedisTemplate的代码结构</h4><p>从<code>RedisTemplate</code>类说起。</p><p>在<code>RedisTemplate</code>类中，定义了这样四个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer keySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer valueSerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer hashKeySerializer = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer hashValueSerializer = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>分别代表了普通<code>key</code>，<code>value</code>，和<code>Hash</code>类型的<code>key</code>，value的序列化策略，可以分别设置。</p><p>另外定义变量，用来指定默认的序列化策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> RedisSerializer&lt;?&gt; defaultSerializer;</span><br></pre></td></tr></table></figure><p>在<code>RedisTemplate</code>类中，定义了<code>afterPropertiesSet()</code>方法，当<code>Spring</code>创建<code>RedisTemplate</code>类的对象时，会调用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    <span class="keyword">boolean</span> defaultUsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(<span class="keyword">this</span>.classLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.enableDefaultSerializer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.keySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.keySerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.valueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.valueSerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hashKeySerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hashKeySerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hashValueSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hashValueSerializer = <span class="keyword">this</span>.defaultSerializer;</span><br><span class="line">            defaultUsed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.enableDefaultSerializer &amp;&amp; defaultUsed) &#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.defaultSerializer, <span class="string">"default serializer null and not all serializers initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.scriptExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scriptExecutor = <span class="keyword">new</span> DefaultScriptExecutor(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在默认情况下，<code>RedisTemplate</code>使用的默认序列化策略是<code>JdkSerializationRedisSerializer</code>。包括<code>RedisTemplate</code>下的<code>key</code>，<code>value</code>，<code>hash-key</code>，hash-value的序列化，都用这种策略。</p><p>再来看看<code>StringRedisTemplate</code>，他作为RedisTemplate的子类，只是修改了序列化策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="keyword">this</span>.setKeySerializer(stringSerializer);</span><br><span class="line">        <span class="keyword">this</span>.setValueSerializer(stringSerializer);</span><br><span class="line">        <span class="keyword">this</span>.setHashKeySerializer(stringSerializer);</span><br><span class="line">        <span class="keyword">this</span>.setHashValueSerializer(stringSerializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRedisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">this</span>.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">this</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RedisConnection <span class="title">preProcessConnection</span><span class="params">(RedisConnection connection, <span class="keyword">boolean</span> existingConnection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultStringRedisConnection(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>StringRedisTemplate</code>整个类的内容，可以看到，在他的默认构造中，<code>key</code>，<code>value</code>，<code>hash-key</code>，<code>hash-value</code>都使用的是StringRedisSerializer类作为序列化策略。这也就是<code>StringRedisTemplate</code>和他的父类RedisTemplate的主要区别。</p><h4 id="三-序列化策略"><a href="#三-序列化策略" class="headerlink" title="三.序列化策略"></a>三.序列化策略</h4><p>更进一步，看一下这个序列化策略是什么。</p><p>上面提到的<code>StringRedisSerializer</code>和<code>JdkSerializationRedisSerializer</code>都是序列化策略类，他们都实现了一个<code>RedisSerializer&lt;T&gt;</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisSerializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> T var1) <span class="keyword">throws</span> SerializationException;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] var1)</span> <span class="keyword">throws</span> SerializationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口表达的意思很简单，两个方法，serialize用于序列化，把对象变为<code>byte</code>数组，<code>deserialize</code>用于反序列化，把byte数组转为对象。</p><h5 id="StringRedisSerializer"><a href="#StringRedisSerializer" class="headerlink" title="StringRedisSerializer"></a>StringRedisSerializer</h5><p>看看<code>StringRedisSerializer</code>是怎么做的：</p><p><strong>1.StringRedisSerializer的构造：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(charset, <span class="string">"Charset must not be null!"</span>);</span><br><span class="line">    <span class="keyword">this</span>.charset = charset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了编码格式，默认<code>UTF_8</code>。</p><p><strong>2.StringRedisSerializer的serialize和deserialize方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bytes == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> String(bytes, <span class="keyword">this</span>.charset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> String string) &#123;</span><br><span class="line">    <span class="keyword">return</span> string == <span class="keyword">null</span> ? <span class="keyword">null</span> : string.getBytes(<span class="keyword">this</span>.charset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>StringRedisSerializer</code>采用的是字符串和对应编码下二进制数组之间的转换。</p><p>在这种编码格式下，如果我们向redis保存信息，然后用客户端访问<code>Redis</code>时，只要编码格式一致，就能看到保存信息的原文。保存字符串<code>ABC</code>，客户端看到的也是字符串<code>ABC</code>。</p><h5 id="JdkSerializationRedisSerializer"><a href="#JdkSerializationRedisSerializer" class="headerlink" title="JdkSerializationRedisSerializer"></a>JdkSerializationRedisSerializer</h5><p>然后对比看看<code>JdkSerializationRedisSerializer</code>是怎么做的。</p><p><strong>1.JdkSerializationRedisSerializer的构造：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;Object, <span class="keyword">byte</span>[]&gt; serializer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;<span class="keyword">byte</span>[], Object&gt; deserializer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkSerializationRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> SerializingConverter(), <span class="keyword">new</span> DeserializingConverter());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkSerializationRedisSerializer</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> SerializingConverter(), <span class="keyword">new</span> DeserializingConverter(classLoader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>JdkSerializationRedisSerializer</code>定义了两个变量，serializer和<code>deserializer</code>，显然是用来序列化和反序列化的，他们两个的类型是一样的，都是Converter接口，只是泛型不同。</p><p>Converter接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就一个方法。</p><p>另外在<code>JdkSerializationRedisSerializer</code>的构造中，对serializer和<code>deserializer</code>进行了初始化，使用<code>SerializingConverter</code>和DeserializingConverter作为实现类。</p><p><strong>2.JdkSerializationRedisSerializer的serialize和deserialize方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SerializationUtils.isEmpty(bytes)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.deserializer.convert(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Cannot deserialize"</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> Object object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> SerializationUtils.EMPTY_ARRAY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">byte</span>[])<span class="keyword">this</span>.serializer.convert(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Cannot serialize"</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是调用了对应<code>Converter</code>的<code>convert</code>方法。</p><p><strong>3.关于Converter</strong></p><p>既然到这了，就再深入一步，看看<code>SerializingConverter</code>和DeserializingConverter的<code>convert</code>方法。</p><p><strong>首先，序列化：</strong></p><p><code>SerializingConverter</code>的相关方法，贴一部分关键的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerializingConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = <span class="keyword">new</span> DefaultSerializer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] convert(Object source) &#123;</span><br><span class="line">        ByteArrayOutputStream byteStream = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span>  &#123;</span><br><span class="line">                <span class="keyword">this</span>.serializer.serialize(source, byteStream);</span><br><span class="line">                <span class="keyword">return</span> byteStream.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SerializationFailedException(<span class="string">"Failed to serialize object using "</span> +</span><br><span class="line">                                <span class="keyword">this</span>.serializer.getClass().getSimpleName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>SerializingConverter</code>类定义了<code>serializer</code>变量，用<strong>DefaultSerializer</strong>类实现，序列化的方式是调用<code>DefaultSerializer</code>的<code>serialize</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Object object, OutputStream outputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Serializable)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(getClass().getSimpleName() + <span class="string">" requires a Serializable payload "</span> +</span><br><span class="line">                                <span class="string">"but received an object of type ["</span> + object.getClass().getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">        objectOutputStream.writeObject(object);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultSerializer</code>的<code>serialize</code>方法使用了<code>ObjectOutputStream</code>，调用writeObject方法序列化对象。</p><p><strong>对应的，反序列化：</strong></p><p><code>DeserializingConverter</code>的convert方法，贴一下相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DeserializingConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deserializer = <span class="keyword">new</span> DefaultDeserializer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(<span class="keyword">byte</span>[] source)</span> </span>&#123;</span><br><span class="line">        ByteArrayInputStream byteStream = <span class="keyword">new</span> ByteArrayInputStream(source);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.deserializer.deserialize(byteStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SerializationFailedException(<span class="string">"Failed to deserialize payload. "</span> +</span><br><span class="line">                                <span class="string">"Is the byte array a result of corresponding serialization for "</span> +</span><br><span class="line">                                <span class="keyword">this</span>.deserializer.getClass().getSimpleName() + <span class="string">"?"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见<code>DeserializingConverter</code>使用了<strong>DefaultDeserializer</strong>作为反序列化工具，调用了他的deserialize方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ConfigurableObjectInputStream(inputStream, <span class="keyword">this</span>.classLoader);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to deserialize object type"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>SerializingConverter</code>，<code>DeserializingConverter</code>使用的是<code>ConfigurableObjectInputStream</code>，并调用他的<code>readObject</code>方法进行反序列化。</p><p>这种序列化方式，如果保存信息至<code>redis</code>，用客户端查看时，保存的信息看起来像是在原来的字符前面加了几个字符。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JdkSerializationRedisSerializer jdkSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer();</span><br><span class="line">StringRedisSerializer stringSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"><span class="keyword">byte</span>[] jdkByteArr = jdkSerializer.serialize(<span class="string">"CSDN博客"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] stringByteArr = stringSerializer.serialize(<span class="string">"CSDN博客"</span>);</span><br></pre></td></tr></table></figure><p>这种情况下，得到的<code>byte</code>数组是：</p><p><code>jdkByteArr</code>：</p><blockquote><p>{-84,-19,0,5,116,0,10,67,83,68,78,-27,-115,-102,-27,-82,-94}</p></blockquote><p>stringByteArr：</p><blockquote><p>{67,83,68,78,-27,-115,-102,-27,-82,-94}</p></blockquote><p><code>StringRedisSerializer</code>把字符串本身转化成<code>byte</code>数组，而<code>JdkSerializationRedisSerializer</code>在数组前面加了几个字符，这些字符也会被保存到redis中。</p><p>所以，从数据上来说，这两种序列化策略处理的数据是不会共通的，各人管各人的。</p><h4 id="四-关于redisTemplate的Operations"><a href="#四-关于redisTemplate的Operations" class="headerlink" title="四.关于redisTemplate的Operations"></a>四.关于redisTemplate的Operations</h4><p>使用<code>redisTemplate</code>时，除了调用<code>execute</code>方法并自定义RedisCallback之外，还可以使用<code>redisTemplate</code>提供的几个Operations接口。</p><p><code>redisTemplate</code>中定义了以下几个<code>Operations</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ValueOperations&lt;K, V&gt; valueOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ListOperations&lt;K, V&gt; listOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> SetOperations&lt;K, V&gt; setOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ZSetOperations&lt;K, V&gt; zSetOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> GeoOperations&lt;K, V&gt; geoOps;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HyperLogLogOperations&lt;K, V&gt; hllOps;</span><br></pre></td></tr></table></figure><p>这几个<code>Operations</code>接口，分别提供了对不同种类数据的操作方法。</p><p>以<code>ValueOperations</code>为例，他提供的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K var1, V var2, <span class="keyword">long</span> var3, TimeUnit var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">setIfAbsent</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiSet</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">multiSetIfAbsent</span><span class="params">(Map&lt;? extends K, ? extends V&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">V <span class="title">getAndSet</span><span class="params">(K var1, V var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">List&lt;V&gt; <span class="title">multiGet</span><span class="params">(Collection&lt;K&gt; var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Long <span class="title">increment</span><span class="params">(K var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Double <span class="title">increment</span><span class="params">(K var1, <span class="keyword">double</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Integer <span class="title">append</span><span class="params">(K var1, String var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">get</span><span class="params">(K var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K var1, V var2, <span class="keyword">long</span> var3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Long <span class="title">size</span><span class="params">(K var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">setBit</span><span class="params">(K var1, <span class="keyword">long</span> var2, <span class="keyword">boolean</span> var4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">Boolean <span class="title">getBit</span><span class="params">(K var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure><p>其他的<code>Operations</code>提供的方法各有不同，但是这些<code>Operations</code>的使用方式都是相同的。</p><p>不同的Operations分别通过<code>RedisTemplate</code>的以下方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ValueOperations&lt;K, V&gt; <span class="title">opsForValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.valueOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.valueOps = <span class="keyword">new</span> DefaultValueOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListOperations&lt;K, V&gt; <span class="title">opsForList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.listOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listOps = <span class="keyword">new</span> DefaultListOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SetOperations&lt;K, V&gt; <span class="title">opsForSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.setOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setOps = <span class="keyword">new</span> DefaultSetOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.setOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ZSetOperations&lt;K, V&gt; <span class="title">opsForZSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.zSetOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.zSetOps = <span class="keyword">new</span> DefaultZSetOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.zSetOps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> GeoOperations&lt;K, V&gt; <span class="title">opsForGeo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.geoOps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.geoOps = <span class="keyword">new</span> DefaultGeoOperations(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.geoOps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在这些获得<code>Operations</code>的方法中，都提供了一个默认实现类，并且把<code>RedisTemplate</code>对象本身当做参数传给了这个实现类。</p><p>还是以<code>ValueOperations</code>为例，<code>RedisTemplate</code>提供的默认实现类是DefaultValueOperations，看看这个类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.redis.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.AbstractOperations.ValueDeserializingRedisCallback;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultValueOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ValueOperations</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    DefaultValueOperations(RedisTemplate&lt;K, V&gt; template) &#123;</span><br><span class="line">        <span class="keyword">super</span>(template);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.get(rawKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getAndSet</span><span class="params">(K key, V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(newValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.getSet(rawKey, rawValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">increment</span><span class="params">(K key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Long)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.incrBy(rawKey, delta);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">increment</span><span class="params">(K key, <span class="keyword">double</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Double)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.incrBy(rawKey, delta);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">append</span><span class="params">(K key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawString = <span class="keyword">this</span>.rawString(value);</span><br><span class="line">        <span class="keyword">return</span> (Integer)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            Long result = connection.append(rawKey, rawString);</span><br><span class="line">            <span class="keyword">return</span> result != <span class="keyword">null</span> ? result.intValue() : <span class="keyword">null</span>;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(K key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawReturn = (<span class="keyword">byte</span>[])<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.getRange(rawKey, start, end);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.deserializeString(rawReturn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;V&gt; <span class="title">multiGet</span><span class="params">(Collection&lt;K&gt; keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keys.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[][] rawKeys = <span class="keyword">new</span> <span class="keyword">byte</span>[keys.size()][];</span><br><span class="line">            <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            Object hashKey;</span><br><span class="line">            <span class="keyword">for</span>(Iterator var4 = keys.iterator(); var4.hasNext(); rawKeys[counter++] = <span class="keyword">this</span>.rawKey(hashKey)) &#123;</span><br><span class="line">                hashKey = var4.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;<span class="keyword">byte</span>[]&gt; rawValues = (List)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.mGet(rawKeys);</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.deserializeValues(rawValues);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiSet</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.isEmpty()) &#123;</span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; rawKeys = <span class="keyword">new</span> LinkedHashMap(m.size());</span><br><span class="line">            Iterator var3 = m.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                Entry&lt;? extends K, ? extends V&gt; entry = (Entry)var3.next();</span><br><span class="line">                rawKeys.put(<span class="keyword">this</span>.rawKey(entry.getKey()), <span class="keyword">this</span>.rawValue(entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                connection.mSet(rawKeys);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">multiSetIfAbsent</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; rawKeys = <span class="keyword">new</span> LinkedHashMap(m.size());</span><br><span class="line">            Iterator var3 = m.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">                Entry&lt;? extends K, ? extends V&gt; entry = (Entry)var3.next();</span><br><span class="line">                rawKeys.put(<span class="keyword">this</span>.rawKey(entry.getKey()), <span class="keyword">this</span>.rawValue(entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> connection.mSetNX(rawKeys);</span><br><span class="line">            &#125;, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">                connection.set(rawKey, rawValue);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value, <span class="keyword">final</span> <span class="keyword">long</span> timeout, <span class="keyword">final</span> TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.potentiallyUsePsetEx(connection);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">potentiallyUsePsetEx</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!TimeUnit.MILLISECONDS.equals(unit) || !<span class="keyword">this</span>.failsafeInvokePsetEx(connection)) &#123;</span><br><span class="line">                    connection.setEx(rawKey, TimeoutUtils.toSeconds(timeout, unit), rawValue);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">failsafeInvokePsetEx</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">boolean</span> failed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.pSetEx(rawKey, timeout, rawValue);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedOperationException var4) &#123;</span><br><span class="line">                    failed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> !failed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">setIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.setNX(rawKey, rawValue);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">        <span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            connection.setRange(rawKey, rawValue, offset);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">size</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Long)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.strLen(rawKey);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">setBit</span><span class="params">(K key, <span class="keyword">long</span> offset, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.setBit(rawKey, offset, value);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getBit</span><span class="params">(K key, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">        <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.getBit(rawKey, offset);</span><br><span class="line">        &#125;, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有<code>Operations</code>实现类都是<code>AbstractOperations</code>的子类，另外各自实现各自的接口。</p><p>实现类的方法中多数都是调用了<code>this.execute()</code>方法，这个方法在父类AbstractOperations中，最终调用的其实也是<code>RedisTemplate</code>的<code>execute()</code>方法。</p><p>以上面<code>DefaultValueOperations</code>的<code>set()</code>方法为例，看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">    <span class="keyword">this</span>.execute(<span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">            connection.set(rawKey, rawValue);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是对<code>value</code>的处理，调用<code>this.rawValue()</code>方法，把value序列化成<code>byte</code>数组，这个方法在父类<code>AbstractOperations</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] rawValue(Object value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.valueSerializer() == <span class="keyword">null</span> &amp;&amp; value <span class="keyword">instanceof</span> <span class="keyword">byte</span>[] ? (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])value) : <span class="keyword">this</span>.valueSerializer().serialize(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，代码用的是自己的<code>valueSerializer</code>来序列化<code>value</code>，这个valueSerializer来自<code>RedisTemplate</code>。</p><p>回到<code>set()</code>方法，<code>value</code>序列化完成后，调用<code>this.execute()</code>方法，给此方法传递的第一个参数是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key) &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">        connection.set(rawKey, rawValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个参数实际上是一个<code>ValueDeserializingRedisCallback</code>对象，在其中定义了<code>inRedis()</code>方法的实现。</p><p><code>this.execute()</code>方法在父类AbstractOperations中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; callback, <span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.template.execute(callback, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>this.template</code>指的就是初始化时传入的<code>RedisTemplate</code>，其execute()方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.execute(action, exposeConnection, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection, <span class="keyword">boolean</span> pipeline)</span> </span>&#123;</span><br><span class="line">    Assert.isTrue(<span class="keyword">this</span>.initialized, <span class="string">"template not initialized; call afterPropertiesSet() before using it"</span>);</span><br><span class="line">    Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line">    RedisConnectionFactory factory = <span class="keyword">this</span>.getRequiredConnectionFactory();</span><br><span class="line">    RedisConnection conn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Object var11;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.enableTransactionSupport) &#123;</span><br><span class="line">            conn = RedisConnectionUtils.bindConnection(factory, <span class="keyword">this</span>.enableTransactionSupport);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn = RedisConnectionUtils.getConnection(factory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> existingConnection = TransactionSynchronizationManager.hasResource(factory);</span><br><span class="line">        RedisConnection connToUse = <span class="keyword">this</span>.preProcessConnection(conn, existingConnection);</span><br><span class="line">        <span class="keyword">boolean</span> pipelineStatus = connToUse.isPipelined();</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.openPipeline();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RedisConnection connToExpose = exposeConnection ? connToUse : <span class="keyword">this</span>.createRedisConnectionProxy(connToUse);</span><br><span class="line">        T result = action.doInRedis(connToExpose);</span><br><span class="line">        <span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">            connToUse.closePipeline();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var11 = <span class="keyword">this</span>.postProcessResult(result, connToUse, existingConnection);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RedisConnectionUtils.releaseConnection(conn, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法初始化了<code>RedisConnection</code>，最后面调用了<code>RedisCallback</code>的<code>doInRedis()</code>方法，也就是这一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T result = action.doInRedis(connToExpose);</span><br></pre></td></tr></table></figure><p>这里的变量<code>action</code>就是在<code>set()</code>方法中自定义的<code>new AbstractOperations&lt;K, V&gt;.ValueDeserializingRedisCallback(key)</code>。</p><p><code>ValueDeserializingRedisCallback</code>类是<code>AbstractOperations</code>的内部抽象类，他的<code>doInRedis()</code>方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] result = <span class="keyword">this</span>.inRedis(AbstractOperations.<span class="keyword">this</span>.rawKey(<span class="keyword">this</span>.key), connection);</span><br><span class="line">    <span class="keyword">return</span> AbstractOperations.<span class="keyword">this</span>.deserializeValue(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见调用了<code>inRedis()</code>方法，其第一个参数是序列化后的<code>key</code>，调用的是<code>AbstractOperations</code>的<code>rawKey()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] rawKey(Object key) &#123;</span><br><span class="line">    Assert.notNull(key, <span class="string">"non null key required"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.keySerializer() == <span class="keyword">null</span> &amp;&amp; key <span class="keyword">instanceof</span> <span class="keyword">byte</span>[] ? (<span class="keyword">byte</span>[])((<span class="keyword">byte</span>[])key) : <span class="keyword">this</span>.keySerializer().serialize(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把<code>key</code>进行序列化，<code>keySerializer()</code>方法从<code>RedisTemplate</code>中获取<code>keySerializer</code>，并由<code>keySerializer</code>对<code>key</code>进行序列化。</p><p>在<code>ValueDeserializingRedisCallback</code>类中的<code>inRedis()</code>方法是抽象方法，具体的实现在<code>DefaultValueOperations</code>的<code>set()</code>方法中，也就是这一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] inRedis(<span class="keyword">byte</span>[] rawKey, RedisConnection connection) &#123;</span><br><span class="line">    connection.set(rawKey, rawValue);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用的是<code>RedisConnection</code>的<code>set()</code>方法，完成<code>Redis</code>的<code>set</code>操作。</p><p>以上就是在RedisTemplate中使用<code>ValueOperations</code>进行<code>set</code>操作的全部代码流程。</p><p>对<code>Redis</code>的不同操作分散在<code>RedisTemplate</code>的不同Operations中，只是调用的方法不同，调用流程都差不多。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul><li><a href="https://blog.csdn.net/lkforce/article/details/103685707" target="_blank" rel="noopener">https://blog.csdn.net/lkforce/article/details/103685707</a></li></ul><p>如果大家喜欢我的文章，可以关注个人订阅号。欢迎随时留言、交流。如果想加入微信群的话一起讨论的话，请加管理员微信号：<code>chengcheng222e</code>，他会拉你们进群。</p><p><img src="http://static.cyblogs.com/onegoleya.jpeg" alt="简栈文化服务订阅号"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;headerlink&quot; title=&quot;一.简介&quot;&gt;&lt;/a&gt;一.简介&lt;/h4&gt;&lt;p&gt;简单的说，&lt;code&gt;RedisTemplate&lt;/code&gt;和&lt;code&gt;StringRedisTemplate&lt;/cod
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.cyblogs.com/tags/Redis/"/>
    
  </entry>
  
</feed>
